format 75
"evaluator" // evaluator
  revision 220
  modified_by 48 "finnerty"
  owner 48 "finnerty"
  // class settings
  //class diagram settings
  draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
  //use case diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default class_drawing_mode default shadow default show_stereotype_properties default
  //sequence diagram settings
  show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
  //collaboration diagram settings
  show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
  //object diagram settings
   write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
  //component diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //deployment diagram settings
  package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //state diagram settings
  package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
  show_activities default region_horizontally default drawing_language default show_stereotype_properties default
  //activity diagram settings
  package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
  show_infonote default drawing_language default show_stereotype_properties default
  
  stereotype "library"
  cpp_h_dir "evaluator"
  cpp_src_dir "evaluator"
  cpp_namespace "evaluator"
  python_dir "cmc"
  classview 468655 "evaluator base"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    associated_deployment_view deploymentview_ref 372143 // evaluator deployment
    classdiagram 563759 "Evaluator Overview"
      draw_all_relations default hide_attributes yes hide_operations yes hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      size A4
    end

    class 439472 "const_range_t"
      visibility package stereotype "typedef" base_type class_ref 1136687 // iterator_range
      nactuals 1
      actual class class_ref 1136687 // iterator_range
        rank 0 explicit_value "boost::ptr_vector< evaluator::base_evaluator >::const_iterator"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_decl ""
      idl_decl "${comment}typedef ${type} ${name};
"
      explicit_switch_type ""
      
      classrelation 533808 // <realization>
	relation 532912 -_-|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 533808 // <realization>
	  b parent class_ref 1136687 // iterator_range
      end

      classrelation 533936 // <dependency>
	relation 533040 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 533936 // <dependency>
	  b parent class_ref 912175 // base_evaluator
      end
    end

    class 912175 "base_evaluator"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment "Calculate the value/cost of the transformation on the ensemble of a
given change_set."
      classrelation 824240 // <generalisation>
	relation 823344 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 824240 // <generalisation>
	  b parent class_ref 275887 // noncopyable
      end

      classrelation 823728 // <dependency>
	relation 822832 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 823728 // <dependency>
	  b parent class_ref 986799 // coordinate
      end

      classrelation 823856 // <dependency>
	relation 822960 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 823856 // <dependency>
	  b parent class_ref 223792 // coordinate_set
      end

      extra_member 551600 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 529201 "~base_evaluator"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 477103 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      classrelation 1250223 // <dependency>
	relation 1212463 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 1250223 // <dependency>
	  b parent class_ref 912431 // access
      end

      operation 2109615 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
  };
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Serialize all but the observable set."
      end

      extra_member 551472 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1659183 "compute_potential"
	abstract const cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param inout name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "  Compute the change in potential energy."
      end

      operation 538672 "compute_total_potential"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 2
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment " Calculate the total potential energy. In general this is the sum"
      end

      operation 487345 "description"
	const public explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "Log message descibing the evaluator and its parameters"
      end

      operation 327600 "do_description"
	abstract const cpp_virtual private explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Log message descibing the derived evaluator and its parameters"
      end

      operation 622512 "on_conclude_trial"
	cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {}
"
	
	
	
	
	comment "  Called after the trial is complete. (default do nothing)"
      end

      operation 151345 "prepare"
	abstract cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param in name "eman" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "Prepare the evaluator for use with the given simulator and
stepper."
      end

      operation 166193 "type_label"
	abstract const cpp_virtual public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 216624 "write_document"
	preserve_cpp_body_indent const public explicit_return_type "void"
	nparams 1
	  param inout name "wr" type class_ref 163632 // input_document
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Add an input file section.

 only throw possible should be from os.write() operation

 The output of this factory method is made up like

 evaluator
 type <type_label()>
 <call do_write_input_section>
 end
"
      end

      operation 2165295 "do_write_document"
	abstract preserve_cpp_body_indent const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Add derived content to input file section wr[ix]. 

 only throw possible should be from os.write() operation"
      end
    end

    class 439344 "evaluator_manager"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 810160 // <dependency>
	relation 809264 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 810160 // <dependency>
	  b parent class_ref 912175 // base_evaluator
      end

      classrelation 533680 // evaluators_ (<directional composition>)
	relation 532784 *-->
	  stereotype "ptr_vector"
	  a role_name "evaluators_" multiplicity "*" private
	    comment "Set of evaluators for a simulation."
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}< ${type} > ${name}${value};
"
	    python "${comment}${self}${name} = ${stereotype}()
"
	    classrelation_ref 533680 // evaluators_ (<directional composition>)
	  b parent class_ref 912175 // base_evaluator
      end

      attribute 618032 "permittivity_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The relative permittivity of the media"
      end

      attribute 617904 "temperature_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The simulation temperature"
      end

      extra_member 564912 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 840368 "evaluator_manager"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
: evaluators_()
, permittivity_( standard_aqueous_permittivity() )
, temperature_( standard_room_temperature() )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 840496 "~evaluator_manager"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 840624 "evaluator_manager"
	stereotype "move"
	private explicit_return_type ""
	nparams 1
	  param inout name "source" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${inline}${name}${(}${t0} & ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 840752 "evaluator_manager"
	stereotype "copy"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 840880 "operator="
	private return_type class_ref 439344 // evaluator_manager
	nparams 1
	  param in name "source" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${abstract} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 383664 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 841008 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};"
	cpp_def "${comment}template<class Archive> ${inline}${type} ${class}::${name}${(}${t0} & ${p0}, const ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
      end

      extra_member 565040 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 840240 "add_evaluator"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param inout name "evltr" type class_ref 912175 // base_evaluator
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}std::unique_ptr< ${t0} >& ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}std::unique_ptr< ${t0} >& ${p0}${)}${const}${volatile}${throw}${staticnl}
{
   this->evaluators_.push_back( ${p0}.release() );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}${)}:
${docstring}self.evaluators_.append( ${p0} )
"
	
	comment " Transfer ownership of an energy evaluators into the evaluators list
"
      end

      operation 1362992 "add_evaluator"
	stereotype "move"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param inout name "evltr" type class_ref 912175 // base_evaluator
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}std::unique_ptr< ${t0} >&& ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}std::unique_ptr< ${t0} >&& ${p0}${)}${const}${volatile}${throw}${staticnl}
{
   this->evaluators_.push_back( ${p0}.release() );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}${)}:
${docstring}self.evaluators_.append( ${p0} )
"
	
	comment " Transfer ownership of an energy evaluators into the evaluators list
"
      end

      operation 841776 "compute_potential"
	const public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param inout name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, ${t2} & ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Compute the change in potential energy."
      end

      operation 841648 "compute_total_potential"
	const public explicit_return_type "double"
	nparams 2
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Calculate the total potential energy."
      end

      operation 841264 "description"
	const public explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Details about the current simulation to be written to the
 log at the start of the simulation."
      end

      operation 849200 "empty"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->evaluators_.${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 840112 "get_evaluators"
	const public return_type class_ref 439472 // const_range_t
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}
{
  return ${type}( this->evaluators_.begin (), this->evaluators_.end () );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}return self.evaluators_
"
	
	comment " Access the list of evaluators"
      end

      operation 841904 "on_conclude_trial"
	cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "  Called after the trial is complete. (default do nothing)"
      end

      operation 1379248 "permittivity"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1379760 "permittivity"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name}_ = ${p0};
}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 841392 "prepare"
	public explicit_return_type "void"
	nparams 2
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 849072 "size"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->evaluators_.${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The number of evaluators"
      end

      operation 1379376 "standard_aqueous_permittivity"
	class_operation public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return 80.0; }
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Standard relative permittivity of water (80.0)"
      end

      operation 1379504 "standard_room_temperature"
	class_operation public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return 298.15; }
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Standard room temperature (24°C) in Kelvin"
      end

      operation 1379120 "temperature"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1379632 "temperature"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name}_ = ${p0};
}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 842032 "write_document"
	public explicit_return_type "void"
	nparams 1
	  param inout name "wr" type class_ref 163632 // input_document
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Write contents of simulation as an input document"
      end

      operation 1793072 "build_input_delegater"
	class_operation public explicit_return_type "void"
	nparams 2
	  param inout name "eman" type class_ref 439344 // evaluator_manager
	  param inout name "delegate" type class_ref 1012655 // input_delegater
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}boost::shared_ptr< ${t0} > ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}boost::shared_ptr< ${t0} > ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Adds factory methods and input parsers for all the types that can be instantiated from 
 the input file."
      end
    end

    class 694064 "hard_sphere_overlap"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Calculate if particles overlap as hard-spheres."
      classrelation 1119024 // <generalisation>
	relation 1118128 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 1119024 // <generalisation>
	  b parent class_ref 912175 // base_evaluator
      end

      classrelation 1118640 // <dependency>
	relation 1117744 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 1118640 // <dependency>
	  b parent class_ref 986799 // coordinate
      end

      classrelation 1118768 // <dependency>
	relation 1117872 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 1118768 // <dependency>
	  b parent class_ref 223792 // coordinate_set
      end

      attribute 846256 "radii_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${stereotype}()
"
	idl_decl ""
	comment " Cached specie radii"
      end

      extra_member 734640 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 2026800 "~hard_sphere_overlap"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 734768 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      classrelation 1118896 // <dependency>
	relation 1118000 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 1118896 // <dependency>
	  b parent class_ref 912431 // access
      end

      operation 2026928 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
  ar & boost::serialization::base_object< base_evaluator >(*this);
  ar & this->radii_;
  };
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Serialize all but the observable set."
      end

      extra_member 734896 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 2027056 "compute_potential"
	const public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param inout name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, ${t2} & ${p2}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Energy is always zero, but set fail if particles overlap as
 hard spheres."
      end

      operation 2027184 "compute_total_potential"
	const public explicit_return_type "double"
	nparams 2
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  return 0.0;
}
"
	
	
	
	
	comment " Assume no-overlap in verified ensemble, so energy is always zero."
      end

      operation 2027440 "do_description"
	const cpp_virtual private explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Log message descibing the derived evaluator and its parameters"
      end

      operation 2027696 "prepare"
	public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param in name "eman" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, const ${t2} & ${p2}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Capture specie radii."
      end

      operation 2027824 "type_label"
	const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} override
{
  return ${class}::${name}_();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 2028208 "type_label_"
	class_operation preserve_cpp_body_indent public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return std::string(\"hard-sphere\");
}
"
	
	
	
	
      end

      operation 2028080 "do_write_document"
	preserve_cpp_body_indent const private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " No derived content"
      end

      operation 2028464 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 1143599 // evaluator_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a evaluator_definition to the meta object."
      end

      operation 2028336 "make_evaluator"
	class_operation preserve_cpp_body_indent public return_type class_ref 912175 // base_evaluator
	nparams 1
	  param in name "param_set" type class_ref 844336 // input_parameter_memo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}std::unique_ptr< ${type} > ${name}${(}const std::vector< ${t0} > & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}std::unique_ptr< ${type} > ${class}::${name}${(}const std::vector< ${t0} > & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Set up the evaluator using the given map of name/value pairs."
      end
    end

    class 700592 "object_overlap"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Calculate if particles overlap as hard-spheres."
      classrelation 1132464 // <generalisation>
	relation 1131568 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 1132464 // <generalisation>
	  b parent class_ref 912175 // base_evaluator
      end

      classrelation 1132592 // <dependency>
	relation 1131696 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 1132592 // <dependency>
	  b parent class_ref 986799 // coordinate
      end

      classrelation 1132720 // <dependency>
	relation 1131824 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 1132720 // <dependency>
	  b parent class_ref 223792 // coordinate_set
      end

      extra_member 741424 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 2069552 "~object_overlap"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 741552 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      classrelation 1132848 // <dependency>
	relation 1131952 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 1132848 // <dependency>
	  b parent class_ref 912431 // access
      end

      operation 2069680 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
  ar & boost::serialization::base_object< base_evaluator >(*this);
  };
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Serialize all but the observable set."
      end

      extra_member 741680 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 2069808 "compute_potential"
	const public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param inout name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, ${t2} & ${p2}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Energy is always zero, but set fail if particles overlaps object as
 detected by the system region."
      end

      operation 2069936 "compute_total_potential"
	const public explicit_return_type "double"
	nparams 2
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  return 0.0;
}
"
	
	
	
	
	comment " Assume no-overlap in verified ensemble, so energy is always zero."
      end

      operation 2070064 "do_description"
	const cpp_virtual private explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Log message descibing the derived evaluator and its parameters"
      end

      operation 2070192 "prepare"
	public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param in name "eman" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, const ${t2} & ${p2}${)}${const}${volatile}${throw}
{}
"
	
	
	
	
	comment " Do nothing."
      end

      operation 2070320 "type_label"
	const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} override
{
  return ${class}::${name}_();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 2070448 "type_label_"
	class_operation preserve_cpp_body_indent public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return std::string(\"object-overlap\");
}
"
	
	
	
	
      end

      operation 2070576 "do_write_document"
	preserve_cpp_body_indent const private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " No derived content"
      end

      operation 2070704 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 1143599 // evaluator_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a evaluator_definition to the meta object."
      end

      operation 2070832 "make_evaluator"
	class_operation preserve_cpp_body_indent public return_type class_ref 912175 // base_evaluator
	nparams 1
	  param in name "param_set" type class_ref 844336 // input_parameter_memo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}std::unique_ptr< ${type} > ${name}${(}const std::vector< ${t0} > & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}std::unique_ptr< ${type} > ${class}::${name}${(}const std::vector< ${t0} > & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Set up the evaluator using the given map of name/value pairs."
      end
    end
  end

  classview 207024 "evaluator meta"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    associated_deployment_view deploymentview_ref 372143 // evaluator deployment
    classdiagram 630703 "evaluator meta from input file"
      draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      size A4
    end

    class 566192 "evaluator_definition"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 803376 // <generalisation>
	relation 802480 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 803376 // <generalisation>
	  b parent class_ref 539568 // input_definition
      end

      class 1143983 "evaluator_generator_fn"
	visibility public stereotype "typedef" base_type class_ref 252719 // function1
	nactuals 2
	actual class class_ref 252719 // function1
	  rank 0 explicit_value "std::unique_ptr< base_evaluator >"
	actual class class_ref 252719 // function1
	  rank 1 explicit_value "std::vector< core::input_parameter_memo > const&"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl "${comment}typedef ${type} ${name};
"
	explicit_switch_type ""
	
	classrelation 1436080 // <realization>
	  relation 1435184 -_-|>
	    a public
	      cpp default "${type}"
	      python "${type}"
	      classrelation_ref 1436080 // <realization>
	    b parent class_ref 252719 // function1
	end

	classrelation 190001 // <dependency>
	  relation 189745 -_->
	    a default
	      cpp default "#include in source"
	      python "${type}"
	      classrelation_ref 190001 // <dependency>
	    b parent class_ref 912175 // base_evaluator
	end
      end

      attribute 611376 "factory_"
	private type class_ref 1143983 // evaluator_generator_fn
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " A method for generating evaluator objects."
      end

      extra_member 551344 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1355696 "evaluator_definition"
	const public explicit_return_type ""
	nparams 3
	  param in name "label" explicit_type "string"
	  param in name "desc" explicit_type "string"
	  param in name "fn" type class_ref 1143983 // evaluator_generator_fn
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw}
: input_definition( ${p0}, ${p1} )
, factory_( ${p2} )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Main Ctor

 \\param label : name of the evaluator subtype."
      end

      operation 1355568 "evaluator_definition"
	const private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1355440 "~evaluator_definition"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1355312 "evaluator_definition"
	stereotype "move"
	private explicit_return_type ""
	nparams 1
	  param inout name "source" type class_ref 566192 // evaluator_definition
	cpp_decl "    ${comment}${inline}${name}${(}${t0} && ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1355184 "evaluator_definition"
	stereotype "copy"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 566192 // evaluator_definition
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1355056 "operator="
	private return_type class_ref 566192 // evaluator_definition
	nparams 1
	  param in name "source" type class_ref 566192 // evaluator_definition
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${abstract} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 551216 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1354928 "operator()"
	const public return_type class_ref 912175 // base_evaluator
	nparams 1
	  param in name "params" type class_ref 844336 // input_parameter_memo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}std::unique_ptr< ${type} > ${name}${(}const std::vector< ${t0} >& ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  return this->factory_( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Generate a sampler from the given label and paramneters and
 add to the report manager.
"
      end

      extra_member 551088 "access base class methods"
	
	stereotype "using"
	cpp "using input_definition::add_definition;
using input_definition::empty;
using input_definition::has_definition;
using input_definition::label;
using input_definition::publish_help;
using input_definition::size;
" ""
	java ""
	php ""
	python ""
	idl ""
      end
    end

    class 1143599 "evaluator_meta"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 1314095 // <generalisation>
	relation 1275567 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 1314095 // <generalisation>
	  b parent class_ref 1082671 // input_base_meta
      end

      classrelation 534064 // manager_ (<directional composition>)
	relation 533168 *-->
	  stereotype "shared_ptr"
	  a role_name "manager_" multiplicity "0..1" private
	    comment " Where to put the evaluator objects generated from the input file."
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}< ${type} > ${name}${value};
"
	    python "${comment}${self}${name} = ${stereotype}()
"
	    classrelation_ref 534064 // manager_ (<directional composition>)
	  b parent class_ref 439344 // evaluator_manager
      end

      attribute 1444783 "parameter_set_"
	private type class_ref 844336 // input_parameter_memo
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${stereotype}()
"
	idl_decl ""
	comment "The type specific name/value pairs"
      end

      classrelation 810032 // type_to_object_ (<directional composition>)
	relation 809136 *-->
	  stereotype "ptr_vector"
	  a role_name "type_to_object_" multiplicity "*" private
	    comment " Evaluator factories"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}< ${type} > ${name}${value};
"
	    python "${comment}${self}${name} = ${stereotype}()
"
	    classrelation_ref 810032 // type_to_object_ (<directional composition>)
	  b parent class_ref 566192 // evaluator_definition
      end

      attribute 1444911 "type_"
	private explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "The type-label of the evaluator to construct"
      end

      operation 2165679 "evaluator_meta"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param inout name "eman" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${inline}${name}${(}boost::shared_ptr< ${t0} >& ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}boost::shared_ptr< ${t0} >& ${p0}${)} 
: input_base_meta (core::strngs::evaluator_label(), true, true)
, manager_( ${p0} )
, parameter_set_()
, type_()
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 2165807 "~evaluator_meta"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}
{}
"
	
	
	
	
      end

      operation 842416 "add_definition"
	public explicit_return_type "void"
	nparams 1
	  param inout name "defn" type class_ref 566192 // evaluator_definition
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}std::unique_ptr< ${t0} > & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}std::unique_ptr< ${t0} > & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Add ctor for input \"evaluator\" section with \"type = [defn.label]\" 

 \\pre not has_definition( defn.label )
 \\post has_definition( defn.label )"
      end

      operation 1371952 "add_definition"
	stereotype "move"
	public explicit_return_type "void"
	nparams 1
	  param inout name "defn" type class_ref 566192 // evaluator_definition
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}std::unique_ptr< ${t0} > && ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}std::unique_ptr< ${t0} > && ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Add ctor for input \"evaluator\" section with \"type = [defn.label]\" 

 \\pre not has_definition( defn.label )
 \\post has_definition( defn.label )"
      end

      operation 2330672 "definition_key_list"
	public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}std::vector< ${type} > ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}std::vector< ${type} > ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get a list of definition labels/keys"
      end

      operation 1370288 "empty"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return this->type_to_object_.${name}(); }

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Ary there no evaluator definitions?"
      end

      operation 1686320 "get_definition"
	const public return_type class_ref 566192 // evaluator_definition
	nparams 1
	  param in name "label" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type}& ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}const ${type}& ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get definition of evaluator that matches the label"
      end

      operation 1362736 "has_definition"
	const public explicit_return_type "bool"
	nparams 1
	  param in name "label" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Is there a ctor to match input \"sampler\" section with
 \"type = [label]\""
      end

      operation 842160 "publish_help"
	const public explicit_return_type "void"
	nparams 1
	  param inout name "helper" type class_ref 1004335 // input_help
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 203824 "do_read_entry"
	cpp_virtual private explicit_return_type "bool"
	nparams 1
	  param inout name "reader" type class_ref 313392 // input_base_reader
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Read an entry in the input file. Return true if the entry was processed.

throw an error if input file is incorrect (using UTILITY_INPUT macro)"
      end

      operation 203952 "do_read_end"
	cpp_virtual private explicit_return_type "void"
	nparams 1
	  param in name "reader" type class_ref 313392 // input_base_reader
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Perform checks at the end of reading a section."
      end

      operation 1362352 "do_reset"
	cpp_virtual private explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Reset internal data."
      end

      operation 1370160 "size"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return this->type_to_object_.${name}(); }

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The number of evaluator definitions"
      end
    end
  end

  classview 387887 "lennard-jones"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    associated_deployment_view deploymentview_ref 372143 // evaluator deployment
    classdiagram 425391 "LJ data"
      draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      size A4
    end

    class 579248 "lennard_jones"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl "class ${name}(object):
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment "
    \\begin{alignat}{3} V_{LJ}& = 4 \\varepsilon &\\left[
    \\left( \\frac {\\sigma} {r} \\right)^{12} - \\left(
    \\frac {\\sigma} {r} \\right)^6 \\right]\\\\ & = \\varepsilon
    &\\left[\\left( \\frac {r_m} {r} \\right)^{12} - 2 \\left(
    \\frac {r_m} {r} \\right)^6 \\right] \\end{alignat}

where
  \\varepsilon is the depth of the potential well, \\sigma is
  the finite distance at which the inter-particle potential
  is zero, r is the distance between the particles,
  and r_m is the distance at which the potential reaches
  its minimum.

At r_m, the potential function has the value -\\varepsilon.
The distances are related as r_m = 2^{1/6}\\sigma.
These parameters can be fitted to reproduce experimental
data or accurate quantum chemistry calculations.  Due to
its computational simplicity, the Lennard-Jones potential
is used extensively in computer simulations even though
more accurate potentials exist.

"
      classrelation 837296 // <generalisation>
	relation 836400 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 837296 // <generalisation>
	  b parent class_ref 912175 // base_evaluator
      end

      classrelation 837424 // <dependency>
	relation 836528 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 837424 // <dependency>
	  b parent class_ref 912431 // access
      end

      classrelation 837552 // <dependency>
	relation 836656 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 837552 // <dependency>
	  b parent class_ref 134959 // ensemble
      end

      classrelation 837680 // <dependency>
	relation 836784 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 837680 // <dependency>
	  b parent class_ref 865967 // constants
      end

      classrelation 837808 // <dependency>
	relation 836912 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 837808 // <dependency>
	  b parent class_ref 1016239 // strngs
      end

      attribute 624688 "epsilon_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "map"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}< std::string, ${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${stereotype}()
"
	idl_decl ""
	comment " Per specie map of epsilon values."
      end

      attribute 624816 "sigma_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "map"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}< std::string, ${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${stereotype}()
"
	idl_decl ""
	comment " Per specie map of sigma values."
      end

      attribute 624560 "epsilon_cache_"
	private explicit_type "double"
	multiplicity "*"
	init_value "None"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${stereotype}()
"
	idl_decl ""
	comment " The epsilon array indexed by ( i * specie_count + j )."
      end

      attribute 624944 "sigma_cache_"
	private explicit_type "double"
	multiplicity "*"
	init_value "None"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${stereotype}()
"
	idl_decl ""
	comment " The sigma array indexed by ( i * specie_count + j )."
      end

      extra_member 571568 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1415600 "~lennard_jones"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;
"
	
	
	
	
      end

      operation 1415856 "lennard_jones"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}
: base_evaluator ()
, epsilon_()
, sigma_()
, epsilon_cache_()
, sigma_cache_()
{}
"
	
	
	
	
	comment " Default ctor, Should be called only by serialize and make_evaluator method"
      end

      extra_member 571696 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1415984 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  ar & boost::serialization::base_object< base_evaluator >(*this);
  ar & this->epsilon_; ar & this->sigma_; ar & this->epsilon_cache_; ar & this->sigma_cache_;
}
"
	
	
	
	
      end

      extra_member 571824 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1416112 "compute_potential"
	preserve_cpp_body_indent const public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param inout name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, ${t2} & ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}, ${p1}${v1}, ${p2}${v2}${)}:
${docstring}${body}
"
	
	comment "Calculate the change in Lennard-Jones formulation of
van de Waals energy on the ensemble by changes"
      end

      operation 1416240 "compute_total_potential"
	preserve_cpp_body_indent const public explicit_return_type "double"
	nparams 2
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}, ${p1}${v1}, ${p2}${v2}${)}:
${docstring}${body}
"
	
	comment " Calculate the total in Coulomb Electrostatic
 energy on the ensemble."
      end

      operation 1416368 "do_description"
	const private explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Log message descibing this evaluator subclass and its parameters"
      end

      operation 1416752 "prepare"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param in name "eman" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, const ${t2} & ${p2}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}${)}:
${docstring}self.scalar_ = self.factor_/( sim.get_cell_region().permittivity() * sim.get_temperature() )
"
	
	comment "Prepare the evaluator for use with the given simulator and
stepper.

Base specie type defines all parameters necessary for the
coulomb evaluator, so no species are remove from specs."
      end

      operation 1416880 "type_label"
	preserve_cpp_body_indent const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} override
{
  return lennard_jones::type_label_();
}"
	
	
	
	
      end

      operation 1417008 "do_write_document"
	preserve_cpp_body_indent const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Write evaluator specific content of input file section.

 only throw possible should be from os.write() operation"
      end

      operation 1417136 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 1143599 // evaluator_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a evaluator_definition to the meta object."
      end

      operation 1417264 "type_label_"
	class_operation preserve_cpp_body_indent public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return std::string(\"lennard-jones\");
}
"
	
	
	
	
      end

      operation 1417392 "make_evaluator"
	class_operation preserve_cpp_body_indent public return_type class_ref 912175 // base_evaluator
	nparams 1
	  param in name "param_set" type class_ref 844336 // input_parameter_memo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}std::unique_ptr< ${type} > ${name}${(}const std::vector< ${t0} > & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}std::unique_ptr< ${type} > ${class}::${name}${(}const std::vector< ${t0} > & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Set up the evaluator using the given map of name/value pairs."
      end
    end

    class 134703 "lennard_jones_mono"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "Single specie Lennard-Jones evaluator"
      classrelation 1117359 // <generalisation>
	relation 1080239 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 1117359 // <generalisation>
	  b parent class_ref 912175 // base_evaluator
      end

      classrelation 1074991 // <dependency>
	relation 1037871 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 1074991 // <dependency>
	  b parent class_ref 134959 // ensemble
      end

      classrelation 203697 // <dependency>
	relation 203441 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 203697 // <dependency>
	  b parent class_ref 865967 // constants
      end

      classrelation 1073583 // <dependency>
	relation 1036591 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 1073583 // <dependency>
	  b parent class_ref 449327 // ftoi
      end

      classrelation 154673 // <dependency>
	relation 154673 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 154673 // <dependency>
	  b parent class_ref 871087 // input_reader
      end

      classrelation 1263919 // <dependency>
	relation 1226031 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 1263919 // <dependency>
	  b parent class_ref 134577 // specie
      end

      classrelation 148145 // <dependency>
	relation 148145 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 148145 // <dependency>
	  b parent class_ref 1016239 // strngs
      end

      attribute 1430063 "filename_"
	private explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "The name of the output file to save energy and pressure to"
      end

      attribute 1430191 "first_save_"
	private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "first time we save sample output."
      end

      attribute 154671 "epsilon_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "epsilon = energy parameter of Lennard-Jones potential"
      end

      attribute 1203759 "eps4_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "4 * epsilon (epsilon = energy parameter of Lennard-Jones potential)"
      end

      attribute 1203887 "eps48_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "48 * epsilon (epsilon = energy parameter of Lennard-Jones potential)"
      end

      attribute 1204143 "sig2_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "sigma squared (sigma = size parameter of the Lennard-Jones potential)"
      end

      attribute 154543 "sigma_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "sigma = size parameter of the Lennard-Jones potential"
      end

      attribute 1204271 "mass_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The mass of the particles"
      end

      attribute 1204399 "rc_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The cut of radius of the potential"
      end

      attribute 1204527 "rc2_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "rc squared (rc = The cut of radius of the potential)"
      end

      attribute 137391 "ecut_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "Energy cut-off radius"
      end

      attribute 1430319 "count_"
	private explicit_type "size_t"
	init_value "0"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "The number of times result has been saved"
      end

      attribute 137519 "tailco_"
	private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "Whether to apply tail corrections"
      end

      attribute 137647 "shiftpot_"
	private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "Whether to shift the potential"
      end

      operation 136495 "corp"
	const public explicit_return_type "double"
	nparams 2
	  param in name "r" explicit_type "double"
	  param in name "rho" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "The pressure correction with tail correction"
      end

      operation 136367 "coru"
	const private explicit_return_type "double"
	nparams 2
	  param in name "r" explicit_type "double"
	  param in name "rho" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "The energy correction with tail correction"
      end

      operation 247857 "compute_potential"
	const public explicit_return_type "void"
	nparams 3
	  param in name "sys" type class_ref 1129135 // simulator
	  param inout name "changes" type class_ref 986543 // change_set
	  param in name "start_index" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} & ${p1}, ${t2} ${p2}${)}${const}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
      end

      operation 489265 "description"
	const public explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "Log message descibing the observable and its parameters"
      end

      operation 136239 "ener"
	const cpp_inline private explicit_return_type "void"
	nparams 3
	  param inout name "energy" explicit_type "double"
	  param inout name "virial" explicit_type "double"
	  param in name "r2" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}, ${t1} & ${p1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} & ${p1}, ${t2} ${p2}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	comment "Interaction Energy"
      end

      operation 154031 "lennard_jones_mono"
	public explicit_return_type ""
	nparams 1
	  param in name "fn" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}${)}${throw} 
${body}
"
	
	
	
	
      end

      operation 2184751 "lennard_jones_mono"
	public explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 134703 // lennard_jones_mono
	cpp_decl "    ${comment}${inline}explicit ${name}${(}const ${t0} & ${p0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} 
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Explicit (non-copy) ctor for class (used in attach)"
      end

      operation 2037807 "lennard_jones_mono"
	private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw}
: filename_()
, first_save_(true)
, epsilon_ ()
, eps4_ ()
, eps48_ ()
, sig2_ ()
, sigma_ ()
, mass_ ()
, rc_ ()
, rc2_ ()
, ecut_ ()
, count_ ()
, tailco_ ()
, shiftpot_ ()
{}
"
	
	
	
	
	comment "For use in constructing object in make_lennard_jones method"
      end

      operation 529457 "~lennard_jones_mono"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 225457 "prepare"
	public explicit_return_type "void"
	nparams 1
	  param in name "sim" type class_ref 1129135 // simulator
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Prepare the evaluator for use with the given simulator and
stepper.

Initialize rc and ecut.  Bind 'sample' method to the stepper."
      end

      operation 136111 "readat"
	public explicit_return_type "void"
	nparams 3
	  param inout name "is" explicit_type "istream"
	  param in name "rho" explicit_type "double"
	  param in name "hbox" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
	comment "  Read model potential parameters"
      end

      operation 138927 "rc"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}
"
	
	
	
	
      end

      operation 139055 "tail_correction"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->tailco_;
}
"
	
	
	
	
      end

      extra_member 449839 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 2036783 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
    ar & boost::serialization::base_object< base_evaluator >(*this);
    ar & filename_;
    ar & first_save_;
    ar & epsilon_;
    ar & eps4_;
    ar & eps48_;
    ar & sig2_;
    ar & sigma_;
    ar & mass_;
    ar & rc_;
    ar & rc2_;
    ar & ecut_;
    ar & count_;
    ar & tailco_;
    ar & shiftpot_;
  };
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 1747375 "sample"
	public explicit_return_type "void"
	nparams 1
	  param in name "sys" type class_ref 1129135 // simulator
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
	comment "write energy and pressure to a stream"
      end

      classrelation 1170351 // <dependency>
	relation 1133231 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 1170351 // <dependency>
	  b parent class_ref 912431 // access
      end

      classrelation 141617 // <dependency>
	relation 141617 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 141617 // <dependency>
	  b parent class_ref 204975 // bind
      end

      operation 166321 "type_label"
	const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}
{
  return ${class}::${name}_();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 166449 "type_label_"
	class_operation public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}
{
  return ${type}(\"lj-single\");
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 166833 "make_evaluator"
	class_operation public return_type class_ref 912175 // base_evaluator
	nparams 2
	  param in name "param_set" explicit_type "string"
	  param in name "simtype" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type}* ${name}${(}std::map<${t0},${t0}> const& ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type}* ${class}::${name}${(}std::map<${t0},${t0}> const& ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "Set up the evaluator using the given map of name/value pairs

Is valid for all simtypes."
      end

      operation 217648 "do_write_input_section"
	preserve_cpp_body_indent const cpp_virtual private explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Write evaluator specific content of input file section.

 only throw possible should be from os.write() operation"
      end
    end

    class 732719 "lennard_jones_evaluator"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "[cite: en.wikipedia.org/wiki/Lennard-Jones_potential]

The Lennard-Jones potential (also referred to as the L-J potential,
6-12 potential, or 12-6 potential) is a mathematically simple model
that approximates the interaction between a pair of neutral atoms
or molecules.  A form of the potential was first proposed in 1924
by John Lennard-Jones.[1] The most common expressions of the L-J
potential are

    \\begin{alignat}{3} V_{LJ}& = 4 \\varepsilon &\\left[ \\left( \\frac
    {\\sigma} {r} \\right)^{12} - \\left( \\frac {\\sigma} {r} \\right)^6
    \\right]\\\\ & = \\varepsilon &\\left[\\left( \\frac {r_m} {r}
    \\right)^{12} - 2 \\left( \\frac {r_m} {r} \\right)^6 \\right]
    \\end{alignat}

where 
  \\varepsilon is the depth of the potential well, 
  \\sigma is the finite distance at which the inter-particle potential is zero,
  r is the distance between the particles, and
  r_m is the distance at which the potential reaches its minimum.  

At r_m, the potential function has the value -\\varepsilon.  The
distances are related as r_m = 2^{1/6}\\sigma.  These parameters can
be fitted to reproduce experimental data or accurate quantum chemistry
calculations.  Due to its computational simplicity, the Lennard-Jones
potential is used extensively in computer simulations even though
more accurate potentials exist.

Pairwise parameters are determined using the Lorentz-Berthelot mixing 
rules, namely:
Â­\\varepsilon_{ij} = \\sqrt \\varepsilon_{ii} \\varepsilon_{jj}
Â­\\sigma_{ij} = frac{ \\sigma_{ii} + \\sigma_{jj} }{ 2 }

This means only self-self interaction terms need to be specified
in the input file. Although it may be possible to directly
set particular pairwise terms.

M. P. Allen and D. J. Tildesley, Computer Simulation of Liquids (Clarendon, Oxford, 1987)].
"
      attribute 912815 "_cutoff_sq"
	private explicit_type "double, 2"
	multiplicity "*"
	init_value "None"
	stereotype "multi_array"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "The cut-off distance (squared) used to short-cut the energy evaluation for large distances."
      end

      attribute 913071 "_minima_distance"
	private explicit_type "double, 2"
	multiplicity "*"
	init_value "None"
	stereotype "multi_array"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The distance between two particles of type specie0 and specie1 where the
minima in enegy is located (squared)."
      end

      attribute 912943 "_minima_energy"
	private explicit_type "double, 2"
	multiplicity "*"
	init_value "None"
	stereotype "multi_array"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " The depth of the energy well between two species. This
 is the \\varepsilon value in the L-J potential."
      end

      operation 1281071 "call_method"
	public explicit_return_type "double"
	nparams 2
	  param in name "change_set" type class_ref 772271 // object
	  param in name "item_list" type class_ref 772271 // object
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
	comment " Calculate particle-particle_set LJ interactions contribution. "
      end

      operation 1281199 "lennard_jones_evaluator"
	public explicit_return_type ""
	nparams 1
	  param in name "geom" type class_ref 772271 // object
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}${)}${throw}
  ${body}
"
	
	
	
	
	comment "As change particle : change particle Coulomb interactions are calculated
in the same way as change particle : config particle, the __init__ method
makes _do_change_contribution an alias for _do_contribution. The
nspec argument is the number of interacting species."
      end

      operation 1420079 "lennard_jones_energy"
	class_operation const private explicit_return_type "double"
	nparams 4
	  param in name "r_sq" explicit_type "double"
	  param in name "r_cutoff_sq" explicit_type "double"
	  param in name "r_min" explicit_type "double"
	  param in name "e_min" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}${)}${const}${volatile}${throw}${abstract}
{
  //
  // U_LJ = e_min [ (r_min/r)^12 - 2(r_min/r)^6]
  //
  if (${p0} < ${p1})
  {
    const double f = ${p2} * ${p2} / ${p0};
    const double g = std::pow(f, 3);
    return ${p3} * g * (g - 2.0);
  }
  return 0.0;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end
    end
  end

  classview 368303 "couloumb evaluator classes"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    classdiagram 148017 "Coulomb relations"
      draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      size A4
    end

    class 779183 "coulomb"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl "class ${name}(object):
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment "Compute change in Coulomb electrostatic potential between
the new/old position and existing positions. (Also checks
for particle-particle overlap)

    \\begin{alignat}{3} V_{LJ}& = 4 \\varepsilon &\\left[
    \\left( \\frac {\\sigma} {r} \\right)^{12} - \\left(
    \\frac {\\sigma} {r} \\right)^6 \\right]\\\\ & = \\varepsilon
    &\\left[\\left( \\frac {r_m} {r} \\right)^{12} - 2 \\left(
    \\frac {r_m} {r} \\right)^6 \\right] \\end{alignat}

where
  \\varepsilon is the depth of the potential well, \\sigma is
  the finite distance at which the inter-particle potential
  is zero, r is the distance between the particles,
  and r_m is the distance at which the potential reaches
  its minimum.

At r_m, the potential function has the value -\\varepsilon.
The distances are related as r_m = 2^{1/6}\\sigma.
These parameters can be fitted to reproduce experimental
data or accurate quantum chemistry calculations.  Due to
its computational simplicity, the Lennard-Jones potential
is used extensively in computer simulations even though
more accurate potentials exist.

"
      classrelation 244273 // <generalisation>
	relation 244017 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 244273 // <generalisation>
	  b parent class_ref 912175 // base_evaluator
      end

      classrelation 244913 // <dependency>
	relation 244657 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 244913 // <dependency>
	  b parent class_ref 912431 // access
      end

      classrelation 264625 // <dependency>
	relation 264369 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 264625 // <dependency>
	  b parent class_ref 134959 // ensemble
      end

      classrelation 244529 // <dependency>
	relation 244273 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 244529 // <dependency>
	  b parent class_ref 865967 // constants
      end

      classrelation 244401 // <dependency>
	relation 244145 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 244401 // <dependency>
	  b parent class_ref 1016239 // strngs
      end

      attribute 359217 "scalar_"
	private explicit_type "double"
	init_value "None"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "The simulation specific energy scale converting
charges and Angstrom distances into units of
kT"
      end

      extra_member 558128 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 529329 "~coulomb"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;
"
	
	
	
	
      end

      operation 1350063 "coulomb"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}
: base_evaluator ()
, scalar_()
{}
"
	
	
	
	
	comment " Default ctor, Should be called only by serialize and make_evaluator method"
      end

      extra_member 167345 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 249777 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  ar & boost::serialization::base_object< base_evaluator >(*this);
  ar & this->scalar_;
}
"
	
	
	
	
      end

      extra_member 558256 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 247985 "compute_potential"
	preserve_cpp_body_indent const public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param inout name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, ${t2} & ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}, ${p1}${v1}, ${p2}${v2}${)}:
${docstring}${body}
"
	
	comment "Calculate the change in Coulomb Electrostatic
energy on the ensemble in 'sys' caused by changes in
'changes'."
      end

      operation 538800 "compute_total_potential"
	preserve_cpp_body_indent const public explicit_return_type "double"
	nparams 2
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}, ${p1}${v1}, ${p2}${v2}${)}:
${docstring}${body}
"
	
	comment " Calculate the total in Coulomb Electrostatic
 energy on the ensemble."
      end

      operation 489137 "do_description"
	const private explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Log message descibing this evaluator subclass and its parameters"
      end

      operation 1380016 "factor"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->scalar_;
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Return the internal to external energy scaling factor. This is undefined before first call to prepare().

 = (electron_charge^2) / (4.pi.epsilon_0.boltzmann_constant.angstrom . permittivity . temperature)"
      end

      operation 1379888 "invariant_factor"
	class_operation public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return std::pow( core::constants::electron_charge(), 2 ) / ( 4 * core::constants::pi() * core::constants::epsilon_0() * core::constants::boltzmann_constant() * core::constants::angstrom () );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Return the invariant part of the energy scaling factor

 = (electron_charge^2) / (4.pi.epsilon_0.boltzmann_constant.angstrom)"
      end

      operation 248497 "prepare"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param in name "eman" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, const ${t2} & ${p2}${)}${const}${volatile}${throw}
{
  this->scalar_ = ${class}::invariant_factor() /( ${p2}.permittivity() * ${p2}.temperature() );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}${)}:
${docstring}self.scalar_ = self.factor_/( sim.get_cell_region().permittivity() * sim.get_temperature() )
"
	
	comment "Prepare the evaluator for use with the given simulator and
stepper.

Base specie type defines all parameters necessary for the
coulomb evaluator, so no species are remove from specs."
      end

      operation 248369 "type_label"
	preserve_cpp_body_indent const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} override
{
  return coulomb::type_label_();
}"
	
	
	
	
      end

      operation 217520 "do_write_document"
	preserve_cpp_body_indent const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Write evaluator specific content of input file section.

 only throw possible should be from os.write() operation"
      end

      operation 1369904 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 1143599 // evaluator_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a evaluator_definition to the meta object."
      end

      operation 248241 "type_label_"
	class_operation preserve_cpp_body_indent public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
      end

      operation 248113 "make_evaluator"
	class_operation preserve_cpp_body_indent public return_type class_ref 912175 // base_evaluator
	nparams 1
	  param in name "param_set" type class_ref 844336 // input_parameter_memo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}std::unique_ptr< ${type} > ${name}${(}const std::vector< ${t0} > & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}std::unique_ptr< ${type} > ${class}::${name}${(}const std::vector< ${t0} > & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Set up the evaluator using the given map of name/value pairs."
      end
    end
  end

  classview 400943 "particle position localization"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    classdiagram 161072 "Predefined position and localisation information"
      draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      size A4
    end

    class 546351 "localizer"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment "  Evaluate the mobile structural ion localisation penalty.


  This computes the potential energy change of moving a particle.
  For a harmonic oscillator the potential stores in a particle is

     U = 1/2 k r^2

  Where k is the spring constant and r is the distance from the centre
  of the oscillation.

  To approximate a Uniform distribution the potential is.

     U  = k_bT/2 ( r^2 )/( sigma^2 )  -- eqn 1

  We use units of k_bT and so what we calculate is

     U = C_mob ( r^2 )/( R_i^2 ) -- eqn 2

  Where kmob is a simulation wide constant and R_i is the per-particle
  is the cut-off distance.

  To get eqn 2 to model a Uniform distribution our values of the spring factor
  (C_mob, parameter \"mobk\") and R_i must satisfy the relations.

     C_mob = 1/2 n^2 and R_i = n * sigma -- eqn 3

  where n is any factor. Conversely, given kmob and R_i the distribution
  models a Uniform distribution with 

     sigma^2 = R_i^2 / (2 * C_mob)
     
  DEFAULT SETTINGS:

  In a Uniform distribution, greater that 99.5% of the distribution
  is within 3 standard deviations of the mean position. We take this as
  the default by defining (n) in eqn 3 as 3 giving. 
 
     C_mob = 4.5
     R_i  = 3 * sigma

  If we have B factors from an X-ray we can determine R_i from

     R_i = 3 * sigma = 3 { 1/(2 pi) sqrt( B_i/2 ) }

   



"
      classrelation 204208 // <generalisation>
	relation 203952 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 204208 // <generalisation>
	  b parent class_ref 912175 // base_evaluator
      end

      classrelation 204464 // <dependency>
	relation 204208 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 204464 // <dependency>
	  b parent class_ref 912431 // access
      end

      classrelation 238384 // <dependency>
	relation 238128 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 238384 // <dependency>
	  b parent class_ref 197552 // centroid
      end

      attribute 812079 "spring_factor_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Constant multiplier for mobile ion constraint. Note this
 is the maximum value that the penalty energy can contribute
 to the potential energy as we scale the displacement by the 
 maximum displacement (rsr^2) when calculating Hooke's law
 potential energy.

 fortran equiv k_mobl"
      end

      extra_member 197936 "LIFETIME"
	
	cpp "// lifetime methods

" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 319792 "localizer"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
: spring_factor_( ${class}::default_spring_factor() )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 319920 "~localizer"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 184496 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 276400 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  ar & boost::serialization::base_object< base_evaluator >(*this);
  ar & this->spring_factor_;
}
"
	
	
	
	
      end

      extra_member 198064 "ACCESS"
	
	cpp "// access methods

" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1381168 "default_spring_factor"
	class_operation public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}constexpr ${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return 4.5;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The default spring factor (4.5) when paired with R_max
 values 2 x X-Ray B-factor or atomic simulation RMSDs should
 give comparable atom distributions to the X-Ray or atomic
 simulations.
"
      end

      operation 1152815 "spring_factor"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${)}:
${docstring}${body}
"
	
      end

      operation 1152943 "spring_factor"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "a_factor" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name}_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${)}:
${docstring}${body}
"
	
	comment "  Set the global spring factor."
      end

      operation 275760 "type_label"
	const cpp_virtual public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw} override
{
  return ${class}::${name}_();
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1381040 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 1143599 // evaluator_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a evaluator_definition to the meta object."
      end

      operation 276016 "make_evaluator"
	class_operation preserve_cpp_body_indent public return_type class_ref 912175 // base_evaluator
	nparams 1
	  param in name "param_set" type class_ref 844336 // input_parameter_memo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}std::unique_ptr< ${type} > ${name}${(}const std::vector< ${t0} > & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}std::unique_ptr< ${type} > ${class}::${name}${(}const std::vector< ${t0} > & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Set up the evaluator using the given map of name/value pairs

 Valid for all simtypes. Optional spring factor constant \"mobk\" parameter"
      end

      operation 276272 "type_label_"
	class_operation preserve_cpp_body_indent public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
      end

      extra_member 198192 "ACTION"
	
	cpp "// action methods

" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 275376 "compute_potential"
	const cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param inout name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, ${t2} & ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Calculate change in localization energy if one of the atoms
 in the change set has moved."
      end

      operation 538928 "compute_total_potential"
	const cpp_virtual public explicit_return_type "double"
	nparams 2
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Calculate the total potential energy."
      end

      operation 275504 "do_description"
	const cpp_virtual private explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Log message descibing the evaluator and its parameters"
      end

      operation 276144 "do_write_document"
	preserve_cpp_body_indent const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Write evaluator specific content of input file section.

 only throw possible should be from os.write() operation"
      end

      operation 275632 "prepare"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param in name "eman" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, const ${t2} & ${p2}${)}${const}${throw}
{}
"
	
	
	
	
	comment " This is a no-op; a localizer objects does not need any
 preparation before a simulation."
      end
    end
  end

  classview 148144 "ICC patch"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    associated_deployment_view deploymentview_ref 372143 // evaluator deployment
    comment " Induced Charge Computation: 

 Evaluate interaction energy between a dielectric surface and
 system of charges."
    classdiagram 180656 "icc relations"
      draw_all_relations default hide_attributes yes hide_operations yes hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      size A4
    end

    class 258096 "check_data"
      visibility package stereotype "struct"
      cpp_decl "${comment}${template}struct ${name}${inherit} 
{
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment "  Set of parameters used to verify if saved icc_surface_grid
  and induced_charge_matrix data can be reused."
      operation 351152 "hashdbl"
	class_operation public explicit_return_type "std::size_t"
	nparams 1
	  param in name "v" explicit_type "double"
	cpp_decl "    ${comment}${friend}constexpr ${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}
{
  return std::size_t( v * 1024 * 1024 );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Convert double into size_t"
      end

      attribute 297264 "nsub"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      attribute 297392 "dxf"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      attribute 297520 "dxw"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      attribute 297648 "pore_hlength"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      attribute 297776 "cell_hlength"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      attribute 297904 "pore_radius"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      attribute 298032 "protein_radius"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      attribute 298160 "cell_radius"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      attribute 298288 "vestibule_arc"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      attribute 298416 "membrane_arc"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      attribute 298544 "permittivity"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      attribute 298672 "protein_permittivity"
	public explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " nsub0 check value"
      end

      operation 417712 "set_dxw"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->dxw = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 417840 "set_pore_hlength"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->pore_hlength = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 417968 "cell_hlength"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 418352 "cell_radius"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 419248 "dxf"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 419376 "dxw"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 418608 "membrane_arc"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 419120 "nsub"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 418736 "permittivity"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 418864 "protein_permittivity"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 418224 "protein_radius"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 419504 "pore_hlength"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 418096 "pore_radius"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 418480 "vestibule_arc"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name} = this->hashdbl( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 418992 "set_data"
	public explicit_return_type "void"
	nparams 2
	  param in name "icc" type class_ref 805423 // induced_charge
	  param in name "sim" type class_ref 1129391 // channel_system
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set object's data from source data."
      end

      operation 419760 "compare"
	const public explicit_return_type "bool"
	nparams 2
	  param in name "icc" type class_ref 805423 // induced_charge
	  param in name "sim" type class_ref 1129391 // channel_system
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Compare source data with this object"
      end

      operation 419632 "equivalent"
	const public explicit_return_type "bool"
	nparams 1
	  param in name "other" type class_ref 258096 // check_data
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Compare two check data objects"
      end

      operation 419888 "write_data"
	const public explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Write data to stream."
      end

      operation 420016 "read_data"
	public explicit_return_type "bool"
	nparams 1
	  param inout name "input" explicit_type "istream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Read data from a stream. Return false if problems reading the stream."
      end

      operation 420144 "check_data"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw}
: nsub(), dxf(), dxw(), pore_hlength(), cell_hlength(), pore_radius()
, protein_radius(), cell_radius(), vestibule_arc(), membrane_arc()
, permittivity(), protein_permittivity()
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 420400 "check_data"
	stereotype "copy"
	public explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 258096 // check_data
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 420656 "check_data"
	stereotype "move"
	public explicit_return_type ""
	nparams 1
	  param inout name "source" type class_ref 258096 // check_data
	cpp_decl "    ${comment}${inline}${name}${(}${t0} && ${p0}${v0}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 420912 "swap"
	const public explicit_return_type "bool"
	nparams 1
	  param in name "other" type class_ref 258096 // check_data
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Compare two check data objects"
      end

      operation 420272 "~check_data"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 420528 "operator="
	public return_type class_ref 258096 // check_data
	nparams 1
	  param in name "source" type class_ref 258096 // check_data
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${abstract}
{
  this->swap( ${p0} );
  return *this;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end
    end

    class 244144 "icc_matrix"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "  Matrix of coefficients of simultaneous equations used
  for calculating induced surface charges from external
  electric field."
      classrelation 268592 // <dependency>
	relation 268336 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 268592 // <dependency>
	  b parent class_ref 912431 // access
      end

      classrelation 266800 // <dependency>
	relation 266544 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 266800 // <dependency>
	  b parent class_ref 184623 // lapack
      end

      class 244272 "array_type"
	visibility package stereotype "typedef" base_type class_ref 203825 // multi_array
	nactuals 3
	actual class class_ref 203825 // multi_array
	  rank 0 explicit_value "double"
	actual class class_ref 203825 // multi_array
	  rank 1 explicit_value "2"
	actual class class_ref 203825 // multi_array
	  rank 2 explicit_value ""
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl "${comment}typedef ${type} ${name};
"
	explicit_switch_type ""
	
	classrelation 266928 // <realization>
	  relation 266672 -_-|>
	    a public
	      cpp default "${type}"
	      python "${type}"
	      classrelation_ref 266928 // <realization>
	    b parent class_ref 203825 // multi_array
	end
      end

      classrelation 267696 // amx_ (<directional composition>)
	relation 267440 *-->
	  a role_name "amx_" multiplicity "1" private
	    comment " The A matrix"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    python "${comment}${self}${name} = ${type}()
"
	    classrelation_ref 267696 // amx_ (<directional composition>)
	  b parent class_ref 244272 // array_type
      end

      attribute 276912 "indx_"
	private type class_ref 230576 // int_type
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The index vector from the LU decomposition"
      end

      attribute 940592 "row_major_"
	private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Storage order of matrix. Defaults to true but may be changed by some methods to optimise performance."
      end

      extra_member 226992 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 388144 "icc_matrix"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
${body}
"
	
	
	
	
      end

      operation 388272 "icc_matrix"
	stereotype "copy"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 244144 // icc_matrix
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 388400 "icc_matrix"
	stereotype "move"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 244144 // icc_matrix
	cpp_decl "    ${comment}${inline}${name}${(}${t0} && ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 388528 "~icc_matrix"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw}
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 388656 "operator="
	private return_type class_ref 244144 // icc_matrix
	nparams 1
	  param in name "source" type class_ref 244144 // icc_matrix
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${abstract} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 228272 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 397360 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
   ar & amx_;
   ar & indx_;
   ar & row_major_;
}
"
	
	
	
	
      end

      extra_member 227120 "ACCESS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 388784 "a"
	const public explicit_return_type "double"
	nparams 2
	  param in name "i1" explicit_type "size_t"
	  param in name "i2" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  std::array< std::size_t, 2 > idx;
  idx[ 0 ] = ${p0};
  idx[ 1 ] = ${p1};
  return this->amx_( idx );
}
"
	
	
	
	
	comment " Get value from A matrix

 \\pre i1 < size and i2 < size (not checked)"
      end

      operation 389168 "empty"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->indx_.${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 2472368 "is_row_major"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->row_major_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 389552 "pivot"
	const public explicit_return_type "double"
	nparams 1
	  param in name "i1" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  return this->indx_.at( ${p0} );
}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get value from H vector

 \\pre idx < size"
      end

      operation 390832 "size"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->indx_.${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 390960 "write_a_matrix"
	const public explicit_return_type "void"
	nparams 1
	  param inout name "output" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "----------------------------------------------------------------------
 save amx and indx

 This is the counterpoint method to 'readam'.  It saves a digest
 of of the input parameters critical to defining the matrix.
 These are the protein geometry parameters, the patch integration
 grid parameters and the permittivity constants. Then saves the
 'amx' matrix itself.

 \\pre not empty"
      end

      extra_member 227248 "ACTION"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 397488 "back_substitute"
	const public explicit_return_type "void"
	nparams 1
	  param inout name "ch" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}std::vector< ${t0} > & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}std::vector< ${t0} > & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 532144 "back_substitute"
	const public explicit_return_type "void"
	nparams 1
	  param inout name "ch" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}std::valarray< ${t0} > & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}std::valarray< ${t0} > & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 391216 "compute_amx"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param inout name "grid" explicit_type "icc_surface_grid"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Compute the A matrix by integrating the the grid.

 \\pre empty
 \\pre not grid.empty
"
      end

      operation 391472 "lu_decompose_amx"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " After the A matrix has been generated, perform LU decomposition.
"
      end
    end

    class 1005615 "icc_surface_grid"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Convert 2D geometry into a surface of rotation as a
 dielectric boundary surface. Discretize the surface in
 preparation of computing a set of simultaneous equations
 for calculating the surface charge on a surface element
 based on the external electric field."
      classrelation 252336 // <dependency>
	relation 252080 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 252336 // <dependency>
	  b parent class_ref 912431 // access
      end

      classrelation 333360 // <dependency>
	relation 332976 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 333360 // <dependency>
	  b parent class_ref 1005871 // integrator
      end

      attribute 250800 "area_"
	private explicit_type "double"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Surface area of a patch"
      end

      attribute 250672 "deps_"
	private explicit_type "double"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The effective dielectric constant on the outside of a patch"
      end

      attribute 307248 "eps_in_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${stereotype}()
"
	idl_decl ""
	comment " The permittivity on the inside of the surface (ie negative
 direction of surface normal)"
      end

      attribute 307120 "eps_out_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${stereotype}()
"
	idl_decl ""
	comment " The permittivity on the outside of the surface (ie positive
 direction of surface normal)"
      end

      classrelation 1102639 // intgs_ (<directional composition>)
	relation 1065519 *-->
	  stereotype "ptr_vector"
	  a role_name "intgs_" private
	    comment " Integrator functors/closures for each patch"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	    python "${comment}${self}${name} = ${type}()
"
	    classrelation_ref 1102639 // intgs_ (<directional composition>)
	  b parent class_ref 1005871 // integrator
      end

      attribute 250544 "ux_"
	private explicit_type "double"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " X dimension of normal vector to centre of patch "
      end

      attribute 250416 "uy_"
	private explicit_type "double"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Y dimension of normal vector to centre of patch"
      end

      attribute 250288 "uz_"
	private explicit_type "double"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Z dimension of normal vector to centre of patch"
      end

      attribute 250160 "xyz_"
	private type class_ref 223792 // coordinate_set
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " x, y, z coordinate of patch"
      end

      attribute 1288239 "dx_zaxis_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "  The desired tile size for lines parallel or radial to the z-axis."
      end

      attribute 1288367 "dx_radial_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "  The desired tile size to split up the circumferences of circles that are 
  centred on the z-axis."
      end

      attribute 1288495 "nsub0_"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Number of sub-tiles in each dimension when integrating between
 two separate tiles"
      end

      attribute 1289775 "npatch_"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Number of grid points/tiles"
      end

      attribute 1289903 "npatch_alloc_"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Allocated array size"
      end

      attribute 252080 "patch_file_version_"
	class_attribute const_attribute private explicit_type "size_t"
	init_value "1"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "  The version of the patch file this class understands"
      end

      extra_member 212144 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 348592 "icc_surface_grid"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 348720 "icc_surface_grid"
	stereotype "copy"
	private explicit_return_type ""
	nparams 1
	  param in name "source" explicit_type "icc_surface_grid"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Deleted"
      end

      operation 348976 "icc_surface_grid"
	stereotype "move"
	private explicit_return_type ""
	nparams 1
	  param inout name "source" explicit_type "icc_surface_grid"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} && ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Deleted"
      end

      operation 1835439 "~icc_surface_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 348848 "operator="
	public explicit_return_type "icc_surface_grid"
	nparams 1
	  param in name "source" explicit_type "icc_surface_grid"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${abstract} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Deleted"
      end

      operation 2003887 "write_grid"
	const public explicit_return_type "void"
	nparams 1
	  param inout name "output" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Write the tile definitions to disk."
      end

      extra_member 212528 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 349360 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
   ar & area_;
   ar & deps_;
   ar & eps_in_;
   ar & eps_out_;
   ar & intgs_;
   ar & ux_;
   ar & uy_;
   ar & uz_;
   ar & xyz_;
   ar & dx_zaxis_;
   ar & dx_radial_;
   ar & nsub0_;
   ar & npatch_;
   ar & npatch_alloc_;
}
"
	
	
	
	
      end

      extra_member 212272 "ACCESS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1836463 "area"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 1
	  param in name "jpatch" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_[ ${p0} ];
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 2530736 "surface_area"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Total area of all surface elements"
      end

      operation 346928 "coordinates"
	const public return_type class_ref 223792 // coordinate_set
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type}& ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->xyz_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Get the set of patch x,y,z coordinates"
      end

      operation 1836975 "deps"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 1
	  param in name "jpatch" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_[ ${p0} ];
}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 369840 "empty"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->npatch_ == 0;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Number of grid points"
      end

      operation 434480 "eps_in"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 1
	  param in name "jpatch" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_[ ${p0} ];
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " The permittivity on the inside of the surface (ie negative
 direction of surface normal)"
      end

      operation 434608 "eps_out"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 1
	  param in name "jpatch" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_[ ${p0} ];
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " The permittivity on the outside of the surface (ie positive
 direction of surface normal)"
      end

      operation 348464 "have_integrators"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return not this->intgs_.empty() and this->intgs_.size() == this->npatch_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Do we have integrators available to be able to generate
 the matrix?

 \\return not intg_.empty and intg_.size = size"
      end

      operation 350512 "get_dxf"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->dx_radial_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis"
      end

      operation 350384 "get_dxw"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->dx_zaxis_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta that divides lines and arcs that
 are parallel or radial to the z-axis."
      end

      operation 350256 "get_nsub0"
	stereotype "get"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->nsub0_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the subtiling factor that determines how many subtiles
 a patch/tile is divided into during integration "
      end

      operation 1837103 "size"
	const cpp_inline public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->npatch_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Number of grid points"
      end

      operation 1836591 "ux"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 1
	  param in name "jpatch" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_[ ${p0} ];
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 1836719 "uy"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 1
	  param in name "jpatch" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_[ ${p0} ];
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 1836847 "uz"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 1
	  param in name "jpatch" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_[ ${p0} ];
}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 1836079 "x"
	stereotype "get"
	const cpp_inline public explicit_return_type "double"
	nparams 1
	  param in name "jpatch" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->xyz_.${name}( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " -- grid point attributes"
      end

      operation 1836207 "y"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 1
	  param in name "jpatch" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->xyz_.${name}( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 1836335 "z"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 1
	  param in name "jpatch" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->xyz_.${name}( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      extra_member 212400 "ACTION"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1835567 "add_line"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 8
	  param in name "a_zleft" explicit_type "double"
	  param in name "a_zright" explicit_type "double"
	  param in name "a_radius" explicit_type "double"
	  param in name "a_epsin" explicit_type "double"
	  param in name "a_epsout" explicit_type "double"
	  param in name "a_z_min" explicit_type "size_t"
	  param in name "a_r_min" explicit_type "size_t"
	  param in name "is_internal" explicit_type "bool"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}, ${t7} ${p7}${v7}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6} ${p6}, ${t7} ${p7}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " ----------------------------------------
 Calculate tiles along a cylinder. When is_internal is false
 the calculation of patches is changed to create larger
 patches.  The changes are:
  dx = (is_internal ? dxf : dxw/sqrt(rl2))
  nzl = max( ( a_z_min ), int(dll/dx) + 1)
  nfil = max( a_r_min, int(cir/dx) + 1)


 @param a_zleft : the z-value of left end of cylinder
 @param a_zright : the z-value of right end of cylinder
 @param a_radius : the radius of the cylinder
 @param a_deps : the change in permitivity across boundary
 @param a_z_min : the minimum number of tile in the z direction
       (Fortran ionch used 10 for inner and ?4? for outer
 @param is_internal : whether the tiles face towards (true) the
       z-axis or away. "
      end

      operation 1835695 "add_arc"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 10
	  param in name "za0" explicit_type "double"
	  param in name "ra0" explicit_type "double"
	  param in name "ra" explicit_type "double"
	  param in name "ta1" explicit_type "double"
	  param in name "ta2" explicit_type "double"
	  param in name "a_epsin" explicit_type "double"
	  param in name "a_epsout" explicit_type "double"
	  param in name "a_z_min" explicit_type "size_t"
	  param in name "a_r_min" explicit_type "size_t"
	  param in name "is_outer" explicit_type "bool"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}, ${t7} ${p7}${v7}, ${t8} ${p8}${v8}, ${t9} ${p9}${v9}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6} ${p6}, ${t7} ${p7}, ${t8} ${p8}, ${t9} ${p9}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "

 \\param is_outer : is the media on the outer side of the
    arc or inner side. (For the four \"corners\" of the standard 
    toroid will be true.)"
      end

      operation 1835823 "add_wall"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 8
	  param in name "a_z" explicit_type "double"
	  param in name "a_rl1" explicit_type "double"
	  param in name "a_rl2" explicit_type "double"
	  param in name "a_epsin" explicit_type "double"
	  param in name "a_epsout" explicit_type "double"
	  param in name "min_phi" explicit_type "size_t"
	  param in name "min_rad" explicit_type "size_t"
	  param in name "is_to_positive" explicit_type "bool"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}, ${t7} ${p7}${v7}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6} ${p6}, ${t7} ${p7}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "


 \\param is_to_positive : is the media on the more positive side of the wall?"
      end

      operation 349104 "clear"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Remove the tile definitions."
      end

      operation 348336 "clear_integrators"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  this->intgs_.clear();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  After generating the A matrix the integrator objects are no-longer
  needed and, optionally, can be removed."
      end

      operation 1835951 "generate_matrix"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param inout name "a_matrix" explicit_type "boost::multi_array< double, 2 >"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Integrate grid

 \\pre not empty
 \\pre have_integrators"
      end

      operation 347056 "resize"
	public explicit_return_type "void"
	nparams 1
	  param in name "npatch" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Resize the allocated memory."
      end

      operation 346800 "set_dxf"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  UTILITY_REQUIRE( this->empty(), \"Cannot change integration settings after defining the geometry.\" );
  this->dx_radial_ = ${p0};
}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis (only 
 useful before generating A matrix)

 \\pre empty"
      end

      operation 346672 "set_dxw"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  UTILITY_REQUIRE( this->empty(), \"Cannot change integration settings after defining the geometry.\" );
  this->dx_zaxis_ = ${p0};
}

"
	
	
	
	
	comment " Set the patch/tile delta that divides lines and arcs that
 are parallel or radial to the z-axis.  (only useful before 
 generating A matrix) 

 \\pre empty"
      end

      operation 346544 "set_nsub0"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  UTILITY_REQUIRE( this->empty(), \"Cannot change integration settings after defining the geometry.\" );
  this->nsub0_ = ${p0};
}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the radial delta 

 \\pre empty"
      end
    end

    class 805423 "induced_charge"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " Induced Charge Computation evaluator.

 Evaluate the interaction between dielectric boundary and ensemble of
 charges. This is done by calculating the surface charge on the
 dielectric surface from the external electric field and then calculating
 the Coulomb interactions between the surface charge and the ensemble
 of charges.
 
 NOTES
 * We assume constant permittivity in solvent.
 * We assume the dielectric boundary has a fixed geometry during
   the simulation."
      classrelation 1349039 // <generalisation>
	relation 1309871 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 1349039 // <generalisation>
	  b parent class_ref 912175 // base_evaluator
      end

      classrelation 252592 // <dependency>
	relation 252336 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 252592 // <dependency>
	  b parent class_ref 912431 // access
      end

      classrelation 326832 // <dependency>
	relation 326448 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 326832 // <dependency>
	  b parent class_ref 1005615 // icc_surface_grid
      end

      classrelation 268720 // amx_ (<directional composition>)
	relation 268464 *-->
	  a role_name "amx_" private
	    comment " The ICC A matrix."
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    python "${comment}${self}${name} = ${type}()
"
	    classrelation_ref 268720 // amx_ (<directional composition>)
	  b parent class_ref 244144 // icc_matrix
      end

      attribute 990383 "c_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The c vector"
      end

      attribute 990255 "cnew_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_mutable cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The changed C vector from latest trial"
      end

      classrelation 251952 // grid_ (<directional composition>)
	relation 251696 *-->
	  stereotype "unique_ptr"
	  a role_name "grid_" multiplicity "*" private
	    comment "  The set of patches on the surface"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}< ${type} > ${name}${value};
"
	    python "${comment}${self}${name} = ${stereotype}()
"
	    classrelation_ref 251952 // grid_ (<directional composition>)
	  b parent class_ref 1005615 // icc_surface_grid
      end

      attribute 990511 "h_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The h vector"
      end

      attribute 990639 "hnew_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_mutable cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The changed h vector from the latest trial"
      end

      attribute 990127 "rip_"
	private explicit_type "double, 2"
	multiplicity "*"
	stereotype "multi_array"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The stored particle-patch distances"
      end

      attribute 991023 "ripnew_"
	private explicit_type "std::vector< double >"
	multiplicity "*"
	stereotype "vector"
	cpp_mutable cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The trial particle-patch distances"
      end

      attribute 1339695 "a_matrix_filename"
	private explicit_type "string"
	init_value "\"a\""
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}_${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	get_oper operation_ref 343984 // get_a_matrix_filename
	set_oper operation_ref 344112 // set_a_matrix_filename
	comment " filename for storing the A matrix (default : amx.XXX)

 NOTE: boost text archive format may exist with filename (amx.XXX.ar)

 file format:
 1 # file version
 npchsz # dimension -> ( npchsz x npchsz )
 i1 i2 value # indices and entry
 ... "
      end

      attribute 1339823 "patch_filename"
	private explicit_type "string"
	init_value "\"patch\""
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}_${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	get_oper operation_ref 344496 // get_patch_filename
	set_oper operation_ref 344624 // set_patch_filename
	comment " filename for storing the tile definition (patch grid) (default : patch.XXX)

 NOTE: boost text archive format may exist with filename (patch.XXX.ar)

 file format:
 1 { 2 }  # format version
 npchsz # number of patches
 prx pry prz area pux puy puz deps { c1x c1y c1z c2x c2y c2z c3x c3y c3z c4x c4y c4z } 
 ..."
      end

      attribute 252336 "alfa_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Scale factor = kT . echg / (4 * pi * eps0 * angstrom * epsw )

NOTE : We assume constant permittivity in solvent."
      end

      attribute 298800 "epsw_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Solvent permittivity "
      end

      attribute 355248 "old_potential_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "Value of potential for the last accepted configuration."
      end

      attribute 355376 "new_potential_"
	private explicit_type "double"
	cpp_mutable cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "Value of potential for current test configuration."
      end

      attribute 933808 "epspr_"
	private explicit_type "double"
	stereotype "parameter"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " PARAMETER: The permittivity of the protein

 DEFAULT : 10"
      end

      attribute 933936 "protein_radius_"
	private explicit_type "double"
	stereotype "parameter"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " PARAMETER: The outer radius of the protein 

 PR > rgn.channel_radius + rgn.arc_radius + membrane_arc_radius and PR < rgn.radius

 DEFAULT:  rgn.channel_radius + rgn.arc_radius + membrane_arc_radius"
      end

      attribute 934064 "membrane_arc_radius_"
	private explicit_type "double"
	stereotype "parameter"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " PARAMETER: arc radius of toroid inside the membrane

 DEFAULT: rgn.arc_radius"
      end

      extra_member 212656 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 537008 "induced_charge"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
${body}
"
	
	
	
	
      end

      operation 350768 "induced_charge"
	stereotype "copy"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 805423 // induced_charge
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} = delete;
"
	
	
	
	
	comment "no copy"
      end

      operation 351024 "induced_charge"
	stereotype "move"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 805423 // induced_charge
	cpp_decl "    ${comment}${inline}${name}${(}${t0} && ${p0}${)}${volatile}${throw} = delete;
"
	
	
	
	
	comment "no move"
      end

      operation 350640 "~induced_charge"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw}
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 350896 "operator="
	private return_type class_ref 805423 // induced_charge
	nparams 1
	  param in name "source" type class_ref 805423 // induced_charge
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${abstract} = delete;
"
	
	
	
	
	comment "no assignment"
      end

      operation 2455856 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 1143599 // evaluator_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a evaluator_definition to the meta object."
      end

      operation 537264 "make_evaluator"
	class_operation preserve_cpp_body_indent public return_type class_ref 912175 // base_evaluator
	nparams 1
	  param in name "param_set" type class_ref 844336 // input_parameter_memo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}std::unique_ptr< ${type} > ${name}${(}const std::vector< ${t0} >& ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}std::unique_ptr< ${type} > ${class}::${name}${(}const std::vector< ${t0} >& ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Set up the evaluator using the given map of name/value pairs

Valid only for channel_system simtypes. Accepts no input parameters."
      end

      extra_member 213168 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 537136 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  ar & boost::serialization::base_object< base_evaluator >(*this);
   ar & amx_;
   ar & c_;
   ar & cnew_;
   ar & grid_;
   ar & h_;
   ar & hnew_;
   ar & rip_;
   ar & ripnew_;
   ar & a_matrix_filename_;
   ar & patch_filename_;
   ar & alfa_;
   ar & epsw_;
   ar & old_potential_;
   ar & new_potential_;
   ar & epspr_;
   ar & protein_radius_;
   ar & membrane_arc_radius_;
}
"
	
	
	
	
      end

      extra_member 823088 "KEY INHERITED METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 538160 "compute_potential"
	preserve_cpp_body_indent const public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param inout name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, ${t2} & ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " UNIFIED ICC ENERGY
 
 This method calculates the change in coulombic potential energy between
 the particles and the surface patches.
"
      end

      operation 539056 "compute_total_potential"
	const cpp_virtual public explicit_return_type "double"
	nparams 2
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Calculate the total potential energy."
      end

      operation 537776 "prepare"
	stereotype "TODO"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param in name "eman" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, const ${t2} & ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Prepare the evaluator for running a simulation loop set."
      end

      extra_member 212784 "ACCESS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 2456112 "amx_file_label"
	class_operation public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return \"amx_file\";
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 352176 "do_description"
	const cpp_virtual private explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Log message descibing the evaluator and its parameters"
      end

      operation 352048 "do_write_document"
	preserve_cpp_body_indent const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Write evaluator specific content of input file section.

 only throw possible should be from os.write() operation"
      end

      operation 349744 "empty"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->amx_.${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 537392 "field"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->c_[ ${p0} ];
}
"
	
	
	
	
	comment "Field experienced normal to a given surface element"
      end

      operation 343984 "get_a_matrix_filename"
	force_body_gen const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} ${name}${(}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}const ${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return a_matrix_filename_;
}
"
	cpp_name_spec "get_${name}"
	final 
	java_name_spec "get${Name}"
	php_final 
	php_name_spec "get${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}self${p0}${v0}${)}:
${docstring}return self.a_matrix_filename
"
	python_name_spec "get${name}"
	
	idl_name_spec "get_${name}"
	get_of_attribute attribute_ref 1339695 // a_matrix_filename
	comment " Filename to save A matrix data. If empty no data is saved separately."
      end

      operation 410672 "get_alfa"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->alfa_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis"
      end

      operation 349872 "get_dxf"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
   return this->grid_->${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis"
      end

      operation 350000 "get_dxw"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
   return this->grid_->${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta that divides lines and arcs that
 are parallel or radial to the z-axis."
      end

      operation 350128 "get_nsub0"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
   return this->grid_->${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the subtiling factor that determines how many subtiles
 a patch/tile is divided into during integration "
      end

      operation 344496 "get_patch_filename"
	force_body_gen const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} ${name}${(}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}const ${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return patch_filename_;
}
"
	cpp_name_spec "get_${name}"
	final 
	java_name_spec "get${Name}"
	php_final 
	php_name_spec "get${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}self${p0}${v0}${)}:
${docstring}return self.patch_filename
"
	python_name_spec "get${name}"
	
	idl_name_spec "get_${name}"
	get_of_attribute attribute_ref 1339823 // patch_filename
	comment " Filename to save patch data. If empty no data is saved separately."
      end

      operation 422064 "get_permittivity"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->epsw_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the relative permittivity of the solvent media"
      end

      operation 2485680 "get_protein_permittivity"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->epspr_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the relative permittivity of the protein media"
      end

      operation 2485552 "get_protein_radius"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->protein_radius_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the radius of the outer part of the protein. It should be less than the cell radius but
 greater than the sum of the channel radius and the vestibule and membrane
 arc radii."
      end

      operation 2485424 "get_membrane_arc_radius"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->membrane_arc_radius_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the arc radius of the protein toroid within the membrane."
      end

      operation 2455984 "patch_file_label"
	class_operation public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return \"patch_file\";
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 538416 "surface_charge"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Induced charge on a given surface element"
      end

      operation 421680 "surface_area"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  return this->grid_->area( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Area of a given surface element"
      end

      operation 2530608 "surface_area"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return this->grid_->surface_area();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Total area of all surface elements"
      end

      operation 538288 "surface_value"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->h_[ ${p0} ];
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " H array value on a given surface element"
      end

      operation 349616 "size"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->amx_.${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 351408 "type_label"
	const cpp_virtual public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw} override
{
  return ${class}::${name}_();
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 351280 "type_label_"
	class_operation preserve_cpp_body_indent public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
      end

      operation 417200 "write_data"
	const public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Write surface tile and A matrix data to files"
      end

      extra_member 212912 "ACTION"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 538032 "compute_initial_c_h"
	public explicit_return_type "void"
	nparams 1
	  param in name "pman" type class_ref 446128 // particle_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Compute the initial C and H matrices"
      end

      operation 537904 "compute_total_surface_charge"
	const public explicit_return_type "void"
	nparams 2
	  param out name "charget" explicit_type "double"
	  param out name "areat" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
	comment "Compute the total surface area and charge"
      end

      operation 2003375 "create_amx"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "rgn" type class_ref 486448 // membrane_cylinder_region
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
   this->create_amx( ${p0}.channel_half_length(), ${p0}.channel_radius(), ${p0}.arc_radius() );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create the  matrix, this involves defining the patch grid,
 integrating the grid to generate the A' matrix then inverting
 this matrix to get the A matrix.

 Use the input geometry to define the information that the
 'patch' module will use to generate a set of 'patches' that
 cover the protein surface.

 fortran equiv patch::defgrd + patch::matrix
  see ionch::iccgrid::add_XXXX for patch::goXXXX
  see ionch::XXXX_integrator types for patch::intXXXX"
      end

      operation 410416 "create_amx"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 3
	  param in name "zl1" explicit_type "double"
	  param in name "rl1" explicit_type "double"
	  param in name "rlvest" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create the  matrix, this involves defining the patch grid,
 integrating the grid to generate the A' matrix then inverting
 this matrix to get the A matrix.

 Use the input geometry to define the information that the
 'patch' module will use to generate a set of 'patches' that
 cover the protein surface.

 fortran equiv patch::defgrd + patch::matrix
  see ionch::iccgrid::add_XXXX for patch::goXXXX
  see ionch::XXXX_integrator types for patch::intXXXX"
      end

      operation 421040 "create_amx"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param inout name "grid" explicit_type "icc_surface_grid"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}std::unique_ptr< ${t0} >& ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}std::unique_ptr< ${t0} >& ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Swap the internatl grid with the supplied
 grid and create the A matrix, this involves
 integrating the grid to generate the A' matrix
 then inverting this matrix to get the A matrix.

 Use the input geometry to define the information
 that the 'patch' module will use to generate a
 set of 'patches' that cover the protein surface.

 fortran equiv patch::defgrd + patch::matrix
  see ionch::iccgrid::add_XXXX for patch::goXXXX
  see ionch::XXXX_integrator types for
  patch::intXXXX
"
      end

      operation 2523952 "create_amx_f"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 3
	  param in name "zl1" explicit_type "double"
	  param in name "rl1" explicit_type "double"
	  param in name "rlvest" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create the  matrix like fortran does, this involves defining the patch grid,
 integrating the grid to generate the A' matrix then inverting
 this matrix to get the A matrix.

 Use the input geometry to define the information that the
 'patch' module will use to generate a set of 'patches' that
 cover the protein surface.

 fortran equiv patch::defgrd + patch::matrix
  see ionch::iccgrid::add_XXXX for patch::goXXXX
  see ionch::XXXX_integrator types for patch::intXXXX"
      end

      operation 538544 "on_conclude_trial"
	public explicit_return_type "void"
	nparams 1
	  param in name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "  Called after the result of the trial is known."
      end

      operation 344112 "set_a_matrix_filename"
	force_body_gen public explicit_return_type "void"
	nparams 1
	  param in name "value" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  a_matrix_filename_ = ${p0};

}
"
	cpp_name_spec "set_${name}"
	
	java_name_spec "set${Name}"
	
	php_name_spec "set${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}self, ${p0}${)}:
${docstring}self.a_matrix_filename = ${p0}
"
	python_name_spec "set${name}"
	
	idl_name_spec "set_${name}"
	set_of_attribute attribute_ref 1339695 // a_matrix_filename
	comment " Set filename to save A matrix information. If not set then no data is saved."
      end

      operation 410544 "set_alfa"
	public explicit_return_type "void"
	nparams 1
	  param in name "temperature" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Set the alfa scaling factor:
  alfa = k{temperature} . echg / (4 * pi * eps0 * angstrom * {permittivity} )

 \\param temperature : in kelvin
 \\param permittivity : relative permittivity."
      end

      operation 346160 "set_dxf"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  this->grid_->${name}( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis (only 
 useful before generating A matrix)"
      end

      operation 346288 "set_dxw"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  this->grid_->${name}( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the patch/tile delta that divides lines and arcs that
 are parallel or radial to the z-axis.  (only useful before 
 generating A matrix)"
      end

      operation 2456496 "set_membrane_arc_radius"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->membrane_arc_radius_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the arc radius of the protein toroid within the membrane."
      end

      operation 346416 "set_nsub0"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  this->grid_->${name}( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the subtiling factor that determines how many subtiles
 a patch/tile is divided into during integration  (only useful 
 before generating A matrix)"
      end

      operation 344624 "set_patch_filename"
	force_body_gen public explicit_return_type "void"
	nparams 1
	  param in name "value" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  patch_filename_ = ${p0};

}
"
	cpp_name_spec "set_${name}"
	
	java_name_spec "set${Name}"
	
	php_name_spec "set${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}self, ${p0}${)}:
${docstring}self.patch_filename = ${p0}
"
	python_name_spec "set${name}"
	
	idl_name_spec "set_${name}"
	set_of_attribute attribute_ref 1339823 // patch_filename
	comment " Set filename to save patch information. If not set then no patch
 data is saved."
      end

      operation 421936 "set_permittivity"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->epsw_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the relative permittivity of the solvent media"
      end

      operation 2456240 "set_protein_permittivity"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->epspr_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the relative permittivity of the protein media"
      end

      operation 2456368 "set_protein_radius"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->protein_radius_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the radius of the outer part of the protein. It should be less than the cell radius but
 greater than the sum of the channel radius and the vestibule and membrane
 arc radii."
      end

      operation 537648 "dump"
	const public explicit_return_type "void"
	nparams 1
	  param in name "fname" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Dump data from current object"
      end

      operation 2531120 "get_patch_coordinate"
	public explicit_return_type "void"
	nparams 3
	  param in name "idx" explicit_type "size_t"
	  param inout name "pos" type class_ref 986799 // coordinate
	  param inout name "norm" type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} & ${p1}, ${t2} & ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch centre point and normal"
      end

      operation 2550832 "gaussbox"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " calculate a gaussbox over ALL surfaces, so parea_ must be composed
 of closed surfaces"
      end
    end

    class 1005871 "integrator"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " ICC surface integrator interface"
      classrelation 268080 // <dependency>
	relation 267824 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 268080 // <dependency>
	  b parent class_ref 912431 // access
      end

      attribute 1321519 "index_"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The index of the patch for this integrator"
      end

      attribute 268208 "nsub_other_"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The number of subdivisions to use for integrating other patches."
      end

      attribute 268336 "nsub_self_"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The number of subdivisions to use for integrating self patch."
      end

      operation 396592 "integrator"
	protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1958959 "integrator"
	public explicit_return_type ""
	nparams 2
	  param in name "a_nsub" explicit_type "size_t"
	  param in name "a_index" explicit_type "size_t"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw}
: index_(${p1})
, nsub_other_(${p0})
, nsub_self_(${p0}*6.0)
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " The single nsub constructor (sets nsub_other = a_nsub and nsub_self = 5 * nsub_other)"
      end

      operation 376880 "integrator"
	public explicit_return_type ""
	nparams 3
	  param in name "a_nsubO" explicit_type "size_t"
	  param in name "a_nsubS" explicit_type "size_t"
	  param in name "a_index" explicit_type "size_t"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw};

"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throw}
: index_(${p2})
, nsub_other_(${p0})
, nsub_self_(${p1})
{
  UTILITY_REQUIRE( (a_nsubS % 2) == 0, \"Number of subelements in self integration must be even.\" );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " The only constructor"
      end

      operation 1959087 "~integrator"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 1959215 "operator ()"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 7
	  param in name "other" explicit_type "size_t"
	  param in name "pxi" explicit_type "double"
	  param in name "pyi" explicit_type "double"
	  param in name "pzi" explicit_type "double"
	  param in name "pux" explicit_type "double"
	  param in name "puy" explicit_type "double"
	  param in name "puz" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Virtual method for performing the integration."
      end

      operation 345776 "integrator"
	stereotype "copy"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 1005871 // integrator
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 346032 "integrator"
	stereotype "move"
	private explicit_return_type ""
	nparams 1
	  param inout name "source" type class_ref 1005871 // integrator
	cpp_decl "    ${comment}${inline}${name}${(}${t0} && ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 345904 "operator="
	private return_type class_ref 1005871 // integrator
	nparams 1
	  param in name "source" type class_ref 1005871 // integrator
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${abstract} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 227760 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 396336 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
   ar & index_;
   ar & nsub_other_;
   ar & nsub_self_;
}
"
	
	
	
	
      end

      operation 361392 "index"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 377264 "nsub_other"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Number of sub-tiles in each dimension when integrating between
 two separate tiles"
      end

      operation 377136 "nsub_self"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Number of sub-tiles in each dimension when integrating a tile
 with itself"
      end
    end

    class 1024303 "arc_integrator"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " ICC surface integrator for surface arcs"
      classrelation 1116719 // <generalisation>
	relation 1079599 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 1116719 // <generalisation>
	  b parent class_ref 1005871 // integrator
      end

      attribute 1322287 "za0_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Z coord of arc centre"
      end

      attribute 1322415 "ra0_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Radial from z-axis of arc centre"
      end

      attribute 1322543 "radius_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Radius of arc"
      end

      attribute 1322671 "theta1_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Tile edges"
      end

      attribute 1322799 "theta2_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
      end

      attribute 1322927 "phi1_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
      end

      attribute 1323055 "phi2_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
      end

      operation 396720 "arc_integrator"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}explicit ${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Should only be used for serialization"
      end

      operation 1959727 "arc_integrator"
	public explicit_return_type ""
	nparams 9
	  param in name "a_nsub" explicit_type "size_t"
	  param in name "a_index" explicit_type "size_t"
	  param in name "a_zcentre" explicit_type "double"
	  param in name "a_rcentre" explicit_type "double"
	  param in name "a_rad" explicit_type "double"
	  param in name "ta1" explicit_type "double"
	  param in name "ta2" explicit_type "double"
	  param in name "fi1" explicit_type "double"
	  param in name "fi2" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}, ${t7} ${p7}${v7}, ${t8} ${p8}${v8}${)}${volatile}${throw}
: integrator(${p0}, a_index)
      , za0_ (a_zcentre)
      , ra0_ (a_rcentre)
      , radius_(a_rad)
      , theta1_(ta1)
      , theta2_(ta2)
      , phi1_(fi1)
      , phi2_(fi2)
    {};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " The only constructor"
      end

      operation 377648 "arc_integrator"
	public explicit_return_type ""
	nparams 10
	  param in name "a_nsubO" explicit_type "size_t"
	  param in name "a_nsubS" explicit_type "size_t"
	  param in name "a_index" explicit_type "size_t"
	  param in name "a_zcentre" explicit_type "double"
	  param in name "a_rcentre" explicit_type "double"
	  param in name "a_rad" explicit_type "double"
	  param in name "ta1" explicit_type "double"
	  param in name "ta2" explicit_type "double"
	  param in name "fi1" explicit_type "double"
	  param in name "fi2" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}, ${t7} ${p7}${v7}, ${t8} ${p8}${v8}, ${t9} ${p9}${v9}${)}${volatile}${throw}
: integrator( ${p0}, ${p1}, a_index)
      , za0_ (a_zcentre)
      , ra0_ (a_rcentre)
      , radius_(a_rad)
      , theta1_(ta1)
      , theta2_(ta2)
      , phi1_(fi1)
      , phi2_(fi2)
    {}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " The only constructor"
      end

      operation 1959855 "~arc_integrator"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      extra_member 227888 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 396464 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
   ar & boost::serialization::base_object< integrator >(*this);
   ar & za0_;
   ar & ra0_;
   ar & radius_;
   ar & theta1_;
   ar & theta2_;
   ar & phi1_;
   ar & phi2_;
}
"
	
	
	
	
      end

      operation 1959983 "operator ()"
	preserve_cpp_body_indent const public explicit_return_type "double"
	nparams 7
	  param in name "pchx" explicit_type "size_t"
	  param in name "pxi" explicit_type "double"
	  param in name "pyi" explicit_type "double"
	  param in name "pzi" explicit_type "double"
	  param in name "pux" explicit_type "double"
	  param in name "puy" explicit_type "double"
	  param in name "puz" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6} ${p6}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Integrate over arc tiles."
      end

      operation 359600 "za0"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Centre of arc circle"
      end

      operation 359856 "ra0"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Radial distance from axis of rotation of the centre of
 the arc"
      end

      operation 359984 "radius"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Radius of the arc"
      end

      operation 360112 "theta1"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Start angle in axial direction"
      end

      operation 360368 "phi1"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Start angle in rotation direction"
      end

      operation 360240 "theta2"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " End angle in axial direction"
      end

      operation 360496 "phi2"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " End angle in rotation direction"
      end
    end

    class 1024175 "cylinder_integrator"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " ICC surface integrator cylindrical surfaces"
      classrelation 1116591 // <generalisation>
	relation 1079471 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 1116591 // <generalisation>
	  b parent class_ref 1005871 // integrator
      end

      attribute 1321647 "radius_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Radius of cylinder"
      end

      attribute 1321775 "zmin_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Tile edges"
      end

      attribute 1321903 "zmax_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
      end

      attribute 1322031 "phimin_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
      end

      attribute 1322159 "phimax_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
      end

      operation 396976 "cylinder_integrator"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}explicit ${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Should only be used for serialization and testing"
      end

      operation 1959343 "cylinder_integrator"
	public explicit_return_type ""
	nparams 7
	  param in name "a_nsub" explicit_type "size_t"
	  param in name "a_index" explicit_type "int"
	  param in name "a_rad" explicit_type "double"
	  param in name "z1" explicit_type "double"
	  param in name "z2" explicit_type "double"
	  param in name "fi1" explicit_type "double"
	  param in name "fi2" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}${)}${volatile}${throw}
: integrator( ${p0}, a_index)
, radius_(a_rad)
, zmin_(z1)
, zmax_(z2)
, phimin_(fi1)
, phimax_(fi2)
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " The only constructor"
      end

      operation 377520 "cylinder_integrator"
	public explicit_return_type ""
	nparams 8
	  param in name "a_nsubO" explicit_type "size_t"
	  param in name "a_nsubS" explicit_type "size_t"
	  param in name "a_index" explicit_type "int"
	  param in name "a_rad" explicit_type "double"
	  param in name "z1" explicit_type "double"
	  param in name "z2" explicit_type "double"
	  param in name "fi1" explicit_type "double"
	  param in name "fi2" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}, ${t7} ${p7}${v7}${)}${volatile}${throw}
: integrator( ${p0}, ${p1}, a_index)
, radius_(a_rad)
, zmin_(z1)
, zmax_(z2)
, phimin_(fi1)
, phimax_(fi2)
{}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " The only constructor"
      end

      operation 1959471 "~cylinder_integrator"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      extra_member 228016 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 396848 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
   ar & boost::serialization::base_object< integrator >(*this);
   ar & radius_;
   ar & zmin_;
   ar & zmax_;
   ar & phimin_;
   ar & phimax_;
}
"
	
	
	
	
      end

      operation 1959599 "operator ()"
	preserve_cpp_body_indent const public explicit_return_type "double"
	nparams 7
	  param in name "pchx" explicit_type "size_t"
	  param in name "pxi" explicit_type "double"
	  param in name "pyi" explicit_type "double"
	  param in name "pzi" explicit_type "double"
	  param in name "pux" explicit_type "double"
	  param in name "puy" explicit_type "double"
	  param in name "puz" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6} ${p6}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Integrate over cylinder tiles."
      end

      operation 361520 "radius"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Radial distance from axis of rotation"
      end

      operation 361648 "zmin"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Lower edge in rotation axis direction"
      end

      operation 361776 "zmax"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Other edge in rotation axis direction"
      end

      operation 361904 "phimin"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Lower edge in direction around of rotation axis"
      end

      operation 362032 "phimax"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Other edge in direction around rotation axis"
      end
    end

    class 1024431 "wall_integrator"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " ICC surface integrator radial surfaces"
      classrelation 1116847 // <generalisation>
	relation 1079727 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 1116847 // <generalisation>
	  b parent class_ref 1005871 // integrator
      end

      attribute 268464 "z_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "Z coordinate of wall"
      end

      attribute 1323183 "ra0_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Inner radius of disk"
      end

      attribute 1323311 "ra1_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Outer radius of disk"
      end

      attribute 1323439 "radius_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Tile centre radius"
      end

      attribute 1323567 "phi1_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Tile edges"
      end

      attribute 1323695 "phi2_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
      end

      operation 397232 "wall_integrator"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}explicit ${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1960111 "wall_integrator"
	public explicit_return_type ""
	nparams 8
	  param in name "a_nsub" explicit_type "size_t"
	  param in name "a_index" explicit_type "size_t"
	  param in name "a_z" explicit_type "double"
	  param in name "a_ra0" explicit_type "double"
	  param in name "a_ra1" explicit_type "double"
	  param in name "a_rad" explicit_type "double"
	  param in name "fi1" explicit_type "double"
	  param in name "fi2" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}, ${t7} ${p7}${v7}${)}${volatile}${throw}
: integrator(a_nsub, a_index)
      , z_ (a_z)
      , ra0_ (a_ra0)
      , ra1_ (a_ra1)
      , radius_(a_rad)
      , phi1_(fi1)
      , phi2_(fi2)
    {}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " The only constructor"
      end

      operation 377392 "wall_integrator"
	public explicit_return_type ""
	nparams 9
	  param in name "a_nsubO" explicit_type "size_t"
	  param in name "a_nsubS" explicit_type "size_t"
	  param in name "a_index" explicit_type "size_t"
	  param in name "a_z" explicit_type "double"
	  param in name "a_ra0" explicit_type "double"
	  param in name "a_ra1" explicit_type "double"
	  param in name "a_rad" explicit_type "double"
	  param in name "fi1" explicit_type "double"
	  param in name "fi2" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}, ${t7} ${p7}${v7}, ${t8} ${p8}${v8}${)}${volatile}${throw}
: integrator(${p0}, ${p1}, a_index)
      , z_ (a_z)
      , ra0_ (a_ra0)
      , ra1_ (a_ra1)
      , radius_(a_rad)
      , phi1_(fi1)
      , phi2_(fi2)
    {}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " The only constructor"
      end

      operation 1960239 "~wall_integrator"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      extra_member 228144 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 397104 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
   ar & boost::serialization::base_object< integrator >(*this);
   ar & z_;
   ar & ra0_;
   ar & ra1_;
   ar & radius_;
   ar & phi1_;
   ar & phi2_;
}
"
	
	
	
	
      end

      operation 1960367 "operator ()"
	preserve_cpp_body_indent const public explicit_return_type "double"
	nparams 7
	  param in name "pchx" explicit_type "size_t"
	  param in name "pxi" explicit_type "double"
	  param in name "pyi" explicit_type "double"
	  param in name "pzi" explicit_type "double"
	  param in name "pux" explicit_type "double"
	  param in name "puy" explicit_type "double"
	  param in name "puz" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6} ${p6}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Virtual method for performing the integration."
      end

      operation 377008 "z"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Lower radial distance from axis of rotation"
      end

      operation 362288 "ra0"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Lower radial distance from axis of rotation"
      end

      operation 362800 "ra1"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Upper radial distance from axis of rotation"
      end

      operation 362928 "radius"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Mean radial distance from axis of rotation"
      end

      operation 362544 "phi1"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Start angle in rotation direction"
      end

      operation 362416 "phi2"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " End angle in rotation direction"
      end
    end

    class 786736 "icc_fortran"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment " Induced Charge Computation evaluator (fortran).

 Evaluate the interaction between dielectric boundary and ensemble of
 charges. This is done by calculating the surface charge on the
 dielectric surface from the external electric field and then calculating
 the Coulomb interactions between the surface charge and the ensemble
 of charges.
 
 NOTES
 * We assume constant permittivity in solvent.
 * We assume the dielectric boundary has a fixed geometry during
   the simulation."
      classrelation 1304496 // <generalisation>
	relation 1303600 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 1304496 // <generalisation>
	  b parent class_ref 912175 // base_evaluator
      end

      classrelation 1304624 // <dependency>
	relation 1303728 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 1304624 // <dependency>
	  b parent class_ref 912431 // access
      end

      attribute 947120 "c_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The c vector"
      end

      attribute 947248 "cnew_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_mutable cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The changed C vector from latest trial"
      end

      attribute 947376 "h_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The h vector"
      end

      attribute 947504 "hnew_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_mutable cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The changed h vector from the latest trial"
      end

      attribute 955952 "rip_"
	private explicit_type "double, 2"
	multiplicity "*"
	stereotype "multi_array"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The stored particle-patch distances"
      end

      attribute 955824 "ripnew_"
	private explicit_type "std::vector< double >"
	multiplicity "*"
	stereotype "vector"
	cpp_mutable cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The trial particle-patch distances"
      end

      attribute 947888 "a_matrix_filename"
	private explicit_type "string"
	init_value "\"a\""
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}_${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	get_oper operation_ref 2505264 // get_a_matrix_filename
	set_oper operation_ref 2508336 // set_a_matrix_filename
	comment " filename for storing the A matrix (default : amx.XXX)

 NOTE: boost text archive format may exist with filename (amx.XXX.ar)

 file format:
 1 # file version
 npchsz # dimension -> ( npchsz x npchsz )
 i1 i2 value # indices and entry
 ... "
      end

      attribute 948016 "patch_filename"
	private explicit_type "string"
	init_value "\"patch\""
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}_${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	get_oper operation_ref 2505904 // get_patch_filename
	set_oper operation_ref 2509104 // set_patch_filename
	comment " filename for storing the tile definition (patch grid) (default : patch.XXX)

 NOTE: boost text archive format may exist with filename (patch.XXX.ar)

 file format:
 1 { 2 }  # format version
 npchsz # number of patches
 prx pry prz area pux puy puz deps { c1x c1y c1z c2x c2y c2z c3x c3y c3z c4x c4y c4z } 
 ..."
      end

      attribute 948144 "alfa_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Scale factor = kT . echg / (4 * pi * eps0 * angstrom * epsw )

NOTE : We assume constant permittivity in solvent."
      end

      attribute 948272 "epsw_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Solvent permittivity "
      end

      attribute 948400 "old_potential_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "Value of potential for the last accepted configuration."
      end

      attribute 948528 "new_potential_"
	private explicit_type "double"
	cpp_mutable cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "Value of potential for current test configuration."
      end

      attribute 948656 "epspr_"
	private explicit_type "double"
	stereotype "parameter"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " PARAMETER: The permittivity of the protein

 DEFAULT : 10"
      end

      attribute 948784 "protein_radius_"
	private explicit_type "double"
	stereotype "parameter"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " PARAMETER: The outer radius of the protein 

 PR > rgn.channel_radius + rgn.arc_radius + membrane_arc_radius and PR < rgn.radius

 DEFAULT:  rgn.channel_radius + rgn.arc_radius + membrane_arc_radius"
      end

      attribute 948912 "membrane_arc_radius_"
	private explicit_type "double"
	stereotype "parameter"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " PARAMETER: arc radius of toroid inside the membrane

 DEFAULT: rgn.arc_radius"
      end

      attribute 949296 "dx_zaxis_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "  The desired tile size for lines parallel or radial to the z-axis."
      end

      attribute 949168 "dx_radial_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "  The desired tile size to split up the circumferences of circles that are 
  centred on the z-axis."
      end

      attribute 949040 "nsub0_"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Number of sub-tiles in each dimension when integrating between
 two separate tiles"
      end

      extra_member 829616 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 2503216 "icc_fortran"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
${body}
"
	
	
	
	
      end

      operation 2503344 "icc_fortran"
	stereotype "copy"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 786736 // icc_fortran
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} = delete;
"
	
	
	
	
	comment "no copy"
      end

      operation 2503472 "icc_fortran"
	stereotype "move"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 786736 // icc_fortran
	cpp_decl "    ${comment}${inline}${name}${(}${t0} && ${p0}${)}${volatile}${throw} = delete;
"
	
	
	
	
	comment "no move"
      end

      operation 2503600 "~icc_fortran"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw}
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 2503728 "operator="
	private return_type class_ref 786736 // icc_fortran
	nparams 1
	  param in name "source" type class_ref 786736 // icc_fortran
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${abstract} = delete;
"
	
	
	
	
	comment "no assignment"
      end

      operation 2503856 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 1143599 // evaluator_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a evaluator_definition to the meta object."
      end

      operation 2503984 "make_evaluator"
	class_operation preserve_cpp_body_indent public return_type class_ref 912175 // base_evaluator
	nparams 1
	  param in name "param_set" type class_ref 844336 // input_parameter_memo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}std::unique_ptr< ${type} > ${name}${(}const std::vector< ${t0} >& ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}std::unique_ptr< ${type} > ${class}::${name}${(}const std::vector< ${t0} >& ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Set up the evaluator using the given map of name/value pairs

Valid only for channel_system simtypes. Accepts no input parameters."
      end

      extra_member 829744 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 2504112 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  ar & boost::serialization::base_object< base_evaluator >(*this);
   ar & c_;
   ar & cnew_;
   ar & h_;
   ar & hnew_;
   ar & a_matrix_filename_;
   ar & patch_filename_;
   ar & alfa_;
   ar & epsw_;
   ar & old_potential_;
   ar & new_potential_;
   ar & epspr_;
   ar & protein_radius_;
   ar & membrane_arc_radius_;
   ar & dx_zaxis_;
   ar & dx_radial_;
   ar & nsub0_;
}
"
	
	
	
	
      end

      extra_member 829872 "KEY INHERITED METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 2504240 "compute_potential"
	preserve_cpp_body_indent const public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param inout name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, ${t2} & ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " UNIFIED ICC ENERGY
 
 This method calculates the change in coulombic potential energy between
 the particles and the surface patches.
"
      end

      operation 2504368 "compute_total_potential"
	const cpp_virtual public explicit_return_type "double"
	nparams 2
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Calculate the total potential energy."
      end

      operation 2504496 "prepare"
	stereotype "TODO"
	cpp_virtual public explicit_return_type "void"
	nparams 3
	  param in name "pman" type class_ref 446128 // particle_manager
	  param in name "gman" type class_ref 452656 // geometry_manager
	  param in name "eman" type class_ref 439344 // evaluator_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, const ${t2} & ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Prepare the evaluator for running a simulation loop set."
      end

      extra_member 830000 "ACCESS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 2504624 "amx_file_label"
	class_operation public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return \"amx_file\";
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 2504752 "do_description"
	const cpp_virtual private explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Log message descibing the evaluator and its parameters"
      end

      operation 2504880 "do_write_document"
	preserve_cpp_body_indent const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Write evaluator specific content of input file section.

 only throw possible should be from os.write() operation"
      end

      operation 2505008 "empty"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->h_.${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 2505136 "field"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->c_[ ${p0} ];
}
"
	
	
	
	
	comment "Field experienced normal to a given surface element"
      end

      operation 2505264 "get_a_matrix_filename"
	force_body_gen const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} ${name}${(}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}const ${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return a_matrix_filename_;
}
"
	cpp_name_spec "get_${name}"
	final 
	java_name_spec "get${Name}"
	php_final 
	php_name_spec "get${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}self${p0}${v0}${)}:
${docstring}return self.a_matrix_filename
"
	python_name_spec "get${name}"
	
	idl_name_spec "get_${name}"
	get_of_attribute attribute_ref 947888 // a_matrix_filename
	comment " Filename to save A matrix data. If empty no data is saved separately."
      end

      operation 2505392 "get_alfa"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->alfa_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis"
      end

      operation 2510384 "get_dxf"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->dx_radial_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis"
      end

      operation 2510256 "get_dxw"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->dx_zaxis_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta that divides lines and arcs that
 are parallel or radial to the z-axis."
      end

      operation 2510128 "get_nsub0"
	stereotype "get"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->nsub0_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the subtiling factor that determines how many subtiles
 a patch/tile is divided into during integration "
      end

      operation 2505904 "get_patch_filename"
	force_body_gen const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} ${name}${(}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}const ${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return patch_filename_;
}
"
	cpp_name_spec "get_${name}"
	final 
	java_name_spec "get${Name}"
	php_final 
	php_name_spec "get${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}self${p0}${v0}${)}:
${docstring}return self.patch_filename
"
	python_name_spec "get${name}"
	
	idl_name_spec "get_${name}"
	get_of_attribute attribute_ref 948016 // patch_filename
	comment " Filename to save patch data. If empty no data is saved separately."
      end

      operation 2506032 "get_permittivity"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->epsw_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the relative permittivity of the solvent media"
      end

      operation 2506160 "get_protein_permittivity"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->epspr_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the relative permittivity of the protein media"
      end

      operation 2506288 "get_protein_radius"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->protein_radius_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the radius of the outer part of the protein. It should be less than the cell radius but
 greater than the sum of the channel radius and the vestibule and membrane
 arc radii."
      end

      operation 2506416 "get_membrane_arc_radius"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->membrane_arc_radius_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the arc radius of the protein toroid within the membrane."
      end

      operation 2506544 "patch_file_label"
	class_operation public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return \"patch_file\";
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 2506672 "surface_charge"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Induced charge on a given surface element"
      end

      operation 2506800 "surface_area"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  const int i${p0}{ ${p0} + 1 };
  return IONCH_AREA( i${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Area of a given surface element"
      end

      operation 2530864 "surface_area"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return IONCH_TOTALAREA();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Total area of all surface elements"
      end

      operation 2506928 "surface_value"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->h_[ ${p0} ];
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " H array value on a given surface element"
      end

      operation 2507056 "size"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->h_.${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 2507184 "type_label"
	const cpp_virtual public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw} override
{
  return ${class}::${name}_();
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 2507312 "type_label_"
	class_operation preserve_cpp_body_indent public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
      end

      operation 2507440 "write_data"
	const public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Write surface tile and A matrix data to files"
      end

      extra_member 830128 "ACTION"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 2507568 "compute_initial_c_h"
	public explicit_return_type "void"
	nparams 1
	  param in name "pman" type class_ref 446128 // particle_manager
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Compute the initial C and H matrices"
      end

      operation 2507696 "compute_total_surface_charge"
	const public explicit_return_type "void"
	nparams 2
	  param out name "charget" explicit_type "double"
	  param out name "areat" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
	comment "Compute the total surface area and charge"
      end

      operation 2507824 "create_amx"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "rgn" type class_ref 486448 // membrane_cylinder_region
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
   this->create_amx( ${p0}.channel_half_length(), ${p0}.channel_radius(), ${p0}.arc_radius() );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create the  matrix, this involves defining the patch grid,
 integrating the grid to generate the A' matrix then inverting
 this matrix to get the A matrix.

 Use the input geometry to define the information that the
 'patch' module will use to generate a set of 'patches' that
 cover the protein surface.

 fortran equiv patch::defgrd + patch::matrix
  see ionch::iccgrid::add_XXXX for patch::goXXXX
  see ionch::XXXX_integrator types for patch::intXXXX"
      end

      operation 2507952 "create_amx"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 3
	  param in name "zl1" explicit_type "double"
	  param in name "rl1" explicit_type "double"
	  param in name "rlvest" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create the  matrix, this involves defining the patch grid,
 integrating the grid to generate the A' matrix then inverting
 this matrix to get the A matrix.

 Use the input geometry to define the information that the
 'patch' module will use to generate a set of 'patches' that
 cover the protein surface.

 fortran equiv patch::defgrd + patch::matrix
  see ionch::iccgrid::add_XXXX for patch::goXXXX
  see ionch::XXXX_integrator types for patch::intXXXX"
      end

      operation 2508208 "on_conclude_trial"
	public explicit_return_type "void"
	nparams 1
	  param in name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "  Called after the result of the trial is known."
      end

      operation 2508336 "set_a_matrix_filename"
	force_body_gen public explicit_return_type "void"
	nparams 1
	  param in name "value" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  a_matrix_filename_ = ${p0};

}
"
	cpp_name_spec "set_${name}"
	
	java_name_spec "set${Name}"
	
	php_name_spec "set${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}self, ${p0}${)}:
${docstring}self.a_matrix_filename = ${p0}
"
	python_name_spec "set${name}"
	
	idl_name_spec "set_${name}"
	set_of_attribute attribute_ref 947888 // a_matrix_filename
	comment " Set filename to save A matrix information. If not set then no data is saved."
      end

      operation 2508464 "set_alfa"
	public explicit_return_type "void"
	nparams 1
	  param in name "temperature" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Set the alfa scaling factor:
  alfa = k{temperature} . echg / (4 * pi * eps0 * angstrom * {permittivity} )

 \\param temperature : in kelvin
 \\param permittivity : relative permittivity."
      end

      operation 2510768 "set_dxf"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  UTILITY_REQUIRE( this->empty(), \"Cannot change integration settings after defining the geometry.\" );
  this->dx_radial_ = ${p0};
}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis (only 
 useful before generating A matrix)

 \\pre empty"
      end

      operation 2510640 "set_dxw"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  UTILITY_REQUIRE( this->empty(), \"Cannot change integration settings after defining the geometry.\" );
  this->dx_zaxis_ = ${p0};
}

"
	
	
	
	
	comment " Set the patch/tile delta that divides lines and arcs that
 are parallel or radial to the z-axis.  (only useful before 
 generating A matrix) 

 \\pre empty"
      end

      operation 2508848 "set_membrane_arc_radius"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->membrane_arc_radius_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the arc radius of the protein toroid within the membrane."
      end

      operation 2510512 "set_nsub0"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  UTILITY_REQUIRE( this->empty(), \"Cannot change integration settings after defining the geometry.\" );
  this->nsub0_ = ${p0};
}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the radial delta 

 \\pre empty"
      end

      operation 2509104 "set_patch_filename"
	force_body_gen public explicit_return_type "void"
	nparams 1
	  param in name "value" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  patch_filename_ = ${p0};

}
"
	cpp_name_spec "set_${name}"
	
	java_name_spec "set${Name}"
	
	php_name_spec "set${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}self, ${p0}${)}:
${docstring}self.patch_filename = ${p0}
"
	python_name_spec "set${name}"
	
	idl_name_spec "set_${name}"
	set_of_attribute attribute_ref 948016 // patch_filename
	comment " Set filename to save patch information. If not set then no patch
 data is saved."
      end

      operation 2509232 "set_permittivity"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->epsw_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the relative permittivity of the solvent media"
      end

      operation 2509360 "set_protein_permittivity"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->epspr_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the relative permittivity of the protein media"
      end

      operation 2509488 "set_protein_radius"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->protein_radius_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the radius of the outer part of the protein. It should be less than the cell radius but
 greater than the sum of the channel radius and the vestibule and membrane
 arc radii."
      end

      operation 2509616 "dump"
	const public explicit_return_type "void"
	nparams 1
	  param in name "fname" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Dump data from current object"
      end

      operation 2531248 "get_patch_coordinate"
	public explicit_return_type "void"
	nparams 3
	  param in name "idx" explicit_type "size_t"
	  param inout name "pos" type class_ref 986799 // coordinate
	  param inout name "norm" type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} & ${p1}, ${t2} & ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch centre point and normal"
      end

      operation 2550960 "gaussbox"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return IONCH_GAUSSBOX(const_cast< double* >(this->h_.data()));
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end
    end
  end

  classview 252848 "fortran ICC"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    associated_deployment_view deploymentview_ref 372143 // evaluator deployment
  end

  classview 174256 "ICC surface geometry (IN PROGRESS)"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    classdiagram 187184 "geometry"
      draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      size A4
    end

    class 250800 "icc_geometry"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      class 251056 "tile_range"
	visibility package 
	nactuals 1
	actual class class_ref 1136687 // iterator_range
	  rank 0 value class_ref 251184 // tile_iterator
	cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
	java_decl ""
	php_decl ""
	python_decl "class ${name}${inherit}:
${docstring}${members}
"
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 275376 // <realization>
	  relation 275120 -_-|>
	    a public
	      cpp default "${type}"
	      python "${type}"
	      classrelation_ref 275376 // <realization>
	    b parent class_ref 1136687 // iterator_range
	end
      end

      class 251184 "tile_iterator"
	visibility package 
	cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
	java_decl ""
	php_decl ""
	python_decl "class ${name}${inherit}:
${docstring}${members}
"
	idl_decl ""
	explicit_switch_type ""
	
	class 251312 "value_type"
	  visibility package stereotype "typedef" base_type class_ref 250928 // icc_tile
	  cpp_decl "${comment}typedef ${type} ${name};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl "${comment}typedef ${type} ${name};
"
	  explicit_switch_type ""
	  
	end
      end

      operation 404144 "end_point"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  The end point of the geometry object in the (r,z) plane"
      end

      operation 404400 "end_tangent"
	public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  The tangent of the line in the (r,z) plane at the end point"
      end

      operation 404016 "start_point"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The starting point of the geometry object in the (r,z) plane"
      end

      operation 404272 "start_tangent"
	public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  The tangent of the line in the (r,z) plane at the starting point"
      end

      operation 404528 "subdivide"
	public return_type class_ref 251056 // tile_range
	nparams 2
	  param in name "rsub" explicit_type "size_t"
	  param in name "zsub" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Subdivide the geometry into rsub tiles around the axis of rotation
 and zsub tiles along the axis."
      end
    end

    class 250928 "icc_tile"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      operation 405296 "area"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 404656 "centroid"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 405936 "centroid_normal"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 404784 "corner_one"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 404912 "corner_two"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 405040 "corner_three"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 405168 "corner_four"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 405424 "normal_one"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 405552 "normal_two"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 405680 "normal_three"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 406192 "normal_four"
	public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end
    end

    class 251440 "subdivide_algorithm"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Interface to algorithms for calculating subtiles along a region of
 the surface of rotation."
      attribute 287280 "centroid"
	public type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The current tile centroid coordinate."
      end

      attribute 287408 "normal"
	public type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The current tile centroid normal."
      end

      attribute 287536 "deps"
	const_attribute public explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "  The current permitivity delta (a constant)"
      end

      attribute 287664 "area"
	public explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The current tile area"
      end

      attribute 288944 "ridx_"
	protected explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Current index around the axis of rotation"
      end

      attribute 290352 "zidx_"
	protected explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Current index along the axis of rotation"
      end

      attribute 290480 "rend_"
	protected explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Maximum index around the axis of rotation"
      end

      attribute 290608 "zend_"
	protected explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Maximum index along the axis of rotation"
      end

      operation 409904 "algorithm_for_tile"
	abstract const cpp_virtual public return_type class_ref 251440 // subdivide_algorithm
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}std::unique_ptr< ${type} > ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Create an algorithm for subtiling the current tile."
      end

      operation 409776 "at_end"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->zidx_ == this->zend_ and this->ridx_ == this->rend_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Have we covered all the tiles?"
      end

      operation 406832 "initiate"
	abstract cpp_virtual public explicit_return_type ""
	nparams 2
	  param in name "rsize" explicit_type "size_t"
	  param in name "zsize" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The number of tiles to subdivide surface into around (rsize)
 and along (zsize) the axis of rotation. This resets the algorithm."
      end

      operation 406960 "initiate"
	abstract cpp_virtual public explicit_return_type ""
	nparams 4
	  param in name "dr" explicit_type "double"
	  param in name "rmin" explicit_type "size_t"
	  param in name "dz" explicit_type "double"
	  param in name "zmin" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The approximate size and minimum number of tiles to subdivide 
 surface into around (dr and rmin) and along (dz and zmin) the 
 axis of rotation. This resets the algorithm."
      end

      operation 407088 "next"
	abstract cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate the next tile. Return false if the last tile has been
 rached."
      end

      operation 407216 "size_bound"
	abstract const cpp_virtual public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate an upper estimate of the number of tiles to
 be generated. "
      end

      operation 407344 "subdivide_algorithm"
	public explicit_return_type ""
	nparams 1
	  param in name "deps" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw}
: centroid()
, normal()
, deps( ${p0} )
, area()
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 408112 "subdivide_algorithm"
	protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}explicit ${inline}${name}${(}${)}${volatile}${throw}
: centroid()
, normal()
, deps()
, area()
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Default ctor for serialization"
      end

      operation 407600 "subdivide_algorithm"
	stereotype "copy"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 251440 // subdivide_algorithm
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " No copy"
      end

      operation 407856 "subdivide_algorithm"
	stereotype "move"
	private explicit_return_type ""
	nparams 1
	  param inout name "source" type class_ref 251440 // subdivide_algorithm
	cpp_decl "    ${comment}${inline}${name}${(}${t0} && ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " no move"
      end

      operation 407472 "~subdivide_algorithm"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 407728 "operator="
	private return_type class_ref 251440 // subdivide_algorithm
	nparams 1
	  param in name "source" type class_ref 251440 // subdivide_algorithm
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${abstract} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " No assign"
      end
    end

    class 251568 "wall_algorithm"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Integrate a surface normal to the axis of rotation

 (Notes on dimension nomenclature. The r coordinate
 is the coordinate around the axis of rotation. The z
 coordinate is described as being along the axis of rotation.
 However, a wall is normal to the axis of rotation.  Therefore
 the z direction is also along the normal to the axis of
 rotation in this case."
      classrelation 275504 // <generalisation>
	relation 275248 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 275504 // <generalisation>
	  b parent class_ref 251440 // subdivide_algorithm
      end

      attribute 287920 "r1_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The smaller radial distance from the axis of rotation"
      end

      attribute 288048 "r2_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The largeer radial distance from the axis of rotation"
      end

      attribute 288176 "rr1_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The current lower radial from axis of rotation"
      end

      attribute 288304 "rr2_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The upper radial from the axis of rotation"
      end

      attribute 290736 "rc_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The centroid radial from the axis of rotation"
      end

      attribute 288432 "ratio_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "  The ratio between lower and upper radial of a tile"
      end

      attribute 288560 "dr_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The angular delta around the axis of rotation"
      end

      operation 408240 "initiate"
	cpp_virtual public explicit_return_type "void"
	nparams 2
	  param in name "rsize" explicit_type "size_t"
	  param in name "zsize" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The number of tiles to subdivide surface into around (rsize)
 and along (zsize) the axis of rotation. This resets the algorithm."
      end

      operation 408368 "initiate"
	cpp_virtual public explicit_return_type ""
	nparams 4
	  param in name "dr" explicit_type "double"
	  param in name "rmin" explicit_type "size_t"
	  param in name "dz" explicit_type "double"
	  param in name "zmin" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The approximate size and minimum number of tiles to subdivide 
 surface into around (dr and rmin) and along (dz and zmin) the 
 axis of rotation. This resets the algorithm."
      end

      operation 408496 "next"
	cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate the next tile. Return false if the last tile has been
 reached. The definition of the tile is valid regardless of the
 return value, being the data for last valid tile when next 
 returns false."
      end

      operation 409648 "on_z_step"
	private explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 408624 "size_bound"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw} override
{
  return this->zend_ * this->rend_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate an upper estimate of the number of tiles to
 be generated. "
      end

      operation 409264 "wall_algorithm"
	protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw}
: subdivide_algorithm()
, z_(), r1_(), r2_(), dr_(), dz_(), dlr_target_()
, dz_target_(), r_min_(), z_min_(), ridx_()
, zidx_(), rend_(), zend_()
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " For serialization only"
      end

      operation 409520 "wall_algorithm"
	public explicit_return_type ""
	nparams 5
	  param in name "z" explicit_type "double"
	  param in name "r1" explicit_type "double"
	  param in name "r2" explicit_type "double"
	  param in name "deps" explicit_type "double"
	  param in name "is_positive" explicit_type "bool"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}${)}${volatile}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create the algorithm.

 \\param is_positive : does the surface normal point along the 
 positive axis of rotation?
"
      end

      operation 409392 "~wall_algorithm"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end
    end

    class 258224 "icc_orig"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "  Evaluate the ICC surface charges and the resulting pairwise interactions

 NOTE : We assume constant permittivity in solvent.

 read/write inverted A matrix and patches.
 generate patches from geometry"
      classrelation 282288 // <generalisation>
	relation 282032 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 282288 // <generalisation>
	  b parent class_ref 912175 // base_evaluator
      end

      classrelation 282416 // <dependency>
	relation 282160 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 282416 // <dependency>
	  b parent class_ref 912431 // access
      end

      classrelation 282544 // amx_ (<directional composition>)
	relation 282288 *-->
	  a role_name "amx_" private
	    comment " The ICC A matrix."
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    python "${comment}${self}${name} = ${type}()
"
	    classrelation_ref 282544 // amx_ (<directional composition>)
	  b parent class_ref 244144 // icc_matrix
      end

      attribute 298928 "c_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The c vector"
      end

      attribute 299056 "cnew_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_mutable cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The changed C vector from latest trial"
      end

      attribute 299184 "h_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The h vector"
      end

      attribute 299312 "hnew_"
	private explicit_type "double"
	multiplicity "*"
	stereotype "vector"
	cpp_mutable cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The changed h vector from the latest trial"
      end

      attribute 299440 "rip_"
	private explicit_type "double, 2"
	multiplicity "*"
	stereotype "multi_array"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The stored particle-patch distances"
      end

      attribute 299568 "ripnew_"
	private explicit_type "std::vector< double >"
	multiplicity "*"
	stereotype "vector"
	cpp_mutable cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The trial particle-patch distances"
      end

      attribute 299696 "a_matrix_filename"
	private explicit_type "string"
	init_value "\"a\""
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}_${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	get_oper operation_ref 423728 // get_a_matrix_filename
	set_oper operation_ref 426672 // set_a_matrix_filename
	comment " filename for storing the A matrix (default : amx.XXX)

 NOTE: boost text archive format may exist with filename (amx.XXX.ar)

 file format:
 1 # file version
 npchsz # dimension -> ( npchsz x npchsz )
 i1 i2 value # indices and entry
 ... "
      end

      attribute 299824 "patch_filename"
	private explicit_type "string"
	init_value "\"patch\""
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}_${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	get_oper operation_ref 424368 // get_patch_filename
	set_oper operation_ref 427312 // set_patch_filename
	comment " filename for storing the tile definition (patch grid) (default : patch.XXX)

 NOTE: boost text archive format may exist with filename (patch.XXX.ar)

 file format:
 1 { 2 }  # format version
 npchsz # number of patches
 prx pry prz area pux puy puz deps { c1x c1y c1z c2x c2y c2z c3x c3y c3z c4x c4y c4z } 
 ..."
      end

      attribute 299952 "sample_conx_"
	private type class_ref 206255 // connection
	init_value "None"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "Connection to 'inner-loop' signal"
      end

      attribute 300080 "alfa_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Scale factor = kT . echg / (4 * pi * eps0 * angstrom * epsw )

NOTE : We assume constant permittivity in solvent."
      end

      attribute 300208 "epsw_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Solvent permittivity "
      end

      extra_member 234800 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 422192 "icc_orig"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
${body}
"
	
	
	
	
      end

      operation 422320 "icc_orig"
	stereotype "copy"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 258224 // icc_orig
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "no copy"
      end

      operation 422448 "icc_orig"
	stereotype "move"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 258224 // icc_orig
	cpp_decl "    ${comment}${inline}${name}${(}${t0} && ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "no move"
      end

      operation 422576 "~icc_orig"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw}
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 422704 "operator="
	private return_type class_ref 258224 // icc_orig
	nparams 1
	  param in name "source" type class_ref 258224 // icc_orig
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${abstract} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "no assignment"
      end

      operation 422832 "make_evaluator"
	class_operation preserve_cpp_body_indent public explicit_return_type "void"
	nparams 2
	  param in name "param_set" explicit_type "std::map< std::string, std::string >"
	  param inout name "sim" type class_ref 1129135 // simulator
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
	comment "Set up the evaluator using the given map of name/value pairs

Valid only for channel_system simtypes. Accepts no input parameters."
      end

      extra_member 234928 "friend"
	
	cpp "

  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 422960 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  ar & boost::serialization::base_object< base_evaluator >(*this);
   ar & amx_;
   ar & c_;
   ar & cnew_;
   ar & grid_;
   ar & h_;
   ar & hnew_;
   ar & rip_;
   ar & ripnew_;
   ar & a_matrix_filename_;
   ar & patch_filename_;
   ar & alfa_;
   ar & epsw_;
}
"
	
	
	
	
      end

      extra_member 235056 "ACCESS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 423088 "do_description"
	const cpp_virtual private explicit_return_type "void"
	nparams 1
	  param inout name "os" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Log message descibing the evaluator and its parameters"
      end

      operation 423216 "do_write_document"
	preserve_cpp_body_indent const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Write evaluator specific content of input file section.

 only throw possible should be from os.write() operation"
      end

      operation 423344 "enrol"
	cpp_virtual public explicit_return_type "void"
	nparams 1
	  param inout name "sim" type class_ref 1129135 // simulator
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}${)}:
${docstring}pass
"
	
	comment "Register any signals output by the object with 
the simulator and optionally connect to any 
simulator specific signals. The object is responsible
for testing if a signal with the same label has been
registered.

The base class method does nothing."
      end

      operation 423472 "empty"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->amx_.${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 423600 "field"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->c_[ ${p0} ];
}
"
	
	
	
	
	comment "Field experienced normal to a given surface element"
      end

      operation 423728 "get_a_matrix_filename"
	force_body_gen const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} ${name}${(}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}const ${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return a_matrix_filename_;
}
"
	cpp_name_spec "get_${name}"
	final 
	java_name_spec "get${Name}"
	php_final 
	php_name_spec "get${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}self${p0}${v0}${)}:
${docstring}return self.a_matrix_filename
"
	python_name_spec "get${name}"
	
	idl_name_spec "get_${name}"
	get_of_attribute attribute_ref 299696 // a_matrix_filename
      end

      operation 423856 "get_alfa"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->alfa_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis"
      end

      operation 423984 "get_dxf"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
   return this->grid_->${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis"
      end

      operation 424112 "get_dxw"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
   return this->grid_->${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta that divides lines and arcs that
 are parallel or radial to the z-axis."
      end

      operation 424240 "get_nsub0"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
   return this->grid_->${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the subtiling factor that determines how many subtiles
 a patch/tile is divided into during integration "
      end

      operation 424368 "get_patch_filename"
	force_body_gen const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} ${name}${(}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}const ${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  return patch_filename_;
}
"
	cpp_name_spec "get_${name}"
	final 
	java_name_spec "get${Name}"
	php_final 
	php_name_spec "get${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}self${p0}${v0}${)}:
${docstring}return self.patch_filename
"
	python_name_spec "get${name}"
	
	idl_name_spec "get_${name}"
	get_of_attribute attribute_ref 299824 // patch_filename
      end

      operation 424496 "get_permittivity"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->epsw_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis"
      end

      operation 424624 "surface_charge"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Induced charge on a given surface element"
      end

      operation 424752 "surface_area"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  return this->grid_->area( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Area of a given surface element"
      end

      operation 424880 "surface_value"
	const public explicit_return_type "double"
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
   return this->h_[ ${p0} ];
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " H array value on a given surface element"
      end

      operation 425008 "size"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
   return this->amx_.${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 425136 "type_label"
	const cpp_virtual public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw} override
{
  return ${class}::${name}_();
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 425264 "type_label_"
	class_operation preserve_cpp_body_indent public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
      end

      operation 425392 "write_data"
	const public explicit_return_type "void"
	nparams 2
	  param in name "sim" type class_ref 1129135 // simulator
	  param inout name "os_log" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Write surface tile and A matrix data to files"
      end

      extra_member 235184 "ACTION"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 425520 "compute_potential"
	preserve_cpp_body_indent const public explicit_return_type "void"
	nparams 4
	  param in name "spcs" type class_ref 134577 // specie
	  param in name "ens" type class_ref 134959 // ensemble
	  param inout name "changes" type class_ref 986543 // change_set
	  param in name "start_index" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const std::vector< ${t0} > & ${p0}${v0}, const ${t1} & ${p1}${v1}, ${t2} & ${p2}${v2}, ${t3} ${p3}${v3}${)}${const}${volatile}${throw} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const std::vector< ${t0} > & ${p0}, const ${t1} & ${p1}, ${t2} & ${p2}, ${t3} ${p3}${)}${const}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " UNIFIED ICC ENERGY
 
 This method calculates the change in coulombic potential energy between
 the particles and the surface patches.
"
      end

      operation 425648 "compute_initial_c_h"
	public explicit_return_type "void"
	nparams 2
	  param in name "spcs" type class_ref 134577 // specie
	  param in name "ens" type class_ref 134959 // ensemble
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const std::vector< ${t0} > & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const std::vector< ${t0} > & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Compute the initial C and H matrices"
      end

      operation 425776 "compute_total_surface_charge"
	const public explicit_return_type "void"
	nparams 2
	  param out name "charget" explicit_type "double"
	  param out name "areat" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
	comment "Compute the total surface area and charge"
      end

      operation 425904 "create_amx"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 2
	  param in name "sim" type class_ref 1129391 // channel_system
	  param inout name "os_log" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}
{
   this->create_amx( sim.pore_hlength(), sim.pore_radius(), sim.protein_radius(), sim.vestibule_arc_radius(), sim.membrane_arc_radius(), sim.permittivity(), sim.protein_permittivity(), os_log );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create the  matrix, this involves defining the patch grid,
 integrating the grid to generate the A' matrix then inverting
 this matrix to get the A matrix.

 Use the input geometry to define the information that the
 'patch' module will use to generate a set of 'patches' that
 cover the protein surface.

 fortran equiv patch::defgrd + patch::matrix
  see ionch::iccgrid::add_XXXX for patch::goXXXX
  see ionch::XXXX_integrator types for patch::intXXXX"
      end

      operation 426032 "create_amx"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 8
	  param in name "zl1" explicit_type "double"
	  param in name "rl1" explicit_type "double"
	  param in name "rl4" explicit_type "double"
	  param in name "rlvest" explicit_type "double"
	  param in name "rlmemb" explicit_type "double"
	  param in name "epsw" explicit_type "double"
	  param in name "epspr" explicit_type "double"
	  param inout name "os_log" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}, ${t7} & ${p7}${v7}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6} ${p6}, ${t7} & ${p7}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create the  matrix, this involves defining the patch grid,
 integrating the grid to generate the A' matrix then inverting
 this matrix to get the A matrix.

 Use the input geometry to define the information that the
 'patch' module will use to generate a set of 'patches' that
 cover the protein surface.

 fortran equiv patch::defgrd + patch::matrix
  see ionch::iccgrid::add_XXXX for patch::goXXXX
  see ionch::XXXX_integrator types for patch::intXXXX"
      end

      operation 426160 "create_amx"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 2
	  param inout name "grid" explicit_type "icc_surface_grid"
	  param inout name "os_log" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}std::unique_ptr< ${t0} >& ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}std::unique_ptr< ${t0} >& ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Swap the internatl grid with the supplied
 grid and create the A matrix, this involves
 integrating the grid to generate the A' matrix
 then inverting this matrix to get the A matrix.

 Use the input geometry to define the information
 that the 'patch' module will use to generate a
 set of 'patches' that cover the protein surface.

 fortran equiv patch::defgrd + patch::matrix
  see ionch::iccgrid::add_XXXX for patch::goXXXX
  see ionch::XXXX_integrator types for
  patch::intXXXX
"
      end

      operation 426288 "on_inner_loop"
	public explicit_return_type "void"
	nparams 1
	  param in name "changes" type class_ref 986543 // change_set
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Called after the trial"
      end

      operation 426416 "prepare"
	cpp_virtual public explicit_return_type "void"
	nparams 1
	  param in name "sim" type class_ref 1129135 // simulator
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	
	
	comment " Prepare the evaluator for running a simulation loop set."
      end

      operation 426544 "read_data"
	public explicit_return_type "bool"
	nparams 2
	  param in name "sim" type class_ref 1129135 // simulator
	  param inout name "os_log" explicit_type "ostream"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Attempt to read surface tile and A matrix data from files"
      end

      operation 426672 "set_a_matrix_filename"
	force_body_gen public explicit_return_type "void"
	nparams 1
	  param in name "value" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  a_matrix_filename_ = ${p0};

}
"
	cpp_name_spec "set_${name}"
	
	java_name_spec "set${Name}"
	
	php_name_spec "set${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}self, ${p0}${)}:
${docstring}self.a_matrix_filename = ${p0}
"
	python_name_spec "set${name}"
	
	idl_name_spec "set_${name}"
	set_of_attribute attribute_ref 299696 // a_matrix_filename
      end

      operation 426800 "set_alfa"
	public explicit_return_type "void"
	nparams 1
	  param in name "temperature" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Set the alfa scaling factor:
  alfa = k{temperature} . echg / (4 * pi * eps0 * angstrom * {permittivity} )

 \\param temperature : in kelvin
 \\param permittivity : relative permittivity."
      end

      operation 426928 "set_dxf"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  this->grid_->${name}( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis (only 
 useful before generating A matrix)"
      end

      operation 427056 "set_dxw"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  this->grid_->${name}( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the patch/tile delta that divides lines and arcs that
 are parallel or radial to the z-axis.  (only useful before 
 generating A matrix)"
      end

      operation 427184 "set_nsub0"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  this->grid_->${name}( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the subtiling factor that determines how many subtiles
 a patch/tile is divided into during integration  (only useful 
 before generating A matrix)"
      end

      operation 427312 "set_patch_filename"
	force_body_gen public explicit_return_type "void"
	nparams 1
	  param in name "value" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${)}${const}${volatile}${throw};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  patch_filename_ = ${p0};

}
"
	cpp_name_spec "set_${name}"
	
	java_name_spec "set${Name}"
	
	php_name_spec "set${Name}"
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}self, ${p0}${)}:
${docstring}self.patch_filename = ${p0}
"
	python_name_spec "set${name}"
	
	idl_name_spec "set_${name}"
	set_of_attribute attribute_ref 299824 // patch_filename
      end

      operation 427440 "set_permittivity"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->epsw_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the patch/tile delta to divide up the circumference
 of circles normal to and centred on the Z-axis (only 
 useful before generating A matrix)"
      end

      operation 427568 "dump"
	const public explicit_return_type "void"
	nparams 1
	  param in name "fname" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  Dump data from current object"
      end
    end
  end

  classview 414255 "overlap exception"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    class 785711 "overlap_exception"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment "Indicate and Overlap occured."
      classrelation 899375 // <generalisation>
	relation 870191 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 899375 // <generalisation>
	  b parent class_ref 276015 // runtime_error
      end

      operation 1363247 "overlap_exception"
	public explicit_return_type ""
	nparams 1
	  param in name "s" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw}: std::runtime_error(s) {}
"
	
	
	
	
      end

      operation 1356591 "translator"
	class_operation public explicit_return_type "void"
	nparams 1
	  param in name "err" type class_ref 785711 // overlap_exception
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Translate the C++ exception into Python"
      end
    end
  end

  deploymentview 372143 "evaluator deployment"
    //deployment diagram settings
    package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
    draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
    artifact 716207 "base_evaluator"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
#include \"core/strngs.hpp\"
//-
${namespace_start}
${members}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_GUID(evaluator::base_evaluator, \"evaluator::base_evaluator\");"
      associated_classes
	class_ref 912175 // base_evaluator
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 249136 "check_data"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
${namespace_start}
${members}
${namespace_end}"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 258096 // check_data
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 154929 "coulomb"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( evaluator::coulomb );

#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
#include \"core/input_error.hpp\"
// -
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( evaluator::coulomb );"
      python_src "${comment}
${definition}"
      associated_classes
	class_ref 779183 // coulomb
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 423728 "evaluator_manager"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
#include \"core/strngs.hpp\"
#include \"evaluator/coulomb.hpp\"
#include \"evaluator/evaluator_meta.hpp\"
#include \"evaluator/hard_sphere_overlap.hpp\"
#include \"evaluator/lennard_jones.hpp\"
#include \"evaluator/localizer.hpp\"
// -
${namespace_start}
${members}
${namespace_end}


// Should not be needed for base type
// #include <boost/serialization/export.hpp>
// BOOST_CLASS_EXPORT_GUID(evaluator::evaluator_manager, \"evaluator::evaluator_manager\");"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 439472 // const_range_t
	class_ref 439344 // evaluator_manager
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 783151 "evaluator_meta"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// Manual incls
#include <sstream>
#include <bitset>
#include \"core/strngs.hpp\"
#include \"core/input_help.hpp\"
#include \"core/input_error.hpp\"
#include \"utility/utility.hpp\"
${namespace_start}
${members}
${namespace_end}
"
      associated_classes
	class_ref 566192 // evaluator_definition
	class_ref 1143599 // evaluator_meta
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 629936 "hard_sphere_overlap"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( evaluator::hard_sphere_overlap );

#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
#include \"core/input_error.hpp\"
#include \"core/strngs.hpp\"
#include \"particle/ensemble.hpp\"
// -
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( evaluator::hard_sphere_overlap );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 694064 // hard_sphere_overlap
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 538415 "icc_surface_grid"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
#include \"core/constants.hpp\"
#include \"core/strngs.hpp\"
#include \"utility/fuzzy_equals.hpp\"
#include \"utility/utility.hpp\"
// -
#include <array>
// -
${namespace_start}
${members}
${namespace_end}"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 1005615 // icc_surface_grid
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 235824 "icc_matrix"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// -
#include \"core/strngs.hpp\"
#include \"utility/utility.hpp\"
// -
#include <array>
// -
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 244144 // icc_matrix
      end
    end

    artifact 708911 "induced_charge"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( evaluator::induced_charge );

#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
#include \"core/constants.hpp\"
#include \"core/input_error.hpp\"
#include \"core/strngs.hpp\"
#include \"particle/ensemble.hpp\"
// -
#include <array>
// For \"dump\" method.
#include <fstream>
// - 
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( evaluator::induced_charge );"
      associated_classes
	class_ref 805423 // induced_charge
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 236080 "integrator"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( evaluator::arc_integrator );
BOOST_CLASS_EXPORT_KEY( evaluator::cylinder_integrator );
BOOST_CLASS_EXPORT_KEY( evaluator::wall_integrator );
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
#include \"core/constants.hpp\"
#include \"utility/fuzzy_equals.hpp\"
#include \"utility/utility.hpp\"
// -
#include <array>
#include <cmath>
// -
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( evaluator::arc_integrator );
BOOST_CLASS_EXPORT_IMPLEMENT( evaluator::cylinder_integrator );
BOOST_CLASS_EXPORT_IMPLEMENT( evaluator::wall_integrator );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 1005871 // integrator
	class_ref 1024303 // arc_integrator
	class_ref 1024175 // cylinder_integrator
	class_ref 1024431 // wall_integrator
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 650927 "lennard_jones"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( evaluator::lennard_jones );
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// Manual incls
#include \"core/input_base_reader.hpp\"
#include \"core/input_error.hpp\"
// -
#include <boost/algorithm/string.hpp>
#include <iomanip>
// -
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( evaluator::lennard_jones );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 579248 // lennard_jones
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 492335 "localizer"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( evaluator::localizer );

#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
#include \"core/input_base_reader.hpp\"
#include \"core/strngs.hpp\"
#include \"particle/ensemble.hpp\"
// -
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( evaluator::localizer );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 546351 // localizer
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 656304 "object_overlap"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( evaluator::object_overlap );

#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
#include \"core/strngs.hpp\"
// -
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( evaluator::object_overlap );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 700592 // object_overlap
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 716335 "libionch_evaluator"
      stereotype "library"
      associated_artifacts
	artifact_ref 154929 // coulomb
	artifact_ref 235824 // icc_matrix
	artifact_ref 236080 // integrator
	artifact_ref 423728 // evaluator_manager
	artifact_ref 492335 // localizer
	artifact_ref 538415 // icc_surface_grid
	artifact_ref 629936 // hard_sphere_overlap
	artifact_ref 650927 // lennard_jones
	artifact_ref 656304 // object_overlap
	artifact_ref 708911 // induced_charge
	artifact_ref 716207 // base_evaluator
	artifact_ref 783151 // evaluator_meta
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 717104 "patch.f90"
      stereotype "document"
      associated_artifacts
      end
      comment "!  -------------------------------------------------------------
!  ICC data
!
!  baksub
!     convert 'c' vector to 'h' vector by back-substituting
!     from the decomposed 'A' matrix
!  matrix
!     build the initial 'A' matrix and decompose it.

module patch
implicit none
private
  ! Maximum allocation size
  integer, private, parameter :: npchmx_=2048
  ! Whether to output debug_ information
  logical, private, parameter :: dbc_=.true.
  logical, private, parameter :: debug_=.false.
  ! file numbers
  integer, private, parameter :: fidlog=6
  integer, private, parameter :: fidpch=26
  integer, private, parameter :: fidamx=12
  ! 'A' matrix
  double precision, private, dimension(:,:), allocatable :: amx_
  ! the allocated size of the main patch arrays (<= npchmx_)
  integer, private :: npchsz_
  ! Patch x,y,z,area,ux,uy,uz,deps_ date [8 dbls] coords
  ! X coordinate of a patch
  double precision, private, dimension(:), allocatable :: prx_
  ! Y coordinate of a patch
  double precision, private, dimension(:), allocatable :: pry_
  ! Z coordinate of a patch
  double precision, private, dimension(:), allocatable :: prz_
  ! Surface area of a patch
  double precision, private, dimension(:), allocatable :: parea_
  ! X dimension of normal vector to centre of patch 
  double precision, private, dimension(:), allocatable :: pux_
  ! Y dimension of normal vector to centre of patch
  double precision, private, dimension(:), allocatable :: puy_
  ! Z dimension of normal vector to centre of patch
  double precision, private, dimension(:), allocatable :: puz_
  ! The effective dielectric constant on the outside of a patch
  double precision, private, dimension(:), allocatable :: deps_
  ! back substitution index vector
  integer, private, dimension(:), allocatable :: indx_
  ! pi_
  double precision, private :: pi_=3.14  !!INPUT!!
  ! water relative permittivity
  double precision, private :: epsw_=80.0  !!INPUT!!
  ! protein relative permittivity
  double precision, private :: epspr_=10.0  !!INPUT!!
  ! patch size factors
  double precision, private :: dxf_=1.6   !!INPUT!!
  double precision, private :: dxw_=1.6   !!INPUT!!
  ! number of patches
  integer, private :: npatch_ = 0
  ! patch integration factor
  integer, private :: nsub0_=10   !!INPUT!!
  ! Has the inverted 'A' matrix been read or created?
  logical, private :: irdamx_=.false.

  public :: baksub_, getnpch_, matrix_, patchsaves_, gaussbox_, totalarea_, writam_, writpc_
  public :: getx_, gety_, getz_, getux_, getuy_, getuz_, getarea_, getdep_
  type geomdf
     double precision, dimension(8,300) :: dfia,tta1,tta2
     double precision, dimension(6,300) :: dfil,zzl1,zzl2,rrl1,rrl2
     integer, dimension(8,300) :: nfia
     integer, dimension(6,300) :: nfil
     integer, dimension(20) :: ilsign
     double precision, dimension(8) :: za0,ra0,ra,ta1,ta2,uasign
     double precision, dimension(6) :: ulsign,zl1,rl1,zl2,rl2,tgalfa,alfa
     integer, dimension(8) :: nta
     integer, dimension(6) :: nzl,nrl
     integer :: narch,nline,nwall,nwall2,nunif,ncent
  end type geomdf

  interface
    pure elemental function dfeq(lhs,rhs)
      logical :: dfeq
      double precision, intent(in) :: lhs, rhs
    end function dfeq
    function next64(val)
      integer :: next64
      integer, intent(in) :: val
    end function next64
  end interface


interface str
  module procedure logstr
  module procedure fmtfln
end interface str

contains
  ! --------------------------------------------
  ! Give a text representation of a logical value
  !
  ! Converts a logical value into '.true.' or
  ! '.false.'
  pure subroutine logstr(a_bool, output)
    implicit none
    logical, intent(in) :: a_bool
    character(*), intent(inout) :: output
    character(*), parameter :: yes = \".true.\"
    character(*), parameter :: no = \".false.\"
    if (a_bool) then
      output=yes(1:max(1,min(len(output),len(yes))))
    else
      output=no(1:max(1,min(len(output),len(no))))
    endif
  end subroutine logstr

  ! ------------------------------------------------------------
  ! Method to pretty format floating point fields.
  !
  ! This method tries to select the best way to represent the number in
  ! the given width. Firstly one character is always reserved for the
  ! minus sign.  Numbers that can be nicely represented without exponent
  ! are formatted in fixed point, otherwise the numbers are formatted
  ! using an exponent.  Any decimal precision is reduced to the minimum
  ! representable by the type.  The formatted number is then checked for
  ! unnecessary zeros at the end of number, which are removed.
  !
  ! Examples
  ! -11.234 : Only as many decimal places as are non-zero are shown
  ! -0.3456 : Exponent is not used for numbers close to one
  ! -3.456E-001
  subroutine fmtfln(num, output)
    implicit none
    double precision, intent(in) :: num
    character(len=*), intent(inout) :: output
    interface 
      subroutine fmtfl2(val,str,sz)
        double precision, intent(in) :: val
        character(*), intent(inout) :: str
        integer, intent(in) :: sz
      end subroutine fmtfl2
    end interface
    call fmtfl2(num,output,len(output))
  end subroutine fmtfln



  ! Get the number of patches.
  function getnpch_()
    implicit none
    integer :: getnpch_
    getnpch_ = npatch_
  end function getnpch_

  function getx_(idx)
    implicit none
    double precision :: getx_
    integer, intent(in) :: idx
    getx_ = prx_( idx )
  end function getx_

  function gety_(idx)
    implicit none
    double precision :: gety_
    integer, intent(in) :: idx
    gety_ = pry_( idx )
  end function gety_

  function getz_(idx)
    implicit none
    double precision :: getz_
    integer, intent(in) :: idx
    getz_ = prz_( idx )
  end function getz_

  function getux_(idx)
    implicit none
    double precision :: getux_
    integer, intent(in) :: idx
    getux_ = pux_( idx )
  end function getux_

  function getuy_(idx)
    implicit none
    double precision :: getuy_
    integer, intent(in) :: idx
    getuy_ = puy_( idx )
  end function getuy_

  function getuz_(idx)
    implicit none
    double precision :: getuz_
    integer, intent(in) :: idx
    getuz_ = puz_( idx )
  end function getuz_

  function getarea_(idx)
    implicit none
    double precision :: getarea_
    integer, intent(in) :: idx
    getarea_ = parea_( idx )
  end function getarea_

  function getdep_(idx)
    implicit none
    double precision :: getdep_
    integer, intent(in) :: idx
    getdep_ = deps_( idx )
  end function getdep_

  ! --------------------------------
  ! calculate a gaussbox over ALL surfaces, so parea_ must be composed
  ! of closed surfaces
  !
  double precision function gaussbox_(h)
    implicit none
    double precision, dimension(npatch_), intent(in) :: h

    gaussbox_ = sum(parea_(1:npatch_)*h(1:npatch_)/deps_(1:npatch_))
  end function gaussbox_

  double precision function totalarea_()
    implicit none
    
    totalarea_ = sum(parea_(1:npatch_))
  end function totalarea_

  ! ------------------------
  ! Output gaussbox charge and area to fidooo
  !
  !
  ! astep : step number 1...
  !
  ! rchg = cumulative gauss sum/e0
  ! archg = cumulative abs(gauss)
  ! r2chg = cumulative gauss^2
  ! area = surface area for which gauss sum is calculated
  !
  ! chg = current gauss sum
  ! echg = avg rchg
  ! aechg = avg archg
  ! er2chg = avg r2chg
  !
  subroutine patchsaves_(fid,astep,h)
    implicit none
    integer, intent(in) :: fid,astep
    double precision, dimension(npatch_), intent(in) :: h
    double precision, save :: rchg = 0, archg = 0, r2chg = 0
    double precision, save :: area = 0
    double precision, save :: max_chg = 0
    double precision :: chg, echg, aechg, er2chg, abs_chg
    character(20) :: fltout

    if (area.eq.0) area = totalarea_()
    
    chg = gaussbox_(h)

    rchg = rchg + chg
    archg = archg + dabs(chg)
    r2chg = r2chg + chg**2

    echg = rchg/astep
    aechg = archg/astep
    er2chg = r2chg/astep
    
    abs_chg = dabs(chg)
    if (max_chg.lt.abs_chg) max_chg = abs_chg

    write(unit=fid, fmt='(\" epspr_       = \",f10.5)')  epspr_
    call str(chg, fltout)
    write(unit=fid, fmt='(\" gauss[a]    = \",A)')trim(adjustl(fltout))
    call str(echg, fltout)
    write(unit=fid, fmt=*)' <gauss>     = ',trim(adjustl(fltout))
    call str(aechg, fltout)
    write(unit=fid, fmt=*)' <|gauss|>   = ',trim(adjustl(fltout))
    call str(er2chg-echg**2, fltout)
    write(unit=fid, fmt=*)' Var(gauss)  = ',trim(adjustl(fltout))
    call str(er2chg-aechg**2, fltout)
    write(unit=fid, fmt=*)' Var(|gauss|)= ',trim(adjustl(fltout))
    call str(area, fltout)
    write(unit=fid, fmt=*)' area        = ',trim(adjustl(fltout))
    call str(max_chg, fltout)
    write(unit=fid, fmt=*)' max(|gauss|)= ', trim(adjustl(fltout))
  end subroutine patchsaves_
 
  ! Access functions
  ! ------------------------------------------------------------------
  ! Calculate the induced charge per unit area of a patch using
  ! the ICC protocol
  !
  ! The initialisation phase of the ICC protocol generate a solution
  ! matrix for the set of simultaneous equations representing the
  ! patches.  To generate the induced charges on all the patches
  ! we perform a back substitution on the solution matrix using
  ! 'hmat'.  This process is performed by an external Lapack
  ! routine.
  subroutine baksub_(hmat)
  implicit none
  integer :: n1,n2,info,nrhs,nx
  character(*), parameter :: trans=\"N\"
  double precision, dimension(npchmx_), intent(inout) :: hmat
  external dgetrs
  if (dbc_) then
    if (.not.irdamx_) stop \"Error: patch::baksub called with no inverted A matrix\"
  endif
  info=0
  nrhs=1
  n1=npatch_
  n2=npatch_
  nx=npchsz_
  ! Use a LAPACK method to back substitute the rhs (b) 
  ! from the solution from ludcmp.
  call dgetrs (trans, n1, nrhs, amx_, nx, indx_, hmat, n2, info);
  if (0.ne.info) stop \"Matrix back-substitution failed.\"

  end subroutine baksub_

  ! ------------------------------------------------------------------
  ! Generate the patch locations from the base geometry
  !
  !                 ^
  !                 ^ rl5
  !                 |
  !        <- zl3  >|
  !        ---------|---------
  !       /|        |  ^rl4   \\
  !      / |        |  |   ____\\
  !     |<-> = rlcurv  |  ^rl3  |
  !     |<--> = rlvest |  |_____|
  !     \\   |       |  |  ^rl2  /
  !      \\  |       |  |  |    /
  !       \\ |       |  |  |   /
  !        \\|<-zl1->|  |  |  /
  !         ----------------- 
  !           ^ rl1 |  |  |
  !      <-----zl2->|  |  |
  !   ________|_____|_ |__|______ z-axis
  !<<-------------->| zl4
  !
  subroutine defgrd(geodfn,zl1,rl1,rl4,rlvest,rlcurv)
  implicit none
  type (geomdf), intent(inout) :: geodfn
  double precision, intent(in) :: zl1,rl1,rl4,rlvest,rlcurv

  ! LOCALS
  integer, dimension(5,npchmx_) :: isurf
  double precision, dimension(8,300) :: dtta,ara,tac
  double precision, dimension(6,300) :: drl,arr,rlc,dzl,arl,zlc
  double precision, dimension(8) :: dta
  double precision, dimension(6) :: dll
  integer, dimension(5) :: nsurf
  integer ::  iii,is  ! Loop indices
  double precision, dimension(:,:), allocatable :: p__

  double precision :: rl2,rl3,zl2,zl3
  rl2 = rl1 + rlvest
  rl3 = rl4 - rlcurv
  zl2 = zl1 + rlvest
  zl3 = zl2 - rlcurv
  ! -----  Define doughnut geometry -----------------
  geodfn%narch=4
  geodfn%nline=2
  geodfn%nwall=2

  ! archs
  geodfn%za0(1)=  zl1
  geodfn%za0(2)=  zl3
  geodfn%za0(3)= -zl3
  geodfn%za0(4)= -zl1

  geodfn%ra0(1)=  rl2
  geodfn%ra0(2)=  rl3
  geodfn%ra0(3)=  rl3
  geodfn%ra0(4)=  rl2

  geodfn%ra(1)= rlvest
  geodfn%ra(2)= rlcurv
  geodfn%ra(3)= rlcurv
  geodfn%ra(4)= rlvest

  geodfn%ta1(1)= 3*pi_/2
  geodfn%ta1(2)= 0
  geodfn%ta1(3)= pi_/2
  geodfn%ta1(4)= pi_

  geodfn%ta2(1)= 2*pi_
  geodfn%ta2(2)= pi_/2
  geodfn%ta2(3)= pi_
  geodfn%ta2(4)= 3*pi_/2

  geodfn%uasign(1)=-1
  geodfn%uasign(2)=-1
  geodfn%uasign(3)=-1
  geodfn%uasign(4)=-1

  ! lines
  geodfn%zl1(1)= -zl1
  geodfn%rl1(1)=  rl1
  geodfn%zl2(1)=  zl1
  geodfn%rl2(1)=  rl1
  geodfn%alfa(1)   = 0
  geodfn%tgalfa(1) = 0

  geodfn%zl1(2)= -zl3
  geodfn%rl1(2)=  rl4
  geodfn%zl2(2)=  zl3
  geodfn%rl2(2)=  rl4
  geodfn%alfa(2)   = 0
  geodfn%tgalfa(2) = 0

  geodfn%ulsign(1)=-1
  geodfn%ulsign(2)=1
  geodfn%ulsign(3)=1
  geodfn%ulsign(4)=-1

  ! walls
  geodfn%zl1(3)=  zl2
  geodfn%rl1(3)=  rl2
  geodfn%zl2(3)=  zl2
  geodfn%rl2(3)=  rl3

  geodfn%zl1(4)= -zl2
  geodfn%rl1(4)=  rl2
  geodfn%zl2(4)= -zl2
  geodfn%rl2(4)=  rl3

  geodfn%alfa(5)=pi_/2
  geodfn%alfa(6)=pi_/2

  write(unit=fidlog,fmt=*)\" ICC: Calculating tiles on the protein surface\"
  write(unit=fidlog,fmt='(72(\"-\"))')
  ! ------ go over 1st line: filter -----------------

  npatch_=0
  iii=0
  is=0
  nsurf=0
  allocate(p__(8,npchmx_))

  call gofilt

  npatch_=npatch_+iii
  write(unit=fidlog,fmt=*)\" NUMBER OF TILES IN FILTER = \",iii
  write(unit=fidlog,fmt='(50(\"-\"))')

  call goline

  write(unit=fidlog,fmt=*)\" NUMBER OF TILES IN OUTER LINE = \",iii-npatch_
  write(unit=fidlog,fmt='(50(\"-\"))')
  npatch_=iii

  call goarch

  write(unit=fidlog,fmt=*)\" NUMBER OF TILES IN ARCHS = \",iii-npatch_
  write(unit=fidlog,fmt='(50(\"-\"))')
  npatch_=iii

  call gowall

  write(unit=fidlog,fmt=*)\" NUMBER OF TILES IN WALLS = \",iii-npatch_
  write(unit=fidlog,fmt='(50(\"-\"))')
  write(unit=fidlog,fmt=*)\" NUMBER OF TILES TOTAL    = \",iii
  write(unit=fidlog,fmt='(72(\"-\"))')
  npatch_=iii

  !----------------------------------------------------------------------
  ! set npchsz_ and allocate and copy data to patch main arrays
  npchsz_=next64(npatch_)

  ! If prx_ is already defined then this is second call to this method.
  if (.not.allocated(prx_)) then
    allocate(prx_(npchsz_))
    allocate(pry_(npchsz_))
    allocate(prz_(npchsz_))
    allocate(parea_(npchsz_))
    allocate(pux_(npchsz_))
    allocate(puy_(npchsz_))
    allocate(puz_(npchsz_))
    allocate(deps_(npchsz_))
  endif

  prx_(1:npatch_)=p__(1,1:npatch_)
  pry_(1:npatch_)=p__(2,1:npatch_)
  prz_(1:npatch_)=p__(3,1:npatch_)
  parea_(1:npatch_)=p__(4,1:npatch_)
  pux_(1:npatch_)=p__(5,1:npatch_)
  puy_(1:npatch_)=p__(6,1:npatch_)
  puz_(1:npatch_)=p__(7,1:npatch_)
  deps_(1:npatch_)=p__(8,1:npatch_)

  deallocate(p__)

  contains

  ! For lines close and parallel to the z axis
  !
  subroutine gofilt
  implicit none
  integer ::  i,j,k  ! Loop indices
  double precision :: rc,fik,cir
  i=1    
  write(unit=fidlog,fmt='(1X,I1,A)')i,\"th line\"
  write(unit=fidlog,fmt='(A20,2(1X,F7.2))')\"start (z,r) =\",geodfn%zl1(i),geodfn%rl1(i)
  write(unit=fidlog,fmt='(A20,2(1X,F7.2))')\"end (z,r) =\",geodfn%zl2(i),geodfn%rl2(i)
  if (dbc_) then
     if (.not.dfeq(geodfn%rl1(i),geodfn%rl2(i))) then
        stop \"Line not parallel to z-axis\"
     endif
  endif
  dll(i)=(geodfn%zl2(i)-geodfn%zl1(i))
  write(unit=fidlog,fmt='(A20,1X,F7.2)')\"length (z) =\",dll(i)

  ! --- loop over xz coordinate ---------------------
  geodfn%nzl(i)=max(10,int(dll(i)/dxf_)+1)
  write(unit=fidlog,fmt='(A20,1X,I4)')\"mesh size (z) =\",geodfn%nzl(i)
  i3y5r5: do j=1,geodfn%nzl(i)
  !    write(unit=fidlog,fmt=*)j,\"th ring\"
    dzl(i,j)=(geodfn%zl2(i)-geodfn%zl1(i))/dble(geodfn%nzl(i))
    o3j9m0: if (j.eq.1) then
      geodfn%zzl1(i,j)=geodfn%zl1(i)
      geodfn%zzl2(i,j)=geodfn%zl1(i)+dzl(i,j)
    else o3j9m0
      geodfn%zzl1(i,j)=geodfn%zzl2(i,j-1)
      geodfn%zzl2(i,j)=geodfn%zzl1(i,j)+dzl(i,j)
    endif o3j9m0

    arl(i,j)=(geodfn%zzl2(i,j)-geodfn%zzl1(i,j))
    zlc(i,j)=(geodfn%zzl2(i,j)+geodfn%zzl1(i,j))/2

  ! --- loop over phi angle ------------------------
    rc=geodfn%rl1(i)
    cir=2*pi_*rc
    geodfn%nfil(i,j)=max(16,int(cir/dxf_)+1)
    geodfn%dfil(i,j)=2*pi_/dble(geodfn%nfil(i,j))

    write(unit=fidlog,fmt='(A20,1X,I4)')\"mesh size (r) =\",geodfn%nfil(i,j)

    b3a4l6: do k=1,geodfn%nfil(i,j)
      iii=iii+1
      is=is+1
      nsurf(1)=nsurf(1)+1
      isurf(1,nsurf(1))=is
      fik=(k-0.5D0)*geodfn%dfil(i,j)
      p__(1,iii)=rc*dcos(fik)
      p__(2,iii)=rc*dsin(fik)
      p__(3,iii)=zlc(i,j)
      if (dbc_) then
        if (isnan(p__(1,iii))) stop \"px is NaN\"
        if (isnan(p__(2,iii))) stop \"py is NaN\"
        if (isnan(p__(3,iii))) stop \"pz is NaN\"
      endif
      p__(5,iii)=geodfn%ulsign(i)*dcos(fik)
      p__(6,iii)=geodfn%ulsign(i)*dsin(fik)
      p__(7,iii)=-0.D0
      if (dbc_) then
        if (isnan(p__(5,iii))) stop \"ux is NaN\"
        if (isnan(p__(6,iii))) stop \"uy is NaN\"
        if (isnan(p__(7,iii))) stop \"uz is NaN\"
      endif
      ! zlength = arl  rlength = 2.pi_.r/nfil <==> dfil.r
      p__(4,iii)=arl(i,j)*geodfn%dfil(i,j)*rc
      if (dbc_) then
        if (p__(4,iii).le.0.0) stop \"area is negative\"
        if (isnan(p__(4,iii))) stop \"area is NaN\"
        if (isnan(arl(i,j))) stop \"arl is NaN\"
      endif
      p__(8,iii)=2*(epsw_-epspr_)/(epspr_+epsw_)
    enddo b3a4l6
  enddo i3y5r5
  write(unit=fidlog,fmt=\"(50('-'))\")
  end subroutine gofilt

  ! For lines distant and parallel to the z-axis
  subroutine goline
  implicit none
  integer ::  i,j,k  ! Loop indices
  double precision :: rc,dx,fik,cir
  ! ------ go over outer cylinder -------------------

  p6o0d0: do i=2,geodfn%nline
    write(unit=fidlog,fmt='(1X,I1,A)')i,\"th line\"
    write(unit=fidlog,fmt='(A20,1X,F7.2,1X,F7.2)')\"start (z,r) =\",geodfn%zl1(i),geodfn%rl1(i)
    write(unit=fidlog,fmt='(A20,1X,F7.2,1X,F7.2)')\"end (z,r) =\",geodfn%zl2(i),geodfn%rl2(i)
    dll(i)=(geodfn%zl2(i)-geodfn%zl1(i))
    if (dbc_) then
       if (.not.dfeq(geodfn%rl1(i),geodfn%rl2(i))) then
          stop \"Line not parallel to z-axis\"
       endif
    endif
    write(unit=fidlog,fmt='(A20,1X,F7.2)')\"length (z) =\",dll(i)

  ! --- loop over z coordinate ---------------------
    dx=dxw_*dsqrt(geodfn%rl2(i))
    geodfn%nzl(i)=max(4,int(dll(i)/dx)+1)
    write(unit=fidlog,fmt='(A20,1X,I4)')\"mesh size (z) =\",geodfn%nzl(i)
    p3o5e7: do j=1,geodfn%nzl(i)
  !      write(unit=fidlog,fmt=*)j,\"th ring\"
      dzl(i,j)=(geodfn%zl2(i)-geodfn%zl1(i))/dble(geodfn%nzl(i))
      e2g3j7: if (j.eq.1) then
        geodfn%zzl1(i,j)=geodfn%zl1(i)
        geodfn%zzl2(i,j)=geodfn%zl1(i)+dzl(i,j)
      else e2g3j7
        geodfn%zzl1(i,j)=geodfn%zzl2(i,j-1)
        geodfn%zzl2(i,j)=geodfn%zzl1(i,j)+dzl(i,j)
      endif e2g3j7
      arl(i,j)=(geodfn%zzl2(i,j)-geodfn%zzl1(i,j))
      zlc(i,j)=(geodfn%zzl2(i,j)+geodfn%zzl1(i,j))/2

  ! --- loop over phi angle ------------------------
      rc=geodfn%rl1(i)
      cir=2*pi_*rc
      geodfn%nfil(i,j)=max(16,int(cir/dx)+1)
      geodfn%dfil(i,j)=2*pi_/dble(geodfn%nfil(i,j))
      write(unit=fidlog,fmt='(A20,1X,I4)')\"mesh size (r) =\",geodfn%nfil(i,j)

      v4z2z1: do k=1,geodfn%nfil(i,j)
        iii=iii+1
        is=is+1
        nsurf(2)=nsurf(2)+1
        isurf(2,nsurf(2))=is
        fik=(k-0.5D0)*geodfn%dfil(i,j)
        p__(1,iii)=rc*dcos(fik)
        p__(2,iii)=rc*dsin(fik)
        p__(3,iii)=zlc(i,j)
        if (dbc_) then
          if (isnan(p__(1,iii))) stop \"px is NaN\"
          if (isnan(p__(2,iii))) stop \"py is NaN\"
          if (isnan(p__(3,iii))) stop \"pz is NaN\"
        endif
        p__(5,iii)=geodfn%ulsign(i)*dcos(fik)
        p__(6,iii)=geodfn%ulsign(i)*dsin(fik)
        p__(7,iii)=-0.D0
        if (dbc_) then
          if (isnan(p__(5,iii))) stop \"ux is NaN\"
          if (isnan(p__(6,iii))) stop \"uy is NaN\"
          if (isnan(p__(7,iii))) stop \"uz is NaN\"
        endif
        ! zlength = arl  rlength = 2.pi_.r/nfil <==> dfil.r
        p__(4,iii)=arl(i,j)*geodfn%dfil(i,j)*rc
        if (dbc_) then
          if (p__(4,iii).le.0.0) stop \"area is negative\"
          if (isnan(p__(4,iii))) stop \"area is NaN\"
          if (isnan(arl(i,j))) stop \"arl is NaN\"
        endif
        p__(8,iii)=2*(epsw_-epspr_)/(epspr_+epsw_)
      enddo v4z2z1
    enddo p3o5e7
    write(unit=fidlog,fmt=\"(50('-'))\")
  enddo p6o0d0
  end subroutine goline

  !
  ! Jim Fonseca's method for calculating patches on an arch
  !
  subroutine goarch
  implicit none
  double precision :: dla
  integer ::  i,j,k  ! Loop indices
  double precision :: dx,rc,fik,szaml,cir
  c1q4v0: do i=1,geodfn%narch
  
    write(unit=fidlog,fmt='(1X,I1,A)')i,\"th arch\"
    write(unit=fidlog,fmt='(A20,1X,F7.2,1X,F7.2)')\"center (z,r) =\",geodfn%za0(i),geodfn%ra0(i)
    write(unit=fidlog,fmt='(A20,1X,F7.2)')\"radius =\",geodfn%ra(i)
    write(unit=fidlog,fmt='(A20,1X,F7.2,1X,F7.2)')\"angles (begin,end) =\",geodfn%ta1(i),geodfn%ta2(i)
    dta(i)=geodfn%ta2(i)-geodfn%ta1(i)
    write(unit=fidlog,fmt='(A20,1X,F7.2)')\"arc =\",dta(i)   
    dla=geodfn%ra(i)*dta(i)
    write(unit=fidlog,fmt='(A20,1X,F7.2)')\"length (z) =\",dla
    dx=dxw_*dsqrt(geodfn%ra0(i))

  ! loop over theta angle 
  !theta is measured along channel axis
    geodfn%nta(i) = max(4,int(dla/dx)+1)
        
    write(unit=fidlog,fmt='(A20,1X,I4)')\"mesh size (z=arc) =\",geodfn%nta(i)
        
  !loop over arc        
    do j=1,geodfn%nta(i)
  !    write(unit=fidlog,fmt=*)j,\"th ring\"
  !each section of the arc has length dtta(arcnumber,ring)
      dtta(i,j)=dta(i)/dble(geodfn%nta(i))
      if (j.eq.1) then
  ! if it's the first ring, set to beginning theta of the arc keep
  ! in mind it seems that we are counting arcs from right to left,
  ! since we start at theta1, hopefully this doesn't make much of a
  ! difference (i.e. doesn't matter if go ta1 to ta2 or vice versa)
        geodfn%tta1(i,j)=geodfn%ta1(i)
        geodfn%tta2(i,j)=geodfn%ta1(i)+dtta(i,j)
      else
        geodfn%tta1(i,j)=geodfn%tta2(i,j-1)
        geodfn%tta2(i,j)=geodfn%tta1(i,j)+dtta(i,j)
      endif
  !find the center theta (which is not just the average of tta1,tta2)
      ara(i,j)=geodfn%ra0(i)*dtta(i,j) &
        -geodfn%ra(i)*(dcos(geodfn%tta2(i,j))-dcos(geodfn%tta1(i,j)))
      szaml=0.5*geodfn%ra0(i)*(geodfn%tta2(i,j)**2-geodfn%tta1(i,j)**2) &
        - geodfn%ra(i)*(geodfn%tta2(i,j)*dcos(geodfn%tta2(i,j))         &
               -geodfn%tta1(i,j)*dcos(geodfn%tta1(i,j)))+               &
        geodfn%ra(i)*(dsin(geodfn%tta2(i,j))-dsin(geodfn%tta1(i,j)))
      tac(i,j)=szaml/ara(i,j)
      rc=geodfn%ra0(i)+geodfn%ra(i)*dsin(tac(i,j))
  !circumference of this ring            
      cir=2*pi_*rc
      geodfn%nfia(i,j)=max(16,int(cir/dx)+1)
      geodfn%dfia(i,j)=2*pi_/dble(geodfn%nfia(i,j))
      write(unit=fidlog,fmt='(A20,3(1X,F7.2))')\"theta (lo,mid,hi) =\",geodfn%tta1(i,j),tac(i,j),geodfn%tta2(i,j)
      write(unit=fidlog,fmt='(A20,1X,I4)')\"mesh size (r) =\",geodfn%nfia(i,j)

  !loop over all the slices of phi            
      z9c4a8: do k=1,geodfn%nfia(i,j)
        iii=iii+1
        is=is+1
        y4h5p2: if (i.eq.1.or.i.eq.4) then
          nsurf(1)=nsurf(1)+1
          isurf(1,nsurf(1))=is
        else y4h5p2
          nsurf(2)=nsurf(2)+1
          isurf(2,nsurf(2))=is
        endif y4h5p2
        fik=(k-0.5D0)*geodfn%dfia(i,j)
        if (dbc_) then
          if (isnan(fik)) stop \"fik is NaN\"
        endif
        p__(1,iii)=rc*dcos(fik)
        p__(2,iii)=rc*dsin(fik)
        p__(3,iii)=geodfn%za0(i)+geodfn%ra(i)*dcos(tac(i,j))
        if (dbc_) then
          if (isnan(p__(1,iii))) stop \"px is NaN\"
          if (isnan(p__(2,iii))) stop \"py is NaN\"
          if (isnan(p__(3,iii))) stop \"pz is NaN\"
        endif
        p__(5,iii)=-geodfn%uasign(i)*dsin(tac(i,j))*dcos(fik)
        p__(6,iii)=-geodfn%uasign(i)*dsin(tac(i,j))*dsin(fik)
        p__(7,iii)=-geodfn%uasign(i)*dcos(tac(i,j))
        if (dbc_) then
          if (isnan(p__(5,iii))) stop \"ux is NaN\"
          if (isnan(p__(6,iii))) stop \"uy is NaN\"
          if (isnan(p__(7,iii))) stop \"uz is NaN\"
        endif
        p__(4,iii)=geodfn%ra(i)*ara(i,j)*geodfn%dfia(i,j)
        if (dbc_) then
          if (p__(4,iii).le.0.0) stop \"area is negative\"
          if (isnan(p__(4,iii))) stop \"area is NaN\"
          if (isnan(ara(i,j))) stop \"ara is NaN\"
        endif
        p__(8,iii)=2*(epsw_-epspr_)/(epspr_+epsw_)
      enddo z9c4a8
    enddo
    write(unit=fidlog,fmt=\"(50('-'))\")
  enddo c1q4v0
  ! end of loop over archs 
  end subroutine goarch

  subroutine gowall
  implicit none
  integer ::  i,j,k  ! Loop indices
  double precision :: cir,ratio,rc,dfiu,fik,szaml
  integer :: nfiu
  
  ! ------ go over last walls of protein --------

  b0j3s2: do i=geodfn%nline+1,geodfn%nline+geodfn%nwall

    write(unit=fidlog,fmt='(1X,I1,A)')i,\"th line/wall\"
    write(unit=fidlog,fmt='(A20,2(1X,F7.2))')\"start (z,r) =\",geodfn%zl1(i),geodfn%rl1(i)
    write(unit=fidlog,fmt='(A20,2(1X,F7.2))')\"end (z,r) =\",geodfn%zl2(i),geodfn%rl2(i)
    dll(i)=geodfn%rl2(i)-geodfn%rl1(i)
    write(unit=fidlog,fmt='(A20,1X,F7.2)')\"length (r) =\",dll(i)

  ! --- loop over the rest with increasing tiles ---
    cir=2*pi_*(geodfn%rl1(i)+dll(i)/2)
    nfiu=int(cir/dxf_)+1
    dfiu=2*pi_/dble(nfiu)
    ratio=(1+dfiu/2)/(1-dfiu/2)
    ! write(unit=fidlog,fmt=*)\" Ratio old = \",ratio
    geodfn%nrl(i)=int(dlog(geodfn%rl2(i)/geodfn%rl1(i))/dlog(ratio))+1
    ! write(unit=fidlog,fmt=*)\" N r for increasing tiles = \",geodfn%nrl(i)
    ratio=(geodfn%rl2(i)/geodfn%rl1(i))**(1/dble(geodfn%nrl(i)))
    ! write(unit=fidlog,fmt=*)\" Ratio new = \",ratio
    write(unit=fidlog,fmt='(A20,1X,I4)')\"mesh size (r)\",geodfn%nrl(i)
    geodfn%rrl1(i,1)=geodfn%rl1(i)
    w8w7s2: do j=1,geodfn%nrl(i)
      geodfn%dfil(i,j)=dfiu
      geodfn%rrl2(i,j)=geodfn%rrl1(i,j)*ratio
      ! write(unit=fidlog,fmt=*)j,\"th ring\"
      drl(i,j)=geodfn%rrl2(i,j)-geodfn%rrl1(i,j)
      ! write(unit=fidlog,fmt=*)\"   dr     = \",drl(i,j)
      arr(i,j)=0.5D0*(geodfn%rrl2(i,j)**2-geodfn%rrl1(i,j)**2)
      szaml=(1.D0/3.D0)*(geodfn%rrl2(i,j)**3-geodfn%rrl1(i,j)**3)
      rlc(i,j)=szaml/arr(i,j)

  ! --- loop over phi angle --------------------
      rc=rlc(i,j)
      geodfn%nfil(i,j)=nfiu
      geodfn%dfil(i,j)=dfiu
      write(unit=fidlog,fmt='(A20,3(1X,F7.2))')\"r (lo,mid,hi) =\",geodfn%rrl1(i,j),rlc(i,j),geodfn%rrl2(i,j)
      write(unit=fidlog,fmt='(A20,1X,I4)')\"mesh size (r) =\",geodfn%nfil(i,j)
      i6o4l5: do k=1,geodfn%nfil(i,j)
        iii=iii+1
        is=is+1
        nsurf(2)=nsurf(2)+1
        isurf(2,nsurf(2))=is
        fik=(k-0.5D0)*geodfn%dfil(i,j)
        p__(1,iii)=rc*dcos(fik)
        p__(2,iii)=rc*dsin(fik)
        p__(3,iii)=geodfn%zl1(i)
        p__(5,iii)=0
        p__(6,iii)=0
        p__(7,iii)=geodfn%ulsign(i)
        p__(4,iii)=arr(i,j)*geodfn%dfil(i,j)
        p__(8,iii)=2*(epsw_-epspr_)/(epspr_+epsw_)
      enddo i6o4l5
      geodfn%rrl1(i,j+1)=geodfn%rrl2(i,j)
    enddo w8w7s2
    write(unit=fidlog,fmt=\"(50('-'))\")
  enddo b0j3s2

  end subroutine gowall

  end subroutine defgrd

  ! ------------------------------------------------------------------
  ! Compute the A matrix
  !
  ! NOTE: The saved matrix does not adjust the i=j or multiply by deps_

  subroutine matrix_(pi,dxf,dxw,epsw,epspr,nsub0,zl1,rl1,rl4,rlvest,rlcurv)
  implicit none
  double precision, intent(in) :: pi,dxf,dxw,epsw,epspr
  integer, intent(in) :: nsub0     ! patch number (input) parameters
  double precision, intent(in) :: zl1,rl1,rl4,rlvest,rlcurv
  type (geomdf), allocatable :: geodfn

  external dgetrf
  ! LOCALS
  double precision fi1,fi2    ! derived patch size params
  double precision  aij       ! integrator output
  ! LOCALS
  integer i,j,k ! loop indices
  integer nsub     ! patch number (input) parameters
  integer ipatch,jpatch              ! 'A' matrix indices
  integer np10  ! counter for percent-complete output
  character*(*) fmt101
  parameter (fmt101='(2X,I8)')
  ! LOCAL
  integer info,npch2

  pi_ = pi
  dxf_ = dxf
  dxw_ = dxw
  epsw_ = epsw
  epspr_ = epspr
  nsub0_ = nsub0

  if (dbc_) then
    if (irdamx_) stop \"patch::matrix called when inverted matrix exists\"
  endif
  ! if not aa then rdmtrx
  allocate(geodfn)

  ! -----  Define geometry ------------------------------
  call defgrd(geodfn,zl1,rl1,rl4,rlvest,rlcurv)

  ! Npatch defined, allocate memory
  call f4s3s6
  ! ----  Fill matrix -----------------------------------

  write(unit=fidlog,fmt=*)\" Filling matrix, patience\"
  np10=npatch_/10

  e2o3c9: do ipatch=1,npatch_

    if (mod(ipatch,np10).eq.0) write(unit=fidlog,fmt='(i3,\" %\")')10*ipatch/np10

    jpatch=0

    h8s9k7: do i=1,geodfn%nline
      x4x9c4: do j=1,geodfn%nzl(i)
        r5y4j7: do k=1,geodfn%nfil(i,j)
          jpatch=jpatch+1
          p8q0w3: if (ipatch.eq.jpatch) then
  !           if this patch is 'seeing' itself, we need lots of tiny patches
            nsub=5*nsub0_
          else p8q0w3
            nsub=nsub0_
          endif p8q0w3
  !         fi1/2 is start/end of distance (in radians) around the phi angle
          fi1=(k-1)*geodfn%dfil(i,j)
          fi2=k*geodfn%dfil(i,j)
          call intlin(nsub,geodfn%zl1(i),geodfn%rl1(i),geodfn%tgalfa(i),geodfn%zzl1(i,j),geodfn%zzl2(i,j),fi1,fi2,ipatch,aij)
          amx_(ipatch,jpatch)=aij/(4*pi_)
        enddo r5y4j7
      enddo x4x9c4
    enddo h8s9k7

    q1w3h2: do i=1,geodfn%narch
      h8l6c7: do j=1,geodfn%nta(i)
        f8g1o9: do k=1,geodfn%nfia(i,j)
          jpatch=jpatch+1
          k4v5z9: if (ipatch.eq.jpatch) then
  !           if this patch is 'seeing' itself, we need lots of tiny patches
            nsub=5*nsub0_
          else k4v5z9
            nsub=nsub0_
          endif k4v5z9
  !         fi1/2 is start/end of distance (in radians) around the phi angle
          fi1=(k-1)*geodfn%dfia(i,j)
          fi2=k*geodfn%dfia(i,j)
  !          write(unit=fidlog,fmt=*)ipatch,jpatch,nsub,geodfn%za0(i),geodfn%ra0(i),geodfn%ra(i),geodfn%tta1(i,j),
  ! :          geodfn%tta2(i,j),fi1,fi2,uasign(i)
          call intarc(nsub,geodfn%za0(i),geodfn%ra0(i),geodfn%ra(i),geodfn%tta1(i,j),geodfn%tta2(i,j),fi1,fi2,ipatch,aij)
          amx_(ipatch,jpatch)=aij/(4*pi_)
        enddo f8g1o9
      enddo h8l6c7
    enddo q1w3h2

    l3d7u8: do i=geodfn%nline+1,geodfn%nline+geodfn%nwall
      v0y7z9: do j=1,geodfn%nrl(i)
        a9e7o1: do k=1,geodfn%nfil(i,j)
          jpatch=jpatch+1
          x2t2t9: if (ipatch.eq.jpatch) then
  !           if this patch is 'seeing' itself, we need lots of tiny patches
            nsub=5*nsub0_
          else x2t2t9
            nsub=nsub0_
          endif x2t2t9
  !         fi1/2 is start/end of distance (in radians) around the phi angle
          fi1=(k-1)*geodfn%dfil(i,j)
          fi2=k*geodfn%dfil(i,j)
          call intwll(nsub,geodfn%zl1(i),geodfn%rrl1(i,j),geodfn%rrl2(i,j),fi1,fi2,ipatch,aij)
          amx_(ipatch,jpatch)=aij/(4*pi_)
        enddo a9e7o1
      enddo v0y7z9
    enddo l3d7u8
  enddo e2o3c9

  deallocate(geodfn)
  if (debug_) then
    call dumpam( \"amx0.dat\" )
  endif

  ! -----------------------------------------------------
  ! Update A matrix with deps_ etc
  forall (i=1:npatch_) amx_(i,1:npatch_)=deps_(i)*amx_(i,1:npatch_)
  indx_=0
  forall (i=1:npatch_) amx_(i,i)=amx_(i,i)+1

  if (debug_) then
    call dumpam( \"amx1.dat\" )
  endif

  ! -----------------------------------------------------
  ! Do LU decomposition of the A matrix
  ! call ludcmp
  write(unit=fidlog,fmt=*)\"LU decomposing the 'A' matrix (using BLAS)\"
  npch2=npchsz_
  info=0
  call dgetrf(npatch_, npchsz_, amx_, npch2, indx_, info)
  if (debug_) write(unit=fidlog,fmt=*)\"! Matrix has been inverted, info = \",info
  if (0.ne.info) stop \"Matrix inversion failed, no save.\"

  irdamx_=.true.

  contains

  !----------------------------------------------------------------------
  ! Private method to allocate second half of patch system
  ! 
  subroutine f4s3s6
  implicit none

  if (.not.allocated(amx_)) then
    allocate(amx_(npchsz_,npchsz_),indx_(npchsz_))
    amx_=0
    indx_=0
  endif
  end subroutine f4s3s6
 
  ! -----------------------------------------------------
  ! Integrate a patch on an arc
  subroutine intarc(nsub,z0,r0,r,t1,t2,fi1,fi2,ii,aij)
  implicit none
  integer nsub,ii
  double precision z0,r0,r,t1,t2,fi1,fi2,aij

  ! LOCALS
  double precision ar,arel,cosfij,costtc,dfi,dfisub,dt,dtsub
  double precision fij,pxi,pxj,pxij,pyi,pyj,pyij,pzi,pzj,pzij
  double precision rij,rij3,rijsq,sinfij,sinttc,rc,szaml,tt1,tt2
  double precision ttc,uxi,uyi,uzi
  integer i,j ! loop indices

  ar=0
  pxi=prx_(ii)
  pyi=pry_(ii)
  pzi=prz_(ii)
  uxi=pux_(ii)
  uyi=puy_(ii)
  uzi=puz_(ii)

  dt=t2-t1
  dtsub=dt/dble(nsub)
  dfi=fi2-fi1
  dfisub=dfi/dble(nsub)

  aij=0
  if (dfeq(0.0D0,dfi)) stop \"error in intarc, dfi = 0\"
  ! --- double loop over subtiles ----------------------
  ! --- loop over theta angle --------------------------

  o3f5x0: do i=1,nsub
    r3o7r0: if (dfeq(0.0D0,dtsub)) then
      sinttc=0
      costtc=1
    else   r3o7r0
      tt1=t1+(i-1)*dtsub
      tt2=tt1+dtsub
      ar=r0*dtsub-r*(dcos(tt2)-dcos(tt1))
      szaml=0.5D0*r0*(tt2**2-tt1**2)-r*(tt2*dcos(tt2)-tt1*dcos(tt1))+r*(dsin(tt2)-dsin(tt1))
      ttc=szaml/ar
      if (dbc_) then
        if (isnan(ttc)) stop \"error in intarc, ttc is NaN\"
      endif
      sinttc=dsin(ttc)
      costtc=dcos(ttc)
    endif r3o7r0
    rc=r0+r*sinttc
    arel=r*ar*dfisub
    if (dbc_) then
      if (isnan(rc)) stop \"error in intarc, rc is NaN\"
      if (isnan(arel)) stop \"error in intarc, arel is NaN\"
    endif
  ! --- loop over phi angle ----------------------------
    pzj=z0+r*costtc

    y6p7q8: do j=1,nsub
      fij=fi1+(j-0.5D0)*dfisub
      cosfij=dcos(fij)
      sinfij=dsin(fij)
      pxj=rc*cosfij
      pyj=rc*sinfij
      pxij=pxj-pxi
      pyij=pyj-pyi
      pzij=pzj-pzi
      rijsq=pxij*pxij+pyij*pyij+pzij*pzij
      rij=dsqrt(rijsq)
      rij3=rijsq*rij
      aij=aij+(pxij*uxi+pyij*uyi+pzij*uzi)*arel/rij3
    enddo y6p7q8
  enddo o3f5x0
  if (dbc_) then
    if (isnan(aij)) stop \"error in intarc, aij is NaN\"
  endif
  end subroutine intarc

  ! -----------------------------------------------------
  ! Integrate a patch on cylindrical surface

  subroutine intlin(nsub,z0,r0,talfa,z1,z2,fi1,fi2,ii,aij)
  implicit none
  integer nsub,ii
  double precision z0,r0,talfa,z1,z2,fi1,fi2,aij
  ! LOCALS
  double precision ar,arel,cosfij,dfi,dfisub,dz,dzsub
  double precision fij,pxi,pxj,pxij,pyi,pyj,pyij,pzi,pzj,pzij
  double precision rij,rij3,rijsq,sinfij,rc,szaml,zz1,zz2
  double precision zc,uxi,uyi,uzi,calfa
  integer i,j ! loop indices

  pxi=prx_(ii)
  pyi=pry_(ii)
  pzi=prz_(ii)
  uxi=pux_(ii)
  uyi=puy_(ii)
  uzi=puz_(ii)

  ! calfa is cos of alfa
  calfa=1/dsqrt(1+talfa**2)
  ! z2 and z1 are end and begin of this particular ring
  dz=z2-z1
  ! so split up each ring into pieces (10)
  dzsub=dz/dble(nsub)
  ! also around the phi angle
  dfi=fi2-fi1
  dfisub=dfi/dble(nsub)

  aij=0
  ! gonna sum up aij for each patch
  ! will sum over tiny patches (nsub*nsub tiny patches)

  ! --- double loop over subtiles ------
  ! --- loop over theta angle ----------
  ! so each patch is going to have nsub*nsub tiny patches
  i2a3m1: do i=1,nsub
      zz1=z1+(i-1)*dzsub
      zz2=zz1+dzsub
  ! get the centroid in this weird way i can't figure out
  ! r0 is radius if line at beginning (left) side
  ! z0 beginning (left) of line
  ! talfa is tangent of the slope of the line
  ! dzsub is spacing between each tiny patch
  ! zz2 is right side of tinypatch
  ! zz1 is left side of tinypatch
    ar=(r0-z0*talfa)*dzsub+talfa*0.5D0*(zz2**2-zz1**2)
    szaml=0.5D0*(r0-z0*talfa)*(zz2**2-zz1**2)+talfa*(1.D0/3.D0)*(zz2**3-zz1**3)
    zc=szaml/ar
    rc=r0-z0*talfa+zc*talfa
    arel=rc/calfa

  ! --- loop over phi angle ------------

    r3g2u7: do j=1,nsub
  ! loop over tiny patches around phi angle
  ! fij is center of tiny patch around phi angle
      fij=fi1+(j-0.5D0)*dfisub
      cosfij=dcos(fij)
      sinfij=dsin(fij)
  ! pxj,pyz, and pzj are centroid of tiny patch
      pxj=rc*cosfij
      pyj=rc*sinfij
      pzj=zc
  ! pxi,pyi,pzi is center of patch
      pxij=pxj-pxi
      pyij=pyj-pyi
      pzij=pzj-pzi
      rijsq=pxij*pxij+pyij*pyij+pzij*pzij
  ! rij is the distance from the patch centroid to the tiny patch
      rij=dsqrt(rijsq)
      rij3=rijsq*rij
      aij=aij+(pxij*uxi+pyij*uyi+pzij*uzi)*arel*dzsub*dfisub/rij3
    enddo r3g2u7
  enddo i2a3m1
  if (dbc_) then
    if (isnan(aij)) stop \"error in intlin, aij is NaN\"
  endif
  end subroutine intlin

  ! -----------------------------------------------------
  ! Integrate patch on a disk surface
  subroutine intwll(nsub,z0,r1,r2,fi1,fi2,ii,aij)
  implicit none
  integer nsub,ii
  double precision z0,r1,r2,fi1,fi2,aij

  ! LOCALS
  double precision ar,arel,dfi,dfisub,dr,drsub
  double precision fij,pxi,pxj,pxij,pyi,pyj,pyij,pzi,pzj,pzij
  double precision rij,rij3,rijsq,rc,szaml,rr1,rr2,uxi,uyi,uzi
  integer i,j ! loop indices

  pxi=prx_(ii)
  pyi=pry_(ii)
  pzi=prz_(ii)
  uxi=pux_(ii)
  uyi=puy_(ii)
  uzi=puz_(ii)

  dr=r2-r1
  drsub=dr/dble(nsub)
  dfi=fi2-fi1
  dfisub=dfi/dble(nsub)

  aij=0
  ! --- double loop over subtiles ------
  ! --- loop over theta angle ----------

  q1e3h4: do i=1,nsub
    rr1=r1+(i-1)*drsub
    rr2=rr1+drsub
    ar=0.5D0*(rr2**2-rr1**2)
    szaml=(1.D0/3.D0)*(rr2**3-rr1**3)
    rc=szaml/ar
    arel=rc

  ! --- loop over phi angle ------------

    f1l0h6: do j=1,nsub
      fij=fi1+(j-0.5D0)*dfisub
      pxj=rc*dcos(fij)
      pyj=rc*dsin(fij)
      pzj=z0
      pxij=pxj-pxi
      pyij=pyj-pyi
      pzij=pzj-pzi
      rijsq=pxij*pxij+pyij*pyij+pzij*pzij
      rij=dsqrt(rijsq)
      rij3=rijsq*rij
      aij=aij+(pxij*uxi+pyij*uyi+pzij*uzi) *arel*drsub*dfisub/rij3
    enddo f1l0h6
  enddo q1e3h4
  if (dbc_) then
    if (isnan(aij)) stop \"error in intwll, aij is NaN\"
  endif
  end subroutine intwll

  end subroutine matrix_
 
  !----------------------------------------------------------------------
  ! save amx_ and indx_
  !
  ! This is the counterpoint method to 'readam'.  It saves a digest
  ! of of the input parameters critical to defining the matrix.
  ! These are the protein geometry parameters, the patch integration
  ! grid parameters and the permittivity constants. Then saves the
  ! 'amx_' matrix itself.
  subroutine writam_(fngamx) 
  implicit none
  character(*), intent(in) :: fngamx
  integer :: istat, i,j ! loop indices
  ! check variables are:
  ! patch data: npatch_, dxf_,dxw_,nsub0_,
  ! geom data: zl,rl,rlvest(),rlcurv(),epsw_,epspr_
  write(unit=fidlog,fmt=*)\"Saving inverted 'A' matrix\"
  open(unit=fidamx,file=fngamx,action='write',status='replace',iostat=istat)
    if (istat.ne.0) stop \"Unable to open file to save the 'A' matrix\"
    write(unit=fidamx,fmt='(I4)')npatch_
    write(unit=fidamx,fmt=*)  
    x2t9z8: do i=1,npatch_
      write(unit=fidamx,fmt='(I4)')indx_(i)
      s0j2d6: do j=1,npatch_
        write(unit=fidamx,fmt='(I4,1X,I4,1X,E26.18)')i,j,amx_(i,j)
      enddo s0j2d6
      write(unit=fidamx,fmt=*)  
    enddo x2t9z8
  close(unit=fidamx)
  end subroutine writam_

  !----------------------------------------------------------------------
  ! Write patch data
  !
  subroutine writpc_(fngpch)
  implicit none
  character(*), intent(in) :: fngpch
  integer :: istat, ii

  open(unit=fidpch,file=fngpch,action='write',status='replace',iostat=istat)
  if (istat.ne.0) stop 'Unable to open file to save patch geometry.'
  write(unit=fidpch,fmt='(A)')'# index xcoord  ycoord  zcoord area xnorm ynorm znorm deps_'
  write(unit=fidpch,fmt='(A)')'# ordinal ang     ang     ang    ang2 ang   ang   ang   1/permittivity'
  do ii=1,npatch_
    write(unit=fidpch,fmt='(I4,1X,F16.10,7(2x,F16.10))')ii,prx_(ii),&
&     pry_(ii),prz_(ii),parea_(ii),pux_(ii),puy_(ii),puz_(ii),deps_(ii)
  enddo
  close(unit=fidpch)
  end subroutine writpc_

end module patch


"
    end

    artifact 717232 "libionch_fevaluator"
      stereotype "library"
      associated_artifacts
	artifact_ref 717104 // patch.f90
	artifact_ref 723760 // cfortran
	artifact_ref 723888 // icc_fortran
      end
      ncouples 1
      key "butter ldflags" value "$(FORTRANLIBS)"
    end

    artifact 723760 "cfortran"
      stereotype "source"
      cpp_h "/* cfortran.h  4.3 */
/* http://www-zeus.desy.de/~burow/cfortran/                   */
/* Burkhard Burow  burow@desy.de                 1990 - 2001. */

#ifndef __CFORTRAN_LOADED
#define __CFORTRAN_LOADED

/* 
   THIS FILE IS PROPERTY OF BURKHARD BUROW. IF YOU ARE USING THIS FILE YOU
   SHOULD ALSO HAVE ACCESS TO CFORTRAN.DOC WHICH PROVIDES TERMS FOR USING,
   MODIFYING, COPYING AND DISTRIBUTING THE CFORTRAN.H PACKAGE.
*/

/* 
  Avoid symbols already used by compilers and system *.h:
  __ - OSF1 zukal06 V3.0 347 alpha, cc -c -std1 cfortest.c

 */
#ifdef __cplusplus
extern \"C\" {
#endif

/* First prepare for the C compiler. */

#ifndef ANSI_C_preprocessor /* i.e. user can override. */
#ifdef __CF__KnR
#define ANSI_C_preprocessor 0
#else
#ifdef __STDC__
#define ANSI_C_preprocessor 1
#else
#define _cfleft             1
#define _cfright 
#define _cfleft_cfright     0
#define ANSI_C_preprocessor _cfleft/**/_cfright
#endif
#endif
#endif

#if ANSI_C_preprocessor
#define _0(A,B)   A##B
#define  _(A,B)   _0(A,B)  /* see cat,xcat of K&R ANSI C p. 231 */
#define _2(A,B)   A##B     /* K&R ANSI C p.230: .. identifier is not replaced */
#define _3(A,B,C) _(A,_(B,C))
#else                      /* if it turns up again during rescanning.         */
#define  _(A,B)   A/**/B
#define _2(A,B)   A/**/B
#define _3(A,B,C) A/**/B/**/C
#endif

#if (defined(vax)&&defined(unix)) || (defined(__vax__)&&defined(__unix__))
#define VAXUltrix
#endif

#include <stdio.h>     /* NULL [in all machines stdio.h]                      */
#include <string.h>    /* strlen, memset, memcpy, memchr.                     */
#if !( defined(VAXUltrix) || defined(sun) || (defined(apollo)&&!defined(__STDCPP__)) )
#include <stdlib.h>    /* malloc,free                                         */
#else
#include <malloc.h>    /* Had to be removed for DomainOS h105 10.4 sys5.3 425t*/
#ifdef apollo
#define __CF__APOLLO67 /* __STDCPP__ is in Apollo 6.8 (i.e. ANSI) and onwards */
#endif
#endif

#if !defined(__GNUC__) && !defined(__sun) && (defined(sun)||defined(VAXUltrix)||defined(lynx))
#define __CF__KnR     /* Sun, LynxOS and VAX Ultrix cc only supports K&R.     */
                      /* Manually define __CF__KnR for HP if desired/required.*/
#endif                /*       i.e. We will generate Kernighan and Ritchie C. */
/* Note that you may define __CF__KnR before #include cfortran.h, in order to
generate K&R C instead of the default ANSI C. The differences are mainly in the
function prototypes and declarations. All machines, except the Apollo, work
with either style. The Apollo's argument promotion rules require ANSI or use of
the obsolete std_$call which we have not implemented here. Hence on the Apollo,
only C calling FORTRAN subroutines will work using K&R style.*/


/* Remainder of cfortran.h depends on the Fortran compiler. */

#if defined(CLIPPERFortran) || defined(pgiFortran)
#define f2cFortran
#endif

/* VAX/VMS does not let us \\-split long #if lines. */ 
/* Split #if into 2 because some HP-UX can't handle long #if */
#if !(defined(NAGf90Fortran)||defined(f2cFortran)||defined(hpuxFortran)||defined(apolloFortran)||defined(sunFortran)||defined(IBMR2Fortran)||defined(CRAYFortran))
#if !(defined(mipsFortran)||defined(DECFortran)||defined(vmsFortran)||defined(CONVEXFortran)||defined(PowerStationFortran)||defined(AbsoftUNIXFortran)||defined(AbsoftProFortran)||defined(SXFortran))
/* If no Fortran compiler is given, we choose one for the machines we know.   */
#if defined(lynx) || defined(VAXUltrix)
#define f2cFortran    /* Lynx:      Only support f2c at the moment.
                         VAXUltrix: f77 behaves like f2c.
                           Support f2c or f77 with gcc, vcc with f2c. 
                           f77 with vcc works, missing link magic for f77 I/O.*/
#endif
#if defined(__hpux)             /* 921107: Use __hpux instead of __hp9000s300 */
#define       hpuxFortran       /*         Should also allow hp9000s7/800 use.*/
#endif
#if       defined(apollo)
#define           apolloFortran /* __CF__APOLLO67 also defines some behavior. */
#endif
#if          defined(sun) || defined(__sun) 
#define              sunFortran
#endif
#if       defined(_IBMR2)
#define            IBMR2Fortran
#endif
#if        defined(_CRAY)
#define             CRAYFortran /*       _CRAYT3E also defines some behavior. */
#endif
#if        defined(_SX)
#define               SXFortran
#endif
#if         defined(mips) || defined(__mips)
#define             mipsFortran
#endif
#if          defined(vms) || defined(__vms)
#define              vmsFortran
#endif
#if      defined(__alpha) && defined(__unix__)
#define              DECFortran
#endif
#if   defined(__convex__)
#define           CONVEXFortran
#endif
#if   defined(VISUAL_CPLUSPLUS)
#define     PowerStationFortran
#endif
#endif /* ...Fortran */
#endif /* ...Fortran */

/* Split #if into 2 because some HP-UX can't handle long #if */
#if !(defined(NAGf90Fortran)||defined(f2cFortran)||defined(hpuxFortran)||defined(apolloFortran)||defined(sunFortran)||defined(IBMR2Fortran)||defined(CRAYFortran))
#if !(defined(mipsFortran)||defined(DECFortran)||defined(vmsFortran)||defined(CONVEXFortran)||defined(PowerStationFortran)||defined(AbsoftUNIXFortran)||defined(AbsoftProFortran)||defined(SXFortran))
/* If your compiler barfs on ' #error', replace # with the trigraph for #     */
 #error \"cfortran.h:  Can't find your environment among:\\
    - MIPS cc and f77 2.0. (e.g. Silicon Graphics, DECstations, ...)     \\
    - IBM AIX XL C and FORTRAN Compiler/6000 Version 01.01.0000.0000     \\
    - VAX   VMS CC 3.1 and FORTRAN 5.4.                                  \\
    - Alpha VMS DEC C 1.3 and DEC FORTRAN 6.0.                           \\
    - Alpha OSF DEC C and DEC Fortran for OSF/1 AXP Version 1.2          \\
    - Apollo DomainOS 10.2 (sys5.3) with f77 10.7 and cc 6.7.            \\
    - CRAY                                                               \\
    - NEC SX-4 SUPER-UX                                                  \\
    - CONVEX                                                             \\
    - Sun                                                                \\
    - PowerStation Fortran with Visual C++                               \\
    - HP9000s300/s700/s800 Latest test with: HP-UX A.08.07 A 9000/730    \\
    - LynxOS: cc or gcc with f2c.                                        \\
    - VAXUltrix: vcc,cc or gcc with f2c. gcc or cc with f77.             \\
    -            f77 with vcc works; but missing link magic for f77 I/O. \\
    -            NO fort. None of gcc, cc or vcc generate required names.\\
    - f2c    : Use #define    f2cFortran, or cc -Df2cFortran             \\
    - NAG f90: Use #define NAGf90Fortran, or cc -DNAGf90Fortran          \\
    - Absoft UNIX F77: Use #define AbsoftUNIXFortran or cc -DAbsoftUNIXFortran \\
    - Absoft Pro Fortran: Use #define AbsoftProFortran \\
    - Portland Group Fortran: Use #define pgiFortran\"
/* Compiler must throw us out at this point! */
#endif
#endif


#if defined(VAXC) && !defined(__VAXC)
#define OLD_VAXC
#pragma nostandard                       /* Prevent %CC-I-PARAMNOTUSED.       */
#endif

/* Throughout cfortran.h we use: UN = Uppercase Name.  LN = Lowercase Name.   */

#if defined(f2cFortran) || defined(NAGf90Fortran) || defined(DECFortran) || defined(mipsFortran) || defined(apolloFortran) || defined(sunFortran) || defined(CONVEXFortran) || defined(SXFortran) || defined(extname)
#define CFC_(UN,LN)            _(LN,_)      /* Lowercase FORTRAN symbols.     */
#define orig_fcallsc(UN,LN)    CFC_(UN,LN)
#else 
#if defined(CRAYFortran) || defined(PowerStationFortran) || defined(AbsoftProFortran)
#ifdef _CRAY          /* (UN), not UN, circumvents CRAY preprocessor bug.     */
#define CFC_(UN,LN)            (UN)         /* Uppercase FORTRAN symbols.     */
#else                 /* At least VISUAL_CPLUSPLUS barfs on (UN), so need UN. */
#define CFC_(UN,LN)            UN           /* Uppercase FORTRAN symbols.     */
#endif
#define orig_fcallsc(UN,LN)    CFC_(UN,LN)  /* CRAY insists on arg.'s here.   */
#else  /* For following machines one may wish to change the fcallsc default.  */
#define CF_SAME_NAMESPACE
#ifdef vmsFortran
#define CFC_(UN,LN)            LN           /* Either case FORTRAN symbols.   */
     /* BUT we usually use UN for C macro to FORTRAN routines, so use LN here,*/
     /* because VAX/VMS doesn't do recursive macros.                          */
#define orig_fcallsc(UN,LN)    UN
#else      /* HP-UX without +ppu or IBMR2 without -qextname. NOT reccomended. */
#define CFC_(UN,LN)            LN           /* Lowercase FORTRAN symbols.     */
#define orig_fcallsc(UN,LN)    CFC_(UN,LN)
#endif /*  vmsFortran */
#endif /* CRAYFortran PowerStationFortran */
#endif /* ....Fortran */

#define fcallsc(UN,LN)               orig_fcallsc(UN,LN)
#define preface_fcallsc(P,p,UN,LN)   CFC_(_(P,UN),_(p,LN))
#define  append_fcallsc(P,p,UN,LN)   CFC_(_(UN,P),_(LN,p))

#define C_FUNCTION(UN,LN)            fcallsc(UN,LN)      
#define FORTRAN_FUNCTION(UN,LN)      CFC_(UN,LN)

#ifndef COMMON_BLOCK
#ifndef CONVEXFortran
#ifndef CLIPPERFortran
#if     !(defined(AbsoftUNIXFortran)||defined(AbsoftProFortran))
#define COMMON_BLOCK(UN,LN)          CFC_(UN,LN)
#else
#define COMMON_BLOCK(UN,LN)          _(_C,LN)
#endif  /* AbsoftUNIXFortran or AbsoftProFortran */
#else
#define COMMON_BLOCK(UN,LN)          _(LN,__)
#endif  /* CLIPPERFortran */
#else
#define COMMON_BLOCK(UN,LN)          _3(_,LN,_)
#endif  /* CONVEXFortran */
#endif  /* COMMON_BLOCK */

#ifndef DOUBLE_PRECISION
#if defined(CRAYFortran) && !defined(_CRAYT3E)
#define DOUBLE_PRECISION long double
#else
#define DOUBLE_PRECISION double
#endif
#endif

#ifndef FORTRAN_REAL
#if defined(CRAYFortran) &&  defined(_CRAYT3E)
#define FORTRAN_REAL double
#else
#define FORTRAN_REAL float
#endif
#endif

#ifdef CRAYFortran
#ifdef _CRAY
#include <fortran.h>
#else
#include \"fortran.h\"  /* i.e. if crosscompiling assume user has file. */
#endif
#define FLOATVVVVVVV_cfPP (FORTRAN_REAL *)   /* Used for C calls FORTRAN.     */
/* CRAY's double==float but CRAY says pointers to doubles and floats are diff.*/
#define VOIDP  (void *)  /* When FORTRAN calls C, we don't know if C routine 
                            arg.'s have been declared float *, or double *.   */
#else
#define FLOATVVVVVVV_cfPP
#define VOIDP
#endif

#ifdef vmsFortran
#if    defined(vms) || defined(__vms)
#include <descrip.h>
#else
#include \"descrip.h\"  /* i.e. if crosscompiling assume user has file. */
#endif
#endif

#ifdef sunFortran
#if defined(sun) || defined(__sun)
#include <math.h>     /* Sun's FLOATFUNCTIONTYPE, ASSIGNFLOAT, RETURNFLOAT.  */
#else
#include \"math.h\"     /* i.e. if crosscompiling assume user has file. */
#endif
/* At least starting with the default C compiler SC3.0.1 of SunOS 5.3,
 * FLOATFUNCTIONTYPE, ASSIGNFLOAT, RETURNFLOAT are not required and not in
 * <math.h>, since sun C no longer promotes C float return values to doubles.
 * Therefore, only use them if defined.
 * Even if gcc is being used, assume that it exhibits the Sun C compiler
 * behavior in order to be able to use *.o from the Sun C compiler.
 * i.e. If FLOATFUNCTIONTYPE, etc. are in math.h, they required by gcc.
 */
#endif

#ifndef apolloFortran
#define COMMON_BLOCK_DEF(DEFINITION, NAME) extern DEFINITION NAME
#define CF_NULL_PROTO
#else                                         /* HP doesn't understand #elif. */
/* Without ANSI prototyping, Apollo promotes float functions to double.    */
/* Note that VAX/VMS, IBM, Mips choke on 'type function(...);' prototypes. */
#define CF_NULL_PROTO ...
#ifndef __CF__APOLLO67
#define COMMON_BLOCK_DEF(DEFINITION, NAME) \\
 DEFINITION NAME __attribute((__section(NAME)))
#else
#define COMMON_BLOCK_DEF(DEFINITION, NAME) \\
 DEFINITION NAME #attribute[section(NAME)]
#endif
#endif

#ifdef __cplusplus
#undef  CF_NULL_PROTO
#define CF_NULL_PROTO  ...
#endif


#ifndef USE_NEW_DELETE
#ifdef __cplusplus
#define USE_NEW_DELETE 1
#else
#define USE_NEW_DELETE 0
#endif
#endif
#if USE_NEW_DELETE
#define _cf_malloc(N) new char[N]
#define _cf_free(P)   delete[] P
#else
#define _cf_malloc(N) (char *)malloc(N)
#define _cf_free(P)   free(P)
#endif

#ifdef mipsFortran
#define CF_DECLARE_GETARG         int f77argc; char **f77argv
#define CF_SET_GETARG(ARGC,ARGV)  f77argc = ARGC; f77argv = ARGV
#else
#define CF_DECLARE_GETARG
#define CF_SET_GETARG(ARGC,ARGV)
#endif

#ifdef OLD_VAXC                          /* Allow %CC-I-PARAMNOTUSED.         */
#pragma standard                         
#endif

#define AcfCOMMA ,
#define AcfCOLON ;

/*-------------------------------------------------------------------------*/

/*               UTILITIES USED WITHIN CFORTRAN.H                          */

#define _cfMIN(A,B) (A<B?A:B)

/* 970211 - XIX.145:
   firstindexlength  - better name is all_but_last_index_lengths
   secondindexlength - better name is         last_index_length
 */
#define  firstindexlength(A) (sizeof(A[0])==1 ? 1 : (sizeof(A) / sizeof(A[0])) )
#define secondindexlength(A) (sizeof(A[0])==1 ?      sizeof(A) : sizeof(A[0])  )

/* Behavior of FORTRAN LOGICAL. All machines' LOGICAL is same size as C's int.
Conversion is automatic except for arrays which require F2CLOGICALV/C2FLOGICALV.
f2c, MIPS f77 [DECstation, SGI], VAX Ultrix f77,
HP-UX f77                                        : as in C.
VAX/VMS FORTRAN, VAX Ultrix fort,
Absoft Unix Fortran, IBM RS/6000 xlf             : LS Bit = 0/1 = TRUE/FALSE.
Apollo                                           : neg.   = TRUE, else FALSE. 
[Apollo accepts -1 as TRUE for function values, but NOT all other neg. values.]
[DECFortran for Ultrix RISC is also called f77 but is the same as VAX/VMS.]   
[MIPS f77 treats .eqv./.neqv. as .eq./.ne. and hence requires LOGICAL_STRICT.]*/

#if defined(NAGf90Fortran) || defined(f2cFortran) || defined(mipsFortran) || defined(PowerStationFortran) || defined(hpuxFortran800) || defined(AbsoftUNIXFortran) || defined(AbsoftProFortran) || defined(SXFortran)
/* SX/PowerStationFortran have 0 and 1 defined, others are neither T nor F.   */
/* hpuxFortran800 has 0 and 0x01000000 defined. Others are unknown.           */
#define LOGICAL_STRICT      /* Other Fortran have .eqv./.neqv. == .eq./.ne.   */
#endif

#define C2FLOGICALV(A,I) \\
 do {int __i; for(__i=0;__i<I;__i++) A[__i]=C2FLOGICAL(A[__i]); } while (0)
#define F2CLOGICALV(A,I) \\
 do {int __i; for(__i=0;__i<I;__i++) A[__i]=F2CLOGICAL(A[__i]); } while (0)

#if defined(apolloFortran)
#define C2FLOGICAL(L) ((L)?-1:(L)&~((unsigned)1<<sizeof(int)*8-1))
#define F2CLOGICAL(L) ((L)<0?(L):0) 
#else
#if defined(CRAYFortran)
#define C2FLOGICAL(L) _btol(L)
#define F2CLOGICAL(L) _ltob(&(L))     /* Strangely _ltob() expects a pointer. */
#else
#if defined(IBMR2Fortran) || defined(vmsFortran) || defined(DECFortran) || defined(AbsoftUNIXFortran)
/* How come no AbsoftProFortran ? */
#define C2FLOGICAL(L) ((L)?(L)|1:(L)&~(int)1)
#define F2CLOGICAL(L) ((L)&1?(L):0)
#else
#if defined(CONVEXFortran)
#define C2FLOGICAL(L) ((L) ? ~0 : 0 )
#define F2CLOGICAL(L) (L)
#else   /* others evaluate LOGICALs as for C. */
#define C2FLOGICAL(L) (L)
#define F2CLOGICAL(L) (L)
#ifndef LOGICAL_STRICT
#undef  C2FLOGICALV
#undef  F2CLOGICALV
#define C2FLOGICALV(A,I)
#define F2CLOGICALV(A,I)
#endif  /* LOGICAL_STRICT                     */
#endif  /* CONVEXFortran || All Others        */
#endif  /* IBMR2Fortran vmsFortran DECFortran AbsoftUNIXFortran */
#endif  /* CRAYFortran                        */
#endif  /* apolloFortran                      */

/* 970514 - In addition to CRAY, there may be other machines
            for which LOGICAL_STRICT makes no sense. */
#if defined(LOGICAL_STRICT) && !defined(CRAYFortran)
/* Force C2FLOGICAL to generate only the values for either .TRUE. or .FALSE.
   SX/PowerStationFortran only have 0 and 1 defined.
   Elsewhere, only needed if you want to do:
     logical lvariable
     if (lvariable .eq.  .true.) then       ! (1)
   instead of
     if (lvariable .eqv. .true.) then       ! (2)
   - (1) may not even be FORTRAN/77 and that Apollo's f77 and IBM's xlf
     refuse to compile (1), so you are probably well advised to stay away from 
     (1) and from LOGICAL_STRICT.
   - You pay a (slight) performance penalty for using LOGICAL_STRICT. */
#undef  C2FLOGICAL
#ifdef hpuxFortran800
#define C2FLOGICAL(L) ((L)?0x01000000:0)
#else
#if defined(apolloFortran) || defined(vmsFortran) || defined(DECFortran)
#define C2FLOGICAL(L) ((L)?-1:0) /* These machines use -1/0 for .true./.false.*/
#else
#define C2FLOGICAL(L) ((L)? 1:0) /* All others     use +1/0 for .true./.false.*/
#endif
#endif
#endif /* LOGICAL_STRICT */

/* Convert a vector of C strings into FORTRAN strings. */
#ifndef __CF__KnR
static char *c2fstrv(char* cstr, char *fstr, int elem_len, int sizeofcstr)
#else
static char *c2fstrv(      cstr,       fstr,     elem_len,     sizeofcstr)
                     char* cstr; char *fstr; int elem_len; int sizeofcstr;
#endif
{ int i,j;
/* elem_len includes \\0 for C strings. Fortran strings don't have term. \\0.
   Useful size of string must be the same in both languages. */
for (i=0; i<sizeofcstr/elem_len; i++) {
  for (j=1; j<elem_len && *cstr; j++) *fstr++ = *cstr++;
  cstr += 1+elem_len-j;
  for (; j<elem_len; j++) *fstr++ = ' ';
} /* 95109 - Seems to be returning the original fstr. */
return fstr-sizeofcstr+sizeofcstr/elem_len; }

/* Convert a vector of FORTRAN strings into C strings. */
#ifndef __CF__KnR
static char *f2cstrv(char *fstr, char* cstr, int elem_len, int sizeofcstr)
#else
static char *f2cstrv(      fstr,       cstr,     elem_len,     sizeofcstr)
                     char *fstr; char* cstr; int elem_len; int sizeofcstr; 
#endif
{ int i,j;
/* elem_len includes \\0 for C strings. Fortran strings don't have term. \\0.
   Useful size of string must be the same in both languages. */
cstr += sizeofcstr;
fstr += sizeofcstr - sizeofcstr/elem_len;
for (i=0; i<sizeofcstr/elem_len; i++) {
  *--cstr = '\\0';
  for (j=1; j<elem_len; j++) *--cstr = *--fstr;
} return cstr; }

/* kill the trailing char t's in string s. */
#ifndef __CF__KnR
static char *kill_trailing(char *s, char t)
#else
static char *kill_trailing(      s,      t) char *s; char t;
#endif
{char *e; 
e = s + strlen(s);
if (e>s) {                           /* Need this to handle NULL string.*/
  while (e>s && *--e==t);            /* Don't follow t's past beginning. */
  e[*e==t?0:1] = '\\0';               /* Handle s[0]=t correctly.       */
} return s; }

/* kill_trailingn(s,t,e) will kill the trailing t's in string s. e normally 
points to the terminating '\\0' of s, but may actually point to anywhere in s.
s's new '\\0' will be placed at e or earlier in order to remove any trailing t's.
If e<s string s is left unchanged. */ 
#ifndef __CF__KnR
static char *kill_trailingn(char *s, char t, char *e)
#else
static char *kill_trailingn(      s,      t,       e) char *s; char t; char *e;
#endif
{ 
if (e==s) *e = '\\0';                 /* Kill the string makes sense here.*/
else if (e>s) {                      /* Watch out for neg. length string.*/
  while (e>s && *--e==t);            /* Don't follow t's past beginning. */
  e[*e==t?0:1] = '\\0';               /* Handle s[0]=t correctly.       */
} return s; }

/* Note the following assumes that any element which has t's to be chopped off,
does indeed fill the entire element. */
#ifndef __CF__KnR
static char *vkill_trailing(char* cstr, int elem_len, int sizeofcstr, char t)
#else
static char *vkill_trailing(      cstr,     elem_len,     sizeofcstr,      t)
                            char* cstr; int elem_len; int sizeofcstr; char t;
#endif
{ int i;
for (i=0; i<sizeofcstr/elem_len; i++) /* elem_len includes \\0 for C strings. */
  kill_trailingn(cstr+elem_len*i,t,cstr+elem_len*(i+1)-1);
return cstr; }

#ifdef vmsFortran
typedef struct dsc$descriptor_s fstring;
#define DSC$DESCRIPTOR_A(DIMCT)  		                               \\
struct {                                                                       \\
  unsigned short dsc$w_length;	        unsigned char	 dsc$b_dtype;	       \\
  unsigned char	 dsc$b_class;	                 char	*dsc$a_pointer;	       \\
           char	 dsc$b_scale;	        unsigned char	 dsc$b_digits;         \\
  struct {                                                                     \\
    unsigned		       : 3;	  unsigned dsc$v_fl_binscale : 1;      \\
    unsigned dsc$v_fl_redim    : 1;       unsigned dsc$v_fl_column   : 1;      \\
    unsigned dsc$v_fl_coeff    : 1;       unsigned dsc$v_fl_bounds   : 1;      \\
  } dsc$b_aflags;	                                                       \\
  unsigned char	 dsc$b_dimct;	        unsigned long	 dsc$l_arsize;	       \\
           char	*dsc$a_a0;	                 long	 dsc$l_m [DIMCT];      \\
  struct {                                                                     \\
    long dsc$l_l;                         long dsc$l_u;                        \\
  } dsc$bounds [DIMCT];                                                        \\
}
typedef DSC$DESCRIPTOR_A(1) fstringvector;
/*typedef DSC$DESCRIPTOR_A(2) fstringarrarr;
  typedef DSC$DESCRIPTOR_A(3) fstringarrarrarr;*/
#define initfstr(F,C,ELEMNO,ELEMLEN)                                           \\
( (F).dsc$l_arsize=  ( (F).dsc$w_length                        =(ELEMLEN) )    \\
                    *( (F).dsc$l_m[0]=(F).dsc$bounds[0].dsc$l_u=(ELEMNO)  ),   \\
  (F).dsc$a_a0    =  ( (F).dsc$a_pointer=(C) ) - (F).dsc$w_length          ,(F))

#else
#define _NUM_ELEMS      -1
#define _NUM_ELEM_ARG   -2
#define NUM_ELEMS(A)    A,_NUM_ELEMS
#define NUM_ELEM_ARG(B) *_2(A,B),_NUM_ELEM_ARG
#define TERM_CHARS(A,B) A,B
#ifndef __CF__KnR
static int num_elem(char *strv, unsigned elem_len, int term_char, int num_term)
#else
static int num_elem(      strv,          elem_len,     term_char,     num_term)
                    char *strv; unsigned elem_len; int term_char; int num_term;
#endif
/* elem_len is the number of characters in each element of strv, the FORTRAN
vector of strings. The last element of the vector must begin with at least
num_term term_char characters, so that this routine can determine how 
many elements are in the vector. */
{
unsigned num,i;
if (num_term == _NUM_ELEMS || num_term == _NUM_ELEM_ARG) 
  return term_char;
if (num_term <=0) num_term = (int)elem_len;
for (num=0; ; num++) {
  for (i=0; i<(unsigned)num_term && *strv==term_char; i++,strv++);
  if (i==(unsigned)num_term) break;
  else strv += elem_len-i;
}
return (int)num;
}
#endif
/*-------------------------------------------------------------------------*/

/*           UTILITIES FOR C TO USE STRINGS IN FORTRAN COMMON BLOCKS       */

/* C string TO Fortran Common Block STRing. */
/* DIM is the number of DIMensions of the array in terms of strings, not
   characters. e.g. char a[12] has DIM = 0, char a[12][4] has DIM = 1, etc. */
#define C2FCBSTR(CSTR,FSTR,DIM)                                                \\
 c2fstrv((char *)CSTR, (char *)FSTR, sizeof(FSTR)/cfelementsof(FSTR,DIM)+1,    \\
         sizeof(FSTR)+cfelementsof(FSTR,DIM))

/* Fortran Common Block string TO C STRing. */
#define FCB2CSTR(FSTR,CSTR,DIM)                                                \\
 vkill_trailing(f2cstrv((char *)FSTR, (char *)CSTR,                            \\
                        sizeof(FSTR)/cfelementsof(FSTR,DIM)+1,                 \\
                        sizeof(FSTR)+cfelementsof(FSTR,DIM)),                  \\
                sizeof(FSTR)/cfelementsof(FSTR,DIM)+1,                         \\
                sizeof(FSTR)+cfelementsof(FSTR,DIM), ' ')

#define cfDEREFERENCE0
#define cfDEREFERENCE1 *
#define cfDEREFERENCE2 **
#define cfDEREFERENCE3 ***
#define cfDEREFERENCE4 ****
#define cfDEREFERENCE5 *****
#define cfelementsof(A,D) (sizeof(A)/sizeof(_(cfDEREFERENCE,D)(A)))

/*-------------------------------------------------------------------------*/

/*               UTILITIES FOR C TO CALL FORTRAN SUBROUTINES               */

/* Define lookup tables for how to handle the various types of variables.  */

#ifdef OLD_VAXC                                /* Prevent %CC-I-PARAMNOTUSED. */
#pragma nostandard
#endif

#define ZTRINGV_NUM(I)       I
#define ZTRINGV_ARGFP(I) (*(_2(A,I))) /* Undocumented. For PINT, etc. */
#define ZTRINGV_ARGF(I) _2(A,I)
#ifdef CFSUBASFUN
#define ZTRINGV_ARGS(I) ZTRINGV_ARGF(I)
#else
#define ZTRINGV_ARGS(I) _2(B,I)
#endif

#define    PBYTE_cfVP(A,B) PINT_cfVP(A,B)
#define  PDOUBLE_cfVP(A,B)
#define   PFLOAT_cfVP(A,B)
#ifdef ZTRINGV_ARGS_allows_Pvariables
/* This allows Pvariables for ARGS. ARGF machinery is above ARGFP.
 * B is not needed because the variable may be changed by the Fortran routine,
 * but because B is the only way to access an arbitrary macro argument.       */
#define     PINT_cfVP(A,B) int  B = (int)A;              /* For ZSTRINGV_ARGS */
#else
#define     PINT_cfVP(A,B)
#endif
#define PLOGICAL_cfVP(A,B) int *B;      /* Returning LOGICAL in FUNn and SUBn */
#define    PLONG_cfVP(A,B) PINT_cfVP(A,B)
#define   PSHORT_cfVP(A,B) PINT_cfVP(A,B)

#define        VCF_INT_S(T,A,B) _(T,VVVVVVV_cfTYPE) B = A;
#define        VCF_INT_F(T,A,B) _(T,_cfVCF)(A,B)
/* _cfVCF table is directly mapped to _cfCCC table. */
#define     BYTE_cfVCF(A,B)
#define   DOUBLE_cfVCF(A,B)
#if !defined(__CF__KnR)
#define    FLOAT_cfVCF(A,B)
#else
#define    FLOAT_cfVCF(A,B) FORTRAN_REAL B = A;
#endif
#define      INT_cfVCF(A,B)
#define  LOGICAL_cfVCF(A,B)
#define     LONG_cfVCF(A,B)
#define    SHORT_cfVCF(A,B)

/* 980416
   Cast (void (*)(CF_NULL_PROTO)) causes SunOS CC 4.2 occasionally to barf,
   while the following equivalent typedef is fine.
   For consistency use the typedef on all machines.
 */
typedef void (*cfCAST_FUNCTION)(CF_NULL_PROTO);

#define VCF(TN,I)       _Icf4(4,V,TN,_(A,I),_(B,I),F)
#define VVCF(TN,AI,BI)  _Icf4(4,V,TN,AI,BI,S)
#define        INT_cfV(T,A,B,F) _(VCF_INT_,F)(T,A,B)
#define       INTV_cfV(T,A,B,F)
#define      INTVV_cfV(T,A,B,F)
#define     INTVVV_cfV(T,A,B,F)
#define    INTVVVV_cfV(T,A,B,F)
#define   INTVVVVV_cfV(T,A,B,F)
#define  INTVVVVVV_cfV(T,A,B,F)
#define INTVVVVVVV_cfV(T,A,B,F)
#define PINT_cfV(      T,A,B,F) _(T,_cfVP)(A,B)
#define PVOID_cfV(     T,A,B,F)
#if defined(apolloFortran) || defined(hpuxFortran800) || defined(AbsoftUNIXFortran) || defined(AbsoftProFortran)
#define    ROUTINE_cfV(T,A,B,F) void (*B)(CF_NULL_PROTO) = (cfCAST_FUNCTION)A;
#else
#define    ROUTINE_cfV(T,A,B,F)
#endif
#define     SIMPLE_cfV(T,A,B,F)
#ifdef vmsFortran
#define     STRING_cfV(T,A,B,F) static struct {fstring f; unsigned clen;} B =  \\
                                       {{0,DSC$K_DTYPE_T,DSC$K_CLASS_S,NULL},0};
#define    PSTRING_cfV(T,A,B,F) static fstring B={0,DSC$K_DTYPE_T,DSC$K_CLASS_S,NULL};
#define    STRINGV_cfV(T,A,B,F) static fstringvector B =                       \\
  {sizeof(A),DSC$K_DTYPE_T,DSC$K_CLASS_A,NULL,0,0,{0,0,1,1,1},1,0,NULL,0,{1,0}};
#define   PSTRINGV_cfV(T,A,B,F) static fstringvector B =                       \\
          {0,DSC$K_DTYPE_T,DSC$K_CLASS_A,NULL,0,0,{0,0,1,1,1},1,0,NULL,0,{1,0}};
#else
#define     STRING_cfV(T,A,B,F) struct {unsigned int clen, flen;} B;
#define    STRINGV_cfV(T,A,B,F) struct {char *s, *fs; unsigned flen;} B;
#define    PSTRING_cfV(T,A,B,F) int     B;
#define   PSTRINGV_cfV(T,A,B,F) struct{char *fs; unsigned int sizeofA,flen;}B;
#endif
#define    ZTRINGV_cfV(T,A,B,F)  STRINGV_cfV(T,A,B,F)
#define   PZTRINGV_cfV(T,A,B,F) PSTRINGV_cfV(T,A,B,F)

/* Note that the actions of the A table were performed inside the AA table.
   VAX Ultrix vcc, and HP-UX cc, didn't evaluate arguments to functions left to
   right, so we had to split the original table into the current robust two. */
#define ACF(NAME,TN,AI,I)      _(TN,_cfSTR)(4,A,NAME,I,AI,_(B,I),0)
#define   DEFAULT_cfA(M,I,A,B)
#define   LOGICAL_cfA(M,I,A,B) B=C2FLOGICAL(B);
#define  PLOGICAL_cfA(M,I,A,B) A=C2FLOGICAL(A);
#define    STRING_cfA(M,I,A,B)  STRING_cfC(M,I,A,B,sizeof(A))
#define   PSTRING_cfA(M,I,A,B) PSTRING_cfC(M,I,A,B,sizeof(A))
#ifdef vmsFortran
#define  AATRINGV_cfA(    A,B, sA,filA,silA)                                   \\
 initfstr(B,_cf_malloc((sA)-(filA)),(filA),(silA)-1),                          \\
          c2fstrv(A,B.dsc$a_pointer,(silA),(sA));
#define APATRINGV_cfA(    A,B, sA,filA,silA)                                   \\
 initfstr(B,A,(filA),(silA)-1),c2fstrv(A,A,(silA),(sA));
#else
#define  AATRINGV_cfA(    A,B, sA,filA,silA)                                   \\
     (B.s=_cf_malloc((sA)-(filA)),B.fs=c2fstrv(A,B.s,(B.flen=(silA)-1)+1,(sA)));
#define APATRINGV_cfA(    A,B, sA,filA,silA)                                   \\
 B.fs=c2fstrv(A,A,(B.flen=(silA)-1)+1,B.sizeofA=(sA));
#endif
#define   STRINGV_cfA(M,I,A,B)                                                 \\
    AATRINGV_cfA((char *)A,B,sizeof(A),firstindexlength(A),secondindexlength(A))
#define  PSTRINGV_cfA(M,I,A,B)                                                 \\
   APATRINGV_cfA((char *)A,B,sizeof(A),firstindexlength(A),secondindexlength(A))
#define   ZTRINGV_cfA(M,I,A,B)  AATRINGV_cfA( (char *)A,B,                     \\
                    (_3(M,_ELEMS_,I))*(( _3(M,_ELEMLEN_,I))+1),                \\
                              (_3(M,_ELEMS_,I)),(_3(M,_ELEMLEN_,I))+1)
#define  PZTRINGV_cfA(M,I,A,B) APATRINGV_cfA( (char *)A,B,                     \\
                    (_3(M,_ELEMS_,I))*(( _3(M,_ELEMLEN_,I))+1),                \\
                              (_3(M,_ELEMS_,I)),(_3(M,_ELEMLEN_,I))+1)

#define    PBYTE_cfAAP(A,B) &A
#define  PDOUBLE_cfAAP(A,B) &A
#define   PFLOAT_cfAAP(A,B) FLOATVVVVVVV_cfPP &A
#define     PINT_cfAAP(A,B) &A
#define PLOGICAL_cfAAP(A,B) B= &A         /* B used to keep a common W table. */
#define    PLONG_cfAAP(A,B) &A
#define   PSHORT_cfAAP(A,B) &A

#define AACF(TN,AI,I,C) _SEP_(TN,C,cfCOMMA) _Icf(3,AA,TN,AI,_(B,I))
#define        INT_cfAA(T,A,B) &B
#define       INTV_cfAA(T,A,B) _(T,VVVVVV_cfPP) A
#define      INTVV_cfAA(T,A,B) _(T,VVVVV_cfPP)  A[0]
#define     INTVVV_cfAA(T,A,B) _(T,VVVV_cfPP)   A[0][0]
#define    INTVVVV_cfAA(T,A,B) _(T,VVV_cfPP)    A[0][0][0]
#define   INTVVVVV_cfAA(T,A,B) _(T,VV_cfPP)     A[0][0][0][0]
#define  INTVVVVVV_cfAA(T,A,B) _(T,V_cfPP)      A[0][0][0][0][0]
#define INTVVVVVVV_cfAA(T,A,B) _(T,_cfPP)       A[0][0][0][0][0][0]
#define       PINT_cfAA(T,A,B) _(T,_cfAAP)(A,B)
#define      PVOID_cfAA(T,A,B) (void *) A
#if defined(apolloFortran) || defined(hpuxFortran800) || defined(AbsoftUNIXFortran)
#define    ROUTINE_cfAA(T,A,B) &B
#else
#define    ROUTINE_cfAA(T,A,B) (cfCAST_FUNCTION)A
#endif
#define     STRING_cfAA(T,A,B)  STRING_cfCC(T,A,B)
#define    PSTRING_cfAA(T,A,B) PSTRING_cfCC(T,A,B)
#ifdef vmsFortran
#define    STRINGV_cfAA(T,A,B) &B
#else
#ifdef CRAYFortran
#define    STRINGV_cfAA(T,A,B) _cptofcd(B.fs,B.flen)
#else
#define    STRINGV_cfAA(T,A,B) B.fs
#endif
#endif
#define   PSTRINGV_cfAA(T,A,B) STRINGV_cfAA(T,A,B)
#define    ZTRINGV_cfAA(T,A,B) STRINGV_cfAA(T,A,B)
#define   PZTRINGV_cfAA(T,A,B) STRINGV_cfAA(T,A,B)

#if defined(vmsFortran) || defined(CRAYFortran)
#define JCF(TN,I)
#define KCF(TN,I)
#else
#define JCF(TN,I)    _(TN,_cfSTR)(1,J,_(B,I), 0,0,0,0)
#if defined(AbsoftUNIXFortran)
#define  DEFAULT_cfJ(B) ,0
#else
#define  DEFAULT_cfJ(B)
#endif
#define  LOGICAL_cfJ(B) DEFAULT_cfJ(B)
#define PLOGICAL_cfJ(B) DEFAULT_cfJ(B)
#define   STRING_cfJ(B) ,B.flen
#define  PSTRING_cfJ(B) ,B
#define  STRINGV_cfJ(B) STRING_cfJ(B)
#define PSTRINGV_cfJ(B) STRING_cfJ(B)
#define  ZTRINGV_cfJ(B) STRING_cfJ(B)
#define PZTRINGV_cfJ(B) STRING_cfJ(B)

/* KCF is identical to DCF, except that KCF ZTRING is not empty. */
#define KCF(TN,I)    _(TN,_cfSTR)(1,KK,_(B,I), 0,0,0,0)
#if defined(AbsoftUNIXFortran)
#define  DEFAULT_cfKK(B) , unsigned B
#else
#define  DEFAULT_cfKK(B)
#endif
#define  LOGICAL_cfKK(B) DEFAULT_cfKK(B)
#define PLOGICAL_cfKK(B) DEFAULT_cfKK(B)
#define   STRING_cfKK(B) , unsigned B
#define  PSTRING_cfKK(B) STRING_cfKK(B)
#define  STRINGV_cfKK(B) STRING_cfKK(B)
#define PSTRINGV_cfKK(B) STRING_cfKK(B)
#define  ZTRINGV_cfKK(B) STRING_cfKK(B)
#define PZTRINGV_cfKK(B) STRING_cfKK(B)
#endif

#define WCF(TN,AN,I)      _(TN,_cfSTR)(2,W,AN,_(B,I), 0,0,0)
#define  DEFAULT_cfW(A,B)
#define  LOGICAL_cfW(A,B)
#define PLOGICAL_cfW(A,B) *B=F2CLOGICAL(*B);
#define   STRING_cfW(A,B) (A[B.clen]!='\\0'?A[B.clen]='\\0':0); /* A?=\"constnt\"*/
#define  PSTRING_cfW(A,B) kill_trailing(A,' ');
#ifdef vmsFortran
#define  STRINGV_cfW(A,B) _cf_free(B.dsc$a_pointer);
#define PSTRINGV_cfW(A,B)                                                      \\
  vkill_trailing(f2cstrv((char*)A, (char*)A,                                   \\
                           B.dsc$w_length+1, B.dsc$l_arsize+B.dsc$l_m[0]),     \\
                   B.dsc$w_length+1, B.dsc$l_arsize+B.dsc$l_m[0], ' ');
#else
#define  STRINGV_cfW(A,B) _cf_free(B.s);
#define PSTRINGV_cfW(A,B) vkill_trailing(                                      \\
         f2cstrv((char*)A,(char*)A,B.flen+1,B.sizeofA), B.flen+1,B.sizeofA,' ');
#endif
#define  ZTRINGV_cfW(A,B)      STRINGV_cfW(A,B)
#define PZTRINGV_cfW(A,B)     PSTRINGV_cfW(A,B)

#define   NCF(TN,I,C)       _SEP_(TN,C,cfCOMMA) _Icf(2,N,TN,_(A,I),0) 
#define  NNCF(TN,I,C)        UUCF(TN,I,C)
#define NNNCF(TN,I,C)       _SEP_(TN,C,cfCOLON) _Icf(2,N,TN,_(A,I),0) 
#define        INT_cfN(T,A) _(T,VVVVVVV_cfTYPE) * A
#define       INTV_cfN(T,A) _(T,VVVVVV_cfTYPE)  * A
#define      INTVV_cfN(T,A) _(T,VVVVV_cfTYPE)   * A
#define     INTVVV_cfN(T,A) _(T,VVVV_cfTYPE)    * A
#define    INTVVVV_cfN(T,A) _(T,VVV_cfTYPE)     * A
#define   INTVVVVV_cfN(T,A) _(T,VV_cfTYPE)      * A
#define  INTVVVVVV_cfN(T,A) _(T,V_cfTYPE)       * A
#define INTVVVVVVV_cfN(T,A) _(T,_cfTYPE)        * A
#define       PINT_cfN(T,A) _(T,_cfTYPE)        * A
#define      PVOID_cfN(T,A) void *                A
#if defined(apolloFortran) || defined(hpuxFortran800) || defined(AbsoftUNIXFortran)
#define    ROUTINE_cfN(T,A) void (**A)(CF_NULL_PROTO)
#else
#define    ROUTINE_cfN(T,A) void ( *A)(CF_NULL_PROTO)
#endif
#ifdef vmsFortran
#define     STRING_cfN(T,A) fstring *             A
#define    STRINGV_cfN(T,A) fstringvector *       A
#else
#ifdef CRAYFortran
#define     STRING_cfN(T,A) _fcd                  A
#define    STRINGV_cfN(T,A) _fcd                  A
#else
#define     STRING_cfN(T,A) char *                A
#define    STRINGV_cfN(T,A) char *                A
#endif
#endif
#define    PSTRING_cfN(T,A)   STRING_cfN(T,A) /* CRAY insists on arg.'s here. */
#define   PNSTRING_cfN(T,A)   STRING_cfN(T,A) /* CRAY insists on arg.'s here. */
#define   PPSTRING_cfN(T,A)   STRING_cfN(T,A) /* CRAY insists on arg.'s here. */
#define   PSTRINGV_cfN(T,A)  STRINGV_cfN(T,A)
#define    ZTRINGV_cfN(T,A)  STRINGV_cfN(T,A)
#define   PZTRINGV_cfN(T,A) PSTRINGV_cfN(T,A)


/* Apollo 6.7, CRAY, old Sun, VAX/Ultrix vcc/cc and new ultrix
   can't hack more than 31 arg's.
   e.g. ultrix >= 4.3 gives message:
       zow35> cc -c -DDECFortran cfortest.c
       cfe: Fatal: Out of memory: cfortest.c
       zow35>
   Old __hpux had the problem, but new 'HP-UX A.09.03 A 9000/735' is fine
   if using -Aa, otherwise we have a problem.
 */
#ifndef MAX_PREPRO_ARGS
#if !defined(__GNUC__) && (defined(VAXUltrix) || defined(__CF__APOLLO67) || (defined(sun)&&!defined(__sun)) || defined(_CRAY) || defined(__ultrix__) || (defined(__hpux)&&defined(__CF__KnR)))
#define MAX_PREPRO_ARGS 31
#else
#define MAX_PREPRO_ARGS 99
#endif
#endif

#if defined(AbsoftUNIXFortran) || defined(AbsoftProFortran)
/* In addition to explicit Absoft stuff, only Absoft requires:
   - DEFAULT coming from _cfSTR.
     DEFAULT could have been called e.g. INT, but keep it for clarity.
   - M term in CFARGT14 and CFARGT14FS.
 */
#define ABSOFT_cf1(T0) _(T0,_cfSTR)(0,ABSOFT1,0,0,0,0,0)
#define ABSOFT_cf2(T0) _(T0,_cfSTR)(0,ABSOFT2,0,0,0,0,0)
#define ABSOFT_cf3(T0) _(T0,_cfSTR)(0,ABSOFT3,0,0,0,0,0)
#define DEFAULT_cfABSOFT1
#define LOGICAL_cfABSOFT1
#define  STRING_cfABSOFT1 ,MAX_LEN_FORTRAN_FUNCTION_STRING
#define DEFAULT_cfABSOFT2
#define LOGICAL_cfABSOFT2
#define  STRING_cfABSOFT2 ,unsigned D0
#define DEFAULT_cfABSOFT3
#define LOGICAL_cfABSOFT3
#define  STRING_cfABSOFT3 ,D0
#else
#define ABSOFT_cf1(T0)
#define ABSOFT_cf2(T0)
#define ABSOFT_cf3(T0)
#endif

/* _Z introduced to cicumvent IBM and HP silly preprocessor warning.
   e.g. \"Macro CFARGT14 invoked with a null argument.\"
 */
#define _Z

#define  CFARGT14S(S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)                \\
 S(T1,1)   S(T2,2)   S(T3,3)    S(T4,4)    S(T5,5)    S(T6,6)    S(T7,7)       \\
 S(T8,8)   S(T9,9)   S(TA,10)   S(TB,11)   S(TC,12)   S(TD,13)   S(TE,14)
#define  CFARGT27S(S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR) \\
 S(T1,1)   S(T2,2)   S(T3,3)    S(T4,4)    S(T5,5)    S(T6,6)    S(T7,7)       \\
 S(T8,8)   S(T9,9)   S(TA,10)   S(TB,11)   S(TC,12)   S(TD,13)   S(TE,14)      \\
 S(TF,15)  S(TG,16)  S(TH,17)   S(TI,18)   S(TJ,19)   S(TK,20)   S(TL,21)      \\
 S(TM,22)  S(TN,23)  S(TO,24)   S(TP,25)   S(TQ,26)   S(TR,27)

#define  CFARGT14FS(F,S,M,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)           \\
 F(T1,1,0) F(T2,2,1) F(T3,3,1)  F(T4,4,1)  F(T5,5,1)  F(T6,6,1)  F(T7,7,1)     \\
 F(T8,8,1) F(T9,9,1) F(TA,10,1) F(TB,11,1) F(TC,12,1) F(TD,13,1) F(TE,14,1)    \\
 M       CFARGT14S(S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)
#define  CFARGT27FS(F,S,M,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR) \\
 F(T1,1,0)  F(T2,2,1)  F(T3,3,1)  F(T4,4,1)  F(T5,5,1)  F(T6,6,1)  F(T7,7,1)   \\
 F(T8,8,1)  F(T9,9,1)  F(TA,10,1) F(TB,11,1) F(TC,12,1) F(TD,13,1) F(TE,14,1)  \\
 F(TF,15,1) F(TG,16,1) F(TH,17,1) F(TI,18,1) F(TJ,19,1) F(TK,20,1) F(TL,21,1)  \\
 F(TM,22,1) F(TN,23,1) F(TO,24,1) F(TP,25,1) F(TQ,26,1) F(TR,27,1)             \\
 M       CFARGT27S(S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)

#if !(defined(PowerStationFortran)||defined(hpuxFortran800))
/*  Old CFARGT14 -> CFARGT14FS as seen below, for Absoft cross-compile yields:
      SunOS> cc -c -Xa -DAbsoftUNIXFortran c.c
      \"c.c\", line 406: warning: argument mismatch
    Haven't checked if this is ANSI C or a SunOS bug. SunOS -Xs works ok.
    Behavior is most clearly seen in example:
      #define A 1 , 2
      #define  C(X,Y,Z) x=X. y=Y. z=Z.
      #define  D(X,Y,Z) C(X,Y,Z)
      D(x,A,z)
    Output from preprocessor is: x = x . y = 1 . z = 2 .
 #define CFARGT14(F,S,M,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE) \\
       CFARGT14FS(F,S,M,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)
*/
#define  CFARGT14(F,S,M,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)             \\
 F(T1,1,0) F(T2,2,1) F(T3,3,1)  F(T4,4,1)  F(T5,5,1)  F(T6,6,1)  F(T7,7,1)     \\
 F(T8,8,1) F(T9,9,1) F(TA,10,1) F(TB,11,1) F(TC,12,1) F(TD,13,1) F(TE,14,1)    \\
 M       CFARGT14S(S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)
#define  CFARGT27(F,S,M,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR) \\
 F(T1,1,0)  F(T2,2,1)  F(T3,3,1)  F(T4,4,1)  F(T5,5,1)  F(T6,6,1)  F(T7,7,1)   \\
 F(T8,8,1)  F(T9,9,1)  F(TA,10,1) F(TB,11,1) F(TC,12,1) F(TD,13,1) F(TE,14,1)  \\
 F(TF,15,1) F(TG,16,1) F(TH,17,1) F(TI,18,1) F(TJ,19,1) F(TK,20,1) F(TL,21,1)  \\
 F(TM,22,1) F(TN,23,1) F(TO,24,1) F(TP,25,1) F(TQ,26,1) F(TR,27,1)             \\
 M       CFARGT27S(S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)

#define  CFARGT20(F,S,M,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK) \\
 F(T1,1,0)  F(T2,2,1)  F(T3,3,1)  F(T4,4,1)  F(T5,5,1)  F(T6,6,1)  F(T7,7,1)   \\
 F(T8,8,1)  F(T9,9,1)  F(TA,10,1) F(TB,11,1) F(TC,12,1) F(TD,13,1) F(TE,14,1)  \\
 F(TF,15,1) F(TG,16,1) F(TH,17,1) F(TI,18,1) F(TJ,19,1) F(TK,20,1)             \\
 S(T1,1)    S(T2,2)    S(T3,3)    S(T4,4)    S(T5,5)    S(T6,6)    S(T7,7)     \\
 S(T8,8)    S(T9,9)    S(TA,10)   S(TB,11)   S(TC,12)   S(TD,13)   S(TE,14)    \\
 S(TF,15)   S(TG,16)   S(TH,17)   S(TI,18)   S(TJ,19)   S(TK,20)
#define CFARGTA14(F,S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE) \\
 F(T1,A1,1,0)  F(T2,A2,2,1)  F(T3,A3,3,1) F(T4,A4,4,1)  F(T5,A5,5,1)  F(T6,A6,6,1)  \\
 F(T7,A7,7,1)  F(T8,A8,8,1)  F(T9,A9,9,1) F(TA,AA,10,1) F(TB,AB,11,1) F(TC,AC,12,1) \\
 F(TD,AD,13,1) F(TE,AE,14,1) S(T1,1)      S(T2,2)       S(T3,3)       S(T4,4)       \\
 S(T5,5)       S(T6,6)       S(T7,7)      S(T8,8)       S(T9,9)       S(TA,10)      \\
 S(TB,11)      S(TC,12)      S(TD,13)     S(TE,14)
#if MAX_PREPRO_ARGS>31
#define CFARGTA20(F,S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK) \\
 F(T1,A1,1,0)  F(T2,A2,2,1)  F(T3,A3,3,1)  F(T4,A4,4,1)  F(T5,A5,5,1)  F(T6,A6,6,1)  \\
 F(T7,A7,7,1)  F(T8,A8,8,1)  F(T9,A9,9,1)  F(TA,AA,10,1) F(TB,AB,11,1) F(TC,AC,12,1) \\
 F(TD,AD,13,1) F(TE,AE,14,1) F(TF,AF,15,1) F(TG,AG,16,1) F(TH,AH,17,1) F(TI,AI,18,1) \\
 F(TJ,AJ,19,1) F(TK,AK,20,1) S(T1,1)       S(T2,2)       S(T3,3)       S(T4,4)       \\
 S(T5,5)       S(T6,6)       S(T7,7)       S(T8,8)       S(T9,9)       S(TA,10)      \\
 S(TB,11)      S(TC,12)      S(TD,13)      S(TE,14)      S(TF,15)      S(TG,16)      \\
 S(TH,17)      S(TI,18)      S(TJ,19)      S(TK,20)
#define CFARGTA27(F,S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,AP,AQ,AR) \\
 F(T1,A1,1,0)  F(T2,A2,2,1)  F(T3,A3,3,1)  F(T4,A4,4,1)  F(T5,A5,5,1)  F(T6,A6,6,1)  \\
 F(T7,A7,7,1)  F(T8,A8,8,1)  F(T9,A9,9,1)  F(TA,AA,10,1) F(TB,AB,11,1) F(TC,AC,12,1) \\
 F(TD,AD,13,1) F(TE,AE,14,1) F(TF,AF,15,1) F(TG,AG,16,1) F(TH,AH,17,1) F(TI,AI,18,1) \\
 F(TJ,AJ,19,1) F(TK,AK,20,1) F(TL,AL,21,1) F(TM,AM,22,1) F(TN,AN,23,1) F(TO,AO,24,1) \\
 F(TP,AP,25,1) F(TQ,AQ,26,1) F(TR,AR,27,1) S(T1,1)       S(T2,2)       S(T3,3)       \\
 S(T4,4)       S(T5,5)       S(T6,6)       S(T7,7)       S(T8,8)       S(T9,9)       \\
 S(TA,10)      S(TB,11)      S(TC,12)      S(TD,13)      S(TE,14)      S(TF,15)      \\
 S(TG,16)      S(TH,17)      S(TI,18)      S(TJ,19)      S(TK,20)      S(TL,21)      \\
 S(TM,22)      S(TN,23)      S(TO,24)      S(TP,25)      S(TQ,26)      S(TR,27)
#endif
#else
#define  CFARGT14(F,S,M,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)             \\
 F(T1,1,0) S(T1,1) F(T2,2,1)  S(T2,2)  F(T3,3,1)  S(T3,3)  F(T4,4,1)  S(T4,4)  \\
 F(T5,5,1) S(T5,5) F(T6,6,1)  S(T6,6)  F(T7,7,1)  S(T7,7)  F(T8,8,1)  S(T8,8)  \\
 F(T9,9,1) S(T9,9) F(TA,10,1) S(TA,10) F(TB,11,1) S(TB,11) F(TC,12,1) S(TC,12) \\
 F(TD,13,1) S(TD,13) F(TE,14,1) S(TE,14)
#define  CFARGT27(F,S,M,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR) \\
 F(T1,1,0)  S(T1,1)  F(T2,2,1)  S(T2,2)  F(T3,3,1)  S(T3,3)  F(T4,4,1)  S(T4,4)  \\
 F(T5,5,1)  S(T5,5)  F(T6,6,1)  S(T6,6)  F(T7,7,1)  S(T7,7)  F(T8,8,1)  S(T8,8)  \\
 F(T9,9,1)  S(T9,9)  F(TA,10,1) S(TA,10) F(TB,11,1) S(TB,11) F(TC,12,1) S(TC,12) \\
 F(TD,13,1) S(TD,13) F(TE,14,1) S(TE,14) F(TF,15,1) S(TF,15) F(TG,16,1) S(TG,16) \\
 F(TH,17,1) S(TH,17) F(TI,18,1) S(TI,18) F(TJ,19,1) S(TJ,19) F(TK,20,1) S(TK,20) \\
 F(TL,21,1) S(TL,21) F(TM,22,1) S(TM,22) F(TN,23,1) S(TN,23) F(TO,24,1) S(TO,24) \\
 F(TP,25,1) S(TP,25) F(TQ,26,1) S(TQ,26) F(TR,27,1) S(TR,27)

#define  CFARGT20(F,S,M,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK) \\
 F(T1,1,0)  S(T1,1)  F(T2,2,1)  S(T2,2)  F(T3,3,1)  S(T3,3)  F(T4,4,1)  S(T4,4)  \\
 F(T5,5,1)  S(T5,5)  F(T6,6,1)  S(T6,6)  F(T7,7,1)  S(T7,7)  F(T8,8,1)  S(T8,8)  \\
 F(T9,9,1)  S(T9,9)  F(TA,10,1) S(TA,10) F(TB,11,1) S(TB,11) F(TC,12,1) S(TC,12) \\
 F(TD,13,1) S(TD,13) F(TE,14,1) S(TE,14) F(TF,15,1) S(TF,15) F(TG,16,1) S(TG,16) \\
 F(TH,17,1) S(TH,17) F(TI,18,1) S(TI,18) F(TJ,19,1) S(TJ,19) F(TK,20,1) S(TK,20)
#define CFARGTA14(F,S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE) \\
 F(T1,A1,1,0)  S(T1,1)  F(T2,A2,2,1)  S(T2,2)  F(T3,A3,3,1)  S(T3,3)           \\
 F(T4,A4,4,1)  S(T4,4)  F(T5,A5,5,1)  S(T5,5)  F(T6,A6,6,1)  S(T6,6)           \\
 F(T7,A7,7,1)  S(T7,7)  F(T8,A8,8,1)  S(T8,8)  F(T9,A9,9,1)  S(T9,9)           \\
 F(TA,AA,10,1) S(TA,10) F(TB,AB,11,1) S(TB,11) F(TC,AC,12,1) S(TC,12)          \\
 F(TD,AD,13,1) S(TD,13) F(TE,AE,14,1) S(TE,14)
#if MAX_PREPRO_ARGS>31
#define CFARGTA20(F,S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK) \\
 F(T1,A1,1,0)  S(T1,1)  F(T2,A2,2,1)  S(T2,2)  F(T3,A3,3,1)  S(T3,3)           \\
 F(T4,A4,4,1)  S(T4,4)  F(T5,A5,5,1)  S(T5,5)  F(T6,A6,6,1)  S(T6,6)           \\
 F(T7,A7,7,1)  S(T7,7)  F(T8,A8,8,1)  S(T8,8)  F(T9,A9,9,1)  S(T9,9)           \\
 F(TA,AA,10,1) S(TA,10) F(TB,AB,11,1) S(TB,11) F(TC,AC,12,1) S(TC,12)          \\
 F(TD,AD,13,1) S(TD,13) F(TE,AE,14,1) S(TE,14) F(TF,AF,15,1) S(TF,15)          \\
 F(TG,AG,16,1) S(TG,16) F(TH,AH,17,1) S(TH,17) F(TI,AI,18,1) S(TI,18)          \\
 F(TJ,AJ,19,1) S(TJ,19) F(TK,AK,20,1) S(TK,20)                
#define CFARGTA27(F,S,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,AP,AQ,AR) \\
 F(T1,A1,1,0)  S(T1,1)  F(T2,A2,2,1)  S(T2,2)  F(T3,A3,3,1)  S(T3,3)           \\
 F(T4,A4,4,1)  S(T4,4)  F(T5,A5,5,1)  S(T5,5)  F(T6,A6,6,1)  S(T6,6)           \\
 F(T7,A7,7,1)  S(T7,7)  F(T8,A8,8,1)  S(T8,8)  F(T9,A9,9,1)  S(T9,9)           \\
 F(TA,AA,10,1) S(TA,10) F(TB,AB,11,1) S(TB,11) F(TC,AC,12,1) S(TC,12)          \\
 F(TD,AD,13,1) S(TD,13) F(TE,AE,14,1) S(TE,14) F(TF,AF,15,1) S(TF,15)          \\
 F(TG,AG,16,1) S(TG,16) F(TH,AH,17,1) S(TH,17) F(TI,AI,18,1) S(TI,18)          \\
 F(TJ,AJ,19,1) S(TJ,19) F(TK,AK,20,1) S(TK,20) F(TL,AL,21,1) S(TL,21)          \\
 F(TM,AM,22,1) S(TM,22) F(TN,AN,23,1) S(TN,23) F(TO,AO,24,1) S(TO,24)          \\
 F(TP,AP,25,1) S(TP,25) F(TQ,AQ,26,1) S(TQ,26) F(TR,AR,27,1) S(TR,27)
#endif
#endif


#define PROTOCCALLSFSUB1( UN,LN,T1) \\
        PROTOCCALLSFSUB14(UN,LN,T1,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB2( UN,LN,T1,T2) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB3( UN,LN,T1,T2,T3) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB4( UN,LN,T1,T2,T3,T4) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB5( UN,LN,T1,T2,T3,T4,T5) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB6( UN,LN,T1,T2,T3,T4,T5,T6) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB7( UN,LN,T1,T2,T3,T4,T5,T6,T7) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB8( UN,LN,T1,T2,T3,T4,T5,T6,T7,T8) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB9( UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB10(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB11(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB12(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,CF_0,CF_0)
#define PROTOCCALLSFSUB13(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD) \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,CF_0)


#define PROTOCCALLSFSUB15(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF) \\
        PROTOCCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB16(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG) \\
        PROTOCCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB17(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH) \\
        PROTOCCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB18(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI) \\
        PROTOCCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,CF_0,CF_0)
#define PROTOCCALLSFSUB19(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ) \\
        PROTOCCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,CF_0)

#define PROTOCCALLSFSUB21(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL) \\
        PROTOCCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB22(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM) \\
        PROTOCCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB23(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN) \\
        PROTOCCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB24(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO) \\
        PROTOCCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,CF_0,CF_0,CF_0)
#define PROTOCCALLSFSUB25(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP) \\
        PROTOCCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,CF_0,CF_0)
#define PROTOCCALLSFSUB26(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ) \\
        PROTOCCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,CF_0)


#ifndef FCALLSC_QUALIFIER
#ifdef VISUAL_CPLUSPLUS
#define FCALLSC_QUALIFIER __stdcall
#else
#define FCALLSC_QUALIFIER
#endif
#endif

#ifdef __cplusplus
#define CFextern extern \"C\"
#else
#define CFextern extern
#endif


#ifdef CFSUBASFUN
#define PROTOCCALLSFSUB0(UN,LN) \\
   PROTOCCALLSFFUN0( VOID,UN,LN)
#define PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE) \\
   PROTOCCALLSFFUN14(VOID,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)
#define PROTOCCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK)\\
   PROTOCCALLSFFUN20(VOID,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK)
#define PROTOCCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)\\
   PROTOCCALLSFFUN27(VOID,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)
#else
/* Note: Prevent compiler warnings, null #define PROTOCCALLSFSUB14/20 after 
   #include-ing cfortran.h if calling the FORTRAN wrapper within the same 
   source code where the wrapper is created. */
#define PROTOCCALLSFSUB0(UN,LN)     _(VOID,_cfPU)(CFC_(UN,LN))();
#ifndef __CF__KnR
#define PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE) \\
 _(VOID,_cfPU)(CFC_(UN,LN))( CFARGT14(NCF,KCF,_Z,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE) );
#define PROTOCCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK)\\
 _(VOID,_cfPU)(CFC_(UN,LN))( CFARGT20(NCF,KCF,_Z,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK) );
#define PROTOCCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)\\
 _(VOID,_cfPU)(CFC_(UN,LN))( CFARGT27(NCF,KCF,_Z,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR) );
#else
#define PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)     \\
         PROTOCCALLSFSUB0(UN,LN)
#define PROTOCCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK) \\
         PROTOCCALLSFSUB0(UN,LN)
#define PROTOCCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR) \\
         PROTOCCALLSFSUB0(UN,LN)
#endif
#endif


#ifdef OLD_VAXC                                  /* Allow %CC-I-PARAMNOTUSED. */
#pragma standard
#endif


#define CCALLSFSUB1( UN,LN,T1,                        A1)         \\
        CCALLSFSUB5 (UN,LN,T1,CF_0,CF_0,CF_0,CF_0,A1,0,0,0,0)
#define CCALLSFSUB2( UN,LN,T1,T2,                     A1,A2)      \\
        CCALLSFSUB5 (UN,LN,T1,T2,CF_0,CF_0,CF_0,A1,A2,0,0,0)
#define CCALLSFSUB3( UN,LN,T1,T2,T3,                  A1,A2,A3)   \\
        CCALLSFSUB5 (UN,LN,T1,T2,T3,CF_0,CF_0,A1,A2,A3,0,0)
#define CCALLSFSUB4( UN,LN,T1,T2,T3,T4,               A1,A2,A3,A4)\\
        CCALLSFSUB5 (UN,LN,T1,T2,T3,T4,CF_0,A1,A2,A3,A4,0)
#define CCALLSFSUB5( UN,LN,T1,T2,T3,T4,T5,            A1,A2,A3,A4,A5)          \\
        CCALLSFSUB10(UN,LN,T1,T2,T3,T4,T5,CF_0,CF_0,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,0,0,0,0,0)
#define CCALLSFSUB6( UN,LN,T1,T2,T3,T4,T5,T6,         A1,A2,A3,A4,A5,A6)       \\
        CCALLSFSUB10(UN,LN,T1,T2,T3,T4,T5,T6,CF_0,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,0,0,0,0)
#define CCALLSFSUB7( UN,LN,T1,T2,T3,T4,T5,T6,T7,      A1,A2,A3,A4,A5,A6,A7)    \\
        CCALLSFSUB10(UN,LN,T1,T2,T3,T4,T5,T6,T7,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,0,0,0)
#define CCALLSFSUB8( UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,   A1,A2,A3,A4,A5,A6,A7,A8) \\
        CCALLSFSUB10(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,0,0)
#define CCALLSFSUB9( UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,A1,A2,A3,A4,A5,A6,A7,A8,A9)\\
        CCALLSFSUB10(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,0)
#define CCALLSFSUB10(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA)\\
        CCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,CF_0,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,0,0,0,0)
#define CCALLSFSUB11(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB)\\
        CCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,0,0,0)
#define CCALLSFSUB12(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC)\\
        CCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,0,0)
#define CCALLSFSUB13(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD)\\
        CCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,0)

#ifdef __cplusplus
#define CPPPROTOCLSFSUB0( UN,LN)
#define CPPPROTOCLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)
#define CPPPROTOCLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK)
#define CPPPROTOCLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)
#else
#define CPPPROTOCLSFSUB0(UN,LN) \\
        PROTOCCALLSFSUB0(UN,LN)
#define CPPPROTOCLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)     \\
        PROTOCCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)
#define CPPPROTOCLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK) \\
        PROTOCCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK)
#define CPPPROTOCLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR) \\
        PROTOCCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)
#endif

#ifdef CFSUBASFUN
#define CCALLSFSUB0(UN,LN) CCALLSFFUN0(UN,LN)
#define CCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE)\\
        CCALLSFFUN14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE)
#else
/* do{...}while(0) allows if(a==b) FORT(); else BORT(); */
#define CCALLSFSUB0( UN,LN) do{CPPPROTOCLSFSUB0(UN,LN) CFC_(UN,LN)();}while(0)
#define CCALLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE)\\
do{VVCF(T1,A1,B1) VVCF(T2,A2,B2) VVCF(T3,A3,B3) VVCF(T4,A4,B4) VVCF(T5,A5,B5)  \\
   VVCF(T6,A6,B6) VVCF(T7,A7,B7) VVCF(T8,A8,B8) VVCF(T9,A9,B9) VVCF(TA,AA,B10) \\
   VVCF(TB,AB,B11) VVCF(TC,AC,B12) VVCF(TD,AD,B13) VVCF(TE,AE,B14)             \\
   CPPPROTOCLSFSUB14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)          \\
   ACF(LN,T1,A1,1)  ACF(LN,T2,A2,2)  ACF(LN,T3,A3,3)                           \\
   ACF(LN,T4,A4,4)  ACF(LN,T5,A5,5)  ACF(LN,T6,A6,6)  ACF(LN,T7,A7,7)          \\
   ACF(LN,T8,A8,8)  ACF(LN,T9,A9,9)  ACF(LN,TA,AA,10) ACF(LN,TB,AB,11)         \\
   ACF(LN,TC,AC,12) ACF(LN,TD,AD,13) ACF(LN,TE,AE,14)                          \\
   CFC_(UN,LN)( CFARGTA14(AACF,JCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE) );\\
   WCF(T1,A1,1)  WCF(T2,A2,2)  WCF(T3,A3,3)  WCF(T4,A4,4)  WCF(T5,A5,5)        \\
   WCF(T6,A6,6)  WCF(T7,A7,7)  WCF(T8,A8,8)  WCF(T9,A9,9)  WCF(TA,AA,10)       \\
   WCF(TB,AB,11) WCF(TC,AC,12) WCF(TD,AD,13) WCF(TE,AE,14)      }while(0)
#endif


#if MAX_PREPRO_ARGS>31
#define CCALLSFSUB15(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF)\\
        CCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,CF_0,CF_0,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,0,0,0,0,0)
#define CCALLSFSUB16(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG)\\
        CCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,CF_0,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,0,0,0,0)
#define CCALLSFSUB17(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH)\\
        CCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,0,0,0)
#define CCALLSFSUB18(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI)\\
        CCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,0,0)
#define CCALLSFSUB19(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ)\\
        CCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,0)

#ifdef CFSUBASFUN
#define CCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH, \\
        TI,TJ,TK, A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK) \\
        CCALLSFFUN20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH, \\
        TI,TJ,TK, A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK)
#else
#define CCALLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH, \\
        TI,TJ,TK, A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK) \\
do{VVCF(T1,A1,B1)  VVCF(T2,A2,B2)  VVCF(T3,A3,B3)  VVCF(T4,A4,B4)  VVCF(T5,A5,B5)   \\
   VVCF(T6,A6,B6)  VVCF(T7,A7,B7)  VVCF(T8,A8,B8)  VVCF(T9,A9,B9)  VVCF(TA,AA,B10)  \\
   VVCF(TB,AB,B11) VVCF(TC,AC,B12) VVCF(TD,AD,B13) VVCF(TE,AE,B14) VVCF(TF,AF,B15)  \\
   VVCF(TG,AG,B16) VVCF(TH,AH,B17) VVCF(TI,AI,B18) VVCF(TJ,AJ,B19) VVCF(TK,AK,B20)  \\
   CPPPROTOCLSFSUB20(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK)  \\
   ACF(LN,T1,A1,1)  ACF(LN,T2,A2,2)  ACF(LN,T3,A3,3)  ACF(LN,T4,A4,4)          \\
   ACF(LN,T5,A5,5)  ACF(LN,T6,A6,6)  ACF(LN,T7,A7,7)  ACF(LN,T8,A8,8)          \\
   ACF(LN,T9,A9,9)  ACF(LN,TA,AA,10) ACF(LN,TB,AB,11) ACF(LN,TC,AC,12)         \\
   ACF(LN,TD,AD,13) ACF(LN,TE,AE,14) ACF(LN,TF,AF,15) ACF(LN,TG,AG,16)         \\
   ACF(LN,TH,AH,17) ACF(LN,TI,AI,18) ACF(LN,TJ,AJ,19) ACF(LN,TK,AK,20)         \\
   CFC_(UN,LN)( CFARGTA20(AACF,JCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK) ); \\
 WCF(T1,A1,1)  WCF(T2,A2,2)  WCF(T3,A3,3)  WCF(T4,A4,4)  WCF(T5,A5,5)  WCF(T6,A6,6)  \\
 WCF(T7,A7,7)  WCF(T8,A8,8)  WCF(T9,A9,9)  WCF(TA,AA,10) WCF(TB,AB,11) WCF(TC,AC,12) \\
 WCF(TD,AD,13) WCF(TE,AE,14) WCF(TF,AF,15) WCF(TG,AG,16) WCF(TH,AH,17) WCF(TI,AI,18) \\
 WCF(TJ,AJ,19) WCF(TK,AK,20) }while(0)
#endif
#endif         /* MAX_PREPRO_ARGS */

#if MAX_PREPRO_ARGS>31
#define CCALLSFSUB21(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL)\\
        CCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,0,0,0,0,0,0)
#define CCALLSFSUB22(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM)\\
        CCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,CF_0,CF_0,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,0,0,0,0,0)
#define CCALLSFSUB23(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN)\\
        CCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,CF_0,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,0,0,0,0)
#define CCALLSFSUB24(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO)\\
        CCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,0,0,0)
#define CCALLSFSUB25(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,AP)\\
        CCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,AP,0,0)
#define CCALLSFSUB26(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,AP,AQ)\\
        CCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,AP,AQ,0)

#ifdef CFSUBASFUN
#define CCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR, \\
                           A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,AP,AQ,AR) \\
        CCALLSFFUN27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR, \\
                           A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,AP,AQ,AR)
#else
#define CCALLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR, \\
                           A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,AP,AQ,AR) \\
do{VVCF(T1,A1,B1)  VVCF(T2,A2,B2)  VVCF(T3,A3,B3)  VVCF(T4,A4,B4)  VVCF(T5,A5,B5)   \\
   VVCF(T6,A6,B6)  VVCF(T7,A7,B7)  VVCF(T8,A8,B8)  VVCF(T9,A9,B9)  VVCF(TA,AA,B10)  \\
   VVCF(TB,AB,B11) VVCF(TC,AC,B12) VVCF(TD,AD,B13) VVCF(TE,AE,B14) VVCF(TF,AF,B15)  \\
   VVCF(TG,AG,B16) VVCF(TH,AH,B17) VVCF(TI,AI,B18) VVCF(TJ,AJ,B19) VVCF(TK,AK,B20)  \\
   VVCF(TL,AL,B21) VVCF(TM,AM,B22) VVCF(TN,AN,B23) VVCF(TO,AO,B24) VVCF(TP,AP,B25)  \\
   VVCF(TQ,AQ,B26) VVCF(TR,AR,B27)                                                  \\
   CPPPROTOCLSFSUB27(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR) \\
   ACF(LN,T1,A1,1)  ACF(LN,T2,A2,2)  ACF(LN,T3,A3,3)  ACF(LN,T4,A4,4)          \\
   ACF(LN,T5,A5,5)  ACF(LN,T6,A6,6)  ACF(LN,T7,A7,7)  ACF(LN,T8,A8,8)          \\
   ACF(LN,T9,A9,9)  ACF(LN,TA,AA,10) ACF(LN,TB,AB,11) ACF(LN,TC,AC,12)         \\
   ACF(LN,TD,AD,13) ACF(LN,TE,AE,14) ACF(LN,TF,AF,15) ACF(LN,TG,AG,16)         \\
   ACF(LN,TH,AH,17) ACF(LN,TI,AI,18) ACF(LN,TJ,AJ,19) ACF(LN,TK,AK,20)         \\
   ACF(LN,TL,AL,21) ACF(LN,TM,AM,22) ACF(LN,TN,AN,23) ACF(LN,TO,AO,24)         \\
   ACF(LN,TP,AP,25) ACF(LN,TQ,AQ,26) ACF(LN,TR,AR,27)                          \\
   CFC_(UN,LN)( CFARGTA27(AACF,JCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR,\\
                                   A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF,AG,AH,AI,AJ,AK,AL,AM,AN,AO,AP,AQ,AR) ); \\
 WCF(T1,A1,1)  WCF(T2,A2,2)  WCF(T3,A3,3)  WCF(T4,A4,4)  WCF(T5,A5,5)  WCF(T6,A6,6)  \\
 WCF(T7,A7,7)  WCF(T8,A8,8)  WCF(T9,A9,9)  WCF(TA,AA,10) WCF(TB,AB,11) WCF(TC,AC,12) \\
 WCF(TD,AD,13) WCF(TE,AE,14) WCF(TF,AF,15) WCF(TG,AG,16) WCF(TH,AH,17) WCF(TI,AI,18) \\
 WCF(TJ,AJ,19) WCF(TK,AK,20) WCF(TL,AL,21) WCF(TM,AM,22) WCF(TN,AN,23) WCF(TO,AO,24) \\
 WCF(TP,AP,25) WCF(TQ,AQ,26) WCF(TR,AR,27) }while(0)
#endif
#endif         /* MAX_PREPRO_ARGS */

/*-------------------------------------------------------------------------*/

/*               UTILITIES FOR C TO CALL FORTRAN FUNCTIONS                 */

/*N.B. PROTOCCALLSFFUNn(..) generates code, whether or not the FORTRAN
  function is called. Therefore, especially for creator's of C header files
  for large FORTRAN libraries which include many functions, to reduce
  compile time and object code size, it may be desirable to create
  preprocessor directives to allow users to create code for only those
  functions which they use.                                                */

/* The following defines the maximum length string that a function can return.
   Of course it may be undefine-d and re-define-d before individual
   PROTOCCALLSFFUNn(..) as required. It would also be nice to have this derived
   from the individual machines' limits.                                      */
#define MAX_LEN_FORTRAN_FUNCTION_STRING 0x4FE

/* The following defines a character used by CFORTRAN.H to flag the end of a
   string coming out of a FORTRAN routine.                                 */
#define CFORTRAN_NON_CHAR 0x7F

#ifdef OLD_VAXC                                /* Prevent %CC-I-PARAMNOTUSED. */
#pragma nostandard
#endif

#define _SEP_(TN,C,cfCOMMA)     _(__SEP_,C)(TN,cfCOMMA)
#define __SEP_0(TN,cfCOMMA)  
#define __SEP_1(TN,cfCOMMA)     _Icf(2,SEP,TN,cfCOMMA,0)
#define        INT_cfSEP(T,B) _(A,B)
#define       INTV_cfSEP(T,B) INT_cfSEP(T,B)
#define      INTVV_cfSEP(T,B) INT_cfSEP(T,B)
#define     INTVVV_cfSEP(T,B) INT_cfSEP(T,B)
#define    INTVVVV_cfSEP(T,B) INT_cfSEP(T,B)
#define   INTVVVVV_cfSEP(T,B) INT_cfSEP(T,B)
#define  INTVVVVVV_cfSEP(T,B) INT_cfSEP(T,B)
#define INTVVVVVVV_cfSEP(T,B) INT_cfSEP(T,B)
#define       PINT_cfSEP(T,B) INT_cfSEP(T,B)
#define      PVOID_cfSEP(T,B) INT_cfSEP(T,B)
#define    ROUTINE_cfSEP(T,B) INT_cfSEP(T,B)
#define     SIMPLE_cfSEP(T,B) INT_cfSEP(T,B)
#define       VOID_cfSEP(T,B) INT_cfSEP(T,B)    /* For FORTRAN calls C subr.s.*/
#define     STRING_cfSEP(T,B) INT_cfSEP(T,B)
#define    STRINGV_cfSEP(T,B) INT_cfSEP(T,B)
#define    PSTRING_cfSEP(T,B) INT_cfSEP(T,B)
#define   PSTRINGV_cfSEP(T,B) INT_cfSEP(T,B)
#define   PNSTRING_cfSEP(T,B) INT_cfSEP(T,B)
#define   PPSTRING_cfSEP(T,B) INT_cfSEP(T,B)
#define    ZTRINGV_cfSEP(T,B) INT_cfSEP(T,B)
#define   PZTRINGV_cfSEP(T,B) INT_cfSEP(T,B)
                         
#if defined(SIGNED_BYTE) || !defined(UNSIGNED_BYTE)
#ifdef OLD_VAXC
#define INTEGER_BYTE               char    /* Old VAXC barfs on 'signed char' */
#else
#define INTEGER_BYTE        signed char    /* default */
#endif
#else
#define INTEGER_BYTE        unsigned char
#endif
#define    BYTEVVVVVVV_cfTYPE INTEGER_BYTE
#define  DOUBLEVVVVVVV_cfTYPE DOUBLE_PRECISION 
#define   FLOATVVVVVVV_cfTYPE FORTRAN_REAL
#define     INTVVVVVVV_cfTYPE int
#define LOGICALVVVVVVV_cfTYPE int
#define    LONGVVVVVVV_cfTYPE long
#define   SHORTVVVVVVV_cfTYPE short
#define          PBYTE_cfTYPE INTEGER_BYTE
#define        PDOUBLE_cfTYPE DOUBLE_PRECISION 
#define         PFLOAT_cfTYPE FORTRAN_REAL
#define           PINT_cfTYPE int
#define       PLOGICAL_cfTYPE int
#define          PLONG_cfTYPE long
#define         PSHORT_cfTYPE short

#define CFARGS0(A,T,V,W,X,Y,Z) _3(T,_cf,A)
#define CFARGS1(A,T,V,W,X,Y,Z) _3(T,_cf,A)(V)
#define CFARGS2(A,T,V,W,X,Y,Z) _3(T,_cf,A)(V,W)
#define CFARGS3(A,T,V,W,X,Y,Z) _3(T,_cf,A)(V,W,X)
#define CFARGS4(A,T,V,W,X,Y,Z) _3(T,_cf,A)(V,W,X,Y)
#define CFARGS5(A,T,V,W,X,Y,Z) _3(T,_cf,A)(V,W,X,Y,Z)

#define  _Icf(N,T,I,X,Y)                 _(I,_cfINT)(N,T,I,X,Y,0)
#define _Icf4(N,T,I,X,Y,Z)               _(I,_cfINT)(N,T,I,X,Y,Z)
#define           BYTE_cfINT(N,A,B,X,Y,Z)        DOUBLE_cfINT(N,A,B,X,Y,Z)
#define         DOUBLE_cfINT(N,A,B,X,Y,Z) _(CFARGS,N)(A,INT,B,X,Y,Z,0)
#define          FLOAT_cfINT(N,A,B,X,Y,Z)        DOUBLE_cfINT(N,A,B,X,Y,Z)
#define            INT_cfINT(N,A,B,X,Y,Z)        DOUBLE_cfINT(N,A,B,X,Y,Z)
#define        LOGICAL_cfINT(N,A,B,X,Y,Z)        DOUBLE_cfINT(N,A,B,X,Y,Z)
#define           LONG_cfINT(N,A,B,X,Y,Z)        DOUBLE_cfINT(N,A,B,X,Y,Z)
#define          SHORT_cfINT(N,A,B,X,Y,Z)        DOUBLE_cfINT(N,A,B,X,Y,Z)
#define          PBYTE_cfINT(N,A,B,X,Y,Z)       PDOUBLE_cfINT(N,A,B,X,Y,Z)
#define        PDOUBLE_cfINT(N,A,B,X,Y,Z) _(CFARGS,N)(A,PINT,B,X,Y,Z,0)
#define         PFLOAT_cfINT(N,A,B,X,Y,Z)       PDOUBLE_cfINT(N,A,B,X,Y,Z)
#define           PINT_cfINT(N,A,B,X,Y,Z)       PDOUBLE_cfINT(N,A,B,X,Y,Z)
#define       PLOGICAL_cfINT(N,A,B,X,Y,Z)       PDOUBLE_cfINT(N,A,B,X,Y,Z)
#define          PLONG_cfINT(N,A,B,X,Y,Z)       PDOUBLE_cfINT(N,A,B,X,Y,Z)
#define         PSHORT_cfINT(N,A,B,X,Y,Z)       PDOUBLE_cfINT(N,A,B,X,Y,Z)
#define          BYTEV_cfINT(N,A,B,X,Y,Z)       DOUBLEV_cfINT(N,A,B,X,Y,Z)
#define         BYTEVV_cfINT(N,A,B,X,Y,Z)      DOUBLEVV_cfINT(N,A,B,X,Y,Z)
#define        BYTEVVV_cfINT(N,A,B,X,Y,Z)     DOUBLEVVV_cfINT(N,A,B,X,Y,Z)
#define       BYTEVVVV_cfINT(N,A,B,X,Y,Z)    DOUBLEVVVV_cfINT(N,A,B,X,Y,Z)
#define      BYTEVVVVV_cfINT(N,A,B,X,Y,Z)   DOUBLEVVVVV_cfINT(N,A,B,X,Y,Z)
#define     BYTEVVVVVV_cfINT(N,A,B,X,Y,Z)  DOUBLEVVVVVV_cfINT(N,A,B,X,Y,Z)
#define    BYTEVVVVVVV_cfINT(N,A,B,X,Y,Z) DOUBLEVVVVVVV_cfINT(N,A,B,X,Y,Z)
#define        DOUBLEV_cfINT(N,A,B,X,Y,Z) _(CFARGS,N)(A,INTV,B,X,Y,Z,0)
#define       DOUBLEVV_cfINT(N,A,B,X,Y,Z) _(CFARGS,N)(A,INTVV,B,X,Y,Z,0)
#define      DOUBLEVVV_cfINT(N,A,B,X,Y,Z) _(CFARGS,N)(A,INTVVV,B,X,Y,Z,0)
#define     DOUBLEVVVV_cfINT(N,A,B,X,Y,Z) _(CFARGS,N)(A,INTVVVV,B,X,Y,Z,0)
#define    DOUBLEVVVVV_cfINT(N,A,B,X,Y,Z) _(CFARGS,N)(A,INTVVVVV,B,X,Y,Z,0)
#define   DOUBLEVVVVVV_cfINT(N,A,B,X,Y,Z) _(CFARGS,N)(A,INTVVVVVV,B,X,Y,Z,0)
#define  DOUBLEVVVVVVV_cfINT(N,A,B,X,Y,Z) _(CFARGS,N)(A,INTVVVVVVV,B,X,Y,Z,0)
#define         FLOATV_cfINT(N,A,B,X,Y,Z)       DOUBLEV_cfINT(N,A,B,X,Y,Z)
#define        FLOATVV_cfINT(N,A,B,X,Y,Z)      DOUBLEVV_cfINT(N,A,B,X,Y,Z)
#define       FLOATVVV_cfINT(N,A,B,X,Y,Z)     DOUBLEVVV_cfINT(N,A,B,X,Y,Z)
#define      FLOATVVVV_cfINT(N,A,B,X,Y,Z)    DOUBLEVVVV_cfINT(N,A,B,X,Y,Z)
#define     FLOATVVVVV_cfINT(N,A,B,X,Y,Z)   DOUBLEVVVVV_cfINT(N,A,B,X,Y,Z)
#define    FLOATVVVVVV_cfINT(N,A,B,X,Y,Z)  DOUBLEVVVVVV_cfINT(N,A,B,X,Y,Z)
#define   FLOATVVVVVVV_cfINT(N,A,B,X,Y,Z) DOUBLEVVVVVVV_cfINT(N,A,B,X,Y,Z)
#define           INTV_cfINT(N,A,B,X,Y,Z)       DOUBLEV_cfINT(N,A,B,X,Y,Z)
#define          INTVV_cfINT(N,A,B,X,Y,Z)      DOUBLEVV_cfINT(N,A,B,X,Y,Z)
#define         INTVVV_cfINT(N,A,B,X,Y,Z)     DOUBLEVVV_cfINT(N,A,B,X,Y,Z)
#define        INTVVVV_cfINT(N,A,B,X,Y,Z)    DOUBLEVVVV_cfINT(N,A,B,X,Y,Z)
#define       INTVVVVV_cfINT(N,A,B,X,Y,Z)   DOUBLEVVVVV_cfINT(N,A,B,X,Y,Z)
#define      INTVVVVVV_cfINT(N,A,B,X,Y,Z)  DOUBLEVVVVVV_cfINT(N,A,B,X,Y,Z)
#define     INTVVVVVVV_cfINT(N,A,B,X,Y,Z) DOUBLEVVVVVVV_cfINT(N,A,B,X,Y,Z)
#define       LOGICALV_cfINT(N,A,B,X,Y,Z)       DOUBLEV_cfINT(N,A,B,X,Y,Z)
#define      LOGICALVV_cfINT(N,A,B,X,Y,Z)      DOUBLEVV_cfINT(N,A,B,X,Y,Z)
#define     LOGICALVVV_cfINT(N,A,B,X,Y,Z)     DOUBLEVVV_cfINT(N,A,B,X,Y,Z)
#define    LOGICALVVVV_cfINT(N,A,B,X,Y,Z)    DOUBLEVVVV_cfINT(N,A,B,X,Y,Z)
#define   LOGICALVVVVV_cfINT(N,A,B,X,Y,Z)   DOUBLEVVVVV_cfINT(N,A,B,X,Y,Z)
#define  LOGICALVVVVVV_cfINT(N,A,B,X,Y,Z)  DOUBLEVVVVVV_cfINT(N,A,B,X,Y,Z)
#define LOGICALVVVVVVV_cfINT(N,A,B,X,Y,Z) DOUBLEVVVVVVV_cfINT(N,A,B,X,Y,Z)
#define          LONGV_cfINT(N,A,B,X,Y,Z)       DOUBLEV_cfINT(N,A,B,X,Y,Z)
#define         LONGVV_cfINT(N,A,B,X,Y,Z)      DOUBLEVV_cfINT(N,A,B,X,Y,Z)
#define        LONGVVV_cfINT(N,A,B,X,Y,Z)     DOUBLEVVV_cfINT(N,A,B,X,Y,Z)
#define       LONGVVVV_cfINT(N,A,B,X,Y,Z)    DOUBLEVVVV_cfINT(N,A,B,X,Y,Z)
#define      LONGVVVVV_cfINT(N,A,B,X,Y,Z)   DOUBLEVVVVV_cfINT(N,A,B,X,Y,Z)
#define     LONGVVVVVV_cfINT(N,A,B,X,Y,Z)  DOUBLEVVVVVV_cfINT(N,A,B,X,Y,Z)
#define    LONGVVVVVVV_cfINT(N,A,B,X,Y,Z) DOUBLEVVVVVVV_cfINT(N,A,B,X,Y,Z)
#define         SHORTV_cfINT(N,A,B,X,Y,Z)       DOUBLEV_cfINT(N,A,B,X,Y,Z)
#define        SHORTVV_cfINT(N,A,B,X,Y,Z)      DOUBLEVV_cfINT(N,A,B,X,Y,Z)
#define       SHORTVVV_cfINT(N,A,B,X,Y,Z)     DOUBLEVVV_cfINT(N,A,B,X,Y,Z)
#define      SHORTVVVV_cfINT(N,A,B,X,Y,Z)    DOUBLEVVVV_cfINT(N,A,B,X,Y,Z)
#define     SHORTVVVVV_cfINT(N,A,B,X,Y,Z)   DOUBLEVVVVV_cfINT(N,A,B,X,Y,Z)
#define    SHORTVVVVVV_cfINT(N,A,B,X,Y,Z)  DOUBLEVVVVVV_cfINT(N,A,B,X,Y,Z)
#define   SHORTVVVVVVV_cfINT(N,A,B,X,Y,Z) DOUBLEVVVVVVV_cfINT(N,A,B,X,Y,Z)
#define          PVOID_cfINT(N,A,B,X,Y,Z) _(CFARGS,N)(A,B,B,X,Y,Z,0)
#define        ROUTINE_cfINT(N,A,B,X,Y,Z)         PVOID_cfINT(N,A,B,X,Y,Z)
/*CRAY coughs on the first,
  i.e. the usual trouble of not being able to
  define macros to macros with arguments. 
  New ultrix is worse, it coughs on all such uses.
 */
/*#define       SIMPLE_cfINT                    PVOID_cfINT*/
#define         SIMPLE_cfINT(N,A,B,X,Y,Z)         PVOID_cfINT(N,A,B,X,Y,Z)
#define           VOID_cfINT(N,A,B,X,Y,Z)         PVOID_cfINT(N,A,B,X,Y,Z)
#define         STRING_cfINT(N,A,B,X,Y,Z)         PVOID_cfINT(N,A,B,X,Y,Z)
#define        STRINGV_cfINT(N,A,B,X,Y,Z)         PVOID_cfINT(N,A,B,X,Y,Z)
#define        PSTRING_cfINT(N,A,B,X,Y,Z)         PVOID_cfINT(N,A,B,X,Y,Z)
#define       PSTRINGV_cfINT(N,A,B,X,Y,Z)         PVOID_cfINT(N,A,B,X,Y,Z)
#define       PNSTRING_cfINT(N,A,B,X,Y,Z)         PVOID_cfINT(N,A,B,X,Y,Z)
#define       PPSTRING_cfINT(N,A,B,X,Y,Z)         PVOID_cfINT(N,A,B,X,Y,Z)
#define        ZTRINGV_cfINT(N,A,B,X,Y,Z)         PVOID_cfINT(N,A,B,X,Y,Z)
#define       PZTRINGV_cfINT(N,A,B,X,Y,Z)         PVOID_cfINT(N,A,B,X,Y,Z)
#define           CF_0_cfINT(N,A,B,X,Y,Z)
                         

#define   UCF(TN,I,C)  _SEP_(TN,C,cfCOMMA) _Icf(2,U,TN,_(A,I),0)
#define  UUCF(TN,I,C)  _SEP_(TN,C,cfCOMMA) _SEP_(TN,1,I) 
#define UUUCF(TN,I,C)  _SEP_(TN,C,cfCOLON) _Icf(2,U,TN,_(A,I),0)
#define        INT_cfU(T,A) _(T,VVVVVVV_cfTYPE)   A
#define       INTV_cfU(T,A) _(T,VVVVVV_cfTYPE)  * A
#define      INTVV_cfU(T,A) _(T,VVVVV_cfTYPE)   * A
#define     INTVVV_cfU(T,A) _(T,VVVV_cfTYPE)    * A
#define    INTVVVV_cfU(T,A) _(T,VVV_cfTYPE)     * A
#define   INTVVVVV_cfU(T,A) _(T,VV_cfTYPE)      * A
#define  INTVVVVVV_cfU(T,A) _(T,V_cfTYPE)       * A
#define INTVVVVVVV_cfU(T,A) _(T,_cfTYPE)        * A
#define       PINT_cfU(T,A) _(T,_cfTYPE)        * A
#define      PVOID_cfU(T,A) void  *A 
#define    ROUTINE_cfU(T,A) void (*A)(CF_NULL_PROTO) 
#define       VOID_cfU(T,A) void   A    /* Needed for C calls FORTRAN sub.s.  */
#define     STRING_cfU(T,A) char  *A    /*            via VOID and wrapper.   */
#define    STRINGV_cfU(T,A) char  *A
#define    PSTRING_cfU(T,A) char  *A
#define   PSTRINGV_cfU(T,A) char  *A
#define    ZTRINGV_cfU(T,A) char  *A
#define   PZTRINGV_cfU(T,A) char  *A

/* VOID breaks U into U and UU. */
#define       INT_cfUU(T,A) _(T,VVVVVVV_cfTYPE) A
#define      VOID_cfUU(T,A)             /* Needed for FORTRAN calls C sub.s.  */
#define    STRING_cfUU(T,A) char *A 


#define      BYTE_cfPU(A)   CFextern INTEGER_BYTE      FCALLSC_QUALIFIER A
#define    DOUBLE_cfPU(A)   CFextern DOUBLE_PRECISION  FCALLSC_QUALIFIER A
#if ! (defined(FLOATFUNCTIONTYPE)&&defined(ASSIGNFLOAT)&&defined(RETURNFLOAT))
#define     FLOAT_cfPU(A)   CFextern FORTRAN_REAL      FCALLSC_QUALIFIER A
#else				   	                   
#define     FLOAT_cfPU(A)   CFextern FLOATFUNCTIONTYPE FCALLSC_QUALIFIER A
#endif				   	                   
#define       INT_cfPU(A)   CFextern int   FCALLSC_QUALIFIER   A
#define   LOGICAL_cfPU(A)   CFextern int   FCALLSC_QUALIFIER   A
#define      LONG_cfPU(A)   CFextern long  FCALLSC_QUALIFIER   A
#define     SHORT_cfPU(A)   CFextern short FCALLSC_QUALIFIER   A
#define    STRING_cfPU(A)   CFextern void  FCALLSC_QUALIFIER   A
#define      VOID_cfPU(A)   CFextern void  FCALLSC_QUALIFIER   A

#define    BYTE_cfE INTEGER_BYTE     A0;
#define  DOUBLE_cfE DOUBLE_PRECISION A0;
#if ! (defined(FLOATFUNCTIONTYPE)&&defined(ASSIGNFLOAT)&&defined(RETURNFLOAT))
#define   FLOAT_cfE FORTRAN_REAL  A0;
#else
#define   FLOAT_cfE FORTRAN_REAL AA0;   FLOATFUNCTIONTYPE A0;
#endif
#define     INT_cfE int    A0;
#define LOGICAL_cfE int    A0;
#define    LONG_cfE long   A0;
#define   SHORT_cfE short  A0;
#define    VOID_cfE
#ifdef vmsFortran
#define  STRING_cfE static char AA0[1+MAX_LEN_FORTRAN_FUNCTION_STRING];        \\
                       static fstring A0 =                                     \\
             {MAX_LEN_FORTRAN_FUNCTION_STRING,DSC$K_DTYPE_T,DSC$K_CLASS_S,AA0};\\
               memset(AA0, CFORTRAN_NON_CHAR, MAX_LEN_FORTRAN_FUNCTION_STRING);\\
                                    *(AA0+MAX_LEN_FORTRAN_FUNCTION_STRING)='\\0';
#else
#ifdef CRAYFortran
#define  STRING_cfE static char AA0[1+MAX_LEN_FORTRAN_FUNCTION_STRING];        \\
                   static _fcd A0; *(AA0+MAX_LEN_FORTRAN_FUNCTION_STRING)='\\0';\\
                memset(AA0,CFORTRAN_NON_CHAR, MAX_LEN_FORTRAN_FUNCTION_STRING);\\
                            A0 = _cptofcd(AA0,MAX_LEN_FORTRAN_FUNCTION_STRING);
#else
/* 'cc: SC3.0.1 13 Jul 1994' barfs on char A0[0x4FE+1]; 
 * char A0[0x4FE +1]; char A0[1+0x4FE]; are both OK.     */
#define STRING_cfE static char A0[1+MAX_LEN_FORTRAN_FUNCTION_STRING];          \\
                       memset(A0, CFORTRAN_NON_CHAR,                           \\
                              MAX_LEN_FORTRAN_FUNCTION_STRING);                \\
                       *(A0+MAX_LEN_FORTRAN_FUNCTION_STRING)='\\0';
#endif
#endif
/* ESTRING must use static char. array which is guaranteed to exist after
   function returns.                                                     */

/* N.B.i) The diff. for 0 (Zero) and >=1 arguments.
       ii)That the following create an unmatched bracket, i.e. '(', which
          must of course be matched in the call.
       iii)Commas must be handled very carefully                         */
#define    INT_cfGZ(T,UN,LN) A0=CFC_(UN,LN)(
#define   VOID_cfGZ(T,UN,LN)    CFC_(UN,LN)(
#ifdef vmsFortran
#define STRING_cfGZ(T,UN,LN)    CFC_(UN,LN)(&A0
#else
#if defined(CRAYFortran) || defined(AbsoftUNIXFortran) || defined(AbsoftProFortran)
#define STRING_cfGZ(T,UN,LN)    CFC_(UN,LN)( A0
#else
#define STRING_cfGZ(T,UN,LN)    CFC_(UN,LN)( A0,MAX_LEN_FORTRAN_FUNCTION_STRING
#endif
#endif

#define     INT_cfG(T,UN,LN)    INT_cfGZ(T,UN,LN)
#define    VOID_cfG(T,UN,LN)   VOID_cfGZ(T,UN,LN)
#define  STRING_cfG(T,UN,LN) STRING_cfGZ(T,UN,LN), /*, is only diff. from _cfG*/

#define    BYTEVVVVVVV_cfPP
#define     INTVVVVVVV_cfPP     /* These complement FLOATVVVVVVV_cfPP. */
#define  DOUBLEVVVVVVV_cfPP
#define LOGICALVVVVVVV_cfPP
#define    LONGVVVVVVV_cfPP
#define   SHORTVVVVVVV_cfPP
#define          PBYTE_cfPP
#define           PINT_cfPP
#define        PDOUBLE_cfPP
#define       PLOGICAL_cfPP
#define          PLONG_cfPP
#define         PSHORT_cfPP
#define         PFLOAT_cfPP FLOATVVVVVVV_cfPP

#define BCF(TN,AN,C)        _SEP_(TN,C,cfCOMMA) _Icf(2,B,TN,AN,0)
#define        INT_cfB(T,A) (_(T,VVVVVVV_cfTYPE)) A
#define       INTV_cfB(T,A)            A
#define      INTVV_cfB(T,A)           (A)[0]
#define     INTVVV_cfB(T,A)           (A)[0][0]
#define    INTVVVV_cfB(T,A)           (A)[0][0][0]
#define   INTVVVVV_cfB(T,A)           (A)[0][0][0][0]
#define  INTVVVVVV_cfB(T,A)           (A)[0][0][0][0][0]
#define INTVVVVVVV_cfB(T,A)           (A)[0][0][0][0][0][0]
#define       PINT_cfB(T,A) _(T,_cfPP)&A
#define     STRING_cfB(T,A) (char *)   A
#define    STRINGV_cfB(T,A) (char *)   A
#define    PSTRING_cfB(T,A) (char *)   A
#define   PSTRINGV_cfB(T,A) (char *)   A
#define      PVOID_cfB(T,A) (void *)   A
#define    ROUTINE_cfB(T,A) (cfCAST_FUNCTION)A
#define    ZTRINGV_cfB(T,A) (char *)   A
#define   PZTRINGV_cfB(T,A) (char *)   A
                                                              	
#define SCF(TN,NAME,I,A)    _(TN,_cfSTR)(3,S,NAME,I,A,0,0)
#define  DEFAULT_cfS(M,I,A)
#define  LOGICAL_cfS(M,I,A)
#define PLOGICAL_cfS(M,I,A)
#define   STRING_cfS(M,I,A) ,sizeof(A)
#define  STRINGV_cfS(M,I,A) ,( (unsigned)0xFFFF*firstindexlength(A) \\
                              +secondindexlength(A))
#define  PSTRING_cfS(M,I,A) ,sizeof(A)
#define PSTRINGV_cfS(M,I,A) STRINGV_cfS(M,I,A)
#define  ZTRINGV_cfS(M,I,A)
#define PZTRINGV_cfS(M,I,A)

#define   HCF(TN,I)         _(TN,_cfSTR)(3,H,cfCOMMA, H,_(C,I),0,0)
#define  HHCF(TN,I)         _(TN,_cfSTR)(3,H,cfCOMMA,HH,_(C,I),0,0)
#define HHHCF(TN,I)         _(TN,_cfSTR)(3,H,cfCOLON, H,_(C,I),0,0)
#define  H_CF_SPECIAL       unsigned
#define HH_CF_SPECIAL
#define  DEFAULT_cfH(M,I,A)
#define  LOGICAL_cfH(S,U,B)
#define PLOGICAL_cfH(S,U,B)
#define   STRING_cfH(S,U,B) _(A,S) _(U,_CF_SPECIAL) B
#define  STRINGV_cfH(S,U,B) STRING_cfH(S,U,B)
#define  PSTRING_cfH(S,U,B) STRING_cfH(S,U,B)
#define PSTRINGV_cfH(S,U,B) STRING_cfH(S,U,B)
#define PNSTRING_cfH(S,U,B) STRING_cfH(S,U,B)
#define PPSTRING_cfH(S,U,B) STRING_cfH(S,U,B)
#define  ZTRINGV_cfH(S,U,B)
#define PZTRINGV_cfH(S,U,B)

/* Need VOID_cfSTR because Absoft forced function types go through _cfSTR. */
/* No spaces inside expansion. They screws up macro catenation kludge.     */
#define           VOID_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define           BYTE_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define         DOUBLE_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define          FLOAT_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define            INT_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define        LOGICAL_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,LOGICAL,A,B,C,D,E)
#define           LONG_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define          SHORT_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define          BYTEV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define         BYTEVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define        BYTEVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define       BYTEVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define      BYTEVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define     BYTEVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define    BYTEVVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define        DOUBLEV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define       DOUBLEVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define      DOUBLEVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define     DOUBLEVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define    DOUBLEVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define   DOUBLEVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define  DOUBLEVVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define         FLOATV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define        FLOATVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define       FLOATVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define      FLOATVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define     FLOATVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define    FLOATVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define   FLOATVVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define           INTV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define          INTVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define         INTVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define        INTVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define       INTVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define      INTVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define     INTVVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define       LOGICALV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define      LOGICALVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define     LOGICALVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define    LOGICALVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define   LOGICALVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define  LOGICALVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define LOGICALVVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define          LONGV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define         LONGVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define        LONGVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define       LONGVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define      LONGVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define     LONGVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define    LONGVVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define         SHORTV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define        SHORTVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define       SHORTVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define      SHORTVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define     SHORTVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define    SHORTVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define   SHORTVVVVVVV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define          PBYTE_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define        PDOUBLE_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define         PFLOAT_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define           PINT_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define       PLOGICAL_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,PLOGICAL,A,B,C,D,E)
#define          PLONG_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define         PSHORT_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define         STRING_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,STRING,A,B,C,D,E)
#define        PSTRING_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,PSTRING,A,B,C,D,E)
#define        STRINGV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,STRINGV,A,B,C,D,E)
#define       PSTRINGV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,PSTRINGV,A,B,C,D,E)
#define       PNSTRING_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,PNSTRING,A,B,C,D,E)
#define       PPSTRING_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,PPSTRING,A,B,C,D,E)
#define          PVOID_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define        ROUTINE_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define         SIMPLE_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,DEFAULT,A,B,C,D,E)
#define        ZTRINGV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,ZTRINGV,A,B,C,D,E)
#define       PZTRINGV_cfSTR(N,T,A,B,C,D,E) _(CFARGS,N)(T,PZTRINGV,A,B,C,D,E)
#define           CF_0_cfSTR(N,T,A,B,C,D,E)

/* See ACF table comments, which explain why CCF was split into two. */
#define CCF(NAME,TN,I)     _(TN,_cfSTR)(5,C,NAME,I,_(A,I),_(B,I),_(C,I))
#define  DEFAULT_cfC(M,I,A,B,C)
#define  LOGICAL_cfC(M,I,A,B,C)  A=C2FLOGICAL( A);
#define PLOGICAL_cfC(M,I,A,B,C) *A=C2FLOGICAL(*A);
#ifdef vmsFortran
#define   STRING_cfC(M,I,A,B,C) (B.clen=strlen(A),B.f.dsc$a_pointer=A,         \\
        C==sizeof(char*)||C==(unsigned)(B.clen+1)?B.f.dsc$w_length=B.clen:     \\
          (memset((A)+B.clen,' ',C-B.clen-1),A[B.f.dsc$w_length=C-1]='\\0'));
      /* PSTRING_cfC to beware of array A which does not contain any \\0.      */
#define  PSTRING_cfC(M,I,A,B,C) (B.dsc$a_pointer=A, C==sizeof(char*) ?         \\
             B.dsc$w_length=strlen(A):  (A[C-1]='\\0',B.dsc$w_length=strlen(A), \\
       memset((A)+B.dsc$w_length,' ',C-B.dsc$w_length-1), B.dsc$w_length=C-1));
#else
#define   STRING_cfC(M,I,A,B,C) (B.clen=strlen(A),                             \\
                C==sizeof(char*)||C==(unsigned)(B.clen+1)?B.flen=B.clen:       \\
                        (memset((A)+B.clen,' ',C-B.clen-1),A[B.flen=C-1]='\\0'));
#define  PSTRING_cfC(M,I,A,B,C) (C==sizeof(char*)? B=strlen(A):                \\
                    (A[C-1]='\\0',B=strlen(A),memset((A)+B,' ',C-B-1),B=C-1));
#endif
          /* For CRAYFortran for (P)STRINGV_cfC, B.fs is set, but irrelevant. */
#define  STRINGV_cfC(M,I,A,B,C) \\
        AATRINGV_cfA(    A,B,(C/0xFFFF)*(C%0xFFFF),C/0xFFFF,C%0xFFFF)
#define PSTRINGV_cfC(M,I,A,B,C) \\
       APATRINGV_cfA(    A,B,(C/0xFFFF)*(C%0xFFFF),C/0xFFFF,C%0xFFFF)
#define  ZTRINGV_cfC(M,I,A,B,C) \\
        AATRINGV_cfA(    A,B, (_3(M,_ELEMS_,I))*((_3(M,_ELEMLEN_,I))+1),       \\
                              (_3(M,_ELEMS_,I)), (_3(M,_ELEMLEN_,I))+1   )
#define PZTRINGV_cfC(M,I,A,B,C) \\
       APATRINGV_cfA(    A,B, (_3(M,_ELEMS_,I))*((_3(M,_ELEMLEN_,I))+1),       \\
                              (_3(M,_ELEMS_,I)), (_3(M,_ELEMLEN_,I))+1   )

#define     BYTE_cfCCC(A,B) &A
#define   DOUBLE_cfCCC(A,B) &A
#if !defined(__CF__KnR)
#define    FLOAT_cfCCC(A,B) &A
                               /* Although the VAX doesn't, at least the      */
#else                          /* HP and K&R mips promote float arg.'s of     */
#define    FLOAT_cfCCC(A,B) &B /* unprototyped functions to double. Cannot    */
#endif                         /* use A here to pass the argument to FORTRAN. */
#define      INT_cfCCC(A,B) &A
#define  LOGICAL_cfCCC(A,B) &A
#define     LONG_cfCCC(A,B) &A
#define    SHORT_cfCCC(A,B) &A
#define    PBYTE_cfCCC(A,B)  A
#define  PDOUBLE_cfCCC(A,B)  A
#define   PFLOAT_cfCCC(A,B)  A
#define     PINT_cfCCC(A,B)  A
#define PLOGICAL_cfCCC(A,B)  B=A       /* B used to keep a common W table. */
#define    PLONG_cfCCC(A,B)  A
#define   PSHORT_cfCCC(A,B)  A

#define CCCF(TN,I,M)           _SEP_(TN,M,cfCOMMA) _Icf(3,CC,TN,_(A,I),_(B,I))
#define        INT_cfCC(T,A,B) _(T,_cfCCC)(A,B) 
#define       INTV_cfCC(T,A,B)  A
#define      INTVV_cfCC(T,A,B)  A
#define     INTVVV_cfCC(T,A,B)  A
#define    INTVVVV_cfCC(T,A,B)  A
#define   INTVVVVV_cfCC(T,A,B)  A
#define  INTVVVVVV_cfCC(T,A,B)  A
#define INTVVVVVVV_cfCC(T,A,B)  A
#define       PINT_cfCC(T,A,B) _(T,_cfCCC)(A,B) 
#define      PVOID_cfCC(T,A,B)  A
#if defined(apolloFortran) || defined(hpuxFortran800) || defined(AbsoftUNIXFortran)
#define    ROUTINE_cfCC(T,A,B) &A
#else
#define    ROUTINE_cfCC(T,A,B)  A
#endif
#define     SIMPLE_cfCC(T,A,B)  A
#ifdef vmsFortran
#define     STRING_cfCC(T,A,B) &B.f
#define    STRINGV_cfCC(T,A,B) &B
#define    PSTRING_cfCC(T,A,B) &B
#define   PSTRINGV_cfCC(T,A,B) &B
#else
#ifdef CRAYFortran
#define     STRING_cfCC(T,A,B) _cptofcd(A,B.flen)
#define    STRINGV_cfCC(T,A,B) _cptofcd(B.s,B.flen)
#define    PSTRING_cfCC(T,A,B) _cptofcd(A,B)
#define   PSTRINGV_cfCC(T,A,B) _cptofcd(A,B.flen)
#else
#define     STRING_cfCC(T,A,B)  A
#define    STRINGV_cfCC(T,A,B)  B.fs
#define    PSTRING_cfCC(T,A,B)  A
#define   PSTRINGV_cfCC(T,A,B)  B.fs
#endif
#endif
#define    ZTRINGV_cfCC(T,A,B)   STRINGV_cfCC(T,A,B)
#define   PZTRINGV_cfCC(T,A,B)  PSTRINGV_cfCC(T,A,B)

#define    BYTE_cfX  return A0;
#define  DOUBLE_cfX  return A0;
#if ! (defined(FLOATFUNCTIONTYPE)&&defined(ASSIGNFLOAT)&&defined(RETURNFLOAT))
#define   FLOAT_cfX  return A0;
#else
#define   FLOAT_cfX  ASSIGNFLOAT(AA0,A0); return AA0;
#endif
#define     INT_cfX  return A0;
#define LOGICAL_cfX  return F2CLOGICAL(A0);
#define    LONG_cfX  return A0;
#define   SHORT_cfX  return A0;
#define    VOID_cfX  return   ;
#if defined(vmsFortran) || defined(CRAYFortran)
#define  STRING_cfX  return kill_trailing(                                     \\
                                      kill_trailing(AA0,CFORTRAN_NON_CHAR),' ');
#else
#define  STRING_cfX  return kill_trailing(                                     \\
                                      kill_trailing( A0,CFORTRAN_NON_CHAR),' ');
#endif

#define CFFUN(NAME) _(__cf__,NAME)

/* Note that we don't use LN here, but we keep it for consistency. */
#define CCALLSFFUN0(UN,LN) CFFUN(UN)()

#ifdef OLD_VAXC                                  /* Allow %CC-I-PARAMNOTUSED. */
#pragma standard
#endif

#define CCALLSFFUN1( UN,LN,T1,                        A1)         \\
        CCALLSFFUN5 (UN,LN,T1,CF_0,CF_0,CF_0,CF_0,A1,0,0,0,0)
#define CCALLSFFUN2( UN,LN,T1,T2,                     A1,A2)      \\
        CCALLSFFUN5 (UN,LN,T1,T2,CF_0,CF_0,CF_0,A1,A2,0,0,0)
#define CCALLSFFUN3( UN,LN,T1,T2,T3,                  A1,A2,A3)   \\
        CCALLSFFUN5 (UN,LN,T1,T2,T3,CF_0,CF_0,A1,A2,A3,0,0)
#define CCALLSFFUN4( UN,LN,T1,T2,T3,T4,               A1,A2,A3,A4)\\
        CCALLSFFUN5 (UN,LN,T1,T2,T3,T4,CF_0,A1,A2,A3,A4,0)
#define CCALLSFFUN5( UN,LN,T1,T2,T3,T4,T5,            A1,A2,A3,A4,A5)          \\
        CCALLSFFUN10(UN,LN,T1,T2,T3,T4,T5,CF_0,CF_0,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,0,0,0,0,0)
#define CCALLSFFUN6( UN,LN,T1,T2,T3,T4,T5,T6,         A1,A2,A3,A4,A5,A6)       \\
        CCALLSFFUN10(UN,LN,T1,T2,T3,T4,T5,T6,CF_0,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,0,0,0,0)
#define CCALLSFFUN7( UN,LN,T1,T2,T3,T4,T5,T6,T7,      A1,A2,A3,A4,A5,A6,A7)    \\
        CCALLSFFUN10(UN,LN,T1,T2,T3,T4,T5,T6,T7,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,0,0,0)
#define CCALLSFFUN8( UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,   A1,A2,A3,A4,A5,A6,A7,A8) \\
        CCALLSFFUN10(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,0,0)
#define CCALLSFFUN9( UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,A1,A2,A3,A4,A5,A6,A7,A8,A9)\\
        CCALLSFFUN10(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,0)
#define CCALLSFFUN10(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA)\\
        CCALLSFFUN14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,CF_0,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,0,0,0,0)
#define CCALLSFFUN11(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB)\\
        CCALLSFFUN14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,CF_0,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,0,0,0)
#define CCALLSFFUN12(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC)\\
        CCALLSFFUN14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,CF_0,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,0,0)
#define CCALLSFFUN13(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD)\\
        CCALLSFFUN14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,CF_0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,0)

#define CCALLSFFUN14(UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE)\\
((CFFUN(UN)(  BCF(T1,A1,0) BCF(T2,A2,1) BCF(T3,A3,1) BCF(T4,A4,1) BCF(T5,A5,1) \\
              BCF(T6,A6,1) BCF(T7,A7,1) BCF(T8,A8,1) BCF(T9,A9,1) BCF(TA,AA,1) \\
              BCF(TB,AB,1) BCF(TC,AC,1) BCF(TD,AD,1) BCF(TE,AE,1)              \\
           SCF(T1,LN,1,A1)  SCF(T2,LN,2,A2)  SCF(T3,LN,3,A3)  SCF(T4,LN,4,A4)  \\
           SCF(T5,LN,5,A5)  SCF(T6,LN,6,A6)  SCF(T7,LN,7,A7)  SCF(T8,LN,8,A8)  \\
           SCF(T9,LN,9,A9)  SCF(TA,LN,10,AA) SCF(TB,LN,11,AB) SCF(TC,LN,12,AC) \\
           SCF(TD,LN,13,AD) SCF(TE,LN,14,AE))))

/*  N.B. Create a separate function instead of using (call function, function
value here) because in order to create the variables needed for the input
arg.'s which may be const.'s one has to do the creation within {}, but these
can never be placed within ()'s. Therefore one must create wrapper functions.
gcc, on the other hand may be able to avoid the wrapper functions. */

/* Prototypes are needed to correctly handle the value returned correctly. N.B.
Can only have prototype arg.'s with difficulty, a la G... table since FORTRAN
functions returning strings have extra arg.'s. Don't bother, since this only
causes a compiler warning to come up when one uses FCALLSCFUNn and CCALLSFFUNn
for the same function in the same source code. Something done by the experts in
debugging only.*/    

#define PROTOCCALLSFFUN0(F,UN,LN)                                              \\
_(F,_cfPU)( CFC_(UN,LN))(CF_NULL_PROTO);                                       \\
static _Icf(2,U,F,CFFUN(UN),0)() {_(F,_cfE) _Icf(3,GZ,F,UN,LN) ABSOFT_cf1(F));_(F,_cfX)}

#define PROTOCCALLSFFUN1( T0,UN,LN,T1)                                         \\
        PROTOCCALLSFFUN5 (T0,UN,LN,T1,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFFUN2( T0,UN,LN,T1,T2)                                      \\
        PROTOCCALLSFFUN5 (T0,UN,LN,T1,T2,CF_0,CF_0,CF_0)
#define PROTOCCALLSFFUN3( T0,UN,LN,T1,T2,T3)                                   \\
        PROTOCCALLSFFUN5 (T0,UN,LN,T1,T2,T3,CF_0,CF_0)
#define PROTOCCALLSFFUN4( T0,UN,LN,T1,T2,T3,T4)                                \\
        PROTOCCALLSFFUN5 (T0,UN,LN,T1,T2,T3,T4,CF_0)
#define PROTOCCALLSFFUN5( T0,UN,LN,T1,T2,T3,T4,T5)                             \\
        PROTOCCALLSFFUN10(T0,UN,LN,T1,T2,T3,T4,T5,CF_0,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFFUN6( T0,UN,LN,T1,T2,T3,T4,T5,T6)                          \\
        PROTOCCALLSFFUN10(T0,UN,LN,T1,T2,T3,T4,T5,T6,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFFUN7( T0,UN,LN,T1,T2,T3,T4,T5,T6,T7)                       \\
        PROTOCCALLSFFUN10(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,CF_0,CF_0,CF_0)
#define PROTOCCALLSFFUN8( T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8)                    \\
        PROTOCCALLSFFUN10(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,CF_0,CF_0)
#define PROTOCCALLSFFUN9( T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9)                 \\
        PROTOCCALLSFFUN10(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,CF_0)
#define PROTOCCALLSFFUN10(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA)              \\
        PROTOCCALLSFFUN14(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,CF_0,CF_0,CF_0,CF_0)
#define PROTOCCALLSFFUN11(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB)           \\
        PROTOCCALLSFFUN14(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,CF_0,CF_0,CF_0)
#define PROTOCCALLSFFUN12(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC)        \\
        PROTOCCALLSFFUN14(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,CF_0,CF_0)
#define PROTOCCALLSFFUN13(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD)     \\
        PROTOCCALLSFFUN14(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,CF_0)

/* HP/UX 9.01 cc requires the blank between '_Icf(3,G,T0,UN,LN) CCCF(T1,1,0)' */

#ifndef __CF__KnR
#define PROTOCCALLSFFUN14(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)  \\
 _(T0,_cfPU)(CFC_(UN,LN))(CF_NULL_PROTO); static _Icf(2,U,T0,CFFUN(UN),0)(     \\
   CFARGT14FS(UCF,HCF,_Z,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE) )          \\
{       CFARGT14S(VCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)    _(T0,_cfE) \\
 CCF(LN,T1,1)  CCF(LN,T2,2)  CCF(LN,T3,3)  CCF(LN,T4,4)  CCF(LN,T5,5)          \\
 CCF(LN,T6,6)  CCF(LN,T7,7)  CCF(LN,T8,8)  CCF(LN,T9,9)  CCF(LN,TA,10)         \\
 CCF(LN,TB,11) CCF(LN,TC,12) CCF(LN,TD,13) CCF(LN,TE,14)    _Icf(3,G,T0,UN,LN) \\
 CFARGT14(CCCF,JCF,ABSOFT_cf1(T0),T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)); \\
 WCF(T1,A1,1)   WCF(T2,A2,2)   WCF(T3,A3,3)   WCF(T4,A4,4)  WCF(T5,A5,5)       \\
 WCF(T6,A6,6)   WCF(T7,A7,7)   WCF(T8,A8,8)   WCF(T9,A9,9)  WCF(TA,A10,10)     \\
 WCF(TB,A11,11) WCF(TC,A12,12) WCF(TD,A13,13) WCF(TE,A14,14) _(T0,_cfX)}
#else
#define PROTOCCALLSFFUN14(T0,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)  \\
 _(T0,_cfPU)(CFC_(UN,LN))(CF_NULL_PROTO); static _Icf(2,U,T0,CFFUN(UN),0)(     \\
   CFARGT14FS(UUCF,HHCF,_Z,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE) )        \\
 CFARGT14FS(UUUCF,HHHCF,_Z,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE) ;        \\
{       CFARGT14S(VCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)    _(T0,_cfE) \\
 CCF(LN,T1,1)  CCF(LN,T2,2)  CCF(LN,T3,3)  CCF(LN,T4,4)  CCF(LN,T5,5)          \\
 CCF(LN,T6,6)  CCF(LN,T7,7)  CCF(LN,T8,8)  CCF(LN,T9,9)  CCF(LN,TA,10)         \\
 CCF(LN,TB,11) CCF(LN,TC,12) CCF(LN,TD,13) CCF(LN,TE,14)    _Icf(3,G,T0,UN,LN) \\
 CFARGT14(CCCF,JCF,ABSOFT_cf1(T0),T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)); \\
 WCF(T1,A1,1)   WCF(T2,A2,2)   WCF(T3,A3,3)   WCF(T4,A4,4)   WCF(T5,A5,5)      \\
 WCF(T6,A6,6)   WCF(T7,A7,7)   WCF(T8,A8,8)   WCF(T9,A9,9)   WCF(TA,A10,10)    \\
 WCF(TB,A11,11) WCF(TC,A12,12) WCF(TD,A13,13) WCF(TE,A14,14) _(T0,_cfX)}
#endif

/*-------------------------------------------------------------------------*/

/*               UTILITIES FOR FORTRAN TO CALL C ROUTINES                  */

#ifdef OLD_VAXC                                /* Prevent %CC-I-PARAMNOTUSED. */
#pragma nostandard
#endif

#if defined(vmsFortran) || defined(CRAYFortran)
#define   DCF(TN,I)
#define  DDCF(TN,I)
#define DDDCF(TN,I)
#else
#define   DCF(TN,I)          HCF(TN,I)
#define  DDCF(TN,I)         HHCF(TN,I)
#define DDDCF(TN,I)        HHHCF(TN,I)
#endif

#define QCF(TN,I)       _(TN,_cfSTR)(1,Q,_(B,I), 0,0,0,0)
#define  DEFAULT_cfQ(B)
#define  LOGICAL_cfQ(B)
#define PLOGICAL_cfQ(B)
#define  STRINGV_cfQ(B) char *B; unsigned int _(B,N);
#define   STRING_cfQ(B) char *B=NULL;
#define  PSTRING_cfQ(B) char *B=NULL;
#define PSTRINGV_cfQ(B) STRINGV_cfQ(B)
#define PNSTRING_cfQ(B) char *B=NULL;
#define PPSTRING_cfQ(B)

#ifdef     __sgi   /* Else SGI gives warning 182 contrary to its C LRM A.17.7 */
#define ROUTINE_orig    *(void**)& 
#else
#define ROUTINE_orig     (void *)  
#endif

#define ROUTINE_1     ROUTINE_orig   
#define ROUTINE_2     ROUTINE_orig   
#define ROUTINE_3     ROUTINE_orig   
#define ROUTINE_4     ROUTINE_orig   
#define ROUTINE_5     ROUTINE_orig   
#define ROUTINE_6     ROUTINE_orig   
#define ROUTINE_7     ROUTINE_orig   
#define ROUTINE_8     ROUTINE_orig   
#define ROUTINE_9     ROUTINE_orig   
#define ROUTINE_10    ROUTINE_orig   
#define ROUTINE_11    ROUTINE_orig   
#define ROUTINE_12    ROUTINE_orig   
#define ROUTINE_13    ROUTINE_orig   
#define ROUTINE_14    ROUTINE_orig   
#define ROUTINE_15    ROUTINE_orig   
#define ROUTINE_16    ROUTINE_orig   
#define ROUTINE_17    ROUTINE_orig   
#define ROUTINE_18    ROUTINE_orig   
#define ROUTINE_19    ROUTINE_orig   
#define ROUTINE_20    ROUTINE_orig   
#define ROUTINE_21    ROUTINE_orig   
#define ROUTINE_22    ROUTINE_orig   
#define ROUTINE_23    ROUTINE_orig   
#define ROUTINE_24    ROUTINE_orig   
#define ROUTINE_25    ROUTINE_orig   
#define ROUTINE_26    ROUTINE_orig   
#define ROUTINE_27    ROUTINE_orig   

#define TCF(NAME,TN,I,M)              _SEP_(TN,M,cfCOMMA) _(TN,_cfT)(NAME,I,_(A,I),_(B,I),_(C,I))
#define           BYTE_cfT(M,I,A,B,D) *A
#define         DOUBLE_cfT(M,I,A,B,D) *A
#define          FLOAT_cfT(M,I,A,B,D) *A
#define            INT_cfT(M,I,A,B,D) *A
#define        LOGICAL_cfT(M,I,A,B,D)  F2CLOGICAL(*A)
#define           LONG_cfT(M,I,A,B,D) *A
#define          SHORT_cfT(M,I,A,B,D) *A
#define          BYTEV_cfT(M,I,A,B,D)  A
#define        DOUBLEV_cfT(M,I,A,B,D)  A
#define         FLOATV_cfT(M,I,A,B,D)  VOIDP A
#define           INTV_cfT(M,I,A,B,D)  A
#define       LOGICALV_cfT(M,I,A,B,D)  A
#define          LONGV_cfT(M,I,A,B,D)  A
#define         SHORTV_cfT(M,I,A,B,D)  A
#define         BYTEVV_cfT(M,I,A,B,D)  (void *)A /* We have to cast to void *,*/
#define        BYTEVVV_cfT(M,I,A,B,D)  (void *)A /* since we don't know the   */
#define       BYTEVVVV_cfT(M,I,A,B,D)  (void *)A /* dimensions of the array.  */
#define      BYTEVVVVV_cfT(M,I,A,B,D)  (void *)A /* i.e. Unfortunately, can't */
#define     BYTEVVVVVV_cfT(M,I,A,B,D)  (void *)A /* check that the type       */
#define    BYTEVVVVVVV_cfT(M,I,A,B,D)  (void *)A /* matches the prototype.    */
#define       DOUBLEVV_cfT(M,I,A,B,D)  (void *)A
#define      DOUBLEVVV_cfT(M,I,A,B,D)  (void *)A
#define     DOUBLEVVVV_cfT(M,I,A,B,D)  (void *)A
#define    DOUBLEVVVVV_cfT(M,I,A,B,D)  (void *)A
#define   DOUBLEVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define  DOUBLEVVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define        FLOATVV_cfT(M,I,A,B,D)  (void *)A
#define       FLOATVVV_cfT(M,I,A,B,D)  (void *)A
#define      FLOATVVVV_cfT(M,I,A,B,D)  (void *)A
#define     FLOATVVVVV_cfT(M,I,A,B,D)  (void *)A
#define    FLOATVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define   FLOATVVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define          INTVV_cfT(M,I,A,B,D)  (void *)A  
#define         INTVVV_cfT(M,I,A,B,D)  (void *)A  
#define        INTVVVV_cfT(M,I,A,B,D)  (void *)A  
#define       INTVVVVV_cfT(M,I,A,B,D)  (void *)A
#define      INTVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define     INTVVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define      LOGICALVV_cfT(M,I,A,B,D)  (void *)A
#define     LOGICALVVV_cfT(M,I,A,B,D)  (void *)A
#define    LOGICALVVVV_cfT(M,I,A,B,D)  (void *)A
#define   LOGICALVVVVV_cfT(M,I,A,B,D)  (void *)A
#define  LOGICALVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define LOGICALVVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define         LONGVV_cfT(M,I,A,B,D)  (void *)A
#define        LONGVVV_cfT(M,I,A,B,D)  (void *)A
#define       LONGVVVV_cfT(M,I,A,B,D)  (void *)A
#define      LONGVVVVV_cfT(M,I,A,B,D)  (void *)A
#define     LONGVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define    LONGVVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define        SHORTVV_cfT(M,I,A,B,D)  (void *)A
#define       SHORTVVV_cfT(M,I,A,B,D)  (void *)A
#define      SHORTVVVV_cfT(M,I,A,B,D)  (void *)A
#define     SHORTVVVVV_cfT(M,I,A,B,D)  (void *)A
#define    SHORTVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define   SHORTVVVVVVV_cfT(M,I,A,B,D)  (void *)A
#define          PBYTE_cfT(M,I,A,B,D)  A
#define        PDOUBLE_cfT(M,I,A,B,D)  A
#define         PFLOAT_cfT(M,I,A,B,D)  VOIDP A
#define           PINT_cfT(M,I,A,B,D)  A
#define       PLOGICAL_cfT(M,I,A,B,D)  ((*A=F2CLOGICAL(*A)),A)
#define          PLONG_cfT(M,I,A,B,D)  A
#define         PSHORT_cfT(M,I,A,B,D)  A
#define          PVOID_cfT(M,I,A,B,D)  A
#if defined(apolloFortran) || defined(hpuxFortran800) || defined(AbsoftUNIXFortran)
#define        ROUTINE_cfT(M,I,A,B,D)  _(ROUTINE_,I)  (*A)
#else
#define        ROUTINE_cfT(M,I,A,B,D)  _(ROUTINE_,I)    A
#endif
/* A == pointer to the characters
   D == length of the string, or of an element in an array of strings
   E == number of elements in an array of strings                             */
#define TTSTR(    A,B,D)                                                       \\
           ((B=_cf_malloc(D+1))[D]='\\0', memcpy(B,A,D), kill_trailing(B,' '))
#define TTTTSTR(  A,B,D)   (!(D<4||A[0]||A[1]||A[2]||A[3]))?NULL:              \\
                            memchr(A,'\\0',D)                 ?A   : TTSTR(A,B,D)
#define TTTTSTRV( A,B,D,E) (_(B,N)=E,B=_cf_malloc(_(B,N)*(D+1)), (void *)      \\
  vkill_trailing(f2cstrv(A,B,D+1, _(B,N)*(D+1)), D+1,_(B,N)*(D+1),' '))
#ifdef vmsFortran
#define         STRING_cfT(M,I,A,B,D)  TTTTSTR( A->dsc$a_pointer,B,A->dsc$w_length)
#define        STRINGV_cfT(M,I,A,B,D)  TTTTSTRV(A->dsc$a_pointer, B,           \\
                                             A->dsc$w_length , A->dsc$l_m[0])
#define        PSTRING_cfT(M,I,A,B,D)    TTSTR( A->dsc$a_pointer,B,A->dsc$w_length)
#define       PPSTRING_cfT(M,I,A,B,D)           A->dsc$a_pointer
#else
#ifdef CRAYFortran
#define         STRING_cfT(M,I,A,B,D)  TTTTSTR( _fcdtocp(A),B,_fcdlen(A))
#define        STRINGV_cfT(M,I,A,B,D)  TTTTSTRV(_fcdtocp(A),B,_fcdlen(A),      \\
                              num_elem(_fcdtocp(A),_fcdlen(A),_3(M,_STRV_A,I)))
#define        PSTRING_cfT(M,I,A,B,D)    TTSTR( _fcdtocp(A),B,_fcdlen(A))
#define       PPSTRING_cfT(M,I,A,B,D)           _fcdtocp(A)
#else
#define         STRING_cfT(M,I,A,B,D)  TTTTSTR( A,B,D)
#define        STRINGV_cfT(M,I,A,B,D)  TTTTSTRV(A,B,D, num_elem(A,D,_3(M,_STRV_A,I)))
#define        PSTRING_cfT(M,I,A,B,D)    TTSTR( A,B,D)
#define       PPSTRING_cfT(M,I,A,B,D)           A
#endif
#endif
#define       PNSTRING_cfT(M,I,A,B,D)    STRING_cfT(M,I,A,B,D)
#define       PSTRINGV_cfT(M,I,A,B,D)   STRINGV_cfT(M,I,A,B,D)
#define           CF_0_cfT(M,I,A,B,D)

#define RCF(TN,I)           _(TN,_cfSTR)(3,R,_(A,I),_(B,I),_(C,I),0,0)
#define  DEFAULT_cfR(A,B,D)
#define  LOGICAL_cfR(A,B,D)
#define PLOGICAL_cfR(A,B,D) *A=C2FLOGICAL(*A);
#define   STRING_cfR(A,B,D) if (B) _cf_free(B);
#define  STRINGV_cfR(A,B,D) _cf_free(B);
/* A and D as defined above for TSTRING(V) */
#define RRRRPSTR( A,B,D)    if (B) memcpy(A,B, _cfMIN(strlen(B),D)),           \\
                  (D>strlen(B)?memset(A+strlen(B),' ', D-strlen(B)):0), _cf_free(B);
#define RRRRPSTRV(A,B,D)    c2fstrv(B,A,D+1,(D+1)*_(B,N)), _cf_free(B);
#ifdef vmsFortran
#define  PSTRING_cfR(A,B,D) RRRRPSTR( A->dsc$a_pointer,B,A->dsc$w_length)
#define PSTRINGV_cfR(A,B,D) RRRRPSTRV(A->dsc$a_pointer,B,A->dsc$w_length)
#else
#ifdef CRAYFortran
#define  PSTRING_cfR(A,B,D) RRRRPSTR( _fcdtocp(A),B,_fcdlen(A))
#define PSTRINGV_cfR(A,B,D) RRRRPSTRV(_fcdtocp(A),B,_fcdlen(A))
#else
#define  PSTRING_cfR(A,B,D) RRRRPSTR( A,B,D)
#define PSTRINGV_cfR(A,B,D) RRRRPSTRV(A,B,D)
#endif
#endif
#define PNSTRING_cfR(A,B,D) PSTRING_cfR(A,B,D)
#define PPSTRING_cfR(A,B,D)

#define    BYTE_cfFZ(UN,LN) INTEGER_BYTE     FCALLSC_QUALIFIER fcallsc(UN,LN)(
#define  DOUBLE_cfFZ(UN,LN) DOUBLE_PRECISION FCALLSC_QUALIFIER fcallsc(UN,LN)(
#define     INT_cfFZ(UN,LN) int   FCALLSC_QUALIFIER fcallsc(UN,LN)(
#define LOGICAL_cfFZ(UN,LN) int   FCALLSC_QUALIFIER fcallsc(UN,LN)(
#define    LONG_cfFZ(UN,LN) long  FCALLSC_QUALIFIER fcallsc(UN,LN)(
#define   SHORT_cfFZ(UN,LN) short FCALLSC_QUALIFIER fcallsc(UN,LN)(
#define    VOID_cfFZ(UN,LN) void  FCALLSC_QUALIFIER fcallsc(UN,LN)(
#ifndef __CF__KnR
/* The void is req'd by the Apollo, to make this an ANSI function declaration.
   The Apollo promotes K&R float functions to double. */
#define   FLOAT_cfFZ(UN,LN) FORTRAN_REAL FCALLSC_QUALIFIER fcallsc(UN,LN)(void
#ifdef vmsFortran
#define  STRING_cfFZ(UN,LN) void  FCALLSC_QUALIFIER fcallsc(UN,LN)(fstring *AS
#else
#ifdef CRAYFortran
#define  STRING_cfFZ(UN,LN) void  FCALLSC_QUALIFIER fcallsc(UN,LN)(_fcd     AS
#else
#if  defined(AbsoftUNIXFortran) || defined(AbsoftProFortran)
#define  STRING_cfFZ(UN,LN) void  FCALLSC_QUALIFIER fcallsc(UN,LN)(char    *AS
#else
#define  STRING_cfFZ(UN,LN) void  FCALLSC_QUALIFIER fcallsc(UN,LN)(char    *AS, unsigned D0
#endif
#endif
#endif
#else
#if ! (defined(FLOATFUNCTIONTYPE)&&defined(ASSIGNFLOAT)&&defined(RETURNFLOAT))
#define   FLOAT_cfFZ(UN,LN) FORTRAN_REAL      FCALLSC_QUALIFIER fcallsc(UN,LN)(
#else
#define   FLOAT_cfFZ(UN,LN) FLOATFUNCTIONTYPE FCALLSC_QUALIFIER fcallsc(UN,LN)(
#endif
#if defined(vmsFortran) || defined(CRAYFortran) || defined(AbsoftUNIXFortran)
#define  STRING_cfFZ(UN,LN) void  FCALLSC_QUALIFIER fcallsc(UN,LN)(AS
#else
#define  STRING_cfFZ(UN,LN) void  FCALLSC_QUALIFIER fcallsc(UN,LN)(AS, D0
#endif
#endif

#define    BYTE_cfF(UN,LN)     BYTE_cfFZ(UN,LN)
#define  DOUBLE_cfF(UN,LN)   DOUBLE_cfFZ(UN,LN)
#ifndef __CF_KnR
#define   FLOAT_cfF(UN,LN)  FORTRAN_REAL FCALLSC_QUALIFIER fcallsc(UN,LN)(
#else
#define   FLOAT_cfF(UN,LN)    FLOAT_cfFZ(UN,LN)
#endif
#define     INT_cfF(UN,LN)      INT_cfFZ(UN,LN)
#define LOGICAL_cfF(UN,LN)  LOGICAL_cfFZ(UN,LN)
#define    LONG_cfF(UN,LN)     LONG_cfFZ(UN,LN)
#define   SHORT_cfF(UN,LN)    SHORT_cfFZ(UN,LN)
#define    VOID_cfF(UN,LN)     VOID_cfFZ(UN,LN)
#define  STRING_cfF(UN,LN)   STRING_cfFZ(UN,LN),

#define     INT_cfFF
#define    VOID_cfFF
#ifdef vmsFortran
#define  STRING_cfFF           fstring *AS; 
#else
#ifdef CRAYFortran
#define  STRING_cfFF           _fcd     AS;
#else
#define  STRING_cfFF           char    *AS; unsigned D0;
#endif
#endif

#define     INT_cfL            A0=
#define  STRING_cfL            A0=
#define    VOID_cfL                        

#define    INT_cfK
#define   VOID_cfK
/* KSTRING copies the string into the position provided by the caller. */
#ifdef vmsFortran
#define STRING_cfK                                                             \\
 memcpy(AS->dsc$a_pointer,A0,_cfMIN(AS->dsc$w_length,(A0==NULL?0:strlen(A0))));\\
 AS->dsc$w_length>(A0==NULL?0:strlen(A0))?                                     \\
  memset(AS->dsc$a_pointer+(A0==NULL?0:strlen(A0)),' ',                        \\
         AS->dsc$w_length-(A0==NULL?0:strlen(A0))):0;
#else
#ifdef CRAYFortran
#define STRING_cfK                                                             \\
 memcpy(_fcdtocp(AS),A0, _cfMIN(_fcdlen(AS),(A0==NULL?0:strlen(A0))) );        \\
 _fcdlen(AS)>(A0==NULL?0:strlen(A0))?                                          \\
  memset(_fcdtocp(AS)+(A0==NULL?0:strlen(A0)),' ',                             \\
         _fcdlen(AS)-(A0==NULL?0:strlen(A0))):0;
#else
#define STRING_cfK         memcpy(AS,A0, _cfMIN(D0,(A0==NULL?0:strlen(A0))) ); \\
                 D0>(A0==NULL?0:strlen(A0))?memset(AS+(A0==NULL?0:strlen(A0)), \\
                                            ' ', D0-(A0==NULL?0:strlen(A0))):0;
#endif
#endif

/* Note that K.. and I.. can't be combined since K.. has to access data before
R.., in order for functions returning strings which are also passed in as
arguments to work correctly. Note that R.. frees and hence may corrupt the
string. */
#define    BYTE_cfI  return A0;
#define  DOUBLE_cfI  return A0;
#if ! (defined(FLOATFUNCTIONTYPE)&&defined(ASSIGNFLOAT)&&defined(RETURNFLOAT))
#define   FLOAT_cfI  return A0;
#else
#define   FLOAT_cfI  RETURNFLOAT(A0);
#endif
#define     INT_cfI  return A0;
#ifdef hpuxFortran800
/* Incredibly, functions must return true as 1, elsewhere .true.==0x01000000. */
#define LOGICAL_cfI  return ((A0)?1:0);
#else
#define LOGICAL_cfI  return C2FLOGICAL(A0);
#endif
#define    LONG_cfI  return A0;
#define   SHORT_cfI  return A0;
#define  STRING_cfI  return   ;
#define    VOID_cfI  return   ;

#ifdef OLD_VAXC                                  /* Allow %CC-I-PARAMNOTUSED. */
#pragma standard
#endif

#define FCALLSCSUB0( CN,UN,LN)             FCALLSCFUN0(VOID,CN,UN,LN)
#define FCALLSCSUB1( CN,UN,LN,T1)          FCALLSCFUN1(VOID,CN,UN,LN,T1)
#define FCALLSCSUB2( CN,UN,LN,T1,T2)       FCALLSCFUN2(VOID,CN,UN,LN,T1,T2)
#define FCALLSCSUB3( CN,UN,LN,T1,T2,T3)    FCALLSCFUN3(VOID,CN,UN,LN,T1,T2,T3)
#define FCALLSCSUB4( CN,UN,LN,T1,T2,T3,T4) \\
    FCALLSCFUN4(VOID,CN,UN,LN,T1,T2,T3,T4)
#define FCALLSCSUB5( CN,UN,LN,T1,T2,T3,T4,T5) \\
    FCALLSCFUN5(VOID,CN,UN,LN,T1,T2,T3,T4,T5)
#define FCALLSCSUB6( CN,UN,LN,T1,T2,T3,T4,T5,T6) \\
    FCALLSCFUN6(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6)       
#define FCALLSCSUB7( CN,UN,LN,T1,T2,T3,T4,T5,T6,T7) \\
    FCALLSCFUN7(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7)
#define FCALLSCSUB8( CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8) \\
    FCALLSCFUN8(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8)
#define FCALLSCSUB9( CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9) \\
    FCALLSCFUN9(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9)
#define FCALLSCSUB10(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA) \\
   FCALLSCFUN10(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA)
#define FCALLSCSUB11(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB) \\
   FCALLSCFUN11(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB)
#define FCALLSCSUB12(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC) \\
   FCALLSCFUN12(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC)
#define FCALLSCSUB13(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD) \\
   FCALLSCFUN13(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD)
#define FCALLSCSUB14(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE) \\
   FCALLSCFUN14(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)
#define FCALLSCSUB15(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF) \\
   FCALLSCFUN15(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF)
#define FCALLSCSUB16(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG) \\
   FCALLSCFUN16(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG)
#define FCALLSCSUB17(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH) \\
   FCALLSCFUN17(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH)
#define FCALLSCSUB18(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI) \\
   FCALLSCFUN18(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI)
#define FCALLSCSUB19(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ) \\
   FCALLSCFUN19(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ)
#define FCALLSCSUB20(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK) \\
   FCALLSCFUN20(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK)
#define FCALLSCSUB21(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL) \\
   FCALLSCFUN21(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL)
#define FCALLSCSUB22(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM) \\
   FCALLSCFUN22(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM)
#define FCALLSCSUB23(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN) \\
   FCALLSCFUN23(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN)
#define FCALLSCSUB24(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO) \\
   FCALLSCFUN24(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO)
#define FCALLSCSUB25(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP) \\
   FCALLSCFUN25(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP)
#define FCALLSCSUB26(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ) \\
   FCALLSCFUN26(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ)
#define FCALLSCSUB27(CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR) \\
   FCALLSCFUN27(VOID,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)


#define FCALLSCFUN1( T0,CN,UN,LN,T1) \\
        FCALLSCFUN5 (T0,CN,UN,LN,T1,CF_0,CF_0,CF_0,CF_0)
#define FCALLSCFUN2( T0,CN,UN,LN,T1,T2) \\
        FCALLSCFUN5 (T0,CN,UN,LN,T1,T2,CF_0,CF_0,CF_0)
#define FCALLSCFUN3( T0,CN,UN,LN,T1,T2,T3) \\
        FCALLSCFUN5 (T0,CN,UN,LN,T1,T2,T3,CF_0,CF_0)
#define FCALLSCFUN4( T0,CN,UN,LN,T1,T2,T3,T4) \\
        FCALLSCFUN5 (T0,CN,UN,LN,T1,T2,T3,T4,CF_0)
#define FCALLSCFUN5( T0,CN,UN,LN,T1,T2,T3,T4,T5) \\
        FCALLSCFUN10(T0,CN,UN,LN,T1,T2,T3,T4,T5,CF_0,CF_0,CF_0,CF_0,CF_0)
#define FCALLSCFUN6( T0,CN,UN,LN,T1,T2,T3,T4,T5,T6) \\
        FCALLSCFUN10(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,CF_0,CF_0,CF_0,CF_0)
#define FCALLSCFUN7( T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7) \\
        FCALLSCFUN10(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,CF_0,CF_0,CF_0)
#define FCALLSCFUN8( T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8) \\
        FCALLSCFUN10(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,CF_0,CF_0)
#define FCALLSCFUN9( T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9) \\
        FCALLSCFUN10(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,CF_0)
#define FCALLSCFUN10(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA) \\
        FCALLSCFUN14(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,CF_0,CF_0,CF_0,CF_0)
#define FCALLSCFUN11(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB) \\
        FCALLSCFUN14(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,CF_0,CF_0,CF_0)
#define FCALLSCFUN12(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC) \\
        FCALLSCFUN14(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,CF_0,CF_0)
#define FCALLSCFUN13(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD) \\
        FCALLSCFUN14(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,CF_0)


#define FCALLSCFUN15(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF) \\
        FCALLSCFUN20(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,CF_0,CF_0,CF_0,CF_0,CF_0)
#define FCALLSCFUN16(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG) \\
        FCALLSCFUN20(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,CF_0,CF_0,CF_0,CF_0)
#define FCALLSCFUN17(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH) \\
        FCALLSCFUN20(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,CF_0,CF_0,CF_0)
#define FCALLSCFUN18(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI) \\
        FCALLSCFUN20(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,CF_0,CF_0)
#define FCALLSCFUN19(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ) \\
        FCALLSCFUN20(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,CF_0)
#define FCALLSCFUN20(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK) \\
        FCALLSCFUN27(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0)
#define FCALLSCFUN21(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL) \\
        FCALLSCFUN27(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,CF_0,CF_0,CF_0,CF_0,CF_0,CF_0)
#define FCALLSCFUN22(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM) \\
        FCALLSCFUN27(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,CF_0,CF_0,CF_0,CF_0,CF_0)
#define FCALLSCFUN23(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN) \\
        FCALLSCFUN27(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,CF_0,CF_0,CF_0,CF_0)
#define FCALLSCFUN24(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO) \\
        FCALLSCFUN27(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,CF_0,CF_0,CF_0)
#define FCALLSCFUN25(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP) \\
        FCALLSCFUN27(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,CF_0,CF_0)
#define FCALLSCFUN26(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ) \\
        FCALLSCFUN27(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,CF_0)


#ifndef __CF__KnR
#define FCALLSCFUN0(T0,CN,UN,LN) CFextern _(T0,_cfFZ)(UN,LN) ABSOFT_cf2(T0))   \\
        {_Icf(2,UU,T0,A0,0); _Icf(0,L,T0,0,0) CN(); _Icf(0,K,T0,0,0) _(T0,_cfI)}

#define FCALLSCFUN14(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)    \\
                                 CFextern _(T0,_cfF)(UN,LN)                    \\
 CFARGT14(NCF,DCF,ABSOFT_cf2(T0),T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE) )  \\
 {                 CFARGT14S(QCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)    \\
  _Icf(2,UU,T0,A0,0); _Icf(0,L,T0,0,0)      CN(    TCF(LN,T1,1,0)  TCF(LN,T2,2,1) \\
    TCF(LN,T3,3,1)  TCF(LN,T4,4,1) TCF(LN,T5,5,1)  TCF(LN,T6,6,1)  TCF(LN,T7,7,1) \\
    TCF(LN,T8,8,1)  TCF(LN,T9,9,1) TCF(LN,TA,10,1) TCF(LN,TB,11,1) TCF(LN,TC,12,1) \\
    TCF(LN,TD,13,1) TCF(LN,TE,14,1) );                          _Icf(0,K,T0,0,0) \\
                   CFARGT14S(RCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)  _(T0,_cfI) }

#define FCALLSCFUN27(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)   \\
                                 CFextern _(T0,_cfF)(UN,LN)                    \\
 CFARGT27(NCF,DCF,ABSOFT_cf2(T0),T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR) ) \\
 {                 CFARGT27S(QCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)   \\
  _Icf(2,UU,T0,A0,0); _Icf(0,L,T0,0,0)      CN(     TCF(LN,T1,1,0)  TCF(LN,T2,2,1)  \\
    TCF(LN,T3,3,1)  TCF(LN,T4,4,1)  TCF(LN,T5,5,1)  TCF(LN,T6,6,1)  TCF(LN,T7,7,1)  \\
    TCF(LN,T8,8,1)  TCF(LN,T9,9,1)  TCF(LN,TA,10,1) TCF(LN,TB,11,1) TCF(LN,TC,12,1) \\
    TCF(LN,TD,13,1) TCF(LN,TE,14,1) TCF(LN,TF,15,1) TCF(LN,TG,16,1) TCF(LN,TH,17,1) \\
    TCF(LN,TI,18,1) TCF(LN,TJ,19,1) TCF(LN,TK,20,1) TCF(LN,TL,21,1) TCF(LN,TM,22,1) \\
    TCF(LN,TN,23,1) TCF(LN,TO,24,1) TCF(LN,TP,25,1) TCF(LN,TQ,26,1) TCF(LN,TR,27,1) ); _Icf(0,K,T0,0,0) \\
                   CFARGT27S(RCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)  _(T0,_cfI) }

#else
#define FCALLSCFUN0(T0,CN,UN,LN) CFextern _(T0,_cfFZ)(UN,LN) ABSOFT_cf3(T0)) _Icf(0,FF,T0,0,0)\\
        {_Icf(2,UU,T0,A0,0); _Icf(0,L,T0,0,0) CN(); _Icf(0,K,T0,0,0) _(T0,_cfI)}

#define FCALLSCFUN14(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)    \\
                                 CFextern _(T0,_cfF)(UN,LN)                    \\
 CFARGT14(NNCF,DDCF,ABSOFT_cf3(T0),T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)) _Icf(0,FF,T0,0,0) \\
       CFARGT14FS(NNNCF,DDDCF,_Z,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE);   \\
 {                 CFARGT14S(QCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)    \\
  _Icf(2,UU,T0,A0,0); _Icf(0,L,T0,0,0)      CN(  TCF(LN,T1,1,0) TCF(LN,T2,2,1) \\
    TCF(LN,T3,3,1) TCF(LN,T4,4,1) TCF(LN,T5,5,1) TCF(LN,T6,6,1) TCF(LN,T7,7,1) \\
    TCF(LN,T8,8,1) TCF(LN,T9,9,1) TCF(LN,TA,10,1) TCF(LN,TB,11,1) TCF(LN,TC,12,1) \\
    TCF(LN,TD,13,1) TCF(LN,TE,14,1) );                          _Icf(0,K,T0,0,0) \\
                   CFARGT14S(RCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE)  _(T0,_cfI)}

#define FCALLSCFUN27(T0,CN,UN,LN,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)  \\
                                 CFextern _(T0,_cfF)(UN,LN)                    \\
 CFARGT27(NNCF,DDCF,ABSOFT_cf3(T0),T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)) _Icf(0,FF,T0,0,0) \\
       CFARGT27FS(NNNCF,DDDCF,_Z,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR); \\
 {                 CFARGT27S(QCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)  \\
  _Icf(2,UU,T0,A0,0); _Icf(0,L,T0,0,0)      CN(     TCF(LN,T1,1,0)  TCF(LN,T2,2,1)  \\
    TCF(LN,T3,3,1)  TCF(LN,T4,4,1)  TCF(LN,T5,5,1)  TCF(LN,T6,6,1)  TCF(LN,T7,7,1)  \\
    TCF(LN,T8,8,1)  TCF(LN,T9,9,1)  TCF(LN,TA,10,1) TCF(LN,TB,11,1) TCF(LN,TC,12,1) \\
    TCF(LN,TD,13,1) TCF(LN,TE,14,1) TCF(LN,TF,15,1) TCF(LN,TG,16,1) TCF(LN,TH,17,1) \\
    TCF(LN,TI,18,1) TCF(LN,TJ,19,1) TCF(LN,TK,20,1) TCF(LN,TL,21,1) TCF(LN,TM,22,1) \\
    TCF(LN,TN,23,1) TCF(LN,TO,24,1) TCF(LN,TP,25,1) TCF(LN,TQ,26,1) TCF(LN,TR,27,1) ); _Icf(0,K,T0,0,0) \\
                   CFARGT27S(RCF,T1,T2,T3,T4,T5,T6,T7,T8,T9,TA,TB,TC,TD,TE,TF,TG,TH,TI,TJ,TK,TL,TM,TN,TO,TP,TQ,TR)  _(T0,_cfI)}

#endif
#ifdef __cplusplus
}
#endif


#endif	 /* __CFORTRAN_LOADED */
"
      cpp_src "#define sunFortran
#include \"evaluator/cfortran.hpp\"

#include \"utility/fuzzy_equals.hpp\"
#include \"utility/mathutil.hpp\"

namespace
{
int fuzzy_equal(double a, double b)
{
  return utility::feq< double >(a,b,32);
}

int next_64(int a)
{
  return static_cast<int>( utility::mathutil::next64( static_cast<std::size_t>(a) ) );
}

void pretty_print_number(double *a_dbl, char *a_result, int *sz)
{
  char fmt[16];
  fmt[0]='%';
  if (*sz < 9)
    snprintf(&fmt[1],15,\"-%d.%dG\",*sz,2);
  else
    snprintf(&fmt[1],15,\"-%d.%dG\",*sz,*sz-7);
  snprintf(a_result,*sz,fmt,*a_dbl);
}
}
FCALLSCFUN2(LOGICAL,fuzzy_equal,DFEQ,dfeq,DOUBLE,DOUBLE)
FCALLSCSUB3(pretty_print_number,FMTFL2,fmtfl2,PDOUBLE,PSTRING,PINT)
FCALLSCFUN1(INT,next_64,NEXT64,next64,INT)
"
      associated_classes
      end
      comment "/* cfortran.h  4.3 */
/* http://www-zeus.desy.de/~burow/cfortran/                   */
/* Burkhard Burow  burow@desy.de                 1990 - 2001. */
/* 
   THIS FILE IS PROPERTY OF BURKHARD BUROW. IF YOU ARE USING THIS FILE YOU
   SHOULD ALSO HAVE ACCESS TO CFORTRAN.DOC WHICH PROVIDES TERMS FOR USING,
   MODIFYING, COPYING AND DISTRIBUTING THE CFORTRAN.H PACKAGE.
*/

/* cfortran.doc */            /* anonymous ftp: zebra.desy.de */
/* Burkhard Burow, burow@vxdesy.cern.ch, U. of Toronto, 1993. */
//  
//  
//                   cfortran.h 2.8  :  Interfacing C and FORTRAN
//  
//  Supports: Alpha and VAX VMS, Alpha OSF, DECstation and VAX Ultrix, IBM RS/6000, 
//            Silicon Graphics, Sun, CRAY, Apollo, HP9000, LynxOS, f2c, NAG f90.
//  
//  
//  0 Short Summary of the Syntax Required to Create the Interface
//  --------------------------------------------------------------
//  
//  e.g. Prototyping a FORTRAN subroutine for C: [other argument types.]
//                                 - -
//                                | 0 |
//                                | 1 |
//                                 - -
//  #define SUB_NAME(A,B) CCALLSFSUB2(SUB_NAME,sub_name,STRING,PINT, A,B)
//                                 - -    -                                       -
//                                | 3 |  |   STRING   BYTE    PBYTE       BYTEV(..)|
//                                | 4 |  |   STRINGV  DOUBLE  PDOUBLE   DOUBLEV(..)|
//                                | : |  |  PSTRING   FLOAT   PFLOAT     FLOATV(..)|
//                                | : |  | PNSTRING   INT     PINT         INTV(..)|
//                                |19 |  | PPSTRING   LOGICAL PLOGICAL LOGICALV(..)|
//                                |20 |  |  PSTRINGV  LONG    PLONG       LONGV(..)|
//                                | : |  |   ZTRINGV  SHORT   PSHORT     SHORTV(..)|
//                                | : |  |  PZTRINGV  ROUTINE PVOID      SIMPLE    |
//                                 - -    -                                       -
//  
//  e.g. Prototyping a FORTRAN function for C:
//  PROTOCCALLSFFUN1(INT,FUN_NAME,fun_name,STRING)
//  #define FUN_NAME(A)  CCALLSFFUN1(FUN_NAME,fun_name,STRING, A)
//  
//  e.g. calling FUN_NAME from C:    {int a; a = FUN_NAME(\"hello\");}
//  
//  e.g. Creating a FORTRAN-callable wrapper for
//       a C function returning void, with a 7 dimensional integer array argument:
//  FCALLSCSUB1(csub_name,CSUB_NAME,csub_name,INTVVVVVVV)
//  
//  e.g. Creating a FORTRAN-callable wrapper for other C functions:
//  FCALLSCFUN1(STRING,cfun_name,CFUN_NAME,cfun_name,INT)
//             [ ^-- BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG, SHORT, VOID  
//               are other types returned by functions.       ]
//         
//  e.g. COMMON BLOCKs:
//  FORTRAN:                         common /fcb/  v,w,x
//                                   character *(13) v, w(4), x(3,2)
//  C:
//  typedef struct { char v[13],w[4][13],x[2][3][13]; } FCB_DEF;
//  #define FCB COMMON_BLOCK(FCB,fcb)
//  COMMON_BLOCK_DEF(FCB_DEF,FCB);
//  
//  e.g. accessing FCB in C:          printf(\"%.13s\",FCB.v);
//  
//  
//  
//  I Introduction
//  --------------
//  
//  cfortran.h is an easy-to-use powerful bridge between C and FORTRAN. It provides
//  a completely transparent, machine independent interface between C and FORTRAN
//  routines (= subroutines and/or functions) and global data, i.e. structures and
//  COMMON blocks.
//  
//  The complete cfortran.h package consists of 4 files: the documentation in
//  cfortran.doc, the engine cfortran.h, examples in cfortest.c and 
//  cfortex.f/or. [cfortex.for under VMS, cfortex.f on other machines.]
//  
//  The cfortran.h package continues to be developed. The most recent version is
//  available via anonymous ftp at zebra.desy.de (131.169.2.244).
//  
//  The examples may be run using one of the following sets of instructions:
//  [The first set of instructions is also required with, and only with, ANSI C.]
//  
//  ANSI> # cfortran.h is distributed with the /**/ prepro-token-catenation kludge.
//  ANSI> # To make cfortran.h ANSI compliant and for it to run on:
//  ANSI> # -- RS/6000, CRAY, Apollo C >=Rev6.8, LynxOS, gcc, SGI ANSI C --------
//  ANSI> # -----------DEC C for OpenVMS 1.3 or OSF, HP 'cc -Aa' ----------------
//  ANSI> # -------------------- and other ANSI C compilers ---------------------
//  ANSI> # --------- [Non-ANSI compilers CAN NOT use an ANSI cfortran.h.] ------
//  ANSI> # Do the following once to cfortran.h to replace all '/**/' with '##\":
//  unix> mv cfortran.h cf_temp.h &&sed 's/\\/\\*\\*\\//##/g' cf_temp.h >cfortran.h
//  VMS > ! [Please e-mail the VMS equivalent to the author for inclusion here.]
//  
//  RS/6000> # Users are strongly urged to use f77 -qextname and cc -Dextname
//  RS/6000> xlf -c -qextname cfortex.f
//  RS/6000> cc  -c -Dextname cfortest.c
//  RS/6000> xlf -o cfortest cfortest.o cfortex.o && cfortest 
//  
//  DECFortran> #Only DECstations with DECFortran for Ultrix RISC Systems.
//  DECFortran> cc -c -DDECFortran cfortest.c
//  DECFortran> f77 -o cfortest cfortest.o cfortex.f  &&  cfortest
//  
//  MIPS> # DECstations and Silicon Graphics using the MIPS compilers.
//  MIPS> cc -o cfortest cfortest.c cfortex.f -lI77 -lU77 -lF77  &&  cfortest
//  
//  Apollo> # Some 'C compiler 68K Rev6.8' break. [See Section II o) Notes: Apollo]
//  Apollo> f77 -c cfortex.f && cc -o cfortest cfortest.c cfortex.o  &&  cfortest
//  
//  VMS> define lnk$library sys$library:vaxcrtl
//  VMS> cc cfortest.c
//  VMS> fortran cfortex.for
//  VMS> link/exec=cfortest cfortest,cfortex
//  VMS> run cfortest
//  
//  Alpha/OSF> cc -c -Dmain=MAIN__ cfortest.c
//  Alpha/OSF> f77 -o cfortest cfortest.o cfortex.f  &&  cfortest
//  
//  Sun> # Some old cc(1) need a little help. [See Section II o) Notes: Sun]
//  Sun> f77 -o cfortest cfortest.c cfortex.f -lc -lm  &&  cfortest
//  Sun> # Some f77 don't invoke cc and the libF77.a requires _MAIN_, so instead do:
//  Sun> f77 -c cfortex.f
//  Sun> cc -o cfortest -c -Dmain=MAIN_ cfortest.c cfortex.o -lF77 -lc
//  Sun> # or
//  Sun> cc -c -Dmain=MAIN_ cfortest.c
//  Sun> f77 -o cfortest cfortest.o cfortex.f -lc -lm
//  
//  CRAY> cft77 cfortex.f
//  CRAY> cc -c cfortest.c
//  CRAY> segldr -o cfortest.e cfortest.o cfortex.o
//  CRAY> ./cfortest.e
//  
//  VAX/Ultrix/cc> # For cc on VAX Ultrix only, do the following once to cfortran.h.
//  VAX/Ultrix/cc> mv cfortran.h cftmp.h && grep -v \"^#pragma\" <cftmp.h >cfortran.h
//                                              
//  VAX/Ultrix/f77> # In the following, 'CC' is either 'cc' or 'gcc -ansi'. NOT'vcc'
//  VAX/Ultrix/f77> CC -c -Dmain=MAIN_ cfortest.c
//  VAX/Ultrix/f77> f77 -o cfortest cfortex.f cfortest.o  &&  cfortest
//  
//  LynxOS> # In the following, 'CC' is either 'cc' or 'gcc -ansi'.
//  LynxOS> # Unfortunately cc is easily overwhelmed by cfortran.h,
//  LynxOS> #  and won't compile some of the cfortest.c demos.
//  LynxOS> f2c -R cfortex.f
//  LynxOS> CC -Dlynx -o cfortest cfortest.c cfortex.c -lf2c  &&  cfortest
//  
//  HP9000> # Tested with HP-UX 7.05 B 9000/380 and with A.08.07 A 9000/730
//  HP9000> # CC may be either 'c89 -Aa' or 'cc -Aa'
//  HP9000> #    Depending on the compiler version, you may need to include the
//  HP9000> #    option '-tp,/lib/cpp' or worse, you'll have to stick to the K&R C.
//  HP9000> #    [See Section II o) Notes: HP9000]
//  HP9000> # Users are strongly urged to use f77 +ppu and cc -Dextname
//  HP9000> CC  -Dextname -c cfortest.c
//  HP9000> f77 +ppu         cfortex.f  -o cfortest cfortest.o && cfortest
//  HP9000> # Older f77 may need
//  HP9000> f77 -c cfortex.f
//  HP9000> CC -o cfortest cfortest.c cfortex.o -lI77 -lF77 && cfortest
//  
//  f2c> # In the following, 'CC' is any C compiler.
//  f2c> f2c -R cfortex.f
//  f2c> CC -o cfortest -Df2cFortran cfortest.c cfortex.c -lf2c  &&  cfortest
//  
//  NAGf90> # cfortex.f is distributed with Fortran 77 style comments.
//  NAGf90> # To convert to f90 style comments do the following once to cfortex.f: 
//  NAGf90> mv cfortex.f cf_temp.f && sed 's/^C/\\!/g' cf_temp.f > cfortex.f
//  NAGf90> # In the following, 'CC' is any C compiler.
//  NAGf90> CC -c -DNAGf90Fortran cfortest.c
//  NAGf90> f90 -o cfortest cfortest.o cfortex.f &&  cfortest
//  
//  
//  By changing the SELECTion ifdef of cfortest.c and recompiling one can try out
//  two dozen different few-line examples.
//  
//  
//  
//  The benefits of using cfortran.h include:
//  1. Machine/OS/compiler independent mixing of C and FORTRAN.
//  
//  2. Identical (within syntax) calls across languages, e.g.
//  C FORTRAN
//        CALL HBOOK1(1,'pT spectrum of pi+',100,0.,5.,0.)
//  /* C*/
//             HBOOK1(1,\"pT spectrum of pi+\",100,0.,5.,0.);
//  
//  3. Each routine need only be set up once in its lifetime. e.g.
//  /* Setting up a FORTRAN routine to be called by C.
//     ID,...,VMX are merely the names of arguments.
//     These tags must be unique w.r.t. each other but are otherwise arbitrary. */
//  #define HBOOK1(ID,CHTITLE,NX,XMI,XMA,VMX)                    \\
//   CCALLSFSUB6(HBOOK1,hbook1,INT,STRING,INT,FLOAT,FLOAT,FLOAT, \\
//                 ID,CHTITLE,NX,XMI,XMA,VMX) 
//  
//  4. Source code is NOT required for the C routines exported to FORTRAN, nor for
//     the FORTRAN routines imported to C. In fact, routines are most easily
//     prototyped using the information in the routines' documentation.
//  
//  5. Routines, and the code calling them, can be coded naturally in the language
//     of choice. C routines may be coded with the natural assumption of being 
//     called only by C code. cfortran.h does all the required work for FORTRAN 
//     code to call C routines. Similarly it also does all the work required for C
//     to call FORTRAN routines. Therefore:
//       - C programmers need not embed FORTRAN argument passing mechanisms into 
//         their code.
//       - FORTRAN code need not be converted into C code. i.e. The honed and 
//         time-honored FORTRAN routines are called by C.
//  
//  6. cfortran.h is a single ~1700 line C include file; portable to most
//     remaining, if not all, platforms.
//  
//  7. STRINGS and VECTORS of STRINGS along with the usual simple arguments to 
//     routines are supported as are functions returning STRINGS or numbers. Arrays
//     of pointers to strings and values of structures as C arguments, will soon be
//     implemented. After learning the machinery of cfortran.h, users can expand 
//     it to create custom types of arguments. [This requires no modification to
//     cfortran.h, all the preprocessor directives required to implement the
//     custom types can be defined outside cfortran.h]
//  
//  8. cfortran.h requires each routine to be exported to be explicitly set up. 
//     While is usually only be done once in a header file it would be best if
//     applications were required to do no work at all in order to cross languages.
//     cfortran.h's simple syntax could be a convenient back-end for a program
//     which would export FORTRAN or C routines directly from the source code. 
//  
//  
//                                      -----
//  
//  Example 1 - cfortran.h has been used to make the C header file hbook.h, 
//              which then gives any C programmer, e.g. example.c, full and 
//              completely transparent access to CERN's HBOOK library of routines.
//              Each HBOOK routine required about 3 lines of simple code in
//              hbook.h. The example also demonstrates how FORTRAN common blocks
//              are defined and used.
//  
//  /* hbook.h */
//  #include \"cfortran.h\"
//          :
//  #define HBOOK1(ID,CHTITLE,NX,XMI,XMA,VMX) \\
//       CCALLSFSUB6(HBOOK1,hbook1,INT,STRING,INT,FLOAT,FLOAT,FLOAT, \\
//                 ID,CHTITLE,NX,XMI,XMA,VMX) 
//          :
//  /* end hbook.h */
//  
//  /* example.c */
//  #include \"hbook.h\"
//          :
//  typedef struct {
//    int lines;  
//    int status[SIZE];
//    float p[SIZE];  /* momentum */
//  } FAKE_DEF;
//  #define FAKE COMMON_BLOCK(FAKE,fake)
//  COMMON_BLOCK_DEF(FAKE_DEF,FAKE);
//          :
//  main ()
//  {
//          :
//             HBOOK1(1,\"pT spectrum of pi+\",100,0.,5.,0.);
//  /* c.f. the call in FORTRAN:
//        CALL HBOOK1(1,'pT spectrum of pi+',100,0.,5.,0.)
//  */
//          :
//    FAKE.p[7]=1.0;
//  	:
//  }           
//  
//  N.B. i) The routine is language independent.
//      ii) hbook.h is machine independent.  
//     iii) Applications using routines via cfortran.h are machine independent.
//  
//                                      -----
//  
//  Example 2 - Many VMS System calls are most easily called from FORTRAN, but
//              cfortran.h now gives that ease in C.
//  
//  #include \"cfortran.h\"
//  
//  #define LIB$SPAWN(command,input_file,output_file) \\
//       CCALLSFSUB3(LIB$SPAWN,lib$spawn,STRING,STRING,STRING, \\
//                    command,input_file,output_file)
//  
//  main ()
//  {
//  LIB$SPAWN(\"set term/width=132\",\"\",\"\");
//  }
//  
//  Obviously the cfortran.h command above could be put into a header file along
//  with the description of the other system calls, but as this example shows, it's
//  not much hassle to set up cfortran.h for even a single call.
//  
//                                      -----
//  
//  Example 3 - cfortran.h and the source cstring.c create the cstring.obj library 
//              which gives FORTRAN access to all the functions in C's system 
//              library described by the system's C header file string.h.
//  
//  C     EXAMPLE.FOR
//        PROGRAM EXAMPLE
//        DIMENSION I(20), J(30)
//          :
//        CALL MEMCPY(I,J,7)
//          :
//        END
//  
//  /* cstring.c */
//  #include <string.h>             /* string.h prototypes memcpy() */
//  #include \"cfortran.h\"
//  
//          :
//  FCALLSCSUB3(memcpy,MEMCPY,memcpy,PVOID,PVOID,INT)
//          :
//  
//  
//  The simplicity exhibited in the above example exists for many but not all
//  machines. Note 4. of Section II ii) details the limitations and describes tools
//  which try to maintain the best possible interface when FORTRAN calls C
//  routines.
//  
//                                      -----
//  
//  
//  II Using cfortran.h
//  -------------------
//  
//  The user is asked to look at the source files CFORTEST.C and CFORTEX.FOR for
//  clarification by example.
//  
//  o) Notes: 
//  
//  o Specifying the Fortran compiler
//    cfortran.h generates interfaces for the default Fortran compiler. The default
//  can be overridden by defining, 
//       . in the code, e.g.           #define    NAGf90Fortran
//    OR . in the compile directive, e.g.: unix> cc -DNAGf90Fortran
//  one of the following before including cfortran.h:
//   NAGf90Fortran   f2cFortran  hpuxFortran  apolloFortran  sunFortran
//    IBMR2Fortran  CRAYFortran  mipsFortran     DECFortran  vmsFortran
//  This also allows crosscompilation.
//  NAGf90Fortran, f2cFortran, DECFortran must be requested by the user if wanted.
//  
//  o /**/
//    cfortran.h (ab)uses the comment kludge, /**/, when the ANSI C preprocessor
//  catenation operator, ##, doesn't exist. In at least MIPS C, this kludge is
//  sensitive to  blanks surrounding arguments to macros.
//    Therefore, for applications using non-ANSI C compilers, the argtype_i,
//  routine_name, routine_type and common_block_name arguments to the
//  PROTOCCALLSFFUNn, CCALLSFSUB/FUNn, FCALLSCSUB/FUNn and COMMON_BLOCK macros 
//  --- MUST NOT --- be surrounded by any white space characters, [e.g. blanks,
//  tabs, newlines.]
//  
//  o LOGICAL
//    FORTRAN LOGICAL values of .TRUE. and .FALSE. do not agree with the C
//  representation of TRUE and FALSE on all machines. cfortran.h does the
//  conversion for LOGICAL and PLOGICAL arguments and for functions returning
//  LOGICAL. Users must convert arrays of LOGICALs from C to FORTRAN with the 
//  C2FLOGICALV(array_name, elements_in_array); macro. Similarly, arrays of LOGICAL
//  values may be converted from the FORTRAN into C representation by using
//  F2CLOGICALV(array_name, elements_in_array);
//  
//    When C passes or returns LOGICAL values to FORTRAN, by default cfortran.h 
//  only makes the minimal changes required to the value. [e.g. Set/Unset the 
//  single relevant bit or do nothing for FORTRAN compilers which use 0 as FALSE
//  and treat all other values as TRUE.] Therefore cfortran.h will pass LOGICALs
//  to FORTRAN which do not have an identical representation to .TRUE. or .FALSE.
//  This is fine except for abuses of FORTRAN/77 in the style of:
//         logical l
//         if (l .eq. .TRUE.)     ! (1)
//  instead of the correct:
//         if (l .eqv. .TRUE.)    ! (2)
//  or:
//         if (l)                 ! (3)
//  For FORTRAN code which treats LOGICALs from C in the method of (1),
//  LOGICAL_STRICT must be defined before including cfortran.h, either in the
//  code, \"#define LOGICAL_STRICT\", or compile with \"cc -DLOGICAL_STRICT\".
//  There is no reason to use LOGICAL_STRICT for FORTRAN code which does not do (1).
//  At least the IBM's xlf and the Apollo's f77 do not even allow code along the
//  lines of (1).
//  
//    DECstations' DECFortran and MIPS FORTRAN compilers use different internal
//  representations for LOGICAL values. [Both compilers are usually called f77,
//  although when both are installed on a single machine the MIPS' one is usually
//  renamed. (e.g. f772.1 for version 2.10.)] cc doesn't know which FORTRAN
//  compiler is present, so cfortran.h assumes MIPS f77. To use cc with DECFortran
//  define the preprocessor constant 'DECFortran'.
//  e.g.        i)  cc -DDECFortran -c the_code.c
//          or  ii) #define DECFortran  /* in the C code or add to cfortran.h. */
//  
//    MIPS f77 [SGI and DECstations], f2c, and f77 on VAX Ultrix treat
//  .eqv./.neqv. as .eq./.ne.. Therefore, for these compilers, LOGICAL_STRICT is
//  defined by default in cfortran.h. [The Sun and HP compilers have not been
//  tested, so they may also require LOGICAL_STRICT as the default.]
//  
//  o SHORT and BYTE 
//    They are irrelevant for the CRAY where FORTRAN has no equivalent to C's short.
//  Similarly BYTE is irrelevant for f2c and for VAX Ultrix f77 and fort. The
//  author has tested SHORT and BYTE with a modified cfortest.c/cfortex.f on all
//  machines supported except for the HP9000 and the Sun.
//  
//    BYTE is a signed 8-bit quantity, i.e. values are -128 to 127, on all machines
//  except for the SGI [at least for MIPS Computer Systems 2.0.] On the SGI it is
//  an unsigned 8-bit quantity, i.e. values are 0 to 255, although the SGI 'FORTRAN
//  77 Programmers Guide' claims BYTE is signed. Perhaps MIPS 2.0 is dated, since
//  the DECstations using MIPS 2.10 f77 have a signed BYTE.
//  
//    To minimize the difficulties of signed and unsigned BYTE, cfortran.h creates
//  the type 'INTEGER_BYTE' to agree with FORTRAN's BYTE. Users may define 
//  SIGNED_BYTE or UNSIGNED_BYTE, before including cfortran.h, to specify FORTRAN's
//  BYTE. If neither is defined, cfortran.h assumes SIGNED_BYTE.
//  
//  o CRAY
//    The type DOUBLE in cfortran.h corresponds to FORTRAN's DOUBLE PRECISION.
//  This implies DOUBLE corresponds to C's double on all machines except for the
//  CRAY where C's double is the same as float and DOUBLE corresponds instead to
//  C's long double. Therefore when moving a mixed C and FORTRAN to/from the CRAY,
//  either the C code will have to change, or the FORTRAN code and cfortran.h
//  commands will have to change.
//  
//  To help applications move effortlessly to/from the CRAY, cfortran.h defines the
//  preprocessor constant DOUBLE_PRECISION, which declares variables which are
//  equivalent to FORTRAN's DOUBLE PRECISION on all machines, including CRAY.
//  
//  o f2c
//    f2c, by default promotes REAL functions to double. cfortran.h does not (yet)
//  support this, so the f2c -R option must be used to turn this promotion off.
//  
//  o NAG f90
//    The Fortran 77 subset of Fortran 90 is supported. Extending cfortran.h to 
//  interface C with all of Fortran 90 has not yet been examined.
//    The NAG f90 library hijacks the main() of any program and starts the user's 
//  program with a call to: void f90_main(void);
//  While this in itself is only a minor hassle, a major problem arises because
//  NAG f90 provides no mechanism to access command line arguments.
//    At least version 'NAGWare f90 compiler Version 1.1(334)' appended _CB to
//  common block names instead of the usual _. To fix, add this to cfortran.h:
//  #ifdef old_NAG_f90_CB_COMMON
//  #define COMMON_BLOCK                 CFC_  /* for all other Fortran compilers */
//  #else
//  #define COMMON_BLOCK(UN,LN)          LN/**/_CB
//  #endif
//  
//  o RS/6000
//    Using \"xlf -qextname ...\", which appends an underscore, '_', to all FORTRAN
//  external references, requires \"cc -Dextname ...\" so that cfortran.h also
//  generates these underscores.
//  The use of \"xlf -qextname\" is STRONGLY ENCOURAGED, since it allows for
//  transparent naming schemes when mixing C and Fortran.
//  
//  o HP9000
//    Using \"f77 +ppu      ...\", which appends an underscore, '_', to all FORTRAN
//  external references, requires \"cc -Dextname ...\" so that cfortran.h also
//  generates these underscores.
//  The use of \"f77 +ppu\"      is STRONGLY ENCOURAGED, since it allows for
//  transparent naming schemes when mixing C and Fortran.
//  
//    At least one release of the HP /lib/cpp.ansi preprocessor is broken and will
//  go into an infinite loop when trying to process cfortran.h with the
//  ## catenation operator. The K&R version of cfortran.h must then be used and the
//  K&R preprocessor must be specified. e.g.
//                                           HP9000> cc -Aa -tp,/lib/cpp -c source.c
//  The same problem with a similar solution exists on the Apollo.
//  An irrelevant error message '0: extraneous name /usr/include' will appear for
//  each source file due to another HP bug, and can be safely ignored.
//  e.g. 'cc -v -c -Aa -tp,/lib/cpp cfortest.c' will show that the driver passes
//  '-I /usr/include' instead of '-I/usr/include' to /lib/cpp
//  
//  On some machines the above error causes compilation to stop; one must then use
//  K&R C, as with old HP compilers which don't support function prototyping.
//  cfortran.h has to be informed that K&R C is to being used, e.g.
//  HP9000> cc -D__CF__KnR -c source.c
//  
//  o Apollo
//  On at least one release, 'C compiler 68K Rev6.8(168)', the default C 
//  preprocessor, from cc -A xansi or cc -A ansi, enters an infinite loop when 
//  using cfortran.h. This Apollo bug can be circumvented by using:
//       . The standard cfortran.h, i.e. do not convert the '/**/' to '##'.
//   AND . The pre-ANSI preprocessor, i.e. use cc -Yp,/usr/lib
//  The same problem with a similar solution exists on the HP.
//  
//  o Sun
//  Old versions of cc(1), say <~1986, may require help for cfortran.h applications:
//   . #pragma may not be understood, hence cfortran.h and cfortest.c may require
//     sun> mv cfortran.h cftmp.h && grep -v \"^#pragma\" <cftmp.h >cfortran.h
//     sun> mv cfortest.c cftmp.c && grep -v \"^#pragma\" <cftmp.c >cfortest.c
//   . Old copies of math.h may not include the following from a newer math.h.
//     [For an ancient math.h on a 386 or sparc, get similar from a new math.h.]
//     #ifdef mc68000     /* 5 lines Copyright (c) 1988 by Sun Microsystems, Inc. */
//     #define FLOATFUNCTIONTYPE	int
//     #define RETURNFLOAT(x) 		return (*(int *)(&(x)))
//     #define ASSIGNFLOAT(x,y)	*(int *)(&x) = y
//     #endif
//  
//  o CRAY, Sun, Apollo [pre 6.8 cc], VAX Ultrix and HP9000
//    Only FORTRAN routines with less than 15 arguments can be prototyped for C,
//  since these compilers don't allow more than 31 arguments to a C macro. This can
//  be overcome, [see Section IV], with access to any C compiler without this
//  limitation, e.g. gcc, on ANY machine.
//  
//  o VAX Ultrix
//    vcc (1) with f77 is not supported. Although: 
//  VAXUltrix> f77 -c cfortex.f
//  VAXUltrix> vcc -o cfortest cfortest.c cfortex.o -lI77 -lU77 -lF77  &&  cfortest
//  will link and run. However, the FORTRAN standard I/O is NOT merged with the
//  stdin and stdout of C, and instead uses the files fort.6 and fort.5. For vcc,
//  f77 can't drive the linking, as for gcc and cc, since vcc objects must be
//  linked using lk (1).  f77 -v doesn't tell much, and without VAX Ultrix manuals,
//  the author can only wait for the info. required.
//  
//    fort (1) is not supported. Without VAX Ultrix manuals the author cannot 
//  convince vcc/gcc/cc and fort to generate names of routines and COMMON blocks
//  that match at the linker, lk (1). i.e. vcc/gcc/cc prepend a single underscore
//  to external references, e.g. NAME becomes _NAME, while fort does not modify the
//  references. So ... either fort has prepend an underscore to external
//  references, or vcc/gcc/cc have to generate unmodified names. man 1 fort
//  mentions JBL, is JBL the only way?
//  
//  o VAX VMS C
//    The compiler 'easily' exhausts its table space and generates:
//  %CC-F-BUGCHECK, Compiler bug check during parser phase    .
//                  Submit an SPR with a problem description.
//                  At line number 777 in DISK:[DIR]FILE.C;1.
//  where the line given, '777', includes a call across C and FORTRAN via
//  cfortran.h, usually with >7 arguments and/or very long argument expressions.
//  This SPR can be staved off, with the simple modification to cfortran.h, such
//  that the relevant CCALLSFSUBn (or CCALLSFFUNn or FCALLSCFUNn) is not
//  cascaded up to CCALLSFSUB14, and instead has its own copy of the contents of 
//  CCALLSFSUB14. [If these instructions are not obvious after examining cfortran.h
//  please contact the author.]
//  [Thanks go to Mark Kyprianou (kyp@stsci.edu) for this solution.]
//  
//  o Mips compilers
//    e.g. DECstations and SGI, require applications with a C main() and calls to
//  GETARG(3F), i.e. FORTRAN routines returning the command line arguments, to use
//  two macros as shown:
//          :
//  CF_DECLARE_GETARG;              /* This must be external to all routines.     */
//          :
//  main(int argc, char *argv[])
//  {
//          :
//  CF_SET_GETARG(argc,argv);       /* This must precede any calls to GETARG(3F). */
//          :
//  }
//  The macros are null and benign on all other systems. Sun's GETARG(3F) also
//  doesn't work with a generic C main() and perhaps a workaround similar to the
//  Mips' one exists.
//  
//  o Alpha/OSF
//  Using the DEC Fortran and the DEC C compilers of DEC OSF/1 [RT] V1.2 (Rev. 10),
//  Fortran, when called from C, has occasional trouble using a routine received as
//  a dummy argument.
//  
//  e.g. In the following the Fortran routine 'e' will crash when it tries to use
//       the C routine 'c' or the Fortran routine 'f'.
//       The example works on other systems.
//  
//  C FORTRAN                           /* C */
//        integer function f()          #include <stdio.h>
//        f = 2                         int f_();
//        return                        int e_(int (*u)());
//        end
//                                      int c(){ return 1;}
//        integer function e(u)         int d (int (*u)()) { return u();}
//        integer u
//        external u                    main()
//        e=u()                         {         /* Calls to d  work.  */
//        return                        printf(\"d (c ) returns %d.\\n\",d (c ));
//        end                           printf(\"d (f_) returns %d.\\n\",d (f_));
//                                                /* Calls to e_ crash. */
//                                      printf(\"e_(c ) returns %d.\\n\",e_(c ));
//                                      printf(\"e_(f_) returns %d.\\n\",e_(f_));
//                                      }
//  
//  Solutions to the problem are welcomed!
//  A kludge which allows the above example to work correctly, requires an extra
//  argument to be given when calling the dummy argument function.
//  i.e. Replacing 'e=u()' by 'e=u(1)' allows the above example to work.
//  
//  
//  o The FORTRAN routines are called using macro expansions, therefore the usual
//  caveats for expressions in arguments apply. The expressions to the routines may
//  be evaluated more than once, leading to lower performance and in the worst case
//  bizarre bugs.
//  
//  o Not supported:
//  - C calling FORTRAN functions with (P)ZTRINGV arguments, can't have as an
//    argument a call to a FORTRAN function with (P)ZTRINGV arguments. 
//  - Similarly disallowed is nesting of C calls to any FORTRAN functions with
//    (P)ZTRINGV arguments, recursive [which is an extension to FORTRAN/77], or 
//    otherwise.
//  [The restrictions are actually less severe, but these are sufficient.]
//  
//  o For those who wish to use cfortran.h in large applications. [See Section IV.]
//  This release is intended to make it easy to get applications up and running. 
//  This implies that applications are not as efficient as they could be:
//  - The current mechanism is inefficient if a single header file is used to
//    describe a large library of FORTRAN functions. Code for a static wrapper fn.
//    is generated in each piece of C source code for each FORTRAN function 
//    specified with the CCALLSFFUNn statement, irrespective of whether or not the
//    function is ever called. 
//  - Code for several static utility routines internal to cfortran.h is placed 
//    into any source code which #includes cfortran.h. These routines should
//    probably be in a library.
//  
//  
//  i) Calling FORTRAN routines from C:
//     --------------------------------
//  
//  FORTRAN FUNCTIONs are prototyped by the following macro.
//  [FORTRAN SUBROUTINEs don't require a similar instruction.]
//  
//  PROTOCCALLSFFUNn(routine_type,ROUTINE_NAME,routine_name,argtype_1,...,argtype_n)
//  
//  
//  The FORTRAN routines are defined by one of the following two instructions.
//  
//  for a SUBROUTINE:
//  #define     Routine_name(argname_1,..,argname_n)               \\
//  CCALLSFSUBn(ROUTINE_NAME,routine_name,argtype_1,...,argtype_n, \\
//                           argname_1,..,argname_n) 
//  
//  for a FUNCTION:
//  #define     Routine_name(argname_1,..,argname_n)               \\
//  CCALLSFFUNn(ROUTINE_NAME,routine_name,argtype_1,...,argtype_n, \\
//                           argname_1,..,argname_n) 
//  
//  Where:
//  'n' = 0->10 [SUBROUTINE's ->20] (easily expanded in cfortran.h to > 10 [20]) is 
//      the number of arguments to the routine.
//  Routine_name = C       name of the routine (IN UPPER CASE LETTERS).[see 2.below]
//  ROUTINE_NAME = FORTRAN name of the routine (IN UPPER CASE LETTERS).
//  routine_name = FORTRAN name of the routine (IN lower case LETTERS).
//  routine_type = the type of argument returned by FORTRAN functions.
//               = BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG, SHORT, STRING, VOID.
//                 [Instead of VOID one would usually use CCALLSFSUBn.
//                  VOID forces a wrapper function to be used.]
//  argtype_i    = the type of argument passed to the FORTRAN routine and must be
//                 consistent in the definition and prototyping of the routine s.a.
//               = BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG, SHORT, STRING.
//               For vectors, i.e. 1 dim. arrays use 
//               = BYTEV, DOUBLEV, FLOATV, INTV, LOGICALV, LONGV, SHORTV, 
//                 STRINGV, ZTRINGV.
//               For vectors of vectors, i.e. 2 dim. arrays use
//               = BYTEVV, DOUBLEVV, FLOATVV, INTVV, LOGICALVV, LONGVV, SHORTVV.
//               For n-dim. arrays, 1<=n<=7 [7 is the maximum in Fortran 77],
//               = BYTEV..nV's..V, DOUBLEV..V, FLOATV..V, INTV..V, LOGICALV..V, 
//                 LONGV..V, SHORTV..V.
//                  N.B. Array dimensions and types are checked by the C compiler.
//               For routines changing the values of an argument, the keyword is 
//                    prepended by a 'P'.
//               = PBYTE, PDOUBLE, PFLOAT, PINT, PLOGICAL, PLONG, PSHORT,
//                 PSTRING, PSTRINGV, PZTRINGV.
//               For EXTERNAL procedures passed as arguments use
//               = ROUTINE.
//               For exceptional arguments which require no massaging to fit the
//                    argument passing mechanisms use
//               = PVOID.
//                  The argument is cast and passed as (void *).
//                  Although PVOID could be used to describe all array arguments on
//                  most (all?) machines , it shouldn't be because the C compiler
//                  can no longer check the type and dimension of the array.
//  argname_i    = any valid unique C tag, but must be consistent in the definition 
//                 as shown.
//  
//  Notes:
//  
//  1. cfortran.h may be expanded to handle a more argument type. To suppport new
//  arguments requiring complicated massaging when passed  between Fortran and C,
//  the user will have to understand cfortran.h and follow its code and mechanisms.
//  
//  To define types requiring little or no massaging when passed between Fortran 
//  and C, the pseudo argument type SIMPLE may be used.
//  For a user defined type called 'newtype', the definitions required are:
//  
//  /* The follwing 8 lines are required verbatim, 'newtype' is the name of the 
//  new user defined argument type.
//  */
//  #define Vnewtype              VSIMPLE
//  #define SEP_newtype        SEP_SIMPLE
//  #define INT_newtype        INT_SIMPLE
//  #define Znewtype              ZSIMPLE
//  #define STR_newtype        STR_SIMPLE
//  #define CCnewtype            CCSIMPLE
//  #define AAnewtype( T,A,B)     Bnewtype(T,A)   /* Argument B is not used here. */
//  #define Unewtype(  T,A)       Nnewtype(T,A)
//  
//  /* 'parameter_type(A)' is a declaration for 'A' and describes the type of the 
//  parameter expected by the Fortran function.  This type will be used in the
//  prototype for the function, if  using ANSI C, and to declare the argument used
//  by the intermediate function if calling a Fortran FUNCTION.
//  Valid 'parameter_type(A)' include: int A
//                                     void (*A)()
//                                     double A[17]
//  */
//  #define Nnewtype(  T,A)     parameter_type(A) /* Argument T is not used here. */
//  
//  /* Before any argument of the new type is passed to the Fortran routine, it may
//  be massaged as given by 'massage(A)'.
//  */
//  #define Bnewtype(  T,A)     massage(A)        /* Argument T is not used here. */
//  
//  An example of a simple user defined type is given cfortex.for and cfortest.c.
//  Two uses of SIMPLE user defined types are [don't show the 8 verbatim #defines]:
//  
//  /* Pass the address of a structure, using a type called PSTRUCT */
//  #define NPSTRUCT(  T,A)        void *A
//  #define BPSTRUCT(  T,A)       (void *) &(A)
//  
//  /* Pass an integer by value, (not standard F77 ), using a type called INTVAL */
//  #define NINTVAL(   T,A)      int A
//  #define BINTVAL(   T,A)         (A)
//  
//  [If using VAX VMS, surrounding the #defines with \"#pragma (no)standard\" allows
//   the %CC-I-PARAMNOTUSED messages to be avoided.]
//  
//  Upgrades to cfortran.h try to be, and have been, backwards compatible. This
//  compatibility cannot be offered to user defined types. SIMPLE user defined 
//  types are less of a risk since they require so little effort in their creation.
//  If a user defined type is required in more than one C header file of interfaces
//  to libraries of Fortran routines, good programming practice, and ease of code
//  maintenance, suggests keeping any user defined type within a single file which
//  is #included as required.
//  In fact, argument 'A' in Nnewtype(T,A), and its change to the definition of
//  Unewtype(T,A), was first introduced with version 2.6.
//  
//  
//  2. Routine_name is the name of the macro which the C programmer will use in
//  order to call a FORTRAN routine. In theory Routine_name could be any valid and
//  unique name, but in practice, the name of the FORTRAN routine in UPPER CASE
//  works everywhere and would seem to be an obvious choice.
//  
//  
//  3. <BYTE|DOUBLE|BYTE|DOUBLE|FLOAT|INT|LOGICAL|LONG|SHORT><V|VV|VVV|...>
//  
//  cfortran.h encourages the exact specification of the type and dimension of
//  array parameters because it allows the C compiler to detect errors in the
//  arguments when calling the routine.
//  
//  cfortran.h does not strictly require the exact specification since the argument 
//  is merely the address of the array and is passed on to the calling routine.
//  Any array parameter could be declared as PVOID, but this circumvents
//  C's compiletime ability to check the correctness of arguments and is therefore
//  discouraged.
//  
//  Passing the address of these arguments implies that PBYTEV, PFLOATV, ... ,
//  PDOUBLEVV, ... don't exist in cfortran.h, since by default the routine and the
//  calling code share the same array, i.e. the same values at the same memory
//  location.
//  
//  These comments do NOT apply to arrays of (P)S/ZTRINGV. For these parameters,
//  cfortran.h passes a massaged copy of the array to the routine. When the routine
//  returns, S/ZTRINGV ignores the copy, while PS/ZTRINGV replaces the calling
//  code's original array with copy, which may have been modified by the called
//  routine.
//  
//  
//  4. (P)STRING(V):
//  - STRING - If the argument is a fixed length character array, e.g. char ar[8];,
//  the string is blank, ' ', padded on the right to fill out the array before
//  being passed to the FORTRAN routine. The useful size of the string is the same
//  in both languages, e.g. ar[8] is passed as character*7. If the argument is a
//  pointer, the string cannot be blank padded, so the length is passed as
//  strlen(argument). On return from the FORTRAN routine, pointer arguments are not
//  disturbed, but arrays have the terminating '\\0' replaced to its original
//  position. i.e. The padding blanks are never visible to the C code.
//  
//  - PSTRING - The argument is massaged as with STRING before being passed to the
//  FORTRAN routine. On return, the argument has all trailing blanks removed,
//  regardless of whether the argument was a pointer or an array.
//  
//  - (P)STRINGV - Only supports char arrays. e.g. char bb[6][8];
//  
//  - STRINGV - The elements of the argument are copied into space malloc'd, and
//  each element is padded with blanks. The useful size of each element is the same
//  in both languages. Therefore char bb[6][8]; is equivalent to character*7 bb(6).
//  On return from the routine the malloc'd space is simply released.
//  
//  - PSTRINGV - Since FORTRAN has no trailing '\\0', elements in an array of
//  strings are contiguous. Therefore each element of the C array is padded with
//  blanks and strip out C's trailing '\\0'. After returning from the routine, the
//  trailing '\\0' is reinserted and kill the trailing blanks in each element.
//  
//  - SUMMARY: STRING(V) arguments are blank padded during the call to the FORTRAN
//  routine, but remain original in the C code. (P)STRINGV arguments are blank
//  padded for the FORTRAN call, and after returning from FORTRAN trailing blanks
//  are stripped off.
//  
//  
//  5. (P)ZTRINGV:
//  - (P)ZTRINGV - is identical to (P)STRINGV, except that the dimensions of the
//  array of strings is explicitly specified, [users of (P)ZTRINGV should examine
//  cfortest.c for a working example.]:
//  
//  - (P)ZTRINGV must replace (P)STRINGV wherever the sizeof() can't be used to
//  determine the dimensions of the vector of strings. e.g. when calling FORTRAN
//  from C with a char[][] which the C routine receives as an argument.
//  
//  - To specify the numbers of elements:
//  #define routine_name_ELEMS_j   ZTRINGV_ARGS(k)       
//                                   [..ARGS for subroutines, ..ARGF for functions.]
//  or
//  #define routine_name_ELEMS_j   ZTRINGV_NUM(l)
//  Where: routine_name is as above.
//         j            [1-n], is the argument being specifying.
//         k            [1-n], the value of this argument is the dynamic number of 
//                      elements for argument j. The argument must be of type 
//                      (P)BYTE, (P)DOUBLE, (P)FLOAT, (P)INT, (P)LONG or (P)SHORT.
//         l            the number of elements for argument j. This must be an
//                      integer constant available at compile time.
//                      i.e. it is static.
//  
//  - Similarly to specify the useful length, [i.e. don't count C's trailing '\\0',]
//  of each element:
//  #define routine_name_ELEMLEN_j ZTRINGV_ARGS(m)
//                                   [..ARGS for subroutines, ..ARGF for functions.]
//  or
//  #define routine_name_ELEMLEN_j ZTRINGV_NUM(q)
//  Where: m            [1-n], as for k but this is the length of each element. 
//         q            as for l but this is the length of each element. 
//  
//  
//  6. ROUTINE
//  The argument is an EXTERNAL procedure.
//  
//  When C passes a routine to Fortran, the language of the function must be
//  specified as follows:  [The case of some_*_function must be given as shown.]
//  
//  When C passes a C routine to a Fortran: 
//      FORTRAN_ROUTINE(arg1, .... ,       
//                      C_FUNCTION(SOME_C_FUNCTION,some_c_function),
//                      ...., argn);
//  
//  and similarly when C passes a Fortran routine to Fortran:
//      FORTRAN_ROUTINE(arg1, .... ,
//                      FORTRAN_FUNCTION(SOME_FORT_FUNCTION,some_fort_function),
//                      ...., argn);
//  
//  If fcallsc has been redefined; the same definition of fcallsc used when creating
//  the wrapper for 'some_c_function' must also be defined when C_FUNCTION is used.
//  See ii) 4. of this section for when and how to redefine fcallsc.
//  
//  ROUTINE was introduced with cfortran.h version 2.6. Earlier versions of
//  cfortran.h used PVOID to pass external procedures as arguments. Using PVOID for
//  this purpose is no longer recommended since it won't work 'as is' for
//  apolloFortran.
//  
//  7. CRAY only: 
//  In a given piece of source code, where FFUNC is any FORTRAN routine,
//  FORTRAN_FUNCTION(FFUNC,ffunc)
//  disallows a previous 
//  #define FFUNC(..) CCALLSFSUBn(FFUNC,ffunc,...) [ or CCALLSFFUNn]
//  in order to make the UPPER CASE FFUNC callable from C.
//  #define Ffunc(..) ... is OK though, as are obviously any other names.
//  
//  
//  ii) Calling C routines from FORTRAN:
//      --------------------------------
//  
//  Each of the following two statements to export a C routine to FORTRAN create
//  FORTRAN 'wrappers', written in C, which must be compiled and linked along with
//  the original C routines and with the FORTRAN calling code.
//  
//  FORTRAN callable 'wrappers' may also be created for C macros. i.e. in this
//  section, the term 'C function' may be replaced by 'C macro'.
//  
//  for C functions returning void:
//  FCALLSCSUBn(             Routine_name,ROUTINE_NAME,routine_name,argtype_1,...,argtype_n)
//  
//  for all other C functions:
//  FCALLSCFUNn(routine_type,Routine_name,ROUTINE_NAME,routine_name,argtype_1,...,argtype_n)
//  
//  Where:
//  'n' = 0->10 (easily expanded to > 10) stands for the number of arguments to the 
//      routine.
//  Routine_name = the C       name of the routine. [see 9. below]
//  ROUTINE_NAME = the FORTRAN name of the routine (IN UPPER CASE LETTERS).
//  routine_name = the FORTRAN name of the routine (IN lower case LETTERS).
//  routine_type = the type of argument returned by C functions.
//               = BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG, SHORT, STRING, VOID.
//                 [Instead of VOID, FCALLSCSUBn is recommended.]
//  argtype_i    = the type of argument passed to the FORTRAN routine and must be
//                 consistent in the definition and prototyping of the routine
//               = BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG, SHORT, STRING.
//               For vectors, i.e. 1 dim. arrays use 
//               = BYTEV, DOUBLEV, FLOATV, INTV, LOGICALV, LONGV, SHORTV, STRINGV.
//               For vectors of vectors, 2 dim. arrays use
//               = BYTEVV, DOUBLEVV, FLOATVV, INTVV, LOGICALVV, LONGVV, SHORTVV.
//               For n-dim. arrays use [currently implement n=1,2. n>2 easily done.]
//               = BYTEV..nV's..V, DOUBLEV..V, FLOATV..V, INTV..V, LOGICALV..V, 
//                 LONGV..V, SHORTV..V.
//               For routines changing the values of an argument, the keyword is 
//                    prepended by a 'P'.
//               = PBYTE, PDOUBLE, PFLOAT, PINT, PLOGICAL, PLONG, PSHORT, 
//                 PSTRING, PNSTRING, PPSTRING, PSTRINGV.
//               For EXTERNAL procedures passed as arguments use
//               = ROUTINE.
//               For exceptional arguments which require no massaging to fit the
//                    argument passing mechanisms use
//               = PVOID.
//                  The argument is cast and passed as (void *).
//  
//  
//  Notes:
//  
//  1. FCALLSCSUB/FUNn expect that the routine to be 'wrapped' has been properly
//  prototyped, or at least declared.
//  
//  
//  2. cfortran.h may be expanded to handle a new argument type not already among
//  the above. 
//  
//  
//  3. <BYTE|DOUBLE|BYTE|DOUBLE|FLOAT|INT|LOGICAL|LONG|SHORT><V|VV|VVV|...>
//  
//  cfortran.h encourages the exact specification of the type and dimension of
//  array parameters because it allows the C compiler to detect errors in the
//  arguments when declaring the routine using FCALLSCSUB/FUNn, assuming the
//  routine to be 'wrapped' has been properly prototyped.
//  
//  cfortran.h does not strictly require the exact specification since the argument 
//  is merely the address of the array and is passed on to the calling routine.
//  Any array parameter could be declared as PVOID, but this circumvents
//  C's compiletime ability to check the correctness of arguments and is therefore
//  discouraged.
//  
//  Passing the address of these arguments implies that PBYTEV, PFLOATV, ... ,
//  PDOUBLEVV, ... don't exist in cfortran.h, since by default the routine and the
//  calling code share the same array, i.e. the same values at the same memory
//  location.
//  
//  These comments do NOT apply to arrays of (P)STRINGV. For these parameters,
//  cfortran.h passes a massaged copy of the array to the routine. When the routine
//  returns, STRINGV ignores the copy, while PSTRINGV replaces the calling
//  code's original array with copy, which may have been modified by the called
//  routine.
//  
//  
//  4. (P(N))STRING arguments have any trailing blanks removed before being passed
//  to C, the same holds true for each element in (P)STRINGV. Space is malloc'd in
//  all cases big enough to hold the original string (elements) as well as C's
//  terminating '\\0'. i.e. The useful size of the string (elements) is the same in
//  both languages. P(N)STRING(V) => the string (elements) will be copied from the
//  malloc'd space back into the FORTRAN bytes. If one of the two escape mechanisms
//  mentioned below for PNSTRING has been used, the copying back to FORTRAN is
//  obviously not relevant.
//  
//  
//  5. (PN)STRING's, [NOT PSTRING's nor (P)STRINGV's,] behavior may be overridden
//  in two cases.  In both cases PNSTRING and STRING behave identically.
//  
//  a) If a (PN)STRING argument's first 4 bytes are all the NUL character,
//  i.e. '\\0\\0\\0\\0' the NULL pointer is passed to the C routine.
//  
//  b) If the characters of a (PN)STRING argument contain at least one HEX-00, i.e.
//  the NUL character, i.e. C strings' terminating '\\0', the address of the string
//  is simply passed to the C routine. i.e. The argument is treated in this case as
//  it would be with PPSTRING, to which we refer the reader for more detail.
//  
//  Mechanism a) overrides b). Therefore, to use this mechanism to pass the NULL
//  string, \"\", to C, the first character of the string must obviously be the NUL
//  character, but of the first 4 characters in the string, at least one must not
//  be HEX-00.
//  
//  Example:
//  C FORTRAN                         /* C */
//        character*40 str            #include \"cfortran.h\"
//  C Set up a NULL as :              void cs(char *s) {if (s) printf(\"%s.\\n\",s);}
//  C    i)  4 NUL characters.        FCALLSCSUB1(cs,CS,cs,STRING)
//  C    ii) NULL pointer.
//        character*4 NULL        
//        NULL = CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)
//  
//        data str/'just some string'/
//  
//  C Passing the NULL pointer to cs.
//        call cs(NULL)
//  C Passing a copy of 'str' to cs.
//        call cs(str)
//  C Passing address of 'str' to cs. Trailing blanks NOT killed.
//        str(40:) = NULL
//        call cs(str)
//        end
//  
//  Strings passed from Fortran to C via (PN)STRING must not have undefined
//  contents, otherwise undefined behavior will result, since one of the above two
//  escape mechanisms may occur depending on the contents of the string.
//  
//  This is not be a problem for STRING arguments, which are read-only in the C
//  routine and hence must have a well defined value when being passed in.
//  
//  PNSTRING arguments require special care. Even if they are write-only in the C
//  routine, PNSTRING's above two escape mechanisms require that the value of the
//  argument be well defined when being passed in from Fortran to C. Therefore,
//  unless one or both of PNSTRING's escape mechanisms are required, PSTRING should
//  be used instead of PNSTRING.
//  Prior to version 2.8, PSTRING did have the above two escape mechanisms,
//  but they were removed from PSTRING to allow strings with undefined contents to
//  be passed in. PNSTRING behaves like the old PSTRING.
//  [Thanks go to Paul Dubois (dubios@icf.llnl.gov) for pointing out that PSTRING
//   must allow for strings with undefined contents to be passed in.]
//  
//  Example:
//  C FORTRAN                         /* C */
//        character*10 s,sn           #include \"cfortran.h\"
//                                    void ps(char *s) {strcpy(s,\"hello\");}
//  C Can   call ps  with undef. s.   FCALLSCSUB1(ps,PS,ps,PSTRING)
//        call ps(s)                  FCALLSCSUB1(ps,PNS,pns,PNSTRING)
//        print *,s,'=s'
//                                
//  C Can't call pns with undef. s.
//  C e.g. If first 4 bytes of s were
//  C      \"\\0\\0\\0\\0\", ps would try
//  C      to copy to NULL because
//  C      of PNSTRING mechanism.
//        sn = \"\"
//        call pns(sn)
//        print *,sn,'=sn'
//                                                 
//        end
//  
//  
//  6. PPSTRING
//  The address of the string argument is simply passed to the C routine. Therefore
//  the C routine and the FORTRAN calling code share the same string at the same
//  memory location. If the C routine modifies the string, the string will also be
//  modified for the FORTRAN calling code.
//  The user is responsible for negociating the differences in representation of a
//  string in Fortran and in C, i.e. the differences are not automatically resolved
//  as they are for (P(N)STRING(V).
//  This mechanism is provided for two reasons:
//     - Some C routines require the string to exist at the given memory location, 
//       after the C routine has exited. Recall that for the usual (P(N)STRING(V)
//       mechanism, a copy of the FORTRAN string is given to the C routine, and this
//       copy ceases to exist after returning to the FORTRAN calling code.
//     - This mechanism can save runtime CPU cycles over (P(N)STRING(V), since it
//       does not perform their malloc, copy and kill trailing blanks of the string
//       to be passed.
//       Only in a small minority of cases does the potential benefit of the saved
//       CPU cycles outweigh the programming effort required to manually resolve
//       the differences in representation of a string in Fortran and in C.
//  
//  For arguments passed via PPSTRING, the argument passed may also be an array of
//  strings.
//  
//  7. ROUTINE
//  ANSI C requires that the type of the value returned by the routine by known,
//  For all ROUTINE arguments passed from Fortran to C, the type of ROUTINE is
//  specified by defining a cast as follows:
//  
//  #undef  ROUTINE_j
//  #define ROUTINE_j   (cast)
//  where:
//         j            [1-n], is the argument being specifying.
//         (cast)       is a cast matching that of the argument expected by the C
//                      function protoytpe for which a wrapper is being defined.
//  
//  e.g. To create a Fortran wrapper for qsort(3C):
//  #undef  ROUTINE_4
//  #define ROUTINE_4 (int (*)(void *,void *))
//  FCALLSCSUB4(qsort,FQSORT,fqsort,PVOID,INT,INT,ROUTINE)
//  
//  In order to maintain backward compatibility, cfortran.h defines a generic cast
//  for ROUTINE_1, ROUTINE_2, ..., ROUTINE_10. The user's definition is therefore
//  strictly required only for DEC C, which at the moment is the only compiler
//  which insists on the correct cast for pointers to functions.
//  
//  Apollo only:
//  The Apollo passes Fortran routines via double indirection, so unless you know
//  what you are doing, do NOT redefine ROUTINE_1, ROUTINE_2, ..., ROUTINE_10.
//  
//  
//  8. THE FOLLOWING INSTRUCTIONS ARE NOT REQUIRED FOR VAX VMS
//                                    ------------
//  (P)STRINGV information [NOT required for VAX VMS]: cfortran.h cannot convert
//  the FORTRAN vector of STRINGS to the required C vector of STRINGS without
//  explicitly knowing the number of elements in the vector. The application must
//  do one of the following for each (P)STRINGV argument in a routine before that
//  routine's FCALLSCFUNn/SUBn is called:
//  
//  #define routine_name_STRV_Ai NUM_ELEMS(j)
//   or
//  #define routine_name_STRV_Ai NUM_ELEM_ARG(k)
//   or
//  #define routine_name_STRV_Ai TERM_CHARS(l,m)
//  
//  where: routine_name     is as above.
//         i [i=1->n.]      specifies the argument number of a STRING VECTOR.
//         j                would specify a fixed number of elements. 
//         k [k=1->n. k!=i] would specify an integer argument which specifies the
//                          number of elements.
//         l [char]         the terminating character at the beginning of an
//                          element, indicating to cfortran.h that the preceding
//                          elements in the vector are the valid ones.
//         m [m=1-...]      the number of terminating characters required to appear
//                          at the beginning of the terminating string element.
//                          The terminating element is NOT passed on to 
//                          the C routine.
//  
//  e.g.      #define ce_STRV_A1 TERM_CHARS(' ',2)
//            FCALLSCSUB1(ce,CE,ce,STRINGV)
//  
//  cfortran.h will pass on all elements, in the 1st and only argument to the C
//  routine ce, of the STRING VECTOR until, but not including, the first string
//  element beginning with 2 blank, ' ', characters.
//  
//  
//  9. INSTRUCTIONS REQUIRED ONLY FOR FORTRAN COMPILERS WHICH GENERATE
//                  -------------     
//     ROUTINE NAMES WHICH ARE UNDISTINGUISHABLE FROM C ROUTINE NAMES
//     i.e. VAX VMS 
//          HP9000      if not using the +ppu      option of f77
//          IBM RS/6000 if not using the -qextname option of xlf
//     Call them the same_namespace compilers.
//  
//  FCALLSCSUBn(...) and FCALLSCFUNn(...), when compiled, are expanded into
//  'wrapper' functions, so called because they wrap around the original C 
//  functions and interface the format of the original C functions' arguments and
//  return values with the format of the FORTRAN call.
//  
//  Ideally one wants to be able to call the C routine from FORTRAN using the same
//  name as the original C name. This is not a problem for FORTRAN compilers which
//  append an underscore, '_', to the names of routines, since the original C
//  routine has the name 'name', and the FORTRAN wrapper is called 'name_'.
//  Similarly, if the FORTRAN compiler generates upper case names for routines, the
//  original C routine 'name' can have a wrapper called 'NAME', [Assuming the C
//  routine name is not in upper case.] For these compilers, e.g. Mips, CRAY, IBM
//  RS/6000 'xlf -qextname', HP-UX 'f77 +ppu', the naming of the wrappers is done
//  automatically.
//  
//  For same_namespace compilers things are not as simple, but cfortran.h tries to
//  provide tools and guidelines to minimize the costs involved in meeting their
//  constraints. The following two options can provide same_namespace compilers
//  with distinct names for the wrapper and the original C function.
//  
//  These compilers are flagged by cfortran.h with the CF_SAME_NAMESPACE  constant,
//  so that the change in the C name occurs only when required.
//  
//  For the remainder of the discussion, routine names generated by FORTRAN
//  compilers are referred to in lower case, these names should be read as upper
//  case for the appropriate compilers.
//  
//  
//  HP9000: (When f77 +ppu is not used.)
//  f77 has a -U option which forces uppercase external names to be generated.
//  Unfortunately, cc does not handle recursive macros. Hence, if one wished to use
//  -U for separate C and FORTRAN namespaces, one would have to adopt a different
//  convention of naming the macros which allow C to call FORTRAN subroutines.
//  (Functions are not a problem.) The macros are currently the uppercase of the
//  original FORTRAN name, and would have to be changed to lower case or mixed
//  case, or to a different name. (Lower case would of course cause conflicts on
//  many other machines.) Therefore, it is suggested that f77 -U  not be used, and
//  instead that Option a) or Option b) outlined below be used.
//  
//  
//  VAX/VMS:
//  For the name used by FORTRAN in calling a C routine to be the same as that of
//  the C routine, the source code of the C routine is required. A preprocessor
//  directive can then force the C compiler to generate a different name for the C
//  routine. 
//  e.g.                #if defined(vms)
//                      #define name name_
//                      #endif
//                      void name() {printf(\"name: was called.\\n\");}
//                      FCALLSCSUB0(name,NAME,name)
//  
//  In the above, the C compiler generates the original routine with the name
//  'name_' and a wrapper called 'NAME'. This assumes that the name of the routine,
//  as seen by the C programmer, is not in upper case. The VAX VMS linker is not
//  case sensitive, allowing cfortran.h to export the upper case name as the
//  wrapper, which then doesn't conflict with the routine name in C. Since the IBM
//  and the HP have case sensitive linkers this technique is not available to them.
//  
//  The above technique is required even if the C name is in mixed case, see 
//  Option a) for the other compilers, but is obviously not required when 
//  Option b) is used.
//  
//  
//  Option a) Mixed Case names for the C routines to be called by FORTRAN.
//  
//  If the original C routines have mixed case names, there are no name space
//  conflicts.
//  
//  Nevertheless for VAX/VMS, the technique outlined above must also used.
//  
//  
//  Option b) Modifying the names of C routines when used by FORTRAN:
//  
//  The more robust naming mechanism, which guarantees portability to all machines, 
//  'renames' C routines when called by FORTRAN. Indeed, one must change the names
//  on same_namespace compilers when FORTRAN calls C routines for which the source
//  is unavailable. [Even when the source is available, renaming may be preferable
//  to Option a) for large libraries of C routines.]
//  
//  Obviously, if done for a single type of machine, it must be done for all
//  machines since the names of routines used in FORTRAN code cannot be easily
//  redefined for different machines.
//  
//  The simplest way to achieve this end is to do explicitly give the modified
//  FORTRAN name in the FCALLSCSUBn(...) and FCALLSCFUNn(...) declarations. e.g.
//  
//  FCALLSCSUB0(name,CFNAME,cfname)
//  
//  This allows FORTRAN to call the C routine 'name' as 'cfname'. Any name can of
//  course be used for a given routine when it is called from FORTRAN, although
//  this is discouraged due to the confusion it is sure to cause.  e.g. Bizarre,
//  but valid and allowing C's 'call_back' routine to be called from FORTRAN as
//  'abcd':
//  
//  FCALLSCSUB0(call_back,ABCD,abcd)
//  
//  
//  cfortran.h also provides preprocessor directives for a systematic 'renaming' of
//  the C routines when they are called from FORTRAN. This is done by redefining
//  the fcallsc macro before the FCALLSCSUB/FUN/n declarations as follows:
//  
//  #undef  fcallsc
//  #define fcallsc(UN,LN) preface_fcallsc(CF,cf,UN,LN)
//  
//  FCALLSCSUB0(hello,HELLO,hello)
//  
//  Will cause C's routine 'hello' to be known in FORTRAN as 'cfhello'. Similarly
//  all subsequent FCALLSCSUB/FUN/n declarations will generate wrappers to allow
//  FORTRAN to call C with the C routine's name prefaced by 'cf'. The following has
//  the same effect, with subsequent FCALLSCSUB/FUN/n's appending the modifier to
//  the original C routines name.
//  
//  #undef  fcallsc
//  #define fcallsc(UN,LN) append_fcallsc(Y,y,UN,LN)
//  
//  FCALLSCSUB0(Xroutine,ROUTINE,routine)
//  
//  Hence, C's Xroutine is called from FORTRAN as:
//         CALL XROUTINEY()
//  
//  The original behavior of FCALLSCSUB/FUN/n, where FORTRAN routine names are left
//  identical to those of C, is returned using:
//  
//  #undef  fcallsc
//  #define fcallsc orig_fcallsc
//  
//  
//  In C, when passing a C routine, i.e. its wrapper, as an argument to a FORTRAN
//  routine, the FORTRAN name declared is used and the correct fcallsc must be in
//  effect. E.g. Passing 'name' and 'routine' of the above examples to the FORTRAN
//  routines, FT1 and FT2, respectively:
//  
//  #undef  fcallsc                  /* This might not be needed            */
//  #define fcallsc orig_fcallsc     /* if fcallsc is already orig_fcallsc. */
//  FT1(C_FUNCTION(CFNAME,cfname));
//  
//  #undef  fcallsc
//  #define fcallsc(UN,LN) append_fcallsc(Y,y,UN,LN)
//  FT1(C_FUNCTION(XROUTINE,xroutine));
//  
//  If the names of C routines are modified when used by FORTRAN, fcallsc would
//  usually be defined once in a header_file.h for the application. This definition
//  would then be used and be valid for the entire application and fcallsc would at
//  no point need to be redefined.
//  
//  
//  ONCE AGAIN: THE DEFINITIONS, INSTRUCTIONS, DECLARATIONS AND DIFFICULTIES
//  DESCRIBED HERE, NOTE 9. of II ii), 
//  APPLY ONLY FOR VAX VMS,
//                 IBM RS/6000 WITHOUT THE -qextname OPTION FOR xlf, OR
//                 HP-UX       WITHOUT THE +ppu      OPTION FOR f77
//  AND APPLY ONLY WHEN CREATING WRAPPERS WHICH ENABLE FORTRAN TO CALL C ROUTINES.
//  
//  
//  
//  iii) Using C to manipulate FORTRAN COMMON BLOCKS:
//       -------------------------------------------------------
//  
//  FORTRAN common blocks are set up with the following three constructs:
//  
//  1.
//  #define Common_block_name COMMON_BLOCK(COMMON_BLOCK_NAME,common_block_name)
//  
//  Common_block_name is in UPPER CASE. 
//  COMMON_BLOCK_NAME is in UPPER CASE.
//  common_block_name is in lower case. 
//  [Common_block_name actually follows the same 'rules' as Routine_name in Note 2.
//   of II i).] This construct exists to ensure that C code accessing the common
//  block is machine independent.
//  
//  2.
//  COMMON_BLOCK_DEF(TYPEDEF_OF_STRUCT, Common_block_name);
//  
//  where 
//  typedef { ... } TYPEDEF_OF_STRUCT;
//  declares the structure which maps on to the common block. The #define of
//  Common_block_name must come before the use of COMMON_BLOCK_DEF.
//  
//  3.
//  In exactly one of the C source files, storage should be set aside for the
//  common block with the definition: 
//  
//  TYPEDEF_OF_STRUCT  Common_block_name;
//  
//  The above definition may have to be omitted on some machines for a common block
//  which is initialized by Fortran BLOCK DATA or is declared with a smaller size
//  in the C routines than in the Fortran routines.
//  
//  The rules for common blocks are not well defined when linking/loading a mixture
//  of C and Fortran, but the following information may help resolve problems.
//  
//  From the 2nd or ANSI ed. of K&R C, p.31, last paragraph:
//  i)
//   An external variable must be defined, exactly once, outside of any function;
//   this sets aside storage for it.
//  ii)
//   The variable must also be declared in each function that wants to access it;
//   ...
//   The declaration ... may be implicit from context.
//  
//  In Fortran, every routine says 'common /bar/ foo',
//  i.e. part ii) of the above, but there's no part i) requirement.
//  cc/ld on some machines don't require i) either.
//  Therefore, when handling Fortran, and sometimes C,
//  the loader/linker must automagically set aside storage for common blocks.
//  
//  Some loaders, including at least one for the CRAY, turn off the
//  'automagically set aside storage' capability for Fortran common blocks,
//  if any C object declares that common block.
//  Therefore, C code should define, i.e. set aside storage,
//  for the the common block as shown above.
//  
//  e.g.
//  C Fortran
//        common /fcb/  v,w,x
//        character *(13) v, w(4), x(3,2)
//  
//  /* C */
//  typedef struct { char v[13],w[4][13],x[2][3][13]; } FCB_DEF;
//  #define Fcb COMMON_BLOCK(FCB,fcb)
//  COMMON_BLOCK_DEF(FCB_DEF,Fcb);
//  FCB_DEF Fcb;      /* Definition, which sets aside storage for Fcb, */
//                    /* may appear in at most one C source file.      */
//  
//  
//  C programs can place a string (or a multidimensional array of strings) into a
//  FORTRAN common block using the following call:
//  
//  C2FCBSTR( CSTR, FSTR,DIMENSIONS);
//  
//  where:
//  
//  CSTR is a pointer to the first element of C's copy of the string (array). 
//       The C code must use a duplicate of, not the original, common block string,
//       because the FORTRAN common block does not allocate space for C strings'
//       terminating '\\0'.
//  
//  FSTR is a pointer to the first element of the string (array) in the common
//       block.
//  
//  DIMENSIONS is the number of dimensions of string array. 
//       e.g. char a[10]      has DIMENSIONS=0.
//            char aa[10][17] has DIMENSIONS=1.
//            etc...
//  
//  C2FCBSTR will copy the string (array) from CSTR to FSTR, padding with blanks, 
//  ' ', the trailing characters as required. C2FCBSTR uses DIMENSIONS and FSTR to
//  determine the lengths of the individual string elements and the total number of
//  elements in the string array.
//  
//  Note that:
//  - the number of string elements in CSTR and FSTR are identical.
//  - for arrays of strings, the useful lengths of strings in CSTR and FSTR must be
//    the same. i.e. CSTR elements each have 1 extra character to accommodate the
//    terminating '\\0'.
//  - On most non-ANSI compilers, the DIMENSION argument cannot be prepended by any
//    blanks.
//  
//  
//  FCB2CSTR( FSTR, CSTR,DIMENSIONS)
//  
//  is the inverse of C2FCBSTR, and shares the same arguments and caveats.
//  FCB2CSTR copies each string element of FSTR to CSTR, minus FORTRAN strings'
//  trailing blanks.
//  
//  
//  cfortran.h USERS ARE STRONGLY URGED TO EXAMINE THE COMMON BLOCK EXAMPLES IN
//  CFORTEST.C AND CFORTEX.FOR. The use of strings in common blocks is
//  demonstrated, along with a suggested way for C to imitate FORTRAN EQUIVALENCE'd
//  variables.
//  
//  
//                ===> USERS OF CFORTRAN.H NEED READ NO FURTHER <===
//  
//  
//  III Some Musings
//  ----------------
//  
//  cfortran.h is simple enough to be used by the most basic of applications, i.e.
//  making a single C/FORTRAN routine available to the FORTRAN/C programmers. Yet
//  cfortran.h is powerful enough to easily make entire C/FORTRAN libraries
//  available to FORTRAN/C programmers. 
//  
//  
//  cfortran.h is the ideal tool for FORTRAN libraries which are being (re)written
//  in C, but are to (continue to) support FORTRAN users. It allows the routines to
//  be written in 'natural C', without having to consider the FORTRAN argument
//  passing mechanisms of any machine. It also allows C code accessing these
//  rewritten routines, to use the C entry point. Without cfortran.h, one risks the
//  perverse practice of C code calling a C function using FORTRAN argument passing
//  mechanisms!
//  
//  
//  Perhaps the philosophy and mechanisms of cfortran.h could be used and extended
//  to create other language bridges such as ADAFORTRAN, CPASCAL, COCCAM, etc.
//  
//  
//  The code generation machinery inside cfortran.h, i.e. the global structure is
//  quite good, being clean and workable as seen by its ability to meet the needs
//  and constraints of many different compilers. Though the individual instructions
//  of the A..., C..., T..., R... and K... tables deserve to be cleaned up.
//  
//  
//  
//  IV  Getting Serious with cfortran.h
//  -----------------------------------
//  
//  cfortran.h is set up to be as simple as possible for the casual user. While
//  this ease of use will always be present, 'hooks', i.e. preprocessor directives,
//  are required in cfortran.h so that some of the following 'inefficiencies' can
//  be eliminated if they cause difficulties:
//  
//  o cfortran.h contains a few small routines for string manipulation. These
//  routines are declared static and are included and compiled in all source code
//  which uses cfortran.h. Hooks should be provided in cfortran.h to create an
//  object file of these routines, allowing cfortran.h to merely prototypes
//  these routines in the application source code. This is the only 'problem' which
//  afflicts both halves of cfortran.h. The remaining discussion refers to the C
//  calls FORTRAN half only.
//  
//  o Similar to the above routines, cfortran.h generates code for a 'wrapper'
//  routine for each FUNCTION exported from FORTRAN. Again cfortran.h needs
//  preprocessor directives to create a single object file of these routines,
//  and to merely prototype them in the applications.
//  
//  o Libraries often contain hundreds of routines. While the preprocessor makes
//  quick work of generating the required interface code from cfortran.h and the
//  application.h's, it may be convenient for very large stable libraries to have
//  final_application.h's which already contain the interface code, i.e. these
//  final_application.h's would not require cfortran.h. [The convenience can be
//  imagined for the VAX VMS CC compiler which has a fixed amount of memory for
//  preprocessor directives. Not requiring cfortran.h, with its hundreds of
//  directives, could help prevent this compiler from choking on its internal
//  limits quite so often.]
//  
//  With a similar goal in mind, cfortran.h defines 100's of preprocessor
//  directives. There is always the potential that these will clash with other tags
//  in the users code, so final_applications.h, which don't require cfortran.h,
//  also provide the solution.
//  
//  In the same vein, routines with more than 14 arguments can not be interfaced by
//  cfortran.h with compilers which limit C macros to 31 arguments. To resolve this
//  difficulty, final_application.h's can be created on a compiler without this
//  limitation.
//  
//  Therefore, new machinery is required to do:
//  
//  application.h + cfortran.h => final_application.h
//  
//  The following example may help clarify the means and ends:
//  
//  If the following definition of the HBOOK1 routine, the /*commented_out_part*/,
//  is passed through the preprocessor [perhaps #undefing and #defining preprocessor
//  constants if creating an application.h for compiler other than that of the
//  preprocessor being used, e.g. cpp -Umips -DCRAY ... ] :
//  
//  #include \"cfortran.h\"
//  /*#define HBOOK1(ID,CHTITLE,NX,XMI,XMA,VMX)                 \\*/
//       CCALLSFSUB6(HBOOK1,hbook1,INT,STRING,INT,FLOAT,FLOAT,FLOAT, \\
//                   ID,CHTITLE,NX,XMI,XMA,VMX) 
//  
//  Interface code is produced, based on the 'variables', 
//  ID,CHTITLE,NX,XMI,XMA,VMX, which will correctly massage a HBOOK1 call.
//  Therefore, adding the #define line:
//  
//  #define HBOOK1(ID,CHTITLE,NX,XMI,XMA,VMX)                 \\
//   'interface_code'(ID,CHTITLE,NX,XMI,XMA,VMX)
//  
//  which is placed into final_application.h.
//  
//  The only known limitation of the above method does not allow the 'variable'
//  names to include B1,B2,...,B9,BA,BB,... 
//  
//  Obviously the machinery to automatically generate final_applications.h from
//  cfortran.h and applications.h needs more than just some preprocessor
//  directives, but a fairly simple unix shell script should be sufficient. Any
//  takers?
//  
//  
//  
//  V Machine Dependencies of cfortran.h
//  ------------------------------------
//  
//  Porting cfortran.h applications, e.g. the hbook.h and cstring.c mentioned
//  above, to other machines is trivial since they are machine independent. Porting
//  cfortran.h requires a solid knowledge of the new machines C preprocessor, and
//  its FORTRAN argument passing mechanisms. Logically cfortran.h exists as two
//  halves, a \"C CALLS FORTRAN\" and a \"FORTRAN CALLS C\" utility. In some cases it
//  may be perfectly reasonable to port only 'one half' of cfortran.h onto a new
//  system.
//  
//  
//  The lucky programmer porting cfortran.h to a new machine, must discover the
//  FORTRAN argument passing mechanisms. A safe starting point is to assume that
//  variables and arrays are simply passed by reference, but nothing is guaranteed.
//  Strings, and n-dimensional arrays of strings are a different story. It is
//  doubtful that any systems do it quite like VAX VMS does it, so that a UNIX or
//  f2c versions may provide an easier starting point.
//  
//  
//  cfortran.h uses and abuses the preprocessor's ## operator. Although the ##
//  operator does not exist in many compilers, many kludges do. cfortran.h uses
//  /**/ with no space allowed between the slashes, '/', and the macros or tags
//  to be concatenated. e.g.
//  #define concat(a,b) a/**/b   /* works*/
//  main()
//  {
//    concat(pri,ntf)(\"hello\");           /* e.g. */
//  }
//  N.B. On some compilers without ##, /**/ may also not work. The author may be
//  able to offer alternate kludges.
//  
//  
//  
//  VI History and Acknowledgements
//  -------------------------------
//  
//  1.0 - Supports VAX VMS using C 3.1 and FORTRAN 5.4.                    Oct. '90.
//  1.0 - Supports Silicon Graphics w. Mips Computer 2.0 f77 and cc.       Feb. '91.
//            [Port of C calls FORTRAN half only.]
//  1.1 - Supports Mips Computer System 2.0 f77 and cc.                    Mar. '91.
//            [Runs on at least: Silicon Graphics IRIX 3.3.1
//                               DECstations with Ultrix V4.1]
//  1.2 - Internals made simpler, smaller, faster, stronger.               May  '91.
//      - Mips version works on IBM RS/6000, this is now called the unix version.
//  1.3 - UNIX and VAX VMS versions are merged into a single cfortran.h.   July '91.
//      - C can help manipulate (arrays of) strings in FORTRAN common blocks.
//      - Dimensions of string arrays arguments can be explicit.
//      - Supports Apollo DomainOS 10.2 (sys5.3) with f77 10.7 and cc 6.7.
//  
//  2.0 - Improved code generation machinery creates K&R or ANSI C.        Aug. '91.
//      - Supports Sun, CRAY. f2c with vcc on VAX Ultrix.
//      - cfortran.h macros now require routine and COMMON block names in both 
//        upper and lower case. No changes required to applications though.
//      - PROTOCCALLSFSUBn is eliminated, with no loss to cfortran.h performance.
//      - Improved tools and guidelines for naming C routines called by FORTRAN.
//  2.1 - LOGICAL correctly supported across all machines.                 Oct. '91.
//      - Improved support for DOUBLE PRECISION on the CRAY.
//      - HP9000 fully supported.
//      - VAX Ultrix cc or gcc with f77 now supported.
//  2.2 - SHORT, i.e. INTEGER*2, and BYTE now supported.                   Dec. '91.
//      - LOGICAL_STRICT introduced. More compact and robust internal tables.
//      - typeV and typeVV for type = BYTE, DOUBLE, FLOAT, INT, LOGICAL, LONG,SHORT.
//      - FORTRAN passing strings and NULL pointer to C routines improved. 
//  2.3 - Extraneous arguments removed from many internal tables.          May  '92.
//      - Introduce pseudo argument type SIMPLE for user defined types.
//      - LynxOS using f2c supported. (Tested with LynxOS 2.0 386/AT.)
//  2.4 - Separation of internal C and Fortran compilation directives.     Oct. '92.
//      - f2c and NAG f90 supported on all machines.
//  2.5 - Minor mod.s to source and/or doc for HP9000, f2c, and NAG f90.   Nov. '92.
//  2.6 - Support external procedures as arguments with type ROUTINE.      Dec. '92.
//  2.7 - Support Alpha VMS. Support HP9000 f77 +ppu                       Jan. '93.
//      - Support arrays with up to 7 dimensions.
//      - Minor mod. of Fortran NULL to C via (P)STRING.
//      - Specify the type of ROUTINE passed from Fortran to C [ANSI C requirement.]
//      - Macros never receive a null parameter [RS/6000 requirement.]
//  2.8 - PSTRING for Fortran calls C no longer provides escape to pass     April'93
//        NULL pointer nor to pass address of original string.
//        PNSTRING introduced with old PSTRING's behavior.
//        PPSTRING introduced to always pass original address of string.
//      - Support Alpha/OSF.
//      - Document that common blocks used in C should be declared AND defined.
//  
//  ['Support' implies these and more recent releases of the respective
//   OS/compilers/linkers can be used with cfortran.h. 
//   Earlier releases may also work.]
//  
//  
//  Acknowledgements:
//  M.L.Luvisetto (Istituto Nazionale Fisica Nucleare - Centro Nazionale
//  Analisi Fotogrammi, Bologna, Italy) provided all the support for the port to
//  the CRAY. Marisa's encouragement and enthusiasm was also much appreciated.
//  
//  
//  
//  THIS PACKAGE, I.E. CFORTRAN.H, THIS DOCUMENT, AND THE CFORTRAN.H EXAMPLE
//  PROGRAMS ARE PROPERTY OF THE AUTHOR WHO RESERVES ALL RIGHTS. THIS PACKAGE AND
//  THE CODE IT PRODUCES MAY BE FREELY DISTRIBUTED WITHOUT FEES, SUBJECT TO THE
//  FOLLOWING RESTRICTIONS:
//  - YOU MUST ACCOMPANY ANY COPIES OR DISTRIBUTION WITH THIS (UNALTERED) NOTICE.
//  - YOU MAY NOT RECEIVE MONEY FOR THE DISTRIBUTION OR FOR ITS MEDIA 
//    (E.G. TAPE, DISK, COMPUTER, PAPER.)
//  - YOU MAY NOT PREVENT OTHERS FROM COPYING IT FREELY.
//  - YOU MAY NOT DISTRIBUTE MODIFIED VERSIONS WITHOUT CLEARLY DOCUMENTING YOUR
//    CHANGES AND NOTIFYING THE AUTHOR.
//  - YOU MAY NOT MISREPRESENTED THE ORIGIN OF THIS SOFTWARE, EITHER BY EXPLICIT
//    CLAIM OR BY OMISSION.
//  
//  THE INTENT OF THE ABOVE TERMS IS TO ENSURE THAT THE CFORTRAN.H PACKAGE NOT BE
//  USED FOR PROFIT MAKING ACTIVITIES UNLESS SOME ROYALTY ARRANGEMENT IS ENTERED
//  INTO WITH ITS AUTHOR.
//                
//  THIS SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER
//  EXPRESSED OR IMPLIED. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
//  SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST
//  OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. THE AUTHOR IS NOT RESPONSIBLE
//  FOR ANY SUPPORT OR SERVICE OF THE CFORTRAN.H PACKAGE.
//  
//                                                Burkhard Burow 
//                                                burow@vxdesy.cern.ch
//  
//  P.S. Your comments and questions are welcomed and usually promptly answered.
//  
//  VAX VMS and Ultrix, Alpha, OSF, Silicon Graphics (SGI), DECstation, Mips RISC,
//  Sun, CRAY, IBM RS/6000, Apollo DomainOS, HP, LynxOS, f2c and NAG 
//  are registered trademarks.
          
/* end: cfortran.doc */
"
    end

    artifact 723888 "icc_fortran"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
#include \"core/constants.hpp\"
#include \"core/input_error.hpp\"
#include \"core/strngs.hpp\"
#include \"particle/ensemble.hpp\"
//
#define sunFortran
#include \"evaluator/cfortran.hpp\"
// -

extern \"C\" {
// prototype Fortran functions
PROTOCCALLSFFUN1(DOUBLE,__patch_MOD_GETX,__patch_MOD_getx,INT);
PROTOCCALLSFFUN1(DOUBLE,__patch_MOD_GETY,__patch_MOD_gety,INT);
PROTOCCALLSFFUN1(DOUBLE,__patch_MOD_GETZ,__patch_MOD_getz,INT);
PROTOCCALLSFFUN1(DOUBLE,__patch_MOD_GETUX,__patch_MOD_getux,INT);
PROTOCCALLSFFUN1(DOUBLE,__patch_MOD_GETUY,__patch_MOD_getuy,INT);
PROTOCCALLSFFUN1(DOUBLE,__patch_MOD_GETUZ,__patch_MOD_getuz,INT);
PROTOCCALLSFFUN1(DOUBLE,__patch_MOD_GETAREA,__patch_MOD_getarea,INT);
PROTOCCALLSFFUN1(DOUBLE,__patch_MOD_GETDEP,__patch_MOD_getdep,INT);
PROTOCCALLSFFUN0(INT,__patch_MOD_GETNPCH,__patch_MOD_getnpch);
PROTOCCALLSFFUN1(DOUBLE,__patch_MOD_GAUSSBOX,__patch_MOD_gaussbox,DOUBLEV);
PROTOCCALLSFFUN0(DOUBLE,__patch_MOD_TOTALAREA,__patch_MOD_totalarea);
PROTOCCALLSFSUB1(__patch_MOD_BAKSUB,__patch_MOD_baksub,DOUBLEV);
PROTOCCALLSFSUB1(__patch_MOD_WRITAM,__patch_MOD_writam,STRING);
PROTOCCALLSFSUB1(__patch_MOD_WRITPC,__patch_MOD_writpc,STRING);
PROTOCCALLSFSUB11(__patch_MOD_MATRIX,__patch_MOD_matrix,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,INT,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE);
#define IONCH_PRX(A) CCALLSFFUN1(__patch_MOD_GETX,__patch_MOD_getx,INT,(A))
#define IONCH_PRY(A) CCALLSFFUN1(__patch_MOD_GETY,__patch_MOD_gety,INT,(A))
#define IONCH_PRZ(A) CCALLSFFUN1(__patch_MOD_GETZ,__patch_MOD_getz,INT,(A))
#define IONCH_PUX(A) CCALLSFFUN1(__patch_MOD_GETUX,__patch_MOD_getux,INT,(A))
#define IONCH_PUY(A) CCALLSFFUN1(__patch_MOD_GETUY,__patch_MOD_getuy,INT,(A))
#define IONCH_PUZ(A) CCALLSFFUN1(__patch_MOD_GETUZ,__patch_MOD_getuz,INT,(A))
#define IONCH_AREA(A) CCALLSFFUN1(__patch_MOD_GETAREA,__patch_MOD_getarea,INT,(A))
#define IONCH_DEP(A) CCALLSFFUN1(__patch_MOD_GETDEP,__patch_MOD_getdep,INT,(A))
#define IONCH_NPATCH() CCALLSFFUN0(__patch_MOD_GETNPCH,__patch_MOD_getnpch)
#define IONCH_GAUSSBOX(A) CCALLSFFUN1(__patch_MOD_GAUSSBOX,__patch_MOD_gaussbox,DOUBLEV,(A))
#define IONCH_TOTALAREA() CCALLSFFUN0(__patch_MOD_TOTALAREA,__patch_MOD_totalarea)
#define IONCH_WPATCH(A) CCALLSFSUB1(__patch_MOD_WRITPC,__patch_MOD_writpc,STRING,(A))
#define IONCH_WAMX(A) CCALLSFSUB1(__patch_MOD_WRITAM,__patch_MOD_writam,STRING,(A))
#define IONCH_BAKSUB(A) CCALLSFSUB1(__patch_MOD_BAKSUB,__patch_MOD_baksub,DOUBLEV,(A))


}


${namespace_start}
${members}
${namespace_end}
"
      associated_classes
	class_ref 786736 // icc_fortran
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end
  end

  package_ref 309039 // New ICC evaluator (incomplete)

  package_ref 134704 // evaluator test
end
