class choice_meta
!!!826416.cpp!!!	add_trial_type(in ctor : choice_definition) : void
UTILITY_REQUIRE( not this->has_trial_type( ctor.type_name_ ), ("Attempt to add more than one chooser factory for type \"" + ctor.type_name_ + "\".") );
this->type_to_object_.push_back( ctor );


!!!833200.cpp!!!	add_documentation(inout helper : input_help) : void
const std::string seclabel( core::strngs::fstry() );
// ----------------------------------------
// add section
// ----------------------------------------

//   Specie input section definition
helper.add_section( seclabel,
    "Trial input section definition.  In addition to the listed options, each individual"
    "trial subtypes may have its own specific options.");

// ----------------------------------------
// add parameters
// ----------------------------------------

//   rate : [required, number] trial rate
{
  const std::string description("[required, number] trial relative rate (not necessarily normalized).");
  helper.add_option( seclabel, core::strngs::rate_label(), description );
}
//  type : [required] trial subtype
{
  const std::string description("[required, string] trial subtype (see documentation for valid subtypes).");
  helper.add_option( seclabel, core::strngs::fstype(), description );
}
//  specie : [optional] include/exclude list
{
  const std::string description("[optional, list] Space separated list of specie labels to include or exclude. Exclude species by preceding the label with '-' (e.g. -Aa). All species are included by default, but you may also include only selected species by putting their label in the list without '-' (optionally preceded by '+'). NOTE: This should only be used in special cases, most standard exceptions are handled automatically. For example \"mobile\" type species are automatically excluded from \"jump\" or Grand Canonical trials.");
  helper.add_option( seclabel, core::strngs::fsspec(), description );
}
//  simulator : [optional] simulator subtype
{
  const std::string description("[optional, string] specific simulator subtype to add the evaluator to (see documentation for valid subtypes).");
  helper.add_option( seclabel, core::strngs::simulator_label(), description );
}

// Subtype parameter documentation.
for( auto iter = this->type_to_object_.begin(); iter != this->type_to_object_.end(); ++iter )
{
  for( auto jter = iter->parameter_definition_.begin(); jter != iter->parameter_definition_.end(); ++jter )
  {
    std::string desc = "(for region subtype "+ iter->type_name_ + ")" + jter->second;
    helper.add_option( seclabel, jter->first, desc );
  }
}

!!!826544.cpp!!!	has_trial_type(in trial_label : string) : bool
for( auto const& defn : this->type_to_object_ )
{
  if( defn.type_name_ == trial_label )
  {
    return true;
  }
}
return false;

!!!204592.cpp!!!	do_read_entry(inout reader : input_base_reader) : bool
if( reader.name().find( core::strngs::rate_label() ) == 0 )
{
  // --------------------
  // Choice rate
  double rate = 0.0;
  UTILITY_INPUT( this->rate_ != 0.0, "Parameter \"" + core::strngs::rate_label() + "\" appears more than once in a single " + this->section_label() + " section.", this->section_label() );

  core::input_base_reader::float_input( core::strngs::rate_label(), reader.value(), "Trial", core::strngs::rate_label(), rate, true, false );
  this->rate_ = rate;
  this->missing_required_tags_.reset( CHOICE_RATE );
}
else if( reader.name().find( core::strngs::fstype() ) == 0 )
{
  // --------------------
  // Region type
  UTILITY_INPUT( this->type_.empty(), "Parameter \"" + core::strngs::fstype() + "\" appears more than once in a single " + this->section_label() + " section.", this->section_label() );
  UTILITY_INPUT( not reader.value().empty(), "Trial \"" + core::strngs::fstype() + "\" parameter must have a value.", this->section_label() );
  std::string val( reader.dequote( reader.value() ) );
  UTILITY_INPUT( this->has_trial_type( val ), "Region \"" + core::strngs::fstype() + "\" parameter value (" + val + ") is not a valid " + this->section_label() + " type for this application (see documentation).", this->section_label() );
  this->type_ = val;
  this->missing_required_tags_.reset( CHOICE_TYPE );
}
else if( reader.name().find( core::strngs::fsspec() ) == 0 )
{
  // --------------------
  // Region type
  UTILITY_INPUT( this->specie_list_.empty(), "Parameter \"" + core::strngs::fsspec() + "\" appears more than once in a single " + this->section_label() + " section.", this->section_label() );
  UTILITY_INPUT( not reader.value().empty(), "Trial \"" + core::strngs::fsspec() + "\" parameter must have a value.", this->section_label() );
  this->specie_list_ = reader.dequote( reader.value() );
}
else
{
  // --------------------
  // Assume choice specific parameters
  UTILITY_INPUT( 0 == this->parameter_set_.count( reader.name() ), ( "keyword \""+reader.name()+"\" appears more than once in a single \""+this->section_label()+"\" section" ), this->section_label() );
  this->parameter_set_.insert( std::make_pair( reader.name(), reader.value() ) );
}
return true;

!!!204720.cpp!!!	do_read_end() : void
UTILITY_INPUT( not this->missing_required_tags_.any(), "Not all required tags were present.", this->section_label() );

// find definition
std::size_t idx = 0;
for( idx = 0; idx != this->type_to_object_.size(); ++idx )
{
  if( this->type_to_object_[ idx ].type_name_ == this->type_ )
  {
    break;
  }
}
UTILITY_CHECK( idx != this->type_to_object_.size(), "Check in do_read_entry should mean this is never true." );
auto const& defn = this->type_to_object_[ idx ];
// use definiton to check parameter names
if( not this->parameter_set_.empty() )
{
  for( auto const& entry : this->parameter_set_ )
  {
    UTILITY_INPUT( defn.parameter_definition_.count( entry.first ) != 0, "Parameter named \"" + entry.first + "\" with value (" + entry.second + ") is not understood by " + this->type_ + " " + this->section_label() + ".", this->section_label() );
  }
}

// Use generator to create the chooser object.
this->manager_->add_chooser( defn.factory_( this->parameter_set_, this->type_, this->specie_list_, this->rate_ ) );

!!!1171376.cpp!!!	do_reset() : void
this->missing_required_tags_ = std::bitset< CHOICE_TAG_COUNT >( true );
this->parameter_set_.clear();
this->rate_ = 0.0;
this->specie_list_.clear();
this->type_.clear();

