class rdf_sampler
!!!1570096.cpp!!!	add_definition(inout meta : sampler_meta) : void
std::string desc( "Sample the radial distribution function around each ion collated by ion specie." );
std::unique_ptr< sampler_definition > result( new sampler_definition( type_label_(), desc, &rdf_sampler::make_sampler ) );
// two extra parameters
result->add_definition( { "stepsize", "distance in Angstrom", ">0", std::to_string( default_bin_width() ), "Bin width of pairwise radial population histogram." } );
result->add_definition( { "width", "distance in Angstrom", ">0", std::to_string( default_width() ), "Range of population histogram (excludes particle radii)." } );
meta.add_sampler_type( result );

!!!487729.cpp!!!	description(inout out : ostream) : void
out << " " << this->type_label_() << "\n";
out << " " << std::string( this->type_label_().size(), '-' ) << "\n";
out << "    Collect and report one dimensional density profiles of species\n";
out << "    - Default histogram bin width : " << rdf_sampler::default_bin_width() << "\n";
!!!672816.cpp!!!	get_value() : boost::any
boost::any result = &this->data_sets_;
return result;
!!!336305.cpp!!!	make_sampler(in param_set : string) : base_observable
double width = rdf_sampler::default_width();
double stepsize = rdf_sampler::default_bin_width();
if (param_set.count("width") != 0)
{
  core::input_base_reader::float_input( "width", param_set.at( "width" ), "Radial Distribution function total width", core::strngs::sampler_label(), width, true, false, nullptr );
}
if (0 != param_set.count("stepsize"))
{
  core::input_base_reader::float_input( "stepsize", param_set.at( "stepsize" ), "Radial Distribution histgram bin width", core::strngs::sampler_label(), stepsize, true, false, nullptr );
}
std::unique_ptr< rdf_sampler > result(new rdf_sampler);
result->width_ = width;
result->stepsize_ = stepsize;
boost::shared_ptr< base_observable > tmp(result.release());
return tmp;
!!!336049.cpp!!!	on_report(inout out : ostream, inout sink : base_sink) : void
// Write out RDF histograms
for( std::size_t ispec = 0; ispec != this->specie_count(); ++ispec )
{
  for( std::size_t jspec = ispec; jspec != this->specie_count(); ++jspec )
  {
    auto & histo = this->data_sets_[ this->get_index( ispec, jspec ) ];
    const std::string label { "rdf-"+this->specie_labels_[ispec]+"-"+this->specie_labels_[jspec]+".dat" };
    if( not sink.has_dataset( label ) )
    {
      // need to give a data set definition
      std::unique_ptr< observable::output_series >definition{ new observable::output_series( label, false ) };
      definition->set_title( "Radial distribution histogram for species "+this->specie_labels_[ispec]+" and "+this->specie_labels_[jspec] );
      {
        std::unique_ptr< observable::output_field > field( new observable::digitizer_output( "RMIN RMID RMAX", "ANGSTROM ANGSTROM ANGSTROM", histo.axis(), observable::digitizer_output::USE_ALL ) );
        definition->push_back_field( std::move( field ) );
      }
      {
        std::unique_ptr< observable::output_field > field( new observable::mean_variance_output( "P.mean P.var", "Rate Rate2" ) );
        definition->push_back_field( std::move( field ) );
      }
      sink.add_dataset( std::move( definition ) );
    }

    if( histo.count() > 0 )
    {
      std::unique_ptr< observable::output_series_datum > datum( new observable::output_series_datum{ 0ul, new utility::estimate_array( std::move( histo.release_data() ) ) } );
      sink.receive_data( label, std::move( datum ) );
    }
  }
}
!!!499120.cpp!!!	on_sample(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager) : void
{
  for( auto & entry : this->data_sets_ )
  {
    entry.begin_sample();
  }
  // Compute and sample rij 
  const particle::ensemble &ens( pman.get_ensemble() );
  std::vector< double > rij( ens.size() );
  std::vector< std::size_t > offsets( pman.specie_count() );
  // M(i,j) = data_sets_[ (2N+1-i)*i/2 + j ]
  //
  // offset_base = 2N+1
  std::size_t offset_base = (2 * pman.specie_count() + 1);
  for( std::size_t ispec = 0; ispec != pman.specie_count(); ++ispec )
  {
    offsets[ ispec ] = ( ispec == 0 ? 0ul : ((offset_base - ispec) * ispec) / 2 );
  }
  for ( std::size_t ith = 0; ith != ens.size() - 1; ++ith )
  {
    const std::size_t ispec( ens.key( ith ) );
    if ( ispec != particle::specie_key::nkey )
    {
      gman.calculate_distances( ens.position( ith ), ens.get_coordinates(), rij, ith + 1, ens.size() );
      for ( std::size_t jth = ith + 1; jth != ens.size(); ++jth )
      {
        const std::size_t jspec( ens.key( jth ) );
        if ( jspec != particle::specie_key::nkey )
        {
          std::size_t ii = std::min( ispec, jspec );
          std::size_t jj = std::max( ispec, jspec );
          auto & histo = this->data_sets_[ offsets[ ii ] + (jj - ii) ];
          if( histo.in_range( rij[ jth ] ) )
          {
            histo.sample_datum( rij[ jth ] );
          }
        }
      }
    }
  }
  for( auto & entry : this->data_sets_ )
  {
    entry.end_sample();
  }
}
!!!304817.cpp!!!	prepare(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager, in sman : report_manager) : void
this->specie_labels_.clear();
this->specie_labels_.resize( pman.specie_count() );
std::vector< double > radii( pman.specie_count() );
for( std::size_t ispec = 0; ispec != pman.specie_count(); ++ispec )
{
  auto const& spc = pman.get_specie( ispec );
  this->specie_labels_[ ispec ] = spc.label();
  radii[ ispec ] = spc.radius();
}
this->data_sets_.clear();
for( std::size_t ispec = 0; ispec != pman.specie_count(); ++ispec )
{
  for( std::size_t jspec = ispec; jspec != pman.specie_count(); ++jspec )
  {
    const double min = radii[ ispec ] + radii[ jspec ];
    const double max = min + this->width_;
    this->data_sets_.push_back( { min, max, this->stepsize_, false } );
  }
}
// calculate expected data set size
UTILITY_CHECK( this->data_sets_.size() == ((pman.specie_count() * (pman.specie_count() + 1)) / 2), "Size not what was expected." );
!!!217264.cpp!!!	do_write_document(inout wr : input_document, in ix : size_t) : void
wr[ ix ].add_entry( core::strngs::fstype(), this->type_label_() );
wr[ ix ].add_entry( "width", this->width_ );
wr[ ix ].add_entry( "stepsize", this->stepsize_ );
!!!2607920.cpp!!!	get_histogram(in ispec : size_t, in jspec : size_t) : histogram
UTILITY_REQUIRE( ispec < this->specie_count(), "Specie index out of range." );
UTILITY_REQUIRE( jspec < this->specie_count(), "Specie index out of range." );
if( ispec > jspec )
{
  std::swap( ispec, jspec );
}
return this->data_sets_[ this->get_index( ispec, jspec ) ];
