class chooser
!!!232240.cpp!!!	generate_choices(in species : specie, inout choices : base_choice) : void
std::set< std::string > include, exclude;
if( this->parameter_set_.find( core::strngs::fsspec() ) != this->parameter_set_.end() )
{
  // Have inclusion/exclusion list
  boost::char_separator< char > sep( " " );
  boost::tokenizer< boost::char_separator< char > > tok( this->parameter_set_.at( core::strngs::fsspec() ), sep );
  for( auto const& entry : tok )
  {
    if( entry[0] == '+' )
    {
      include.insert( entry.substr( 1, 2 ) );
    }
    else if( entry[0] == '-' )
    {
      exclude.insert( entry.substr( 1, 2 ) );
    }
    else
    {
      include.insert( entry.substr( 0, 2 ) );
    }
  }
}
// Require that species are not in both include and exclude lists
if( not include.empty() and not exclude.empty() )
{
  for( auto const& entry : include )
  {
    UTILITY_INPUT( 0 == exclude.count( entry ),
                   "Specie label "+entry+" set as included and excluded",
                   core::strngs::fstry() );
  }
}
boost::ptr_vector< base_choice > new_choices;
double rate_sum = 0.0;
for( std::size_t ispec = 0; ispec != species.size(); ++ispec )
{
  auto const& spec = species.at( ispec );
  // Only species in include OR not in exclude list.
  if( ( include.empty() or 0 < include.count( spec.label() ) )
      and ( exclude.empty() or 0 == exclude.count( spec.label() ) ) )
  {
    // Only species with non-zero specie rate can have trials
    if( not utility::feq( spec.rate(), 0.0 ) )
    {
      if( Choice::permitted( spec ) )
      {
        std::unique_ptr< base_choice > choice_ptr( Choice::make_choice( ispec, this->parameter_set_ ) );
        rate_sum += spec.rate();
        choice_ptr->set_probability( spec.rate() );
        new_choices.push_back( choice_ptr.get() );
        choice_ptr.release();
      }
    }
  }
}
// new_choices may be empty.
if( not new_choices.empty() )
{
  const double rate_scale = this->rate_ / rate_sum;
  for( std::size_t ii = 0; ii != new_choices.size(); ++ii )
  {
    new_choices[ii].set_probability( rate_scale * new_choices[ii].probability() );
  }
  // Move choices to result list.
  choices.transfer( choices.end(), new_choices );
}


!!!232112.cpp!!!	make_chooser(in params : string, in type : string, in specie_list : string, in rate : double) : base_chooser
std::unique_ptr< base_chooser > choice_ptr( new chooser< Choice >( params, type, specie_list, rate ) );
return choice_ptr;
