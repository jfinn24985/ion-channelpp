class trial_test
!!!1185584.cpp!!!	test_base_choice_methods(inout choice : base_choice) : void
std::stringstream ss;
double prob;
trial::choice_hash key;
// serialization test
{
  prob = choice->probability();
  key = choice->key();
  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  oa << choice;
}
{
  boost::shared_ptr< trial::base_choice > copy;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  ia >> copy;
  BOOST_REQUIRE( utility::feq( copy->probability(), prob ) );
  BOOST_REQUIRE( copy->key() == key );

  // Try setting probability on copy
  prob += 1.0;
  BOOST_CHECK_NO_THROW( copy->set_probability( prob ) );
  BOOST_REQUIRE( utility::feq( copy->probability(), prob ) );
  BOOST_REQUIRE( not utility::feq( copy->probability(), choice->probability() ) );
}

!!!1220272.cpp!!!	test_choice_generate(in params : string) : void
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "CA" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.11 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::MOBILE );
  spc1.append_position( particle::coordinate( 2.0, 2.0, 0.0 ), particle::centroid( 3.0, 2.0, 2.0, 0.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "CO" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::FLEXIBLE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 2.0 ), particle::centroid( 3.0, 0.0, 0.0, 2.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "OX" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::CHANNEL_ONLY );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 2.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 0.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 2.0, 0.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 5 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 6 );
boost::shared_ptr< geometry::base_region > regn( new geometry::periodic_cube_region( "cell", 5.0 ) );
geometry::geometry_manager gman( regn );
{
  boost::shared_ptr< geometry::base_region > bulk( new geometry::cube_region( "bulk", 4.0, particle::coordinate( 0.0, 0.0, 0.0 ), true ) );
  gman.add_region( bulk );
}
{
  const auto& ens = pman.get_ensemble();
  for( std::size_t idx = 0; idx != ens.size(); ++idx )
  {
    if( ens.key( idx ) != particle::specie_key::nkey )
    {
      particle::coordinate pos = ens.position( idx );
      BOOST_REQUIRE( gman.system_region().is_inside( pos, pman.get_specie( ens.key( idx ) ).radius() ) );
    }
  }
}
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );

bool usable = false;
for( std::size_t idx = 0; idx != pman.specie_count(); ++idx )
{
  if( Choice::permitted( pman.get_specie( idx ) ) )
  {
    usable = true;
    std::unique_ptr< trial::base_choice > chc( Choice::make_choice( idx, params ) );
    const double spc_radius = pman.get_specie( idx ).radius();
    std::size_t nonfails = 0;
    for( std::size_t attempts = 0; attempts != 1024; ++attempts )
    {
      std::unique_ptr< particle::change_set > tryit( chc->generate( pman, gman, rgnr ) );
      BOOST_REQUIRE( tryit->fail() or ( tryit->size() > 0 ) );
      if( not tryit->fail() )
      {
        ++nonfails;
        // new position should be in system or fail should be set.
        const auto& atom = (*tryit)[ 0 ];
        BOOST_REQUIRE( gman.system_region().is_inside( atom.new_position, spc_radius ) );
      }
    }
    BOOST_WARN_GE( nonfails, 0 );
  }
}
BOOST_REQUIRE( usable );


!!!1233328.cpp!!!	test_make_chooser_methods(in params : string, in type : string, in specielist : string, in rate : double, in count : size_t, in exp_rate : double) : void
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "CA" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.11 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::MOBILE );
  spc1.append_position( particle::coordinate( 2.0, 2.0, 0.0 ), particle::centroid( 3.0, 2.0, 2.0, 0.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "CO" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::FLEXIBLE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 2.0 ), particle::centroid( 3.0, 0.0, 0.0, 2.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "OX" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::CHANNEL_ONLY );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 2.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 0.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 2.0, 0.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 5 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 6 );

std::stringstream ss;
{
  std::unique_ptr< trial::base_chooser > chsr = Chooser::make_chooser( params, type, specielist, rate );
  BOOST_CHECK_EQUAL( chsr->rate(), rate );
  BOOST_CHECK_EQUAL( chsr->type(), type );
  BOOST_CHECK_EQUAL( chsr->specie_list(), specielist );
  BOOST_CHECK( chsr->parameters() == params );
  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  oa << chsr;
}
{
  std::unique_ptr< trial::base_chooser > chsr;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  ia >> chsr;
  BOOST_CHECK_EQUAL( chsr->rate(), rate );
  BOOST_CHECK_EQUAL( chsr->type(), type );
  BOOST_CHECK_EQUAL( chsr->specie_list(), specielist );
  BOOST_CHECK( chsr->parameters() == params );
  boost::ptr_vector< trial::base_choice > choices;
  chsr->generate_choices( pman.get_species(), choices );
  BOOST_REQUIRE_EQUAL( choices.size(), count );
  for( std::size_t idx = 0; idx != count; ++idx )
  {
    BOOST_CHECK_CLOSE( choices[ idx ].probability(), exp_rate, 0.00001 );
  }
}

!!!798384.cpp!!!	test_chooser_operation(in chsr : base_chooser, in expected_size : size_t) : void
//XX// The chooser interface provides a single unique 
//XX// function, generate_choices. This method takes a
//XX// simulation object and adds choice objects to a
//XX// a list. The hash 'key' of the generated choice
//XX// objects must 'match' the key of the chooser
//XX// object that generated them.
//XX
//XX// call signature
//XX// void generate_choices(const simulator & sim, boost::ptr_vector< base_choice >& choices) const
//XX
//XX
//XX// generated_choices
//XX// is_permitted
//XX// make_choice
//XX// write_document
//XX// serialize
//XX
//XXboost::ptr_vector< trial::base_choice > choices;
//XX
//XX// dummy simulator
//XXplatform::simulator_fixture simfix;
//XXsimfix.add_solute_species();
//XXsimfix.add_localized_species();
//XX 
//XXchsr.generate_choices( simfix.sim->get_species(), choices );
//XX
//XXBOOST_CHECK( choices.size() == expected_size );
!!!783408.cpp!!!	choice_hash_test() : void
{
  // Test for canonical pattern
  BOOST_CHECK( std::is_default_constructible< trial::choice_hash >::type {} );
  BOOST_CHECK( std::is_copy_constructible< trial::choice_hash >::type {} );
  BOOST_CHECK( std::is_move_constructible< trial::choice_hash >::type {} );
  BOOST_CHECK( ( std::is_assignable< trial::choice_hash, trial::choice_hash >::type {} ) );
  BOOST_CHECK( not std::has_virtual_destructor< trial::choice_hash >::type {} );
}
std::stringstream store;
{
  // Default ctor
  trial::choice_hash var1;
  BOOST_CHECK_EQUAL( var1.key, 0 );
  BOOST_CHECK_EQUAL( var1.start, 0 );
  BOOST_CHECK_EQUAL( var1.finish, 0 );
  BOOST_CHECK_EQUAL( var1.subtype, 0 );

  trial::choice_hash var2;
  BOOST_CHECK( var1.equivalent( var2 ) );
  BOOST_CHECK( var1 == var2 );
  BOOST_CHECK( var1 >= var2 );
  BOOST_CHECK( var1 <= var2 );
  BOOST_CHECK( not (var1 != var2) );
  BOOST_CHECK( not (var1.less_than( var2 ) ) );
  BOOST_CHECK( not (var1 < var2) );

  var1.key = 1;
  var1.start = 2;
  var1.finish = 3;
  var1.subtype = 4;

  BOOST_CHECK( not var1.equivalent( var2 ) );

  trial::choice_hash var3( 1, 2, 3, 4 );
  BOOST_CHECK( var1.key == var3.key );
  BOOST_CHECK( var1.start == var3.start );
  BOOST_CHECK( var1.finish == var3.finish );
  BOOST_CHECK( var1.subtype == var3.subtype );

  // copy ctor
  trial::choice_hash var4( var1 );
  BOOST_CHECK( var1 == var4 );

  // move ctor
  trial::choice_hash var5( std::move( var4 ) );
  BOOST_CHECK( var1 == var5 );

  var5.subtype = 5;
  BOOST_CHECK( var1 != var5 );
  // op=
  var5 = var3;
  BOOST_CHECK( var1 == var5 );

  boost::archive::text_oarchive oa(store);
  // write class instance to archive
  oa << var1;
}
{
  trial::choice_hash var1;
  trial::choice_hash var2;

  BOOST_CHECK( var1 == var2 );

  boost::archive::text_iarchive ia(store);
  // get class instance from archive
  ia >> var1;

  BOOST_CHECK( var1 != var2 );
  BOOST_CHECK_EQUAL( var1.key, 1 );
  BOOST_CHECK_EQUAL( var1.start, 2 );
  BOOST_CHECK_EQUAL( var1.finish, 3 );
  BOOST_CHECK_EQUAL( var1.subtype, 4 );
}
{
  // Check comparison
  trial::choice_hash var1( 1, 2, 3, 4 );
  trial::choice_hash var2( 1, 2, 3, 5 );
  BOOST_CHECK( var1.key == var2.key );
  BOOST_CHECK( var1.start == var2.start );
  BOOST_CHECK( var1.finish == var2.finish );
  BOOST_CHECK( var1.subtype < var2.subtype );

  BOOST_CHECK( var1 != var2 );
  BOOST_CHECK( var1 < var2 );
  BOOST_CHECK( var1 <= var2 );
  BOOST_CHECK( var2 > var1 );
  BOOST_CHECK( var2 >= var1 );
  BOOST_CHECK( not var1.match( var2 ) );

  var2 = var1;
  ++var2.finish;

  BOOST_CHECK( var1 != var2 );
  BOOST_CHECK( var1 < var2 );
  BOOST_CHECK( var1 <= var2 );
  BOOST_CHECK( var2 > var1 );
  BOOST_CHECK( var2 >= var1 );
  BOOST_CHECK( not var1.match( var2 ) );

  var2 = var1;
  ++var2.start;

  BOOST_CHECK( var1 != var2 );
  BOOST_CHECK( var1 < var2 );
  BOOST_CHECK( var1 <= var2 );
  BOOST_CHECK( var2 > var1 );
  BOOST_CHECK( var2 >= var1 );
  BOOST_CHECK( not var1.match( var2 ) );

  var2 = var1;
  ++var2.key;

  BOOST_CHECK( var1 != var2 );
  BOOST_CHECK( var1 < var2 );
  BOOST_CHECK( var1 <= var2 );
  BOOST_CHECK( var2 > var1 );
  BOOST_CHECK( var2 >= var1 );
  BOOST_CHECK( var1.match( var2 ) );

}
!!!1185712.cpp!!!	base_choice_test() : void
{
  // Test for virtual noncopy pattern
  BOOST_CHECK( not std::is_default_constructible< test_choice >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< test_choice >::type {} );
  BOOST_CHECK( not std::is_move_constructible< test_choice >::type {} );
  BOOST_CHECK( not( std::is_assignable< test_choice, test_choice >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< test_choice >::type {} );
}

{
// Public ctor 1
  const double prob = 0.1;
  trial::choice_hash key1( 1, 2, 3, 4 );
  boost::shared_ptr< trial::base_choice > var1( new test_choice( key1 ) );
  BOOST_CHECK_EQUAL( var1->key(), key1 );
  BOOST_CHECK_EQUAL( var1->probability(), 0 );

  BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
  BOOST_CHECK_EQUAL( var1->probability(), prob );

  trial_test::test_base_choice_methods( var1 );
}

{
// Public ctor 2
  trial::choice_hash key2( 1, 0, 0, 0 );
  boost::shared_ptr< trial::base_choice > var2( new test_choice( 1ul ) );
  BOOST_CHECK_EQUAL( var2->key(), key2 );
  BOOST_CHECK_EQUAL( var2->probability(), 0 );

}


!!!1207088.cpp!!!	add_specie_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::add_specie >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::add_specie >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::add_specie >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::add_specie, trial::add_specie >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::add_specie >::type {} );
}
trial::choice_hash key1( 0, 0, 1, 0 );
boost::shared_ptr< trial::add_specie > var1( new trial::add_specie( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  trial_test::test_choice_generate< trial::add_specie >( params );

  trial_test::test_make_chooser_methods< trial::chooser_pair< trial::add_specie,trial::remove_specie  > >( params, "individual", "", 0.5, 4, 0.125 );
}

!!!1206704.cpp!!!	jump_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_choice >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_choice >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_choice >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_choice, trial::jump_choice >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_choice >::type {} );
}
trial::choice_hash key1( 0, 1, 1, 1 );
boost::shared_ptr< trial::jump_choice > var1( new trial::jump_choice( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

std::map< std::string, std::string > params;

trial_test::test_choice_generate< trial::jump_choice >( params );

trial_test::test_make_chooser_methods< trial::chooser< trial::jump_choice > >( params, "jump", "", 0.5, 2, 0.25 );
!!!1206832.cpp!!!	jump_in_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_in >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_in >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_in >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_in, trial::jump_in >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_in >::type {} );
}
trial::choice_hash key1( 0, 1, 1, 2 );
boost::shared_ptr< trial::jump_in > var1( new trial::jump_in( 0ul, "bulk" ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );
BOOST_CHECK_EQUAL( var1->region_name(), "bulk" );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  params[ core::strngs::fsregn() ] = "bulk";
  trial_test::test_choice_generate< trial::jump_in >( params );

  trial_test::test_make_chooser_methods< trial::chooser< trial::jump_in > >( params, "jump-in", "", 0.5, 2, 0.25 );
}
!!!1206960.cpp!!!	jump_out_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_out >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_out >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_out >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_out, trial::jump_out >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_out >::type {} );
}
trial::choice_hash key1( 0, 1, 1, 3 );
boost::shared_ptr< trial::jump_out > var1( new trial::jump_out( 0ul, "channel" ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );
BOOST_CHECK_EQUAL( var1->region_name(), "channel" );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  params[ core::strngs::fsregn() ] = "bulk";
  trial_test::test_choice_generate< trial::jump_out >( params );

  trial_test::test_make_chooser_methods< trial::chooser< trial::jump_out > >( params, "jump-out", "", 0.5, 2, 0.25 );
}
!!!1213744.cpp!!!	jump_around_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_around >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_around >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_around >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_around, trial::jump_around >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_around >::type {} );
}
trial::choice_hash key1( 0, 1, 1, 4 );
boost::shared_ptr< trial::jump_around > var1( new trial::jump_around( 0ul, "channel" ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );
BOOST_CHECK_EQUAL( var1->region_name(), "channel" );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  params[ core::strngs::fsregn() ] = "bulk";
  trial_test::test_choice_generate< trial::jump_around >( params );

  trial_test::test_make_chooser_methods< trial::chooser< trial::jump_around > >( params, "jump", "", 0.5, 1, 0.5 );
}
!!!441776.cpp!!!	move_choice_test() : void
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::move_choice >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::move_choice >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::move_choice >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::move_choice, trial::move_choice >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::move_choice >::type {} );
}

const double prob = 0.1;
const double delta = 10.0;
trial::choice_hash key1( 0, 1, 1, 0 );
boost::shared_ptr< trial::move_choice > var1( new trial::move_choice( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

BOOST_CHECK_EQUAL( var1->max_displacement(), trial::move_choice::default_displacement() );
BOOST_CHECK_NO_THROW( var1->set_max_displacement( delta ) );
BOOST_CHECK_EQUAL( var1->max_displacement(), delta );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  params[ "delta" ] = "0.5";
  trial_test::test_choice_generate< trial::move_choice >( params );

  trial_test::test_make_chooser_methods< trial::chooser< trial::move_choice > >( params, "move", "", 0.5, 5, 0.1 );
}
!!!1207216.cpp!!!	remove_specie_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::remove_specie >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::remove_specie >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::remove_specie >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::remove_specie, trial::remove_specie >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::remove_specie >::type {} );
}
trial::choice_hash key1( 0, 1, 0, 0 );
boost::shared_ptr< trial::remove_specie > var1( new trial::remove_specie( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  trial_test::test_choice_generate< trial::remove_specie >( params );
}
!!!1240752.cpp!!!	choice_meta_lifetime_test() : void
{
  // Test for virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::choice_meta >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::choice_meta >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::choice_meta >::type {} );
  BOOST_CHECK( not ( std::is_assignable< trial::choice_meta, trial::choice_meta >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::choice_meta >::type {} );
}
!!!791600.cpp!!!	choice_meta_move_choice_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.5\nspecie-list Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->chooser_empty() );
BOOST_CHECK( cman->has_chooser( "move" ) );
!!!1240880.cpp!!!	choice_meta_jump_choice_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump" ) );

  dg.add_input_delegate( meta );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"jump\"\nrate 0.5\nspecie-list Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->chooser_empty() );
BOOST_CHECK( cman->has_chooser( "jump" ) );
!!!1241008.cpp!!!	choice_meta_jump_around_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_around::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-around" ) );

  dg.add_input_delegate( meta );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-around\"\nregion \"channel\"\nrate 0.5\nspecie-list Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->chooser_empty() );
BOOST_CHECK( cman->has_chooser( "jump-around" ) );
!!!1241136.cpp!!!	choice_meta_jump_in_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_in::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-in" ) );

  dg.add_input_delegate( meta );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-in\"\nregion \"channel\"\nrate 0.5\nspecie-list Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->chooser_empty() );
BOOST_CHECK( cman->has_chooser( "jump-in" ) );
!!!1241264.cpp!!!	choice_meta_jump_out_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_out::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-out" ) );

  dg.add_input_delegate( meta );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-out\"\nregion \"channel\"\nrate 0.5\nspecie-list Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->chooser_empty() );
BOOST_CHECK( cman->has_chooser( "jump-out" ) );
!!!1241392.cpp!!!	choice_meta_add_remove_choice_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::add_specie::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "individual" ) );

  dg.add_input_delegate( meta );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"individual\"\nrate 0.5\nspecie-list Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->chooser_empty() );
BOOST_CHECK( cman->has_chooser( "individual" ) );
!!!1241520.cpp!!!	input_meta_no_type_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\n#type \"move\"\nrate 0.5\nspecie-list Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


