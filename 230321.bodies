class trial_test
!!!1256496.cpp!!!	mockup_particle_manager() : particle_manager
boost::shared_ptr< particle::particle_manager > pman( new particle::particle_manager );
{
  particle::specie spc1;
  spc1.set_label( "CA" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.11 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::MOBILE );
  spc1.append_position( particle::coordinate( 2.0, 2.0, 0.0 ), particle::centroid( 3.0, 2.0, 2.0, 0.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "CO" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::FLEXIBLE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 2.0 ), particle::centroid( 3.0, 0.0, 0.0, 2.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "OX" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::CHANNEL_ONLY );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 2.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 0.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 2.0, 0.0 ) );
  pman->add_specie( spc1 );
}
pman->add_predefined_particles();
return pman;
!!!1263024.cpp!!!	mockup_geometry_manager() : geometry_manager
boost::shared_ptr< geometry::base_region > regn( new geometry::periodic_cube_region( "cell", 5.0 ) );
boost::shared_ptr< geometry::geometry_manager > gman( new geometry::geometry_manager( regn ) );
{
  boost::shared_ptr< geometry::base_region > bulk( new geometry::cube_region( "bulk", 4.0, particle::coordinate( 0.0, 0.0, 0.0 ), true ) );
  gman->add_region( bulk );
}
return gman;
!!!1185584.cpp!!!	test_base_choice_methods(inout choice : base_choice) : void
std::stringstream ss;
double prob;
particle::change_hash key;
// serialization test
{
  prob = choice->probability();
  key = choice->key();
  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  oa << choice;
}
{
  boost::shared_ptr< trial::base_choice > copy;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  ia >> copy;
  BOOST_REQUIRE( utility::feq( copy->probability(), prob ) );
  BOOST_REQUIRE( copy->key() == key );

  // Try setting probability on copy
  prob += 1.0;
  BOOST_CHECK_NO_THROW( copy->set_probability( prob ) );
  BOOST_REQUIRE( utility::feq( copy->probability(), prob ) );
  BOOST_REQUIRE( not utility::feq( copy->probability(), choice->probability() ) );
}

!!!1220272.cpp!!!	test_choice_generate(in params : string) : void
boost::shared_ptr< particle::particle_manager > pman( trial_test::mockup_particle_manager() );
boost::shared_ptr< geometry::geometry_manager > gman( trial_test::mockup_geometry_manager() );
BOOST_REQUIRE_EQUAL( pman->specie_count(), 5 );
BOOST_REQUIRE_EQUAL( pman->get_ensemble().count(), 6 );
{
  const auto& ens = pman->get_ensemble();
  for( std::size_t idx = 0; idx != ens.size(); ++idx )
  {
    if( ens.key( idx ) != particle::specie_key::nkey )
    {
      particle::coordinate pos = ens.position( idx );
      BOOST_REQUIRE( gman->system_region().is_inside( pos, pman->get_specie( ens.key( idx ) ).radius() ) );
    }
  }
}
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );

bool usable = false;
for( std::size_t idx = 0; idx != pman->specie_count(); ++idx )
{
  if( Choice::permitted( pman->get_specie( idx ) ) )
  {
    usable = true;
    std::unique_ptr< trial::base_choice > chc( Choice::make_choice( idx, *gman, params ) );
    const double spc_radius = pman->get_specie( idx ).radius();
    std::size_t nonfails = 0;
    for( std::size_t attempts = 0; attempts != 1024; ++attempts )
    {
      std::unique_ptr< particle::change_set > tryit( chc->generate( *pman, *gman, rgnr ) );
      BOOST_CHECK( chc->key() == tryit->id() );
      BOOST_REQUIRE( tryit->fail() or ( tryit->size() > 0 ) );
      if( not tryit->fail() )
      {
        ++nonfails;
        // new position should be in system or fail should be set.
        const auto& atom = (*tryit)[ 0 ];
        BOOST_REQUIRE( gman->system_region().is_inside( atom.new_position, spc_radius ) );
      }
    }
    BOOST_WARN_GE( nonfails, 0 );
  }
}
BOOST_REQUIRE( usable );


!!!1233328.cpp!!!	test_make_chooser_methods(in params : string, in type : string, in specielist : string, in rate : double, in count : size_t, in exp_rate : double) : void
boost::shared_ptr< particle::particle_manager > pman( trial_test::mockup_particle_manager() );
boost::shared_ptr< geometry::geometry_manager > gman( trial_test::mockup_geometry_manager() );
BOOST_REQUIRE_EQUAL( pman->specie_count(), 5 );
BOOST_REQUIRE_EQUAL( pman->get_ensemble().count(), 6 );

std::stringstream ss;
{
  std::unique_ptr< trial::base_chooser > chsr = Chooser::make_chooser( params, type, specielist, rate );
  BOOST_CHECK_EQUAL( chsr->rate(), rate );
  BOOST_CHECK_EQUAL( chsr->type(), type );
  BOOST_CHECK_EQUAL( chsr->specie_list(), specielist );
  BOOST_CHECK( chsr->parameters() == params );
  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  oa << chsr;
}
{
  std::unique_ptr< trial::base_chooser > chsr;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  ia >> chsr;
  BOOST_CHECK_EQUAL( chsr->rate(), rate );
  BOOST_CHECK_EQUAL( chsr->type(), type );
  BOOST_CHECK_EQUAL( chsr->specie_list(), specielist );
  BOOST_CHECK( chsr->parameters() == params );
  boost::ptr_vector< trial::base_choice > choices;
  chsr->prepare_choices( pman->get_species(), *gman, choices );
  BOOST_REQUIRE_EQUAL( choices.size(), count );
  for( std::size_t idx = 0; idx != count; ++idx )
  {
    BOOST_CHECK_CLOSE( choices[ idx ].probability(), exp_rate, 0.00001 );
  }
}

!!!1185712.cpp!!!	base_choice_test() : void
{
  // Test for virtual noncopy pattern
  BOOST_CHECK( not std::is_default_constructible< test_choice >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< test_choice >::type {} );
  BOOST_CHECK( not std::is_move_constructible< test_choice >::type {} );
  BOOST_CHECK( not( std::is_assignable< test_choice, test_choice >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< test_choice >::type {} );
}

{
// Public ctor 1
  const double prob = 0.1;
  particle::change_hash key1( 1, 2, 3, 4 );
  boost::shared_ptr< trial::base_choice > var1( new test_choice( key1 ) );
  BOOST_CHECK_EQUAL( var1->key(), key1 );
  BOOST_CHECK_EQUAL( var1->probability(), 0 );

  BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
  BOOST_CHECK_EQUAL( var1->probability(), prob );

  trial_test::test_base_choice_methods( var1 );
}

{
// Public ctor 2
  particle::change_hash key2( 1, 0, 0, 0 );
  boost::shared_ptr< trial::base_choice > var2( new test_choice( 1ul ) );
  BOOST_CHECK_EQUAL( var2->key(), key2 );
  BOOST_CHECK_EQUAL( var2->probability(), 0 );

}


!!!1278640.cpp!!!	choice_manager_test() : void
{
  // Test for noncopyable and nonvirtual pattern
  BOOST_CHECK( std::is_default_constructible< trial::choice_manager >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::choice_manager >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::choice_manager >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::choice_manager, trial::choice_manager >::type {} ) );
  BOOST_CHECK( not std::has_virtual_destructor< trial::choice_manager >::type {} );
}
std::stringstream store;
{
  // Default ctor
  boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
  // choice access methods
  BOOST_CHECK( cman->empty() );
  BOOST_CHECK_EQUAL( cman->size(), 0 );
  BOOST_CHECK( cman->begin() == cman->end() );
  // chooser access methods
  BOOST_CHECK( cman->empty_chooser() );
  BOOST_CHECK_EQUAL( cman->size_chooser(), 0 );
  BOOST_CHECK( cman->begin_chooser() == cman->end_chooser() );
  bool has = false;
  BOOST_CHECK_NO_THROW( has = cman->has_chooser( "move" ) );
  BOOST_CHECK_EQUAL( has, false );

  {
    core::input_delegater dg( 1 );
    {
      boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

      trial::move_choice::add_definition( *meta );

      BOOST_REQUIRE( meta->has_trial_type( "move" ) );

      dg.add_input_delegate( meta );
    }
    // Valid input
    /////////////////////////////
    std::string canon_input( "trial\ntype \"move\"\nrate 0.5\nspecie Na Cl\nend\n\n" );
    core::input_preprocess reader;
    reader.add_buffer( "dummy", canon_input );
    BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

    BOOST_REQUIRE( not cman->empty_chooser() );
    BOOST_CHECK_EQUAL( cman->size_chooser(), 1 );
    BOOST_CHECK( cman->has_chooser( "move" ) );
  }
  boost::archive::text_oarchive oa( store );
  // write class instance to archive
  oa << cman;
}
{
  boost::shared_ptr< trial::choice_manager > cman2;
  boost::archive::text_iarchive ia( store );
  // get class instance from archive
  ia >> cman2;

  // choice access methods
  BOOST_CHECK( cman2->empty() );
  BOOST_CHECK_EQUAL( cman2->size(), 0 );
  BOOST_CHECK( cman2->begin() == cman2->end() );
  // chooser access methods
  BOOST_REQUIRE( not cman2->empty_chooser() );
  BOOST_CHECK( cman2->has_chooser( "move" ) );
  BOOST_CHECK_EQUAL( cman2->size_chooser(), 1 );
  BOOST_CHECK_EQUAL( cman2->begin_chooser()->type(), "move" );
  BOOST_CHECK_CLOSE( cman2->begin_chooser()->rate(), 0.5, 0.000001 );
  BOOST_CHECK_EQUAL( cman2->begin_chooser()->specie_list(), "Na Cl" );
  BOOST_CHECK( cman2->begin_chooser()->parameters().empty() );

  boost::shared_ptr< particle::particle_manager > pman = trial_test::mockup_particle_manager();
  boost::shared_ptr< geometry::geometry_manager > gman = trial_test::mockup_geometry_manager();
  boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
  utility::random_distribution rgnr( generator );

  BOOST_REQUIRE_NO_THROW( cman2->prepare( pman->get_species(), *gman, rgnr ) );

  BOOST_CHECK( not cman2->empty() );
  BOOST_REQUIRE_EQUAL( cman2->size(), 5 );
  BOOST_CHECK( cman2->begin() != cman2->end() );
  std::bitset< 5 > all_spc;
  all_spc.reset(); // set all to none
  const particle::change_hash mover( 0, 1, 1, 0 );
  for (auto const& choice : *cman2 )
  {
    BOOST_CHECK_GE( choice.key().key(), 0 );
    BOOST_CHECK_LE( choice.key().key(), 4 );
    BOOST_CHECK( mover.match( choice.key() ) );
    BOOST_REQUIRE_NO_THROW( all_spc.set( choice.key().key() ) );
  }
  BOOST_REQUIRE( all_spc.all() );
}

!!!1207088.cpp!!!	add_specie_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::add_specie >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::add_specie >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::add_specie >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::add_specie, trial::add_specie >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::add_specie >::type {} );
}
particle::change_hash key1( 0, 0, 1, 0 );
boost::shared_ptr< trial::add_specie > var1( new trial::add_specie( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  trial_test::test_choice_generate< trial::add_specie >( params );

  trial_test::test_make_chooser_methods< trial::chooser_pair< trial::add_specie,trial::remove_specie  > >( params, "individual", "", 0.5, 4, 0.125 );
}

!!!1206704.cpp!!!	jump_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_choice >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_choice >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_choice >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_choice, trial::jump_choice >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_choice >::type {} );
}
particle::change_hash key1( 0, 1, 1, 1 );
boost::shared_ptr< trial::jump_choice > var1( new trial::jump_choice( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

std::map< std::string, std::string > params;

trial_test::test_choice_generate< trial::jump_choice >( params );

trial_test::test_make_chooser_methods< trial::chooser< trial::jump_choice > >( params, "jump", "", 0.5, 2, 0.25 );
!!!1206832.cpp!!!	jump_in_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_in >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_in >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_in >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_in, trial::jump_in >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_in >::type {} );
}
particle::change_hash key1( 0, 1, 1, 2 );
boost::shared_ptr< trial::jump_in > var1( new trial::jump_in( 0ul, 1 ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );
BOOST_CHECK_EQUAL( var1->region_index(), 1 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  params[ core::strngs::fsregn() ] = "bulk";
  trial_test::test_choice_generate< trial::jump_in >( params );

  trial_test::test_make_chooser_methods< trial::chooser< trial::jump_in > >( params, "jump-in", "", 0.5, 2, 0.25 );
}
!!!1206960.cpp!!!	jump_out_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_out >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_out >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_out >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_out, trial::jump_out >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_out >::type {} );
}
particle::change_hash key1( 0, 1, 1, 3 );
boost::shared_ptr< trial::jump_out > var1( new trial::jump_out( 0ul, 1ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );
BOOST_CHECK_EQUAL( var1->region_index(), 1 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  params[ core::strngs::fsregn() ] = "bulk";
  trial_test::test_choice_generate< trial::jump_out >( params );

  trial_test::test_make_chooser_methods< trial::chooser< trial::jump_out > >( params, "jump-out", "", 0.5, 2, 0.25 );
}
!!!1213744.cpp!!!	jump_around_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_around >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_around >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_around >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_around, trial::jump_around >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_around >::type {} );
}
particle::change_hash key1( 0, 1, 1, 4 );
boost::shared_ptr< trial::jump_around > var1( new trial::jump_around( 0ul, 1ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );
BOOST_CHECK_EQUAL( var1->region_index(), 1 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  params[ core::strngs::fsregn() ] = "bulk";
  trial_test::test_choice_generate< trial::jump_around >( params );

  trial_test::test_make_chooser_methods< trial::chooser< trial::jump_around > >( params, "jump-around", "", 0.5, 1, 0.5 );
}
!!!441776.cpp!!!	move_choice_test() : void
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::move_choice >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::move_choice >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::move_choice >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::move_choice, trial::move_choice >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::move_choice >::type {} );
}

const double prob = 0.1;
const double delta = 10.0;
particle::change_hash key1( 0, 1, 1, 0 );
boost::shared_ptr< trial::move_choice > var1( new trial::move_choice( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

BOOST_CHECK_EQUAL( var1->max_displacement(), trial::move_choice::default_displacement() );
BOOST_CHECK_NO_THROW( var1->set_max_displacement( delta ) );
BOOST_CHECK_EQUAL( var1->max_displacement(), delta );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  params[ "delta" ] = "0.5";
  trial_test::test_choice_generate< trial::move_choice >( params );

  trial_test::test_make_chooser_methods< trial::chooser< trial::move_choice > >( params, "move", "", 0.5, 5, 0.1 );
}
!!!1207216.cpp!!!	remove_specie_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::remove_specie >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::remove_specie >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::remove_specie >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::remove_specie, trial::remove_specie >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::remove_specie >::type {} );
}
particle::change_hash key1( 0, 1, 0, 0 );
boost::shared_ptr< trial::remove_specie > var1( new trial::remove_specie( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

{
  std::map< std::string, std::string > params;
  trial_test::test_choice_generate< trial::remove_specie >( params );
}
!!!1240752.cpp!!!	choice_meta_lifetime_test() : void
{
  // Test for virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::choice_meta >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::choice_meta >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::choice_meta >::type {} );
  BOOST_CHECK( not ( std::is_assignable< trial::choice_meta, trial::choice_meta >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::choice_meta >::type {} );
}
!!!791600.cpp!!!	choice_meta_move_choice_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
{
  core::input_help helper;
  dg.get_documentation( helper );
  std::stringstream omsg;
  helper.print( omsg );
  const std::string msg( omsg.str() );
  BOOST_CHECK_LE( msg.find( "--rate" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--type" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--specie" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--delta" ), msg.size() );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->empty_chooser() );
BOOST_CHECK( cman->has_chooser( "move" ) );
BOOST_CHECK_EQUAL( cman->begin_chooser()->type(), "move" );
BOOST_CHECK_CLOSE( cman->begin_chooser()->rate(), 0.5, 0.000001 );
BOOST_CHECK_EQUAL( cman->begin_chooser()->specie_list(), "Na Cl" );
BOOST_CHECK( cman->begin_chooser()->parameters().empty() );

// Echo input.
core::input_document inp( 1 );
BOOST_CHECK_NO_THROW( cman->write_document( inp ) );
BOOST_REQUIRE_EQUAL( inp.size(), 1 );
BOOST_REQUIRE_EQUAL( inp[ 0 ].label(), "trial" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].size(), 3 );
BOOST_REQUIRE( inp[ 0 ].has_entry( "specie" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "type" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "rate" ) );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "specie" ), "Na Cl" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "type" ), "move" );
BOOST_REQUIRE_CLOSE( boost::lexical_cast< double >( inp[ 0 ].get_entry( "rate" ) ), 0.5, 0.00001 );
//inp.write( std::cout );
!!!1240880.cpp!!!	choice_meta_jump_choice_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump" ) );

  dg.add_input_delegate( meta );
}
{
  core::input_help helper;
  dg.get_documentation( helper );
  std::stringstream omsg;
  helper.print( omsg );
  const std::string msg( omsg.str() );
  BOOST_CHECK_LE( msg.find( "--rate" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--type" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--specie" ), msg.size() );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"jump\"\nrate 0.45\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->empty_chooser() );
BOOST_CHECK( cman->has_chooser( "jump" ) );
BOOST_CHECK_EQUAL( cman->begin_chooser()->type(), "jump" );
BOOST_CHECK_CLOSE( cman->begin_chooser()->rate(), 0.45, 0.000001 );
BOOST_CHECK_EQUAL( cman->begin_chooser()->specie_list(), "Na Cl" );
BOOST_CHECK( cman->begin_chooser()->parameters().empty() );

// Echo input.
core::input_document inp( 1 );
BOOST_CHECK_NO_THROW( cman->write_document( inp ) );
BOOST_REQUIRE_EQUAL( inp.size(), 1 );
BOOST_REQUIRE_EQUAL( inp[ 0 ].label(), "trial" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].size(), 3 );
BOOST_REQUIRE( inp[ 0 ].has_entry( "specie" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "type" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "rate" ) );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "specie" ), "Na Cl" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "type" ), "jump" );
BOOST_REQUIRE_CLOSE( boost::lexical_cast< double >( inp[ 0 ].get_entry( "rate" ) ), 0.45, 0.00001 );
!!!1241008.cpp!!!	choice_meta_jump_around_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_around::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-around" ) );

  dg.add_input_delegate( meta );
}
{
  core::input_help helper;
  dg.get_documentation( helper );
  std::stringstream omsg;
  helper.print( omsg );
  const std::string msg( omsg.str() );
  BOOST_CHECK_LE( msg.find( "--rate" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--type" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--specie" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--region" ), msg.size() );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-around\"\nregion \"channel\"\nrate 0.51\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->empty_chooser() );
BOOST_CHECK( cman->has_chooser( "jump-around" ) );
BOOST_CHECK_EQUAL( cman->begin_chooser()->type(), "jump-around" );
BOOST_CHECK_CLOSE( cman->begin_chooser()->rate(), 0.51, 0.000001 );
BOOST_CHECK_EQUAL( cman->begin_chooser()->specie_list(), "Na Cl" );
BOOST_CHECK_EQUAL( cman->begin_chooser()->parameters().size(), 1 );
BOOST_CHECK_EQUAL( cman->begin_chooser()->parameters().at( "region" ), "\"channel\"" );

// Echo input.
core::input_document inp( 1 );
BOOST_CHECK_NO_THROW( cman->write_document( inp ) );
BOOST_REQUIRE_EQUAL( inp.size(), 1 );
BOOST_REQUIRE_EQUAL( inp[ 0 ].label(), "trial" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].size(), 4 );
BOOST_REQUIRE( inp[ 0 ].has_entry( "specie" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "type" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "rate" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "region" ) );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "specie" ), "Na Cl" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "type" ), "jump-around" );
BOOST_REQUIRE_CLOSE( boost::lexical_cast< double >( inp[ 0 ].get_entry( "rate" ) ), 0.51, 0.00001 );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "region" ), "\"channel\"" );
!!!1241136.cpp!!!	choice_meta_jump_in_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_in::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-in" ) );

  dg.add_input_delegate( meta );
}
{
  core::input_help helper;
  dg.get_documentation( helper );
  std::stringstream omsg;
  helper.print( omsg );
  const std::string msg( omsg.str() );
  BOOST_CHECK_LE( msg.find( "--rate" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--type" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--specie" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--region" ), msg.size() );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-in\"\nregion \"bulk\"\nrate 0.55\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->empty_chooser() );
BOOST_CHECK( cman->has_chooser( "jump-in" ) );
BOOST_CHECK_EQUAL( cman->begin_chooser()->type(), "jump-in" );
BOOST_CHECK_CLOSE( cman->begin_chooser()->rate(), 0.55, 0.000001 );
BOOST_CHECK_EQUAL( cman->begin_chooser()->specie_list(), "Na Cl" );
BOOST_CHECK_EQUAL( cman->begin_chooser()->parameters().size(), 1 );
BOOST_CHECK_EQUAL( cman->begin_chooser()->parameters().at( "region" ), "\"bulk\"" );

// Echo input.
core::input_document inp( 1 );
BOOST_CHECK_NO_THROW( cman->write_document( inp ) );
BOOST_REQUIRE_EQUAL( inp.size(), 1 );
BOOST_REQUIRE_EQUAL( inp[ 0 ].label(), "trial" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].size(), 4 );
BOOST_REQUIRE( inp[ 0 ].has_entry( "specie" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "type" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "rate" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "region" ) );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "specie" ), "Na Cl" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "type" ), "jump-in" );
BOOST_REQUIRE_CLOSE( boost::lexical_cast< double >( inp[ 0 ].get_entry( "rate" ) ), 0.55, 0.00001 );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "region" ), "\"bulk\"" );
!!!1241264.cpp!!!	choice_meta_jump_out_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_out::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-out" ) );

  dg.add_input_delegate( meta );
}
{
  core::input_help helper;
  dg.get_documentation( helper );
  std::stringstream omsg;
  helper.print( omsg );
  const std::string msg( omsg.str() );
  BOOST_CHECK_LE( msg.find( "--rate" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--type" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--specie" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--region" ), msg.size() );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-out\"\nregion centre\nrate 0.35\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->empty_chooser() );
BOOST_CHECK( cman->has_chooser( "jump-out" ) );
BOOST_CHECK_EQUAL( cman->begin_chooser()->type(), "jump-out" );
BOOST_CHECK_CLOSE( cman->begin_chooser()->rate(), 0.35, 0.000001 );
BOOST_CHECK_EQUAL( cman->begin_chooser()->specie_list(), "Na Cl" );
BOOST_CHECK_EQUAL( cman->begin_chooser()->parameters().size(), 1 );
BOOST_CHECK_EQUAL( cman->begin_chooser()->parameters().at( "region" ), "centre" );

// Echo input.
core::input_document inp( 1 );
BOOST_CHECK_NO_THROW( cman->write_document( inp ) );
BOOST_REQUIRE_EQUAL( inp.size(), 1 );
BOOST_REQUIRE_EQUAL( inp[ 0 ].label(), "trial" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].size(), 4 );
BOOST_REQUIRE( inp[ 0 ].has_entry( "specie" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "type" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "rate" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "region" ) );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "specie" ), "Na Cl" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "type" ), "jump-out" );
BOOST_REQUIRE_CLOSE( boost::lexical_cast< double >( inp[ 0 ].get_entry( "rate" ) ), 0.35, 0.00001 );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "region" ), "centre" );
!!!1241392.cpp!!!	choice_meta_add_remove_choice_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::add_specie::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "individual" ) );

  dg.add_input_delegate( meta );
}
{
  core::input_help helper;
  dg.get_documentation( helper );
  std::stringstream omsg;
  helper.print( omsg );
  const std::string msg( omsg.str() );
  BOOST_CHECK_LE( msg.find( "--rate" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--type" ), msg.size() );
  BOOST_CHECK_LE( msg.find( "--specie" ), msg.size() );
}
// Valid input
/////////////////////////////
std::string canon_input( "trial\ntype \"individual\"\nrate 0.53\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE( not cman->empty_chooser() );
BOOST_CHECK( cman->has_chooser( "individual" ) );
BOOST_CHECK_EQUAL( cman->begin_chooser()->type(), "individual" );
BOOST_CHECK_CLOSE( cman->begin_chooser()->rate(), 0.53, 0.000001 );
BOOST_CHECK_EQUAL( cman->begin_chooser()->specie_list(), "Na Cl" );
BOOST_CHECK( cman->begin_chooser()->parameters().empty() );

// Echo input.
core::input_document inp( 1 );
BOOST_CHECK_NO_THROW( cman->write_document( inp ) );
BOOST_REQUIRE_EQUAL( inp.size(), 1 );
BOOST_REQUIRE_EQUAL( inp[ 0 ].label(), "trial" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].size(), 3 );
BOOST_REQUIRE( inp[ 0 ].has_entry( "specie" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "type" ) );
BOOST_REQUIRE( inp[ 0 ].has_entry( "rate" ) );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "specie" ), "Na Cl" );
BOOST_REQUIRE_EQUAL( inp[ 0 ].get_entry( "type" ), "individual" );
BOOST_REQUIRE_CLOSE( boost::lexical_cast< double >( inp[ 0 ].get_entry( "rate" ) ), 0.53, 0.00001 );
!!!1241520.cpp!!!	trial_input_no_type_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\n#type \"move\"\nrate 0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial section requires \"type\" parameter" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1248048.cpp!!!	trial_input_type_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype #\"move\"\nrate 0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"type\" parameter requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1248176.cpp!!!	trial_input_type_bad_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump\"\nrate 0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"type\" parameter value (jump) is not a valid" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1248304.cpp!!!	trial_input_duplicate_type_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.5\nspecie Na Cl\n\ntype \"move\"\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"type\" parameter appears more than once" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1248816.cpp!!!	trial_input_no_rate_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\n#rate 0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial section requires \"rate\" parameter" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1248688.cpp!!!	trial_input_rate_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate #0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"rate\" parameter requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1248560.cpp!!!	trial_input_rate_negative_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate -0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"rate\" parameter value (-0.5) must be greater than zero" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1249072.cpp!!!	trial_input_rate_zero_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.0\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"rate\" parameter value (0.0) must be greater than zero" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1248944.cpp!!!	trial_input_rate_nonnumber_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate one\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"rate\" parameter value (one) is not a number" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1248432.cpp!!!	trial_input_duplicate_rate_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.5\nspecie Na Cl\n\nrate 0.4\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"rate\" parameter appears more than once" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1249328.cpp!!!	trial_input_specielist_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.5\nspecie # Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"specie\" parameter requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1249200.cpp!!!	trial_input_duplicate_specielist_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.5\nspecie Na Cl\n\nspecie \"move\"\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"specie\" parameter appears more than once" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1256368.cpp!!!	trial_input_move_delta_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.5\ndelta #0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );

try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 5 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Move trial \"delta\" parameter requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1256240.cpp!!!	trial_input_move_delta_negative_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.5\ndelta -0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );
try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Move trial \"delta\" parameter value (-0.5) must be greater than zero" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1256112.cpp!!!	trial_input_move_delta_zero_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.5\ndelta 0.0\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );
try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 5 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Move trial \"delta\" parameter value (0.0) must be greater than zero" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1255984.cpp!!!	trial_input_move_delta_nonnumber_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.1\ndelta one\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );
try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 5 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Move trial \"delta\" parameter value (one) is not a number" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1255856.cpp!!!	trial_input_move_duplicate_delta_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.5\ndelta 0.5\nspecie Na Cl\n\ndelta 0.4\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"delta\" parameter appears more than once" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1263152.cpp!!!	trial_input_move_unknown_parameter_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::move_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "move" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"move\"\nrate 0.5\nDELTA 0.5\nspecie Na Cl\n\ndelta 0.4\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"DELTA\" parameter with value (0.5) is not understood by move trial" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1270576.cpp!!!	trial_input_jump_unknown_parameter_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_choice::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump\"\nrate 0.5\ndelta 0.5\nspecie Na Cl\n\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"delta\" parameter with value (0.5) is not understood by jump trial" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1271728.cpp!!!	trial_input_jump_in_no_region_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_in::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-in" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-in\"\nrate 0.5\n#region bulk\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );

try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 2 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Jump-in trial requires \"region\" parameter" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1270448.cpp!!!	trial_input_jump_in_region_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_in::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-in" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-in\"\nrate 0.5\nregion #bulk\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );

try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 2 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Jump-in trial \"region\" parameter requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1270064.cpp!!!	trial_input_jump_in_region_bad_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_in::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-in" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-in\"\nrate 0.1\nregion one\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );
try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 5 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Jump-in trial \"region\" parameter value (one) is not a known region label" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1269936.cpp!!!	trial_input_jump_in_duplicate_region_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_in::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-in" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-in\"\nrate 0.5\nregion bulk\nspecie Na Cl\n\nregion channel\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"region\" parameter appears more than once" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1269808.cpp!!!	trial_input_jump_in_unknown_parameter_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_in::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-in" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-in\"\nrate 0.5\nDELTA 0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"DELTA\" parameter with value (0.5) is not understood by jump-in trial" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1271856.cpp!!!	trial_input_jump_out_no_region_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_out::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-out" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-out\"\nrate 0.5\n#region bulk\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );

try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 2 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Jump-out trial requires \"region\" parameter" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1271088.cpp!!!	trial_input_jump_out_region_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_out::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-out" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-out\"\nrate 0.5\nregion #bulk\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );

try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 2 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Jump-out trial \"region\" parameter requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1270960.cpp!!!	trial_input_jump_out_region_bad_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_out::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-out" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-out\"\nrate 0.1\nregion one\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );
try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 5 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Jump-out trial \"region\" parameter value (one) is not a known region label" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"cman->prepare( ... )\" was not expected type: " ) + err.what() );
}


!!!1270832.cpp!!!	trial_input_jump_out_duplicate_region_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_out::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-out" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-out\"\nrate 0.5\nregion bulk\nspecie Na Cl\n\nregion channel\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"region\" parameter appears more than once" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1270704.cpp!!!	trial_input_jump_out_unknown_parameter_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_out::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-out" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-out\"\nrate 0.5\nDELTA 0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"DELTA\" parameter with value (0.5) is not understood by jump-out trial" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1271984.cpp!!!	trial_input_jump_around_no_region_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_around::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-around" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-around\"\nrate 0.5\n#region bulk\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );

try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 2 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Jump-around trial requires \"region\" parameter" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1271600.cpp!!!	trial_input_jump_around_region_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_around::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-around" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-around\"\nrate 0.5\nregion #bulk\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );

try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 2 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Jump-around trial \"region\" parameter requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1271472.cpp!!!	trial_input_jump_around_region_bad_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_around::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-around" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-around\"\nrate 0.1\nregion one\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

auto pman = trial_test::mockup_particle_manager();
auto gman = trial_test::mockup_geometry_manager();
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );
try
{
  // attributes from parameters are only tested when choice object
  // is created (e.g. in choice_manager::prepare)
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
  cman->prepare( pman->get_species(), *gman, rgnr );  
  // If no exception then check for number of choices created.
  BOOST_CHECK_EQUAL( cman->size(), 1 );
  BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Jump-around trial \"region\" parameter value (one) is not a known region label" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"cman->prepare( ... )\" was not expected type: " ) + err.what() );
}


!!!1271344.cpp!!!	trial_input_jump_around_duplicate_region_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_around::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-around" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-around\"\nrate 0.5\nregion bulk\nspecie Na Cl\n\nregion channel\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"region\" parameter appears more than once" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1271216.cpp!!!	trial_input_jump_around_unknown_parameter_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::jump_around::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "jump-around" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"jump-around\"\nrate 0.5\nDELTA 0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"DELTA\" parameter with value (0.5) is not understood by jump-around trial" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1278512.cpp!!!	trial_input_add_specie_unknown_parameter_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
{
  boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );

  trial::add_specie::add_definition( *meta );

  BOOST_REQUIRE( meta->has_trial_type( "individual" ) );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "trial\ntype \"individual\"\nrate 0.5\ndelta 0.5\nspecie Na Cl\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Trial \"delta\" parameter with value (0.5) is not understood by individual trial" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


