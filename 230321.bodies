class trial_test
!!!1185584.cpp!!!	test_base_choice_methods(inout choice : base_choice) : void
std::stringstream ss;
double prob;
trial::choice_hash key;
// serialization test
{
  prob = choice->probability();
  key = choice->key();
  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  oa << choice;
}
{
  boost::shared_ptr< trial::base_choice > copy;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  ia >> copy;
  BOOST_REQUIRE( utility::feq( copy->probability(), prob ) );
  BOOST_REQUIRE( copy->key() == key );

  // Try setting probability on copy
  prob += 1.0;
  BOOST_CHECK_NO_THROW( copy->set_probability( prob ) );
  BOOST_REQUIRE( utility::feq( copy->probability(), prob ) );
  BOOST_REQUIRE( not utility::feq( copy->probability(), choice->probability() ) );
}

!!!1220272.cpp!!!	test_choice_generate(in params : string) : void
particle::particle_manager pman;
{
  particle::specie spc1;
 spc1.set_label( "CA" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.11 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::MOBILE );
  spc1.append_position( particle::coordinate( 2.0, 2.0, 0.0 ), particle::centroid( 3.0, 2.0, 2.0, 0.0 ) );
  pman.add_specie( spc1 );
 
  spc1.set_label( "CO" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::FLEXIBLE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 2.0 ), particle::centroid( 3.0, 0.0, 0.0, 2.0 ) );
  pman.add_specie( spc1 );
 
  spc1.set_label( "OX" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::CHANNEL_ONLY );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 2.0 ) );
  pman.add_specie( spc1 );

  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 0.0 ) );
  pman.add_specie( spc1 );
 
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 2.0, 0.0 ) );
  pman.add_specie( spc1 );
 
 }
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 5 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 6 );
boost::shared_ptr< geometry::base_region > regn( new geometry::periodic_cube_region( "cell", 5.0 ) ); 
geometry::geometry_manager gman( regn );
{
  boost::shared_ptr< geometry::base_region > bulk( new geometry::cube_region( "bulk", 4.0, particle::coordinate( 0.0, 0.0, 0.0 ), true ) ); 
  gman.add_region( bulk );
}
{
  const auto& ens = pman.get_ensemble();
  for( std::size_t idx = 0; idx != ens.size(); ++idx )
  {
    if( ens.key( idx ) != particle::specie_key::nkey )
    {
      particle::coordinate pos = ens.position( idx );
      BOOST_REQUIRE( gman.system_region().is_inside( pos, pman.get_specie( ens.key( idx ) ).radius() ) );
    }
  }
}
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgnr( generator );

bool usable = false;
for(std::size_t idx = 0; idx != pman.specie_count(); ++idx )
{
  if( Choice::permitted( pman.get_specie( idx ) ) )
  {
    usable = true;
    std::unique_ptr< trial::base_choice > chc( Choice::make_choice( idx, params ) );
    std::unique_ptr< particle::change_set > tryit( chc->generate( pman, gman, rgnr ) );
    BOOST_REQUIRE( tryit->fail() or ( tryit->size() > 0 ) );
  }
}
BOOST_REQUIRE( usable );
!!!783408.cpp!!!	choice_hash_test() : void
{
  // Test for canonical pattern
  BOOST_CHECK( std::is_default_constructible< trial::choice_hash >::type {} );
  BOOST_CHECK( std::is_copy_constructible< trial::choice_hash >::type {} );
  BOOST_CHECK( std::is_move_constructible< trial::choice_hash >::type {} );
  BOOST_CHECK( ( std::is_assignable< trial::choice_hash, trial::choice_hash >::type {} ) );
  BOOST_CHECK( not std::has_virtual_destructor< trial::choice_hash >::type {} );
}
std::stringstream store;
{
  // Default ctor
  trial::choice_hash var1;
  BOOST_CHECK_EQUAL( var1.key, 0 );
  BOOST_CHECK_EQUAL( var1.start, 0 );
  BOOST_CHECK_EQUAL( var1.finish, 0 );
  BOOST_CHECK_EQUAL( var1.subtype, 0 );

  trial::choice_hash var2;
  BOOST_CHECK( var1.equivalent( var2 ) );
  BOOST_CHECK( var1 == var2 );
  BOOST_CHECK( var1 >= var2 );
  BOOST_CHECK( var1 <= var2 );
  BOOST_CHECK( not (var1 != var2) );
  BOOST_CHECK( not (var1.less_than( var2 ) ) );
  BOOST_CHECK( not (var1 < var2) );

  var1.key = 1;
  var1.start = 2;
  var1.finish = 3;
  var1.subtype = 4;

  BOOST_CHECK( not var1.equivalent( var2 ) );

  trial::choice_hash var3( 1, 2, 3, 4 );
  BOOST_CHECK( var1.key == var3.key );
  BOOST_CHECK( var1.start == var3.start );
  BOOST_CHECK( var1.finish == var3.finish );
  BOOST_CHECK( var1.subtype == var3.subtype );

  // copy ctor
  trial::choice_hash var4( var1 );
  BOOST_CHECK( var1 == var4 );

  // move ctor
  trial::choice_hash var5( std::move( var4 ) );
  BOOST_CHECK( var1 == var5 );

  var5.subtype = 5;
  BOOST_CHECK( var1 != var5 );
  // op=
  var5 = var3;
  BOOST_CHECK( var1 == var5 );

  boost::archive::text_oarchive oa(store);
  // write class instance to archive
  oa << var1;
}
{
  trial::choice_hash var1;
  trial::choice_hash var2;

  BOOST_CHECK( var1 == var2 );

  boost::archive::text_iarchive ia(store);
  // get class instance from archive
  ia >> var1;

  BOOST_CHECK( var1 != var2 );
  BOOST_CHECK_EQUAL( var1.key, 1 );
  BOOST_CHECK_EQUAL( var1.start, 2 );
  BOOST_CHECK_EQUAL( var1.finish, 3 );
  BOOST_CHECK_EQUAL( var1.subtype, 4 );
}
{
  // Check comparison
  trial::choice_hash var1( 1, 2, 3, 4 );
  trial::choice_hash var2( 1, 2, 3, 5 );
  BOOST_CHECK( var1.key == var2.key );
  BOOST_CHECK( var1.start == var2.start );
  BOOST_CHECK( var1.finish == var2.finish );
  BOOST_CHECK( var1.subtype < var2.subtype );

  BOOST_CHECK( var1 != var2 );
  BOOST_CHECK( var1 < var2 );
  BOOST_CHECK( var1 <= var2 );
  BOOST_CHECK( var2 > var1 );
  BOOST_CHECK( var2 >= var1 );
  BOOST_CHECK( not var1.match( var2 ) );

  var2 = var1;
  ++var2.finish;

  BOOST_CHECK( var1 != var2 );
  BOOST_CHECK( var1 < var2 );
  BOOST_CHECK( var1 <= var2 );
  BOOST_CHECK( var2 > var1 );
  BOOST_CHECK( var2 >= var1 );
  BOOST_CHECK( not var1.match( var2 ) );

  var2 = var1;
  ++var2.start;

  BOOST_CHECK( var1 != var2 );
  BOOST_CHECK( var1 < var2 );
  BOOST_CHECK( var1 <= var2 );
  BOOST_CHECK( var2 > var1 );
  BOOST_CHECK( var2 >= var1 );
  BOOST_CHECK( not var1.match( var2 ) );

  var2 = var1;
  ++var2.key;

  BOOST_CHECK( var1 != var2 );
  BOOST_CHECK( var1 < var2 );
  BOOST_CHECK( var1 <= var2 );
  BOOST_CHECK( var2 > var1 );
  BOOST_CHECK( var2 >= var1 );
  BOOST_CHECK( var1.match( var2 ) );

}
!!!1185712.cpp!!!	base_choice_test() : void
{
  // Test for virtual noncopy pattern
  BOOST_CHECK( not std::is_default_constructible< test_choice >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< test_choice >::type {} );
  BOOST_CHECK( not std::is_move_constructible< test_choice >::type {} );
  BOOST_CHECK( not( std::is_assignable< test_choice, test_choice >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< test_choice >::type {} );
}

{
// Public ctor 1
  const double prob = 0.1;
  trial::choice_hash key1( 1, 2, 3, 4 );
  boost::shared_ptr< trial::base_choice > var1( new test_choice( key1 ) );
  BOOST_CHECK_EQUAL( var1->key(), key1 );
  BOOST_CHECK_EQUAL( var1->probability(), 0 );

  BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
  BOOST_CHECK_EQUAL( var1->probability(), prob );

  trial_test::test_base_choice_methods( var1 );
}

{
// Public ctor 2
  trial::choice_hash key2( 1, 0, 0, 0 );
  boost::shared_ptr< trial::base_choice > var2( new test_choice( 1ul ) );
  BOOST_CHECK_EQUAL( var2->key(), key2 );
  BOOST_CHECK_EQUAL( var2->probability(), 0 );

}


!!!1207088.cpp!!!	add_specie_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::add_specie >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::add_specie >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::add_specie >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::add_specie, trial::add_specie >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::add_specie >::type {} );
}
trial::choice_hash key1( 0, 0, 1, 0 );
boost::shared_ptr< trial::add_specie > var1( new trial::add_specie( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

!!!1206704.cpp!!!	jump_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_choice >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_choice >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_choice >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_choice, trial::jump_choice >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_choice >::type {} );
}
trial::choice_hash key1( 0, 1, 1, 1 );
boost::shared_ptr< trial::jump_choice > var1( new trial::jump_choice( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

std::map< std::string, std::string > params;

trial_test::test_choice_generate< trial::jump_choice >( params );
!!!1206832.cpp!!!	jump_in_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_in >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_in >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_in >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_in, trial::jump_in >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_in >::type {} );
}
trial::choice_hash key1( 0, 1, 1, 2 );
boost::shared_ptr< trial::jump_in > var1( new trial::jump_in( 0ul, "bulk" ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );
BOOST_CHECK_EQUAL( var1->region_name(), "bulk" );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

!!!1206960.cpp!!!	jump_out_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_out >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_out >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_out >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_out, trial::jump_out >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_out >::type {} );
}
trial::choice_hash key1( 0, 1, 1, 3 );
boost::shared_ptr< trial::jump_out > var1( new trial::jump_out( 0ul, "channel" ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );
BOOST_CHECK_EQUAL( var1->region_name(), "channel" );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

!!!1213744.cpp!!!	jump_around_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::jump_around >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::jump_around >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::jump_around >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::jump_around, trial::jump_around >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::jump_around >::type {} );
}
trial::choice_hash key1( 0, 1, 1, 4 );
boost::shared_ptr< trial::jump_around > var1( new trial::jump_around( 0ul, "channel" ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );
BOOST_CHECK_EQUAL( var1->region_name(), "channel" );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

!!!441776.cpp!!!	move_choice_test() : void
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::move_choice >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::move_choice >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::move_choice >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::move_choice, trial::move_choice >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::move_choice >::type {} );
}

const double prob = 0.1;
const double delta = 10.0;
trial::choice_hash key1( 0, 1, 1, 0 );
boost::shared_ptr< trial::move_choice > var1( new trial::move_choice( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

BOOST_CHECK_EQUAL( var1->max_displacement(), trial::move_choice::default_displacement() );
BOOST_CHECK_NO_THROW( var1->set_max_displacement( delta ) );
BOOST_CHECK_EQUAL( var1->max_displacement(), delta );

trial_test::test_base_choice_methods( var1 );

!!!1207216.cpp!!!	remove_specie_choice_test() : void
const double prob = 0.1;
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< trial::remove_specie >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< trial::remove_specie >::type {} );
  BOOST_CHECK( not std::is_move_constructible< trial::remove_specie >::type {} );
  BOOST_CHECK( not( std::is_assignable< trial::remove_specie, trial::remove_specie >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< trial::remove_specie >::type {} );
}
trial::choice_hash key1( 0, 1, 0, 0 );
boost::shared_ptr< trial::remove_specie > var1( new trial::remove_specie( 0ul ) );
BOOST_CHECK_EQUAL( var1->key(), key1 );
BOOST_CHECK_EQUAL( var1->probability(), 0 );

BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
BOOST_CHECK_EQUAL( var1->probability(), prob );

trial_test::test_base_choice_methods( var1 );

!!!791600.cpp!!!	test_chooser_test() : void
//XXstd::stringstream store;
//XX{
//XX  // Test chooser key.
//XX  trial::choice_hash var3( 1, 2, 3, 4 );
//XX
//XX  trial::choice_hash var1;
//XX  BOOST_CHECK_EQUAL( var1.key, 0 );
//XX  BOOST_CHECK_EQUAL( var1.start, 0 );
//XX  BOOST_CHECK_EQUAL( var1.finish, 0 );
//XX  BOOST_CHECK_EQUAL( var1.subtype, 0 );
//XX
//XX  trial::choice_hash var2;
//XX  BOOST_CHECK( var1.equivalent( var2 ) );
//XX  BOOST_CHECK( var1 == var2 );
//XX  BOOST_CHECK( var1 >= var2 );
//XX  BOOST_CHECK( var1 <= var2 );
//XX  BOOST_CHECK( not (var1 != var2) );
//XX  BOOST_CHECK( not (var1.less_than( var2 ) ) );
//XX  BOOST_CHECK( not (var1 < var2) );
//XX
//XX  var1.key = 1;
//XX  var1.start = 2;
//XX  var1.finish = 3;
//XX  var1.subtype = 4;
//XX
//XX  BOOST_CHECK( not var1.equivalent( var2 ) );
//XX
//XX  BOOST_CHECK( var1.key == var3.key );
//XX  BOOST_CHECK( var1.start == var3.start );
//XX  BOOST_CHECK( var1.finish == var3.finish );
//XX  BOOST_CHECK( var1.subtype == var3.subtype );
//XX
//XX  // copy ctor
//XX  trial::choice_hash var4( var1 );
//XX  BOOST_CHECK( var1 == var4 );
//XX
//XX  // move ctor
//XX  trial::choice_hash var5( std::move( var4 ) );
//XX  BOOST_CHECK( var1 == var5 );
//XX
//XX  var5.subtype = 5;
//XX  BOOST_CHECK( var1 != var5 );
//XX  // op=
//XX  var5 = var3;
//XX  BOOST_CHECK( var1 == var5 );
//XX
//XX  boost::archive::text_oarchive oa(store);
//XX  // write class instance to archive
//XX  oa << var1;
//XX}
//XX{
//XX  trial::choice_hash var1;
//XX  trial::choice_hash var2;
//XX
//XX  BOOST_CHECK( var1 == var2 );
//XX
//XX  boost::archive::text_iarchive ia(store);
//XX  // get class instance from archive
//XX  ia >> var1;
//XX
//XX  BOOST_CHECK( var1 != var2 );
//XX  BOOST_CHECK_EQUAL( var1.key, 1 );
//XX  BOOST_CHECK_EQUAL( var1.start, 2 );
//XX  BOOST_CHECK_EQUAL( var1.finish, 3 );
//XX  BOOST_CHECK_EQUAL( var1.subtype, 4 );
//XX}
//XX{
//XX  // Check comparison
//XX  trial::choice_hash var1( 1, 2, 3, 4 );
//XX  trial::choice_hash var2( 1, 2, 3, 5 );
//XX  BOOST_CHECK( var1.key == var2.key );
//XX  BOOST_CHECK( var1.start == var2.start );
//XX  BOOST_CHECK( var1.finish == var2.finish );
//XX  BOOST_CHECK( var1.subtype < var2.subtype );
//XX
//XX  BOOST_CHECK( var1 != var2 );
//XX  BOOST_CHECK( var1 < var2 );
//XX  BOOST_CHECK( var1 <= var2 );
//XX  BOOST_CHECK( var2 > var1 );
//XX  BOOST_CHECK( var2 >= var1 );
//XX  BOOST_CHECK( not var1.match( var2 ) );
//XX
//XX  var2 = var1;
//XX  ++var2.finish;
//XX
//XX  BOOST_CHECK( var1 != var2 );
//XX  BOOST_CHECK( var1 < var2 );
//XX  BOOST_CHECK( var1 <= var2 );
//XX  BOOST_CHECK( var2 > var1 );
//XX  BOOST_CHECK( var2 >= var1 );
//XX  BOOST_CHECK( not var1.match( var2 ) );
//XX
//XX  var2 = var1;
//XX  ++var2.start;
//XX
//XX  BOOST_CHECK( var1 != var2 );
//XX  BOOST_CHECK( var1 < var2 );
//XX  BOOST_CHECK( var1 <= var2 );
//XX  BOOST_CHECK( var2 > var1 );
//XX  BOOST_CHECK( var2 >= var1 );
//XX  BOOST_CHECK( not var1.match( var2 ) );
//XX
//XX  var2 = var1;
//XX  ++var2.key;
//XX
//XX  BOOST_CHECK( var1 != var2 );
//XX  BOOST_CHECK( var1 < var2 );
//XX  BOOST_CHECK( var1 <= var2 );
//XX  BOOST_CHECK( var2 > var1 );
//XX  BOOST_CHECK( var2 >= var1 );
//XX  BOOST_CHECK( var1.match( var2 ) );
//XX
//XX}
!!!798384.cpp!!!	test_chooser_operation(in chsr : base_chooser, in expected_size : size_t) : void
//XX// The chooser interface provides a single unique 
//XX// function, generate_choices. This method takes a
//XX// simulation object and adds choice objects to a
//XX// a list. The hash 'key' of the generated choice
//XX// objects must 'match' the key of the chooser
//XX// object that generated them.
//XX
//XX// call signature
//XX// void generate_choices(const simulator & sim, boost::ptr_vector< base_choice >& choices) const
//XX
//XX
//XX// generated_choices
//XX// is_permitted
//XX// make_choice
//XX// write_document
//XX// serialize
//XX
//XXboost::ptr_vector< trial::base_choice > choices;
//XX
//XX// dummy simulator
//XXplatform::simulator_fixture simfix;
//XXsimfix.add_solute_species();
//XXsimfix.add_localized_species();
//XX 
//XXchsr.generate_choices( simfix.sim->get_species(), choices );
//XX
//XXBOOST_CHECK( choices.size() == expected_size );
