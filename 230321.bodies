class trial_test
!!!420145.cpp!!!	change_atom_test() : void
const std::vector< double > nrij { 1.0, 1.3, 2.4 };
const std::vector< double > orij { 1.1, 1.4, 2.0 };
const double epsdefault{ 80.0 };
const double epsw{ 70.0 };
{
  // Default ctor
  trial::change_atom var1;
  BOOST_CHECK_EQUAL(var1.new_position.x, 0.0);
  BOOST_CHECK_EQUAL(var1.new_position.y, 0.0);
  BOOST_CHECK_EQUAL(var1.new_position.z, 0.0);
  BOOST_CHECK_EQUAL(var1.old_position.x, 0.0);
  BOOST_CHECK_EQUAL(var1.old_position.y, 0.0);
  BOOST_CHECK_EQUAL(var1.old_position.z, 0.0);
  BOOST_CHECK_EQUAL(var1.energy_old, 0.0);
  BOOST_CHECK_EQUAL(var1.energy_new, 0.0);
  BOOST_CHECK_EQUAL(var1.eps_old, 0.0);
  BOOST_CHECK_EQUAL(var1.eps_new, 0.0);
  BOOST_CHECK_EQUAL(var1.index, 0);
  BOOST_CHECK_EQUAL(var1.key, std::size_t(particle::ensemble::nkey));
  BOOST_CHECK_EQUAL(var1.do_old, true);
  BOOST_CHECK_EQUAL(var1.do_new, true);
  BOOST_CHECK(var1.old_rij.empty());
  BOOST_CHECK(var1.new_rij.empty());

}
std::stringstream store;
{
  // Ctor with args
  particle::coordinate old_p (1.0, 10.0, 2.0);
  particle::coordinate new_p (old_p);
  new_p.x -= 0.1;
  new_p.y -= 0.2;
  new_p.z += 0.15;
  trial::change_atom var1(true, true, 10, old_p, new_p, 2, epsdefault, epsw);
  // Check set values
  BOOST_CHECK_EQUAL(var1.do_old, true);
  BOOST_CHECK_EQUAL(var1.do_new, true);
  BOOST_CHECK_EQUAL(var1.index, 10);
  BOOST_CHECK_EQUAL(var1.old_position.x, 1.0);
  BOOST_CHECK_EQUAL(var1.old_position.y, 10.0);
  BOOST_CHECK_EQUAL(var1.old_position.z, 2.0);
  BOOST_CHECK_EQUAL(var1.new_position.x, 0.9);
  BOOST_CHECK_EQUAL(var1.new_position.y, 9.8);
  BOOST_CHECK_EQUAL(var1.new_position.z, 2.15);
  BOOST_CHECK_EQUAL(var1.key, 2);
  BOOST_CHECK_EQUAL(var1.energy_old, 0.0);
  BOOST_CHECK_EQUAL(var1.energy_new, 0.0);
  BOOST_CHECK_EQUAL( var1.eps_old, epsdefault );
  BOOST_CHECK_EQUAL( var1.eps_new, epsw );
  BOOST_CHECK(var1.old_rij.empty());
  BOOST_CHECK(var1.new_rij.empty());
  // Set some values
  var1.energy_old = 0.001;
  var1.energy_new = 0.02;
  var1.old_rij = orij;
  var1.new_rij = nrij;
  // Use var1 to make copies
  {
    // Copy ctor.
    trial::change_atom var2 (var1);
    BOOST_CHECK_EQUAL( var2.new_position.x, var1.new_position.x );
    BOOST_CHECK_EQUAL( var2.new_position.y, var1.new_position.y );
    BOOST_CHECK_EQUAL( var2.new_position.z, var1.new_position.z );
    BOOST_CHECK_EQUAL( var2.old_position.x, var1.old_position.x );
    BOOST_CHECK_EQUAL( var2.old_position.y, var1.old_position.y );
    BOOST_CHECK_EQUAL( var2.old_position.z, var1.old_position.z );
    BOOST_CHECK_EQUAL( var2.index, var1.index );
    BOOST_CHECK_EQUAL( var2.key, var1.key );
    BOOST_CHECK_EQUAL( var2.do_old, var1.do_old );
    BOOST_CHECK_EQUAL( var2.do_new, var1.do_new );
    BOOST_CHECK_EQUAL( var2.energy_old, var1.energy_old );
    BOOST_CHECK_EQUAL( var2.energy_new, var1.energy_new );
    BOOST_CHECK_EQUAL( var2.eps_old, var1.eps_old );
    BOOST_CHECK_EQUAL( var2.eps_new, var1.eps_new );
    BOOST_CHECK_EQUAL_COLLECTIONS(var2.old_rij.begin(), var2.old_rij.end()
        , orij.begin(), orij.end());
    BOOST_CHECK_EQUAL_COLLECTIONS(var2.new_rij.begin(), var2.new_rij.end()
        , nrij.begin(), nrij.end());
    BOOST_CHECK( var2.equivalent(var1) );
  }
  {
    // TEST equivalent is sensitive to change in any one parameter
    BOOST_CHECK( var1.equivalent(var1) );
    {
      trial::change_atom var2( var1 );
      var2.new_position.x += 0.1;
      BOOST_CHECK(not var2.equivalent(var1));
    }   
    {
      trial::change_atom var2(var1);
      var2.new_position.y += 0.1;
      BOOST_CHECK(not var2.equivalent(var1));
    }   
    {
      trial::change_atom var2(var1);
      var2.new_position.z += 0.1;
      BOOST_CHECK(not var2.equivalent(var1));
    }   
    {
      trial::change_atom var2(var1);
      var2.old_position.x += 0.1;
      BOOST_CHECK(not var2.equivalent(var1));
    }   
    {
      trial::change_atom var2(var1);
      var2.old_position.y += 0.1;
      BOOST_CHECK(not var2.equivalent(var1));
    }   
    {
      trial::change_atom var2(var1);
      var2.old_position.z += 0.1;
      BOOST_CHECK(not var2.equivalent(var1));
    }
    {
      trial::change_atom var2(var1);
      var2.energy_old += 0.1;
      BOOST_CHECK(not var2.equivalent(var1));
    }   
    {
      trial::change_atom var2(var1);
      var2.energy_new += 0.1;
      BOOST_CHECK(not var2.equivalent(var1));
    } 
    {
      trial::change_atom var2(var1);
      var2.eps_old += 0.1;
      BOOST_CHECK(not var2.equivalent(var1));
    }   
    {
      trial::change_atom var2(var1);
      var2.eps_new += 0.1;
      BOOST_CHECK(not var2.equivalent(var1));
    } 
    {
      trial::change_atom var2(var1);
      var2.do_old = not var2.do_old;
      BOOST_CHECK(not var2.equivalent(var1));
    }   
    {
      trial::change_atom var2(var1);
      var2.do_new = not var2.do_new;
      BOOST_CHECK(not var2.equivalent(var1));
    }   
    {
      trial::change_atom var2(var1);
      var2.key += 1;
      BOOST_CHECK(not var2.equivalent(var1));
    }   
    {
      trial::change_atom var2(var1);
      var2.index += 1;
      BOOST_CHECK(not var2.equivalent(var1));
    }
    {
      trial::change_atom var2(var1);
      var2.new_rij = orij;
      BOOST_CHECK(not var2.equivalent(var1));
    }
    {
      trial::change_atom var2(var1);
      var2.old_rij = nrij;
      BOOST_CHECK(not var2.equivalent(var1));
    }
  }
  {
    // Assignment operator
    trial::change_atom var2;
    // Check differs
    BOOST_CHECK(not var2.equivalent(var1));
    // check equivalent
    var2 = var1;
    BOOST_CHECK(var2.equivalent(var1));
  }
  {
    trial::change_atom var2;
    trial::change_atom var3(var1);

    // Check differs  
    BOOST_CHECK(not var2.equivalent(var3));

    var2.swap (var3);
    // Check still differs
    BOOST_CHECK(not var2.equivalent(var3));
  }
  boost::archive::text_oarchive oa(store);
  // write class instance to archive
  oa << var1;
}
{
  trial::change_atom var1;

  boost::archive::text_iarchive ia(store);
  // get class instance from archive
  ia >> var1;

  BOOST_CHECK_EQUAL( var1.do_old, true );
  BOOST_CHECK_EQUAL( var1.do_new, true );
  BOOST_CHECK_EQUAL( var1.index, 10 );
  BOOST_CHECK_EQUAL( var1.old_position.x, 1.0 );
  BOOST_CHECK_EQUAL( var1.old_position.y, 10.0 );
  BOOST_CHECK_EQUAL( var1.old_position.z, 2.0 );
  BOOST_CHECK_EQUAL( var1.new_position.x, 0.9 );
  BOOST_CHECK_EQUAL( var1.new_position.y, 9.8 );
  BOOST_CHECK_EQUAL( var1.new_position.z, 2.15 );
  BOOST_CHECK_EQUAL( var1.key, 2 );
  BOOST_CHECK_EQUAL( var1.energy_old, 0.001 );
  BOOST_CHECK_EQUAL( var1.energy_new, 0.02 );
  BOOST_CHECK_EQUAL( var1.eps_old, epsdefault );
  BOOST_CHECK_EQUAL( var1.eps_new, epsw );
  BOOST_CHECK_EQUAL_COLLECTIONS( var1.old_rij.begin(), var1.old_rij.end()
        , orij.begin(), orij.end() );
  BOOST_CHECK_EQUAL_COLLECTIONS( var1.new_rij.begin(), var1.new_rij.end()
        , nrij.begin(), nrij.end() );
}
!!!426673.cpp!!!	change_set_test() : void
std::map< std::string, std::string > move_params;
const double epsw{ 70.0 };
move_params[ "delta" ] = "1.1";
{
  // Default ctor
  trial::change_set var1;
  BOOST_CHECK_EQUAL( var1.accept(), false );
  BOOST_CHECK( var1.begin() == var1.end() );
  BOOST_CHECK( var1.choice() == nullptr );
  BOOST_CHECK_EQUAL( var1.energy(), 0.0 );
  BOOST_CHECK_EQUAL( var1.exponential_factor(), 0.0 );
  BOOST_CHECK_EQUAL( var1.fail(), false );
  BOOST_CHECK_EQUAL( var1.metropolis_factor(), 1.0 );
  BOOST_CHECK_EQUAL( var1.probability_factor(), 1.0 );
  BOOST_CHECK_EQUAL( var1.size(), 0ul );
//  BOOST_CHECK_EQUAL( var1.virial(), 0.0 );
}
{
  trial::move_choice mover( 0, move_params );
  BOOST_CHECK_EQUAL( mover.attempts(), 0 );
  BOOST_CHECK_EQUAL( mover.success(), 0 );
  {
    // Ctor with one arg.
    // ------------------
    trial::change_set var1 ( mover );
    BOOST_CHECK_EQUAL( var1.accept(), false );
    BOOST_CHECK( var1.begin() == var1.end() );
    BOOST_CHECK( var1.choice() == &mover );
    BOOST_CHECK_EQUAL( var1.energy(), 0.0 );
    BOOST_CHECK_EQUAL( var1.exponential_factor(), 0.0 );
    BOOST_CHECK_EQUAL( var1.fail(), false );
    BOOST_CHECK_EQUAL( var1.metropolis_factor(), 1.0 );
    BOOST_CHECK_EQUAL( var1.probability_factor(), 1.0 );
    BOOST_CHECK_EQUAL( var1.size(), 0ul );
//    BOOST_CHECK_EQUAL( var1.virial(), 0.0 );

    // Test set_fail
    // -------------
    var1.set_fail();
    BOOST_CHECK_EQUAL( var1.fail(), true );
    BOOST_CHECK_THROW( var1.metropolis_factor(), std::runtime_error );
  }
  // Test change_set updated the choice object
  // in ctor/dtor
  BOOST_CHECK_EQUAL( mover.attempts(), 1 );
  BOOST_CHECK_EQUAL( mover.success(), 0 );
}
{
  // Test attempt to set a bad probability value
  // Valid only if VALUE > 0.0
  trial::change_set var2;
  BOOST_CHECK_EQUAL( var2.probability_factor(), 1.0 );
  BOOST_CHECK_THROW( var2.update_probability_factor(0.0 ), std::runtime_error);
  BOOST_CHECK_THROW( var2.update_probability_factor(-1.0 ), std::runtime_error);
}
{
  // Test add steps
  trial::move_choice mover( 0, move_params );
  trial::change_set var1 ( mover );

  trial::change_atom s1 ( true, true, 0, particle::coordinate(), particle::coordinate(0.1, 0.0, 0.1 ), 0, epsw, epsw );
//  s1.charge = 2.0;

  // Add once have individual jump move
  var1.add_atom( s1 );
  // Variable that should be changed
  BOOST_CHECK( var1.begin() != var1.end() );
  BOOST_REQUIRE_EQUAL( var1.size(), 1ul );
  BOOST_CHECK( s1.equivalent (var1[0] ));
  BOOST_CHECK( s1.equivalent (*var1.begin() ));

  // Add again: now have salt jump move
  s1.old_position.x += 3.0;
  s1.new_position.x += 3.0;
  s1.key = 1;
//  s1.charge = -1.0;
  var1.add_atom( s1 );
  // Variable that should be changed
  BOOST_CHECK( var1.begin() != var1.end() );
  BOOST_CHECK_EQUAL( var1.size(), 2ul );
  BOOST_CHECK( s1.equivalent (var1[1] ));
  BOOST_CHECK( s1.equivalent (*(var1.begin() + 1 )));

  // Add third time: still have salt jump move
  s1.old_position.y += 3.0;
  s1.new_position.y += 3.0;
//  s1.charge = -1.0;
  var1.add_atom( s1 );
  // Variable that should be changed
  BOOST_CHECK( var1.begin() != var1.end() );
  BOOST_CHECK_EQUAL( var1.size(), 3ul );
  BOOST_CHECK( s1.equivalent (var1[2] ));
  BOOST_CHECK( s1.equivalent (*(var1.begin() + 2 )));
  // Variables that should be unchanged
  BOOST_CHECK_EQUAL( var1.accept(), false );
  BOOST_CHECK( var1.choice() == &mover );
  BOOST_CHECK_EQUAL( var1.energy(), 0.0 );
  BOOST_CHECK_EQUAL( var1.exponential_factor(), 0.0 );
  BOOST_CHECK_EQUAL( var1.fail(), false );
  BOOST_CHECK_EQUAL( var1.metropolis_factor(), 1.0 );
  BOOST_CHECK_EQUAL( var1.probability_factor(), 1.0 );
//  BOOST_CHECK_EQUAL( var1.virial(), 0.0 );
}
// Test factor adjustments
{
  trial::change_set var2;
  trial::change_atom a1;
  var2.add_atom ( a1 );
  BOOST_CHECK_EQUAL( var2.exponential_factor(), 0.0 );
  BOOST_CHECK_EQUAL( var2.probability_factor(), 1.0 );
  {
    // Test metropolis factor
    //  energy==0 exp==0.0 prob==1 beta=1
    //  prob.e( -(beta*energy-exp ))
    //  1 . e -( 0 - 0 ) == 1
    const double metro ( var2.metropolis_factor () );
    if ( not utility::feq(metro, 1.0 ))
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 1.0" );
    }
  }
  {
    // Test update_energy and metropolis
    //  energy==0.1 expf==0.0 probf==1 beta=1
    //  probf.e( -(beta*energy-expf ))
    // 1 . e( -(0.1 - 0 )) == 0.90483741803596
    var2.begin ()->energy_new = 0.1;
    BOOST_CHECK( utility::feq(var2.energy(), 0.1 ));

    const double metro ( var2.metropolis_factor () );
    if ( not utility::feq(metro, 0.90483741803596 ))
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 0.90483741803596" );
    }
  }
  {
    // Test update_probability_factor and metropolis
    //  energy==0.1 expf==0.0 probf==0.1 beta=1
    //  probf.e( -(beta*energy-expf ))
    // 0.3 . e( -(0.1 - 0 )) == 0.3 * 0.90484 = 0.27145
    var2.update_probability_factor( 0.1 );
    BOOST_CHECK( utility::feq(var2.probability_factor(), 0.1 ));
    var2.update_probability_factor( 3.0 );
    BOOST_CHECK( utility::feq(var2.probability_factor(), 0.3 ));

    const double metro ( var2.metropolis_factor () );
    if ( not utility::feq(metro, 0.271451225411, 1 << 12 ))
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 0.271451225411" );
    }
  }
  {
    // Test update_exponential_factor
    //  energy==0.1 expf==0.1 probf==0.1 beta=1
    //  probf.e( -(beta*energy-expf )) ->0.1
    // 0.3 . e( -(0.1 - 0.1 )) == 0.3 * 1 = 0.3
    var2.update_exponential_factor( 0.1 );
    BOOST_CHECK_EQUAL( var2.exponential_factor(), 0.1 );

    const double metro ( var2.metropolis_factor () );
    if ( not utility::feq(metro, 0.3 ))
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 0.3" );
    }
  }
  {
    // Test update_exponential_factor
    //  energy==0.1 expf==0.1 probf==0.1 beta=1
    //  probf.e( -(beta*energy-expf )) ->0.1
    // 0.3 . e( -(1.2 - 0.1 ) == 0.3 * 0.33287 == 0.09986
    var2.begin ()->energy_new += 1.1;
    BOOST_CHECK( utility::feq(var2.energy(), 1.2 ));

    const double metro ( var2.metropolis_factor () );
    BOOST_CHECK_NE( metro, 0.0 );
    if ( not utility::feq(metro, 0.0998613251094, 1 << 12 ))
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 0.0998613251094" );
    }
  }
  {
    // Test update_energy with large energy
    //  energy==100.1 expf==0.1 probf==0.1 beta=1
    //  probf.e( -(beta*energy-expf )) ->0.0....
    // 0.3 . e( -(101.3 - 0.1 ) == 0.3 * 1.238e-44 == 3.3614e-45

    var2.begin ()->energy_new += 100.1;
    BOOST_CHECK( utility::feq(var2.energy(), 101.3 ));

    const double metro ( var2.metropolis_factor () );
    BOOST_CHECK_NE( metro, 0.0 );
    if ( not utility::feq(metro, 3.36139605555e-45, 1 << 13 ))
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 3.36139605555e-45" );
    }
  }
}
{
  // Test serialise
  std::stringstream store;
  {
    trial::move_choice mover( 0, move_params );
    trial::change_set var1 ( mover );
    var1.update_exponential_factor( 0.05 );
    var1.update_probability_factor( 0.5 );
    trial::change_atom s1 ( true, true, 1, particle::coordinate(-0.1, 0.1, 0.1 ), particle::coordinate(), 1, epsw, epsw );
    // Check add
    var1.add_atom ( s1 );
    BOOST_CHECK_EQUAL( var1.size(), 1ul );
    BOOST_CHECK( var1.choice() != nullptr );
    BOOST_CHECK( var1.choice() == &mover );

    boost::archive::text_oarchive oa( store );
    // write class instance to archive
    oa << var1;
    BOOST_CHECK( var1.choice() != nullptr );
    BOOST_CHECK( var1.choice() == &mover );
  }
  {
    trial::move_choice mover2( 1, move_params );
    trial::change_set var2 ( mover2 );
    trial::change_atom s1 ( false, true, 0, particle::coordinate(), particle::coordinate(0.1, -0.1, 0.1 ), 0, epsw, epsw );
    var2.add_atom ( s1 );
    var2.add_atom ( s1 );
    BOOST_CHECK_EQUAL( var2.size(), 2ul );
    BOOST_CHECK_EQUAL( var2[0].key, 0 );
    BOOST_CHECK_EQUAL( var2[0].index, 0 );
    BOOST_CHECK_EQUAL( var2[0].new_position.x, 0.1 );
    BOOST_CHECK_EQUAL( var2[0].new_position.y, -0.1 );
    BOOST_CHECK_EQUAL( var2[0].new_position.z, 0.1 );
    BOOST_CHECK_EQUAL( var2[0].old_position.x, 0.0 );
    BOOST_CHECK_EQUAL( var2[0].old_position.y, 0.0 );
    BOOST_CHECK_EQUAL( var2[0].old_position.z, 0.0 );
    BOOST_CHECK( var2.choice() != nullptr );
    BOOST_CHECK( var2.choice() == &mover2 );

    boost::archive::text_iarchive ia( store );
    // get class instance from archive and over-write existing data
    ia >> var2;

    BOOST_CHECK_EQUAL( var2.energy(), 0.0 );
//    BOOST_CHECK_EQUAL( var2.virial(), 0.0 );
    BOOST_CHECK_EQUAL( var2.exponential_factor(), 0.05 );
    BOOST_CHECK_EQUAL( var2.probability_factor(), 0.5 );
    BOOST_CHECK_EQUAL( var2.size(), 1ul );

    BOOST_CHECK_EQUAL( var2[0].new_position.x, 0.0 );
    BOOST_CHECK_EQUAL( var2[0].new_position.y, 0.0 );
    BOOST_CHECK_EQUAL( var2[0].new_position.z, 0.0 );
    BOOST_CHECK_EQUAL( var2[0].old_position.x, -0.1 );
    BOOST_CHECK_EQUAL( var2[0].old_position.y, 0.1 );
    BOOST_CHECK_EQUAL( var2[0].old_position.z, 0.1 );
    BOOST_CHECK_EQUAL( var2[0].key, 1 );
    BOOST_CHECK_EQUAL( var2[0].index, 1 );
    BOOST_CHECK( var2.choice() == nullptr );
  }
}
!!!441776.cpp!!!	move_choice_test() : void
std::map< std::string, std::string > params;
trial_fixture::test_base_choice< trial::move_choice >( params );
!!!262448.cpp!!!	circle_grid_test() : void
std::stringstream log;
{
   // Circle grid default ctor
   trial::circle_grid var1;
   // Default should have no size
   BOOST_REQUIRE_EQUAL( var1.size(), 0 );
   // Should throw error
   particle::coordinate pnt;
   BOOST_REQUIRE_THROW( var1.set_xy( pnt, 0 ), std::runtime_error );
}
{
   // Circle grid real ctor
   const double radius{ 3.0 };
   const double space{ 1.0 };
   trial::circle_grid var1( radius, space );
   BOOST_CHECK_EQUAL( var1.size(), 21 );

   const double r_edge( std::pow( radius - space, 2 ) );
   const double r_max( std::pow( radius - space/2.0, 2 ) );
   const std::size_t size( var1.size() );
   std::size_t countr1 = 0; // count of elements near r
   for (std::size_t idx = 0; idx != size; ++idx)
   {
      BOOST_CHECK_LT(0, var1.size());
      particle::coordinate pnt;
      var1.set_xy( pnt, idx );
      const double r(pnt.x*pnt.x + pnt.y*pnt.y);
      BOOST_CHECK_LE( r, r_max );
      if (r >= r_edge) ++countr1;
   }
   BOOST_CHECK_EQUAL( size, var1.size() );
   // Should throw error
   particle::coordinate pnt;
   BOOST_REQUIRE_THROW( var1.set_xy( pnt, size ), std::runtime_error );
   BOOST_CHECK_LT( 0, countr1 );
   const std::size_t mod4{ countr1 % 4 };
   const std::size_t mod8{ countr1 % 8 };
   BOOST_CHECK_MESSAGE( mod4 == 0, "4 fold symmetry error: 0 != countr1 % 4" );
   BOOST_WARN_MESSAGE( mod8 == 0, "8 fold symmetry error: 0 != countr1 % 8" );
}
{
   std::vector< particle::coordinate > canon;
   // Circle grid copy and serialization test
   const double radius{ 3.0 };
   const double space{ 1.0 };
   std::stringstream ss;
   {
      trial::circle_grid var1 = trial::circle_grid( radius, space );
      BOOST_CHECK_EQUAL( var1.size(), 21 );

      trial::circle_grid var2( var1 );
      BOOST_CHECK_EQUAL( var2.size(), 21 );
      BOOST_CHECK_EQUAL( var1.size(), 21 );

      trial::circle_grid var3;
      BOOST_CHECK_EQUAL( var3.size(), 0 );
      var3 = var1;
      BOOST_CHECK_EQUAL( var3.size(), 21 );
      BOOST_CHECK_EQUAL( var1.size(), 21 );

      boost::archive::text_oarchive oa(ss);
      // write class instance to archive
      oa << var1;
      BOOST_CHECK_EQUAL( var1.size(), 21 );

      const std::size_t size( var1.size() );
      canon.resize( size );
      for (std::size_t idx = 0; idx != size; ++idx)
      {
         var1.set_xy( canon[ idx ], idx );
         log << "[" << idx << "] = " << canon[ idx ] << "\n";
         BOOST_CHECK_LT(0, var1.size());
         {
            particle::coordinate pnt;
            var2.set_xy( pnt, idx );
            BOOST_CHECK_EQUAL( pnt, canon[idx] );
         }
         {
            particle::coordinate pnt;
            var3.set_xy( pnt, idx );
            BOOST_CHECK_EQUAL( pnt, canon[idx] );
         }
      }
   }
   {
      trial::circle_grid var3;
      BOOST_CHECK_EQUAL( var3.size(), 0 );
      boost::archive::text_iarchive ia(ss);
      // read class instance from archive
      ia >> var3;
      BOOST_CHECK_EQUAL( var3.size(), 21 );
      BOOST_REQUIRE_EQUAL( var3.size(), canon.size() );
      for (std::size_t idx = 0; idx != var3.size(); ++idx)
      {
         particle::coordinate pnt;
         var3.set_xy( pnt, idx );
         BOOST_CHECK_EQUAL( pnt, canon[idx] );
      }

   }
   {
      // circle grid that should be used in tubular grid
      trial::circle_grid var1( 8.5, 0.5 );
      BOOST_CHECK_EQUAL( var1.size(), 861 );
   }
}
!!!427185.cpp!!!	cubic_grid_test() : void
boost::shared_ptr< boost::mt19937> generator(new boost::mt19937);
utility::random_distribution rgen(generator);
// Cubic grid 30.0, 216
// 216**1/3 => 6
// 30/6 => 5 (spacing)
// Edge spacing => 2.5
// Min == 2.5; Max == 27.5
{
  // cubic grid ctor(length, numpart, ranf)
   boost::shared_ptr< trial::grid_generator > var1( new trial::cubic_grid( 30.0, 216, rgen ) );
  BOOST_CHECK_EQUAL( var1->size(), 216 );
  BOOST_CHECK( not var1->empty() );
  // Test base class behavior
  trial_test::test_grid_generator( var1 );
}
{
  // Test all coordinates are in the expected
  // range.
  trial::cubic_grid var1(30.0, 216, rgen);
  const std::size_t size{ var1.size() };
  for (std::size_t idx = 0; idx != size; ++idx)
  {
    particle::coordinate pnt;
    var1.next(pnt);
    BOOST_CHECK_LE(pnt.x, 27.5);
    BOOST_CHECK_LE(pnt.y, 27.5);
    BOOST_CHECK_LE(pnt.z, 27.5);
    BOOST_CHECK_LE(2.5, pnt.x);
    BOOST_CHECK_LE(2.5, pnt.y);
    BOOST_CHECK_LE(2.5, pnt.z);
  }
}
{
  // Check every valid point in the grid is generated
  // by converting grid position into an index
  trial::cubic_grid var1(30.0, 216, rgen);
  const std::size_t size{ var1.size() };
  std::vector< bool > check(size, false);
  std::vector< size_t > indices(size);
  for (std::size_t ix = 0; ix != size; ++ix)
  {
    particle::coordinate pnt;
    var1.next(pnt);
    std::size_t idx ((((pnt.x - 2.5) * 6 + pnt.y - 2.5) * 6 + (pnt.z - 2.5)) / 5.0);
    // Check generated index is less than size
    BOOST_CHECK_LT( idx, size );
    indices[ix] = idx;
    // Check generated index has not already seen
    BOOST_CHECK( not check[idx] );
    check[idx] = true;
  }
  {
    std::sort(indices.begin(), indices.end());
    for (std::size_t ix = 0; ix != size; ++ix)
    {
       // Check generated index runs from 0 to 'size'
      BOOST_CHECK_EQUAL( ix, indices[ix] );
    }
  }
  // Check for missing (false) indices.
  BOOST_CHECK(check.end() == std::find(check.begin(), check.end(), false));
}
!!!262320.cpp!!!	test_grid_generator(inout gridder : grid_generator) : void
// Store generated coordinates
std::vector< particle::coordinate > postns;
// Initial grid point count
const std::size_t count { gridder->size() };
// Test serialization
std::stringstream store;
{
   boost::archive::text_oarchive oa(store);
   // write class instance to archive
   oa << gridder;
}

// Test grid next
for ( std::size_t idx = 0; idx != count; ++idx )
{
   // Not empty before first 'count' calls to gridder->next
   BOOST_CHECK( not gridder->empty() );
   // Non zero size before first 'count' calls to gridder->next
   BOOST_CHECK_LT( 0, gridder->size() );

   const std::size_t remain { gridder->size() };
   particle::coordinate pnt;

   // Next return is not false for first 'count' - 1 calls to gridder->next
   // and false for the 'count'th call.
   BOOST_REQUIRE_MESSAGE( gridder->next( pnt ), "gridder.next() is false before expected end point" );

   // Size decreases by one during call to gridder->next
   BOOST_CHECK_EQUAL( remain - 1, gridder->size() );

   // Generated position is not the same as any previously
   // generated position
   for (auto const& p2 : postns )
   {
      BOOST_REQUIRE_NE( p2, pnt );
   }

   // store generated position.
   postns.push_back( pnt );
}
{
   particle::coordinate pnt;
   BOOST_REQUIRE_MESSAGE( not gridder->next( pnt), "gridder.next() is true after expected end point" );
}
// Gridder is empty after 'count' calls
BOOST_CHECK( gridder->empty() );
// Gridder has zero size after 'count' calls
BOOST_CHECK_EQUAL(0, gridder->size());

// Test deserialization
{
   boost::shared_ptr< trial::grid_generator > g;
   boost::archive::text_iarchive oa(store);
   // read class instance from archive
   oa >> g;

   BOOST_REQUIRE_EQUAL( count, g->size() );
   for ( std::size_t idx = 0; idx != count; ++idx )
   {
      // Not empty before first 'count' calls to gridder->next
      BOOST_CHECK( not g->empty() );
      // Non zero size before first 'count' calls to gridder->next
      BOOST_CHECK_LT( 0, g->size() );

      const std::size_t remain { g->size() };
      particle::coordinate pnt;

      // Next return is not false for first 'count' - 1 calls to gridder->next
      // and false for the 'count'th call.
      BOOST_REQUIRE_MESSAGE( g->next( pnt), "gridder->next() is false before count calls" );

      // Size decreases by one during call to gridder->next
      BOOST_CHECK_EQUAL( remain - 1, g->size() );
   }

}

!!!427313.cpp!!!	tubular_grid_test() : void
boost::shared_ptr< boost::mt19937> generator(new boost::mt19937);
std::stringstream log;
utility::random_distribution rgen(generator);
// Cylindrical grid 
// HLENGTH 31.0,
// RADIUS  8.5
// SPACING 0.5
// ZGRID = (31 - .5) / .5 = 61
// XYGRID = Y \   X
//             \        2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x
//              \ 0     0.5   1     1.5   2     2.5   3     3.5   4     4.5   5     5.5   6     6.5   7     7.5   8
//               \---------------------------------------------------------------------------------------------------
//    33    0    |0     0.5   1     1.5   2     2.5   3     3.5   4     4.5   5     5.5   6     6.5   7     7.5   8.0
// 2x 33    0.5  |0.5   0.7   1.1   1.6   2.1   2.5   3.0   3.5   4.0   4.5   5.0   5.5   6.0   6.5   7.0   7.5   8.0
// 2x 33    1    |1     1.1   1.4   1.8   2.2   2.7   3.2   3.6   4.1   4.6   5.1   5.6   6.1   6.6   7.1   7.6   8.1
// 2x 33    1.5  |1.5   1.6   1.8   2.1   2.5   2.9   3.4   3.8   4.3   4.7   5.2   5.7   6.2   6.7   7.2   7.6   8.1
// 2x 33    2    |2     2.1   2.2   2.5   2.8   3.2   3.6   4.0   4.5   4.9   5.4   5.9   6.3   6.8   7.3   7.8   8.2
// 2x 31    2.5  |2.5   2.5   2.7   2.9   3.2   3.5   3.9   4.3   4.7   5.1   5.6   6.0   6.5   7.0   7.4   7.9
// 2x 31    3    |3     3.0   3.2   3.4   3.6   3.9   4.2   4.6   5.0   5.4   5.8   6.3   6.7   7.2   7.6   8.1
// 2x 29    3.5  |3.5   3.5   3.6   3.8   4.0   4.3   4.6   4.9   5.3   5.7   6.1   6.5   6.9   7.4   7.8
// 2x 29    4    |4     4.0   4.1   4.3   4.5   4.7   5.0   5.3   5.7   6.0   6.4   6.8   7.2   7.6   8.1
// 2x 27    4.5  |4.5   4.5   4.6   4.7   4.9   5.1   5.4   5.7   6.0   6.4   6.7   7.1   7.5   7.9
// 2x 27    5    |5     5.0   5.1   5.2   5.4   5.6   5.8   6.1   6.4   6.7   7.1   7.4   7.8   8.2
// 2x 25    5.5  |5.5   5.5   5.6   5.7   5.9   6.0   6.3   6.5   6.8   7.1   7.4   7.8   8.1
// 2x 23    6    |6     6.0   6.1   6.2   6.3   6.5   6.7   6.9   7.2   7.5   7.8   8.1
// 2x 21    6.5  |6.5   6.5   6.6   6.7   6.8   7.0   7.2   7.4   7.6   7.9   8.2
// 2x 17    7    |7     7.0   7.1   7.2   7.3   7.4   7.6   7.8   8.1
// 2x 13    7.5  |7.5   7.5   7.6   7.6   7.8   7.9   8.1
// 2x 5     8    |8     8.0   8.1   8.1   8.2 
// ======
//    861
//
{
  // Tubular grid ctor (with spacing)
   boost::shared_ptr< trial::grid_generator > var1( new trial::tubular_grid( 31.0, 8.5, 2.5 ) );

  BOOST_CHECK( not var1->empty() );
  // Test base class behavior
  trial_test::test_grid_generator( var1 );
}
{
  // Tubular grid ctor (with target grid point)
  boost::shared_ptr< trial::grid_generator > var1( new trial::tubular_grid( 31.0, 8.5, 500 ) );

  BOOST_CHECK_LE( 500, var1->size() );
  BOOST_CHECK_LE( 0.0, var1->spacing() );
  BOOST_CHECK( not var1->empty() );
  // Test base class behavior
  trial_test::test_grid_generator( var1 );
}

{
  // Tubular grid test: constructed with defined spacing
   const double length{ 31.0 };
   const double radius{ 8.5 };
   const double spacing{ 0.5 };
  trial::tubular_grid var1 (length, radius, spacing);
  BOOST_CHECK_EQUAL(var1.size(), 861*62);
  // Should have some grid points within 3/2*'spacing' of edge
  const double r_edge{ std::pow(radius - (3*spacing/2), 2) };
  const double z1_edge{ (length - 3*spacing)/2 };
  const double z2_edge{ -z1_edge };
  // should have no grid points within ('spacing'/2) of edge
  const double r_max{ std::pow(radius - spacing/2.0, 2) };
  const double z1_max{ (length - spacing)/ 2.0 };
  const double z2_max{ -z1_max };
  const double z_min{ spacing / 2.0 };
  // Number of grid points
  const std::size_t size{ var1.size() };
  std::set< double > zvalues;

  std::size_t counter_spacing_r1 = 0; // count of elements near r, when z>0
  std::size_t counter_spacing_r2 = 0; // count of elements near r, when z<0
  std::size_t counter_spacing_z1 = 0; // count of elements near +z
  std::size_t counter_spacing_z2 = 0; // count of elements near -z

  for (std::size_t idx = 0; idx != size; ++idx)
  {
    BOOST_CHECK_LT(0, var1.size());
    particle::coordinate pnt;
    var1.next(pnt);
    const double r(pnt.x*pnt.x + pnt.y*pnt.y);
    BOOST_CHECK_LE( r, r_max );
    BOOST_CHECK_LE( pnt.z, z1_max );
    BOOST_CHECK_LE( z2_max, pnt.z );
    BOOST_CHECK_LE( z_min, std::abs(pnt.z) );

    if (r > r_edge and pnt.z > 0.0) ++counter_spacing_r1;
    if (r > r_edge and pnt.z < 0.0) ++counter_spacing_r2;
    if (pnt.z > z1_edge) ++counter_spacing_z1;
    if (pnt.z < z2_edge) ++counter_spacing_z2;
    zvalues.insert( pnt.z );
  }
  log << "ZMIN " << z_min << " ZMAX " << z1_max << " ZEDGE " << z1_edge << " SPC " << spacing << "\n";
  for (double zz : zvalues )
  {
     log << zz << " ";
  }
  log << "\n";
  BOOST_CHECK_EQUAL( 0, var1.size() );
  BOOST_CHECK_LT( 0, counter_spacing_r1 );
  BOOST_CHECK_EQUAL( counter_spacing_r1, counter_spacing_r2 );
  // r count should be multiple of 4*60
  const std::size_t mod_60{ counter_spacing_r1 % 62 };
  BOOST_CHECK_MESSAGE( 0 == mod_60, "0 == (counter_spacing_r1 % 62)" );
  const std::size_t mod_120{ counter_spacing_r1 % (2*62) };
  BOOST_CHECK_MESSAGE( 0 == mod_120, "2 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (2*62))" );
  const std::size_t mod_240{ counter_spacing_r1 % (4*62) };
  BOOST_CHECK_MESSAGE( 0 == mod_240, "4 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (4*62))" );
  const std::size_t mod_480{ counter_spacing_r1 % (8*62) };
  BOOST_WARN_MESSAGE( 0 == mod_480, "8 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (4*62))" );


  BOOST_CHECK_LT( 0, counter_spacing_z1 );
  BOOST_CHECK_EQUAL( counter_spacing_z1, counter_spacing_z2 );
  // z count should be 861
  BOOST_CHECK_EQUAL( 861, counter_spacing_z1 );
}
{
  // Tubular grid: constructed with target grid point minimum count
   const double length{ 31.0 };
   const double radius{ 8.5 };
   trial::tubular_grid var1( length, radius, 500);

  std::set< double > zvalues;

  // Should have no points within (spacing/2) of edge
  const double r_max( std::pow(radius - var1.spacing()/2.0, 2) );
  const double z1_max( (length - var1.spacing())/2.0 );
  const double z2_max( -z1_max );
  const double z_min( var1.spacing()/2.0 );
  // Should have some points within 1.5*spacing of edge
  const double r_edge( std::pow(radius - (3*var1.spacing()/2), 2) );
  const double z1_edge( (length - 3*var1.spacing())/2 );
  const double z2_edge( -z1_edge );

  std::size_t counter_ntarget_r1 = 0; // count of elements near r, when z>0
  std::size_t counter_ntarget_r2 = 0; // count of elements near r, when z<0
  std::size_t counter_ntarget_z1 = 0; // count of elements near +z
  std::size_t counter_ntarget_z2 = 0; // count of elements near -z

  particle::coordinate pnt;
  while ( var1.next( pnt ) )
  {
    const double r( pnt.x*pnt.x + pnt.y*pnt.y );
    // Test that no grid points get closer than 'spacing'/2 from edge
    BOOST_CHECK_LE( r, r_max );
    BOOST_CHECK_LE( pnt.z, z1_max );
    BOOST_CHECK_LE( z2_max, pnt.z );
    BOOST_CHECK_LE( z_min, std::abs( pnt.z ) );// no points nearer to z=0.0 than spacing/2

    if ( r > r_edge and pnt.z > 0.0 ) ++counter_ntarget_r1;
    if ( r > r_edge and pnt.z < 0.0 ) ++counter_ntarget_r2;
    if ( pnt.z > z1_edge ) ++counter_ntarget_z1;
    if ( pnt.z < z2_edge ) ++counter_ntarget_z2;
    zvalues.insert( pnt.z );
  }
  log << "ZMIN " << z_min << " ZMAX " << z1_max << " ZEDGE " << z1_edge << " SPC " << var1.spacing() << "\n";
  for (double zz : zvalues )
  {
     log << zz << " ";
  }
  log << "\n";
  BOOST_CHECK_EQUAL( 0, var1.size() );
  // Test that some  grid points get closer than 'spacing' from edge
  // and that there are the same number on each side of z=0
  BOOST_CHECK_LT( 0, counter_ntarget_r1 );
  BOOST_CHECK_EQUAL( counter_ntarget_r1, counter_ntarget_r2 );
  BOOST_CHECK_LT( 0, counter_ntarget_z1 );
  BOOST_CHECK_EQUAL( counter_ntarget_z1, counter_ntarget_z2 );
  const std::size_t mod_2{ counter_ntarget_r2 % 2 };
  BOOST_CHECK_MESSAGE( 0 == mod_2, "2 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 2)" );
  const std::size_t mod_4{ counter_ntarget_r2 % 4 };
  BOOST_CHECK_MESSAGE( 0 == mod_4, "4 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 4)" );
  const std::size_t mod_8{ counter_ntarget_r2 % 8 };
  BOOST_WARN_MESSAGE( 0 == mod_8, "8 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 8)" );
}
