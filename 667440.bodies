class serial_storage
!!!1840944.cpp!!!	compute_output_dir() : string
boost::format res( this->output_dir_fmt() );
// Ignore error of too many arguments.
res.exceptions( boost::io::all_error_bits ^ boost::io::too_many_args_bit );
res % this->run_number();
return res.str();
!!!1848368.cpp!!!	ensure_output_dir() : path
const boost::filesystem::path dpath( this->compute_output_dir() );
if( not boost::filesystem::exists( dpath ) )
{
  boost::filesystem::create_directories( dpath );
}
else
{
  UTILITY_INPUT( boost::filesystem::is_directory( dpath ), "Filesystem object at target output directory path ["+dpath.native()+"] is not a directory", core::strngs::simulator_label(), nullptr );
}
return dpath;
!!!1840816.cpp!!!	find_input_filename() : std::string
// Filenames to generate
//   input.%03d.inp % run_index
//   input.inp
std::string result;
std::string errmsg( "Unable to find input file(s) named:" );

auto test_fn = [](std::string fn)->bool{
 return boost::filesystem::exists( fn )
   and boost::filesystem::is_regular_file( fn )
   and std::ifstream( fn );
};
  
if( not this->filename_base().empty() )
{
  // Check for '%' to see if filename base is a format string
  if( std::string::npos != this->filename_base().find( '%' ) )
  {
    // TRY ONE : filename base is format string
    // -------
    // Assume filename_base is a format string.
    boost::format res( this->filename_base() );
    // Ignore error of too many arguments.
    res.exceptions( boost::io::all_error_bits ^ boost::io::too_many_args_bit );
    res % this->run_number();
    result = res.str();
    // Check if file exists
    if( test_fn( result ) )
    {
      return result;
    }
    else
    {
      // Filename not found
      errmsg.append( " " );
      errmsg.append( result );
    }
    // TRY TWO : remove format code from filename base
    // -------
    result.assign( this->filename_base() );
    // Remove everything from the '%' to the next '.'
    std::size_t pos1 = result.find( '%' ); // We know this is not npos!
    std::size_t pos2 = result.find( '.', pos1 );
    if( std::string::npos != pos2 )
    {
      result.erase( pos1, pos2 - pos1 + 1 );
    }
    else
    {
      result.erase( pos1 );
    }
    // Check if file exists
    if( test_fn( result ) )
    {
      return result;
    }
    else
    {
      // Filename not found
      errmsg.append( " " );
      errmsg.append( result );
    }
  }
  else
  {
    // TRY THREE : filename base is simple string
    // ---------
    result = this->filename_base();
    // Check if file exists
    if( test_fn( result ) )
    {
      return result;
    }
    else
    {
      // Filename not found
      errmsg.append( " " );
      errmsg.append( result );
    }
  }
}
// If we got here no files where found.
const bool input_file_found = false;
UTILITY_INPUT( input_file_found, errmsg, core::strngs::simulator_label(), nullptr );
result.clear(); // To stop compiler complaints
return result;
!!!1838896.cpp!!!	open_output() : base_sink
this->ensure_output_dir();
const std::string fn( this->output_path() );
{
  // attempt to open file in 
  std::ofstream test( fn );
  UTILITY_ALWAYS( test, "Problem openning output file "+fn );
}
return this->open_sink_by_extension( fn, "dbm" );
!!!1839024.cpp!!!	open_input() : input_base_reader
const std::string inputfn = this->find_input_filename();
boost::shared_ptr< core::input_base_reader > reader( new core::input_reader( inputfn ) );
return reader;
!!!1839152.cpp!!!	open_checkpoint() : ostream
this->ensure_output_dir();
const std::string fn( this->checkpoint_path() );
boost::shared_ptr< std::ostream > result( new std::ofstream( fn ) );
UTILITY_ALWAYS( *(result), "Problem openning checkpoint file "+fn );
return result;
!!!1839280.cpp!!!	open_log() : ostream
std::unique_ptr< boost::iostreams::filtering_ostream > tmp( new boost::iostreams::filtering_ostream );
tmp->push( std::cout );
boost::shared_ptr< std::ostream > result( tmp.release() );
return result;
!!!1900592.cpp!!!	add_definition(inout meta : storage_meta) : void
std::string desc( "Use local storage and serial (non-parallel) execution." );
std::unique_ptr< storage_definition > result( new storage_definition( type_label_(), desc ) );
// no extra parameters
meta.add_type( result );
!!!1900848.cpp!!!	type_label_() : string
const std::string result( "standard" );
return result;
