class d3_distribution
!!!1607472.cpp!!!	add_definition(inout meta : sampler_meta) : void
std::string desc( "Sample the 3D distribution of particles." );
std::unique_ptr< sampler_definition > result( new sampler_definition( type_label_(), desc, &d3_distribution::make_sampler ) );
// two extra parameters
result->add_definition( { "stepsize", "number in Angstrom", ">0", std::to_string( default_bin_width() ), "Subsampling cube width of population histogram." } );
result->add_definition( { core::strngs::fsregn(), "list", "specie:region labels", "all species and whole cell", "List of specie label : region label pairs. Use to restrict sampling of a specie to a specific region of the simulation cell. Default is to use all species and the whole cell." } );
meta.add_sampler_type( result );

!!!487985.cpp!!!	description(inout os : ostream) : void
os << " " << this->type_label_() << "\n";
os << " " << std::string( this->type_label_().size(), '-' ) << "\n";
os << "    Collect 3D density distributions for each specie.\n";
os << "    - Region-specific distributions per-specie.\n";
for( auto const& val : this->regions_ )
{
  os << "      - " << val.first << "  : " << val.second << "\n";
}
os << "    - sample bin width : " << this->stepsize_ << " (default ";
os << d3_distribution::default_bin_width() << ")\n";
!!!1607728.cpp!!!	get_value() : boost::any
boost::any result = &this->distributions_;
return result;
!!!365617.cpp!!!	make_sampler(in paramset : string) : base_observable
std::string region_list;
double stepsize = d3_distribution::default_bin_width();
if (paramset.count( core::strngs::fsregn() ) != 0)
{
  core::input_base_reader::text_input( core::strngs::fsregn(), paramset.at( core::strngs::fsregn() ), "3D distribution " + d3_distribution::type_label_(), core::strngs::sampler_label(), region_list, nullptr );
}
if (0 != paramset.count("stepsize"))
{
  core::input_base_reader::float_input( "stepsize", paramset.at( "stepsize" ), d3_distribution::type_label_(), core::strngs::sampler_label(), stepsize, true, false, nullptr );
}
std::unique_ptr<d3_distribution> result( new d3_distribution );
if( not region_list.empty() )
{
  result->regions_ = d3_distribution::process_region_list( region_list );
  if( result->regions_.empty() )
  {
    throw core::input_error::parameter_value_error( "Volume selection", core::strngs::sampler_label(), core::strngs::fsregn(), paramset.at( core::strngs::fsregn() ), nullptr, "Unable to convert value into a list of region labels." );
  }
}
result->stepsize_ = stepsize;
boost::shared_ptr< base_observable > tmp(result.release());
return tmp;
!!!365745.cpp!!!	prepare(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager, in sman : report_manager) : void
if( not this->distributions_.empty() )
{
  this->distributions_.clear();
}
this->specie_labels_.clear();
// regions_ is a map of specie label to region. It is
// optional in that species not in the map will use the
// system region. It is an error for a named region not to
// exist.
if( not this->regions_.empty() )
{
  for( auto const& entry : this->regions_ )
  {
    if( gman.region_key( entry.second ) == gman.region_count() )
    {
      // error, region label not found.
      std::stringstream region_os;
      region_os << "(";
      for( std::size_t ireg = 0; ireg != gman.region_count(); ++ireg )
      {
        region_os << gman.get_region( ireg ).label() << ",";
      }
      std::string reg_list( region_os.str() );
      reg_list.back() = ')';
      throw core::input_error::parameter_value_error( "Volume selection", core::strngs::sampler_label(), core::strngs::fsregn(), entry.second, nullptr, (core::input_error::bad_key_message_format() % reg_list).str() );
    }
  }
}
this->specie_labels_.resize( pman.specie_count() );
for( std::size_t ispec = 0; ispec != pman.specie_count(); ++ispec )
{
  const std::string label = pman.get_specie( ispec ).label();
  this->specie_labels_[ ispec ] = label;
  if( this->regions_.count( label ) == 1 )
  {
    // specie has specific region target
    geometry::coordinate bbmin, bbmax;
    gman.get_region( gman.region_key( this->regions_[ label ] ) ).extent( bbmin, bbmax, pman.get_specie( ispec ).radius() );
    this->distributions_.push_back( { { bbmin, bbmax, this->stepsize_ } } );
  }
  else
  {
    // specie uses global region
    geometry::coordinate bbmin, bbmax;
    gman.system_region().extent( bbmin, bbmax, pman.get_specie( ispec ).radius() );
    this->distributions_.push_back( { { bbmin, bbmax, this->stepsize_ } } );
  }
}
!!!365873.cpp!!!	on_report(inout out : ostream, inout sink : base_sink) : void
// Write out 3D data
for (std::size_t ispec = 0; ispec != this->specie_labels_.size(); ++ispec)
{
  if( this->distributions_[ ispec ].count() > 0 )
  {
    std::string label( "d3df-"+this->specie_labels_[ ispec ]+".dat" );
    auto & data = this->distributions_[ ispec ];
    if( not sink.has_dataset( label ) )
    {
      std::unique_ptr< observable::output_series >definition{ new observable::output_series( label, false ) };
      definition->set_title( "3D density distribution histogram for specie "+ this->specie_labels_[ ispec ] );
      {
        std::unique_ptr< observable::output_field > field( new observable::output_field( "XMID YMID ZMID", "ANGSTROM ANGSTROM ANGSTROM", std::move( std::unique_ptr< observable::field_format >( new observable::digitizer_3d_output( data.axis(), observable::digitizer_output::USE_MID ) ) ) ) );
        definition->push_back_field( field );
      }
      {
        std::unique_ptr< observable::mean_variance_output > formatter{ new observable::mean_variance_output };
        std::unique_ptr< observable::output_field > field( new observable::output_field( "P.mean P.var", "Rate Rate2", std::move( std::unique_ptr< observable::field_format >( new observable::mean_variance_output ) ) ) );
        definition->push_back_field( field );
      }
      sink.add_dataset( definition );
    }
    {
      std::unique_ptr< utility::estimate_array > arr( new utility::estimate_array( std::move( data.release_data() ) ) );
      sink.receive_data( label, 0, arr );
    }
  }
}
!!!366001.cpp!!!	on_sample(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager) : void
for( auto & histo : this->distributions_ )
{
  histo.begin_sample();
}
auto const& ens = pman.get_ensemble();
for( std::size_t ith = 0; ith != ens.size(); ++ith )
{
  const std::size_t ispec( ens.key( ith ) );
  if( ispec != particle::specie_key::nkey )
  {
    geometry::coordinate pos = ens.position( ith );
    if( this->distributions_[ ispec ].in_range( pos ) )
    {
      this->distributions_[ispec].sample_datum( pos );
    }
  }
}
for( auto & histo : this->distributions_ )
{
  histo.end_sample();
}
!!!1608112.cpp!!!	do_write_document(inout wr : input_document, in ix : size_t) : void
wr[ ix ].add_entry( core::strngs::fstype(), this->type_label_() );
if( not this->regions_.empty() )
{
  std::stringstream os;
  for( auto const& entry : this->regions_ )
  {
    if( os.str().size() != 0 )
    {
      os << " ";
    }
    os << entry.first << ":" << entry.second;
  }
  wr[ ix ].add_entry( core::strngs::fsregn(), os.str() );
}
wr[ ix ].add_entry( "stepsize", this->stepsize_ );

!!!1607856.cpp!!!	process_region_list(in list : string) : string
std::map< std::string, std::string > regions;
boost::tokenizer<> tok { list };
std::string label;
for( std::string word_or_pair : tok )
{
  if( label.empty() )
  {
    // specie label part of pair
    if( 2 != word_or_pair.size() )
    {
      throw core::input_error::parameter_value_error( "Specie-region pair list ", core::strngs::sampler_label(), core::strngs::fsregn(), list, nullptr, "Specie label \""+word_or_pair+"\" should have two exactly two letters." ); 
    }
    label = word_or_pair;
  }
  else
  {
    // region part of pair
    auto check_unique = regions.insert( { label, word_or_pair } );
    if( not check_unique.second )
    {
      throw core::input_error::parameter_value_error( "Specie-region pair list ", core::strngs::sampler_label(), core::strngs::fsregn(), list, nullptr, "Specie label \""+label+"\" appears more than once in list" ); 
    }
    label.clear();
  }
}
if( not label.empty() )
{
  throw core::input_error::parameter_value_error( "Specie-region pair list ", core::strngs::sampler_label(), core::strngs::fsregn(), list, nullptr, "Specie label \""+label+"\" has no matching region name." ); 
}
return regions;

