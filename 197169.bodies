class d3_distribution
!!!1607472.cpp!!!	add_definition(inout meta : sampler_meta) : void
std::string desc( "Sample the 3D distribution of particles." );
std::unique_ptr< sampler_definition > result( new sampler_definition( type_label_(), desc, &d3_distribution::make_sampler ) );
// two extra parameters
result->add_definition( { "stepsize", "number in Angstrom", ">0", std::to_string( default_bin_width() ), "Subsampling cube width of population histogram." } );
result->add_definition( { core::strngs::fsregn(), "list", "specie:region labels", "all species and whole cell", "List of specie label : region label pairs. Use to restrict sampling of a specie to a specific region of the simulation cell. Default is to use all species and the whole cell." } );
meta.add_sampler_type( result );

!!!487985.cpp!!!	description(inout os : ostream) : void
os << " " << this->type_label_() << "\n";
os << " " << std::string( this->type_label_().size(), '-' ) << "\n";
os << "    Collect 3D density distributions for each specie.\n";
os << "    - Region-specific distributions per-specie.\n";
for( auto const& val : this->regions_ )
{
  os << "      - " << val.first << "  : " << val.second << "\n";
}
os << "    - sample bin width : " << this->stepsize_ << " (default ";
os << d3_distribution::default_bin_width() << ")\n";
!!!1607728.cpp!!!	get_value() : boost::any
boost::any result = &this->distributions_;
return result;
!!!365617.cpp!!!	make_sampler(in paramset : string) : base_observable
std::string region_list;
double stepsize = d3_distribution::default_bin_width();
if (paramset.count( core::strngs::fsregn() ) != 0)
{
  region_list = paramset.at( core::strngs::fsregn() );
  UTILITY_INPUT( not region_list.empty(), d3_distribution::type_label_() + " paramter \"" + core::strngs::fsregn() + "\" requires a value.", core::strngs::sampler_label(), nullptr );
}
if (0 != paramset.count("stepsize"))
{
  core::input_base_reader::float_input( "stepsize", paramset.at( "stepsize" ), d3_distribution::type_label_(), core::strngs::sampler_label(), stepsize, true, false );
}
std::unique_ptr<d3_distribution> result( new d3_distribution );
if( not region_list.empty() )
{
  result->regions_ = d3_distribution::process_region_list( region_list );
  UTILITY_INPUT( not result->regions_.empty(), d3_distribution::type_label_() + " parameter \"" + core::strngs::fsregn() + "\" value ["+region_list+"] is invalid.", core::strngs::sampler_label(), nullptr );
}
result->stepsize_ = stepsize;
boost::shared_ptr< base_observable > tmp(result.release());
return tmp;
!!!365745.cpp!!!	prepare(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager, in sman : report_manager) : void
if( not this->distributions_.empty() )
{
  this->distributions_.clear();
}
this->specie_labels_.clear();
// regions_ is a map of specie label to region. It is
// optional in that species not in the map will use the
// system region. It is an error for a named region not to
// exist.
if( not this->regions_.empty() )
{
  for( auto const& entry : this->regions_ )
  {
    UTILITY_INPUT( gman.region_key( entry.second ) != gman.region_count(), "Expected a region with name ["+entry.second+"] when generating sampler type "+type_label_(), core::strngs::sampler_label(), nullptr );
  }
}
this->specie_labels_.resize( pman.specie_count() );
for( std::size_t ispec = 0; ispec != pman.specie_count(); ++ispec )
{
  const std::string label = pman.get_specie( ispec ).label();
  this->specie_labels_[ ispec ] = label;
  if( this->regions_.count( label ) == 1 )
  {
    // specie has specific region target
    particle::coordinate bbmin, bbmax;
    gman.get_region( gman.region_key( this->regions_[ label ] ) ).extent( bbmin, bbmax, pman.get_specie( ispec ).radius() );
    this->distributions_.push_back( { { bbmin, bbmax, this->stepsize_ } } );
  }
  else
  {
    // specie uses global region
    particle::coordinate bbmin, bbmax;
    gman.system_region().extent( bbmin, bbmax, pman.get_specie( ispec ).radius() );
    this->distributions_.push_back( { { bbmin, bbmax, this->stepsize_ } } );
  }
}
!!!365873.cpp!!!	on_report(inout out : ostream, inout sink : base_sink) : void
// Write out 3D data
for (std::size_t ispec = 0; ispec != this->specie_labels_.size(); ++ispec)
{
  if (this->distributions_[ ispec ].count() > 0)
  {
    // TODO sim.checkpoint_directory()
    std::stringstream ofs;
    ofs << core::strngs::comment_begin() << " UUID: ";
    ofs << sink.uuid() << "\n";
    ofs << core::strngs::comment_begin();
    ofs << " TITLE: \"3D density distribution histogram for specie ";
    ofs << this->specie_labels_[ ispec ] << "\"\n";
    ofs << core::strngs::comment_begin();
    ofs << " FIELDS: X_MID Y_MID Z_MID PMEAN PVAR\n";
    ofs << core::strngs::comment_begin();
    ofs << " UNITS: ANGSTROM ANGSTROM ANGSTROM COUNT COUNT**2\n";
    ofs << std::fixed;
    ofs.precision(6);
    for( auto datum : this->distributions_[ispec] )
    {
      ofs << datum.midpoint() << " " << std::setw(10) << datum.mean() << " " << std::setw(10) << datum.variance() << "\n";
    }
    sink.write( "d3df-"+this->specie_labels_[ ispec ]+".dat", ofs.str() );
  }
}

!!!366001.cpp!!!	on_sample(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager) : void
for( auto & histo : this->distributions_ )
{
  histo.begin_sample();
}
auto const& ens = pman.get_ensemble();
for( std::size_t ith = 0; ith != ens.size(); ++ith )
{
  const std::size_t ispec( ens.key( ith ) );
  if( ispec != particle::specie_key::nkey )
  {
    particle::coordinate pos = ens.position( ith );
    if( this->distributions_[ ispec ].in_range( pos ) )
    {
      this->distributions_[ispec].sample_datum( pos );
    }
  }
}
for( auto & histo : this->distributions_ )
{
  histo.end_sample();
}
!!!1608112.cpp!!!	do_write_document(inout wr : input_document, in ix : size_t) : void
wr[ ix ].add_entry( core::strngs::fstype(), this->type_label_() );
if( not this->regions_.empty() )
{
  std::stringstream os;
  for( auto const& entry : this->regions_ )
  {
    if( os.str().size() != 0 )
    {
      os << " ";
    }
    os << entry.first << ":" << entry.second;
  }
  wr[ ix ].add_entry( core::strngs::fsregn(), os.str() );
}
wr[ ix ].add_entry( "stepsize", this->stepsize_ );

!!!1607856.cpp!!!	process_region_list(in list : string) : string
std::map< std::string, std::string > regions;
boost::tokenizer<> tok { list };
std::string label;
for( std::string word_or_pair : tok )
{
  if( label.empty() )
  {
    // specie label part of pair
    UTILITY_INPUT( ( 2 == word_or_pair.size() ) or ( 1 == word_or_pair.size() ), "Invalid specie label ["+ word_or_pair +"] in list ["+list+"] in parameter \"region\" of sampler "+type_label_(), core::strngs::sampler_label(), nullptr );
    label = word_or_pair;
  }
  else
  {
    // region part of pair
    auto check_unique = regions.insert( { label, word_or_pair } );
    UTILITY_INPUT( check_unique.second, "Duplicate specie label ["+ label +"] in list ["+list+"] in parameter \"region\" of sampler "+type_label_(), core::strngs::sampler_label(), nullptr );
    label.clear();
  }
}
UTILITY_INPUT( label.empty(), "Have unmatched specie label ["+label+"] in list ["+list+"] in parameter \"region\" of sampler "+type_label_(), core::strngs::sampler_label(), nullptr );
return regions;

