class evaluator_test
!!!848944.cpp!!!	evaluator_manager_lifetime() : void
//std::map< std::string, std::string > params;
std::stringstream store;
std::stringstream log;
{
  //  Constructor tests
  BOOST_CHECK( std::is_default_constructible< evaluator::evaluator_manager >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< evaluator::evaluator_manager >::type {} );
  BOOST_CHECK( not std::is_move_constructible< evaluator::evaluator_manager >::type {} );
  BOOST_CHECK( ( not std::is_assignable< evaluator::evaluator_manager, evaluator::evaluator_manager >::type {} ) );
  BOOST_CHECK( not std::has_virtual_destructor< evaluator::evaluator_manager >::type {} );
}
{
  evaluator::evaluator_manager mgr;
  BOOST_CHECK_EQUAL( mgr.size(), 0 );
  BOOST_CHECK_EQUAL( mgr.permittivity(), evaluator::evaluator_manager::standard_aqueous_permittivity() );
  BOOST_CHECK_EQUAL( mgr.temperature(), evaluator::evaluator_manager::standard_room_temperature() );
  BOOST_CHECK( mgr.empty() );
}
// Constructor test method
const double tmpt{ 300.0 };
const double perm{ 42.0 };
{
  // default
  evaluator::evaluator_manager mgr;
  mgr.permittivity( perm );
  BOOST_CHECK_EQUAL( mgr.permittivity(), perm );
  mgr.temperature( tmpt );
  BOOST_CHECK_EQUAL( mgr.temperature(), tmpt );

  boost::archive::text_oarchive oa( store );
  oa << mgr;
}
// Serialization test method.
{
  evaluator::evaluator_manager mgr;

  boost::archive::text_iarchive ia( store );
  ia >> mgr;
  BOOST_CHECK_EQUAL( mgr.size(), 0 );
  BOOST_CHECK( mgr.empty() );
  BOOST_CHECK_EQUAL( mgr.permittivity(), perm );
  BOOST_CHECK_EQUAL( mgr.temperature(), tmpt );
}
!!!1370032.cpp!!!	evaluator_definition_lifetime() : void
{
  //  Constructor tests
  BOOST_CHECK( not std::is_default_constructible< evaluator::evaluator_definition >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< evaluator::evaluator_definition >::type {} );
  BOOST_CHECK( not std::is_move_constructible< evaluator::evaluator_definition >::type {} );
  BOOST_CHECK( ( not std::is_assignable< evaluator::evaluator_definition, evaluator::evaluator_definition >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< evaluator::evaluator_definition >::type {} );
}
const std::string defn_label( "evaluator" );
const std::string defn_desc( "blah blech blab." );
{
  evaluator::evaluator_definition defn( defn_label, defn_desc, [](std::map<std::string, std::string>)->std::unique_ptr< evaluator::base_evaluator>{ return std::unique_ptr< evaluator::base_evaluator>{}; });
  BOOST_CHECK_EQUAL( defn.label(), defn_label );
  BOOST_CHECK_EQUAL( defn.description(), defn_desc );
  BOOST_CHECK_EQUAL( defn.size(), 0 );
  BOOST_CHECK( defn.empty() );
}

!!!1380272.cpp!!!	coulomb_lifetime_tests() : void
{
  //  Constructor tests
  BOOST_CHECK( std::is_default_constructible< evaluator::coulomb >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< evaluator::coulomb >::type {} );
  BOOST_CHECK( not std::is_move_constructible< evaluator::coulomb >::type {} );
  BOOST_CHECK( ( not std::is_assignable< evaluator::coulomb, evaluator::coulomb >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< evaluator::coulomb >::type {} );
}
const std::string defn_label( "coulomb" );
{
  evaluator::coulomb eval;
  BOOST_CHECK_EQUAL( eval.type_label(), defn_label );
  BOOST_CHECK_EQUAL( eval.factor(), 0.0 );
}

!!!1380144.cpp!!!	coulomb_static_method_tests() : void
{
  // Static method tests.
  BOOST_CHECK_CLOSE( evaluator::coulomb::invariant_factor(), 167109.7903783501, 0.0000001 );
}
const std::string defn_label( "coulomb" );
{
  BOOST_CHECK_EQUAL( evaluator::coulomb::type_label_(), defn_label );

  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  BOOST_REQUIRE_NO_THROW( eval_ptr = evaluator::coulomb::make_evaluator( {} ) );
  BOOST_REQUIRE( eval_ptr );
  evaluator::coulomb *clmb_ptr = dynamic_cast< evaluator::coulomb* >( eval_ptr.get() );
  BOOST_REQUIRE( clmb_ptr != nullptr );
  BOOST_CHECK_EQUAL( eval_ptr->type_label(), defn_label );
  BOOST_CHECK_EQUAL( clmb_ptr->factor(), 0.0 );

  boost::shared_ptr< evaluator::evaluator_manager > eman;
  evaluator::evaluator_meta m( eman );
  BOOST_REQUIRE_NO_THROW( evaluator::coulomb::add_definition( m ) );
  BOOST_CHECK( m.has_definition( defn_label ) );
}

!!!1380528.cpp!!!	coulomb_evaluator_r1_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 2 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

evaluator::coulomb eval;
BOOST_CHECK_EQUAL( eval.factor(), 0.0 );

eval.prepare( pman, gman, eman );
BOOST_CHECK_CLOSE( eval.factor(), evaluator::coulomb::invariant_factor()/( eman.permittivity() * eman.temperature() ), 0.000001 );

double energy = 0.0;
BOOST_REQUIRE_NO_THROW( energy = eval.compute_total_potential( pman, gman ) );
BOOST_CHECK_CLOSE( -energy, eval.factor(), 0.000001 );
!!!1380400.cpp!!!	coulomb_evaluator_r2_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 2.0, 0.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 2 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

evaluator::coulomb eval;
BOOST_CHECK_EQUAL( eval.factor(), 0.0 );

eval.prepare( pman, gman, eman );
BOOST_CHECK_CLOSE( eval.factor(), evaluator::coulomb::invariant_factor()/( eman.permittivity() * eman.temperature() ), 0.000001 );

double energy = 0.0;
BOOST_REQUIRE_NO_THROW( energy = eval.compute_total_potential( pman, gman ) );
BOOST_CHECK_CLOSE( -energy, eval.factor()/2.0, 0.000001 );

// calculate move from current position to position in r1 test
// (1 angstrom distance)

// find Chloride particle
const std::size_t lispec = pman.get_specie_key( "Cl" );
const std::size_t lidx = pman.get_ensemble().nth_specie_index( lispec, 0 );
{
  // Move particle 1 angstrom distance
  const particle::coordinate pstart( pman.get_ensemble().position( lidx ) );
  const particle::coordinate pend( 0.0, 1.0, 0.0 );
  particle::change_atom atm( lispec );
  atm.index = lidx;
  atm.do_old = true;
  atm.old_position = pstart;
  gman.calculate_distances( atm.old_position, pman.get_ensemble().get_coordinates(), atm.old_rij, 0, pman.get_ensemble().size() );
  atm.do_old = true;
  atm.new_position = pend;
  gman.calculate_distances( atm.new_position, pman.get_ensemble().get_coordinates(), atm.new_rij, 0, pman.get_ensemble().size() );

  particle::change_set move;
  move.add_atom( atm );

  const double distance( std::sqrt( gman.calculate_distance_squared( pstart, pend ) ) );

  BOOST_CHECK_CLOSE_FRACTION( distance, 1.0, 0.0000000001 );
  // r1 - r2 total energies
  const double delta_energy( -eval.factor()/2.0 );

  // Calculate energy
  eval.compute_potential( pman, gman, move );
  BOOST_REQUIRE( not move.fail() );
  BOOST_CHECK_CLOSE_FRACTION( move.energy(), delta_energy, 0.0000000001 );
}



!!!1380656.cpp!!!	coulomb_evaluator_d4r1_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 4 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

evaluator::coulomb eval;
BOOST_CHECK_EQUAL( eval.factor(), 0.0 );

eval.prepare( pman, gman, eman );
BOOST_CHECK_CLOSE( eval.factor(), evaluator::coulomb::invariant_factor()/( eman.permittivity() * eman.temperature() ), 0.000001 );

double energy = 0.0;
BOOST_REQUIRE_NO_THROW( energy = eval.compute_total_potential( pman, gman ) );
BOOST_CHECK_CLOSE( -energy, (4.0 - std::sqrt(2.0)) * eval.factor(), 0.000001 );
!!!1380784.cpp!!!	coulomb_evaluator_d8r1_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

std::stringstream store;
double expected_value = 0.0;
{
  std::unique_ptr< evaluator::base_evaluator > eval_ptr( new evaluator::coulomb{} );
  evaluator::coulomb* llp = dynamic_cast< evaluator::coulomb* >( eval_ptr.get() );
  BOOST_REQUIRE( nullptr != llp );
  BOOST_CHECK_EQUAL( llp->factor(), 0.0 );

  eval_ptr->prepare( pman, gman, eman );
  BOOST_CHECK_CLOSE( llp->factor(), evaluator::coulomb::invariant_factor()/( eman.permittivity() * eman.temperature() ), 0.000001 );

  expected_value = -( 12.0 - ( 6 * std::sqrt( 2.0 ) ) + ( 4 / std::sqrt( 3 ) ) ) * llp->factor();

  double energy = 0.0;
  BOOST_REQUIRE_NO_THROW( energy = eval_ptr->compute_total_potential( pman, gman ) );
  BOOST_CHECK_CLOSE( energy, expected_value, 0.000001 );

  boost::archive::text_oarchive oa( store );
  oa << eval_ptr;
}
{
  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  boost::archive::text_iarchive ia( store );
  ia >> eval_ptr;

  double energy = 0.0;
  BOOST_REQUIRE_NO_THROW( energy = eval_ptr->compute_total_potential( pman, gman ) );
  BOOST_CHECK_CLOSE( energy, expected_value, 0.000001 );
}

!!!1394352.cpp!!!	localizer_lifetime_tests() : void
{
  //  Constructor tests
  BOOST_CHECK( std::is_default_constructible< evaluator::localizer >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< evaluator::localizer >::type {} );
  BOOST_CHECK( not std::is_move_constructible< evaluator::localizer >::type {} );
  BOOST_CHECK( ( not std::is_assignable< evaluator::localizer, evaluator::localizer >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< evaluator::localizer >::type {} );
}
const std::string defn_label( core::strngs::localizer_label() );
{
  evaluator::localizer eval;
  BOOST_CHECK_EQUAL( eval.type_label(), defn_label );
  BOOST_CHECK_EQUAL( eval.spring_factor(), evaluator::localizer::default_spring_factor() );
}

!!!1394224.cpp!!!	localizer_static_method_tests() : void
{
  // Static method tests.
  BOOST_CHECK_CLOSE( evaluator::localizer::default_spring_factor(), 4.5, 0.0000001 );
}
const std::string defn_label( core::strngs::localizer_label() );
{
  BOOST_CHECK_EQUAL( evaluator::localizer::type_label_(), defn_label );

  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  BOOST_REQUIRE_NO_THROW( eval_ptr = evaluator::localizer::make_evaluator( {} ) );
  BOOST_REQUIRE( eval_ptr );
  evaluator::localizer *clmb_ptr = dynamic_cast< evaluator::localizer* >( eval_ptr.get() );
  BOOST_REQUIRE( clmb_ptr != nullptr );
  BOOST_CHECK_EQUAL( eval_ptr->type_label(), defn_label );
  BOOST_CHECK_EQUAL( clmb_ptr->spring_factor(), 4.5 );

  boost::shared_ptr< evaluator::evaluator_manager > eman;
  evaluator::evaluator_meta m( eman );
  BOOST_REQUIRE_NO_THROW( evaluator::localizer::add_definition( m ) );
  BOOST_REQUIRE( m.has_definition( defn_label ) );
  BOOST_CHECK( m.get_definition( defn_label ).has_definition( core::strngs::fskmob() ) );
}

!!!1401008.cpp!!!	localizer_methods_test() : void
std::stringstream store;
const double spring_factor( 2.0 );
{
  // static method test
  BOOST_CHECK_EQUAL( core::strngs::localizer_label(), evaluator::localizer::type_label_() );
}
// Constructor test methods
{
  // default
  evaluator::localizer ll;
  BOOST_CHECK_EQUAL( ll.spring_factor(), evaluator::localizer::default_spring_factor() );
  ll.spring_factor( spring_factor );
  BOOST_CHECK_EQUAL( ll.spring_factor(), spring_factor );

  // write_document test
  core::input_document wr( 1 );
  ll.write_document( wr );
  BOOST_CHECK_EQUAL( wr.size(), 1 );
  BOOST_CHECK_EQUAL( wr[ 0 ].label(), core::strngs::evaluator_label() );
  BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fstype() ) );
  BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fstype() ), core::strngs::localizer_label() );
  BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fskmob() ) );
  BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fskmob() ), std::to_string( spring_factor ) );

  // serialize
  boost::archive::text_oarchive oa( store );
  oa << ll;
}
{
  evaluator::localizer ll;
  BOOST_CHECK_EQUAL( ll.spring_factor(),  evaluator::localizer::default_spring_factor() );
  // deserialize
  boost::archive::text_iarchive ia( store );
  ia >> ll;
  BOOST_CHECK_EQUAL( ll.spring_factor(), spring_factor );

  // write description
  std::stringstream desc;
  ll.description( desc );
  // 0 = evaluator, 1 = type, 2 = kmob (+ check kmob value)
  std::bitset< 3 > flags;
  flags.set();
  // Parse description
  while( true )
  {
    std::string line;
    std::getline( desc, line );
    // DEBUG : std::cout << "LINE[" << line << "]\n";
    if( desc.eof() )
    {
      break;
    }
    if( line.empty() )
    {
      continue;
    }
    if( line.find( core::strngs::evaluator_label() ) != std::string::npos )
    {
      flags.set( 0, true );
      if( line.find( core::strngs::localizer_label() ) != std::string::npos )
      {
        flags.set( 1, true );
      }
    }
    if( line.find( core::strngs::fskmob() ) != std::string::npos )
    {
      flags.set( 2, true );
      if( line.find( core::strngs::localizer_label() ) != std::string::npos )
      {
        const std::size_t split_pos
        {
          line.find( ':' )
        };
        BOOST_REQUIRE( std::string::npos != split_pos );
        std::stringstream ss( line.substr( split_pos ) );
        double value;
        ss >> value;
        BOOST_CHECK_CLOSE( value, spring_factor, 0.000001 );
      }
    }
  }
  BOOST_CHECK_MESSAGE( flags[ 0 ], core::strngs::evaluator_label() << " not found." );
  BOOST_CHECK_MESSAGE( flags[ 1 ], core::strngs::localizer_label() << " not found." );
  BOOST_CHECK_MESSAGE( flags[ 2 ], core::strngs::fskmob() << " not found." );

}
{
  std::map< std::string, std::string > params;
  params[ core::strngs::fskmob() ] = "1.0";
  // One arg list with "mobk"
  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  BOOST_CHECK_NO_THROW( eval_ptr = evaluator::localizer::make_evaluator( params ) );

  evaluator::localizer* llp = dynamic_cast< evaluator::localizer* >( eval_ptr.get() );
  BOOST_REQUIRE( nullptr != llp );
  BOOST_CHECK_EQUAL( llp->spring_factor(), 1.0 );

  // write_document test
  core::input_document wr( 1 );
  eval_ptr->write_document( wr );
  BOOST_CHECK_EQUAL( wr.size(), 1 );
  BOOST_CHECK_EQUAL( wr[ 0 ].label(), core::strngs::evaluator_label() );
  BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fstype() ) );
  BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fstype() ), core::strngs::localizer_label() );
  BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fskmob() ) );
  BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fskmob() ), std::to_string( 1.0 ) );

  // serialize
  boost::archive::text_oarchive oa( store );
  oa << eval_ptr;
}
{
  std::unique_ptr< evaluator::base_evaluator > ll;
  // deserialize
  boost::archive::text_iarchive ia( store );
  ia >> ll;
  evaluator::localizer* llp = dynamic_cast< evaluator::localizer* >( ll.get() );
  BOOST_REQUIRE( nullptr != llp );
  BOOST_CHECK_EQUAL( llp->spring_factor(), 1.0 );
}

!!!1401136.cpp!!!	localizer_evaluator_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "OX" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::MOBILE );
  // Original position is on localization point, therefore potential is zero
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ), particle::centroid( 3.0, 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}

pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 3 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 2 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

{
  std::map< std::string, std::string > params;
  params.insert( std::make_pair( core::strngs::fskmob(), "1.0" ) );
  std::unique_ptr< base_evaluator > eval_ptr;
  BOOST_REQUIRE_NO_THROW( eval_ptr = evaluator::localizer::make_evaluator( params ) );

  double energy = 0.0;

  BOOST_REQUIRE_NO_THROW( energy = eval_ptr->compute_total_potential( pman, gman ) );
  BOOST_CHECK_CLOSE_FRACTION( energy, 0.0, 0.0000000001 );

  // find localized particle
  const std::size_t lispec = pman.get_specie_key( "OX" );
  const std::size_t lidx = pman.get_ensemble().nth_specie_index( lispec, 0 );
  {
    // Move particle 1 angstrom distance
    const particle::coordinate pstart( pman.get_ensemble().position( lidx ) );
    const particle::coordinate pend( pstart.x + 0.6, pstart.y, pstart.z - 0.8 );
    particle::change_atom atm( lispec );
    atm.index = lidx;
    atm.do_old = true;
    atm.do_new = true;
    atm.old_position = pstart;
    atm.new_position = pend;
    particle::change_set move;
    move.add_atom( atm );

    const double distance( std::sqrt( gman.calculate_distance_squared( pstart, pend ) ) );

    BOOST_CHECK_CLOSE_FRACTION( distance, 1.0, 0.0000000001 );
    // U = 1/2 k x^2 : spring factor == 1/2 k
    const double delta_energy( 1.0/9.0 );

    // Calculate energy
    eval_ptr->compute_potential( pman, gman, move );
    BOOST_REQUIRE( not move.fail() );
    BOOST_CHECK_CLOSE_FRACTION( move.energy(), delta_energy, 0.0000000001 );
  }
  {
    // Move particle 1 angstrom distance
    const particle::coordinate pstart( pman.get_ensemble().position( lidx ) );
    const particle::coordinate pend( pstart.x + 0.3, pstart.y, pstart.z - 0.4 );
    particle::change_atom atm( lispec );
    atm.index = lidx;
    atm.do_old = true;
    atm.do_new = true;
    atm.old_position = pstart;
    atm.new_position = pend;
    particle::change_set move;
    move.add_atom( atm );

    const double distance( std::sqrt( gman.calculate_distance_squared( pstart, pend ) ) );

    BOOST_CHECK_CLOSE_FRACTION( distance, 0.5, 0.0000000001 );
    // U = 1/2 k x^2 : spring factor == 1/2 k
    const double delta_energy( 0.25/9.0 );

    // Calculate energy
    eval_ptr->compute_potential( pman, gman, move );
    BOOST_REQUIRE( not move.fail() );
    BOOST_CHECK_CLOSE_FRACTION( move.energy(), delta_energy, 0.0000000001 );
  }
  {
    // Move particle 1 angstrom distance
    const particle::coordinate pstart( pman.get_ensemble().position( lidx ) );
    const particle::coordinate pend( pstart.x + 1.9, pstart.y, pstart.z - 2.4 );
    particle::change_atom atm( lispec );
    atm.index = lidx;
    atm.do_old = true;
    atm.do_new = true;
    atm.old_position = pstart;
    atm.new_position = pend;
    particle::change_set move;
    move.add_atom( atm );

    const double distance( std::sqrt( gman.calculate_distance_squared( pstart, pend ) ) );

    BOOST_CHECK_CLOSE_FRACTION( distance, 3.061, 0.001 );

    // Calculate energy
    eval_ptr->compute_potential( pman, gman, move );
    BOOST_REQUIRE( move.fail() );
  }
}
!!!1424176.cpp!!!	lennard_jones_lifetime_tests() : void
{
  //  Constructor tests
  BOOST_CHECK( std::is_default_constructible< evaluator::lennard_jones >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< evaluator::lennard_jones >::type {} );
  BOOST_CHECK( not std::is_move_constructible< evaluator::lennard_jones >::type {} );
  BOOST_CHECK( ( not std::is_assignable< evaluator::lennard_jones, evaluator::lennard_jones >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< evaluator::lennard_jones >::type {} );
}
const std::string defn_label( "lennard-jones" );
{
  evaluator::lennard_jones eval;
  BOOST_CHECK_EQUAL( eval.type_label(), defn_label );
}

!!!1423920.cpp!!!	lennard_jones_static_method_tests() : void
  // Static method tests.
const std::string defn_label( "lennard-jones" );
{
  BOOST_CHECK_EQUAL( evaluator::lennard_jones::type_label_(), defn_label );

  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  std::map< std::string, std::string > params;
  params[ "epsilon" ] = "Na 1.0 Cl 1.0";
  params[ "sigma" ] = "Na 1.0 Cl 1.0";
  BOOST_REQUIRE_NO_THROW( eval_ptr = evaluator::lennard_jones::make_evaluator( params ) );
  BOOST_REQUIRE( eval_ptr );
  evaluator::lennard_jones *lj_ptr = dynamic_cast< evaluator::lennard_jones* >( eval_ptr.get() );
  BOOST_REQUIRE( lj_ptr != nullptr );
  BOOST_CHECK_EQUAL( eval_ptr->type_label(), defn_label );

  boost::shared_ptr< evaluator::evaluator_manager > eman;
  evaluator::evaluator_meta m( eman );
  BOOST_REQUIRE_NO_THROW( evaluator::lennard_jones::add_definition( m ) );
  BOOST_REQUIRE( m.has_definition( defn_label ) );
  auto const& defn = m.get_definition( defn_label );
  BOOST_CHECK( defn.has_definition( "epsilon" ) );
  BOOST_CHECK( defn.has_definition( "sigma" ) );
}

!!!1425072.cpp!!!	lennard_jones_param_different_size_list_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

{
  std::map< std::string, std::string > params;
  params[ "epsilon" ] = "Na 1.0";
  params[ "sigma" ] = "Na 1.0 Cl 1.0";
  try
  {
    std::unique_ptr< evaluator::base_evaluator > eval_ptr( evaluator::lennard_jones::make_evaluator( params ) );
    BOOST_ERROR( "expected \"evaluator::lennard_jones::make_evaluator\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Parameter \"epsilon\" value (Na 1.0) has a different size list to parameter \"sigma\" value (Na 1.0 Cl 1.0) in a evaluator section." ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"evaluator::lennard_jones::make_evaluator\" was not expected type: " ) + err.what() );
  }
}


!!!1425200.cpp!!!	lennard_jones_no_epsilon_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

{
  std::map< std::string, std::string > params;
  // params[ "epsilon" ] = "Na 1.0 Cl 1.0";
  params[ "sigma" ] = "Na 1.0 Cl 1.0";
  try
  {
    std::unique_ptr< evaluator::base_evaluator > eval_ptr( evaluator::lennard_jones::make_evaluator( params ) );
    BOOST_ERROR( "expected \"evaluator::lennard_jones::make_evaluator\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Required parameter \"epsilon\" was not found in a evaluator section." ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"evaluator::lennard_jones::make_evaluator\" was not expected type: " ) + err.what() );
  }
}


!!!1425328.cpp!!!	lennard_jones_no_sigma_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

{
  std::map< std::string, std::string > params;
  params[ "epsilon" ] = "Na 1.0 Cl 1.0";
  // params[ "sigma" ] = "Na 1.0 Cl 1.0";
  try
  {
    std::unique_ptr< evaluator::base_evaluator > eval_ptr( evaluator::lennard_jones::make_evaluator( params ) );
    BOOST_ERROR( "expected \"evaluator::lennard_jones::make_evaluator\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Required parameter \"sigma\" was not found in a evaluator section." ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"evaluator::lennard_jones::make_evaluator\" was not expected type: " ) + err.what() );
  }
}


!!!1425456.cpp!!!	lennard_jones_different_species_in_list_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

{
  std::map< std::string, std::string > params;
  params[ "epsilon" ] = "Na 1.0 Cl 1.0";
  params[ "sigma" ] = "Ca 1.0 Cl 1.0";
  try
  {
    std::unique_ptr< evaluator::base_evaluator > eval_ptr( evaluator::lennard_jones::make_evaluator( params ) );
    BOOST_ERROR( "expected \"evaluator::lennard_jones::make_evaluator\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Parameter \"epsilon\" value (Na 1.0 Cl 1.0) has a different specie labels in the list to parameter \"sigma\" value (Ca 1.0 Cl 1.0) in a evaluator section." ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"evaluator::lennard_jones::make_evaluator\" was not expected type: " ) + err.what() );
  }
}


!!!1425584.cpp!!!	lennard_jones_different_species_to_pman_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

{
  std::map< std::string, std::string > params;
  params[ "epsilon" ] = "Ca 1.0 Cl 1.0";
  params[ "sigma" ] = "Ca 1.0 Cl 1.0";
  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  BOOST_REQUIRE_NO_THROW( eval_ptr = evaluator::lennard_jones::make_evaluator( params ) );
  try
  {
    eval_ptr->prepare( pman, gman, eman );
    BOOST_ERROR( "expected \"evaluator::lennard_jones::make_evaluator\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Missing epsilon and sigma values for \"Na\" specie in Lennard-Jones potential evaluator." ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"evaluator::lennard_jones::make_evaluator\" was not expected type: " ) + err.what() );
  }
}
!!!1425712.cpp!!!	lennard_jones_extra_species_to_pman_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

{
  std::map< std::string, std::string > params;
  params[ "epsilon" ] = "Ca 1.0 Na 1.0 Cl 1.0";
  params[ "sigma" ] = "Ca 1.0 Na 1.0 Cl 1.0";
  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  BOOST_REQUIRE_NO_THROW( eval_ptr = evaluator::lennard_jones::make_evaluator( params ) );
  try
  {
    eval_ptr->prepare( pman, gman, eman );
    BOOST_ERROR( "expected \"evaluator::lennard_jones::make_evaluator\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Less species than epsilon and sigma values in Lennard-Jones potential evaluator." ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"evaluator::lennard_jones::make_evaluator\" was not expected type: " ) + err.what() );
  }
}
!!!1424944.cpp!!!	lennard_jones_missing_species_to_pman_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

{
  std::map< std::string, std::string > params;
  params[ "epsilon" ] = "Cl 1.0";
  params[ "sigma" ] = "Cl 1.0";
  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  BOOST_REQUIRE_NO_THROW( eval_ptr = evaluator::lennard_jones::make_evaluator( params ) );
  try
  {
    eval_ptr->prepare( pman, gman, eman );
    BOOST_ERROR( "expected \"evaluator::lennard_jones::make_evaluator\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "More species than epsilon and sigma values in Lennard-Jones potential evaluator." ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"evaluator::lennard_jones::make_evaluator\" was not expected type: " ) + err.what() );
  }
}
!!!1424432.cpp!!!	lennard_jones_evaluator_d8r1_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

std::stringstream store;
double expected_value = 0.0;
{
  std::map< std::string, std::string > params;
  params[ "epsilon" ] = "Na 1.0 Cl 1.0";
  params[ "sigma" ] = "Na 1.0 Cl 1.0";
  std::unique_ptr< evaluator::base_evaluator > eval_ptr( evaluator::lennard_jones::make_evaluator( params ) );
  evaluator::lennard_jones* llp = dynamic_cast< evaluator::lennard_jones* >( eval_ptr.get() );
  BOOST_REQUIRE( nullptr != llp );

  eval_ptr->prepare( pman, gman, eman );

  expected_value = 12.0 * ( 1/64.0 - 1/8.0 ) + 4 * ( 1/729.0 - 1/27.0 );

  double energy = 0.0;
  BOOST_REQUIRE_NO_THROW( energy = eval_ptr->compute_total_potential( pman, gman ) );
  BOOST_CHECK_CLOSE( energy, expected_value, 0.000001 );

  boost::archive::text_oarchive oa( store );
  oa << eval_ptr;
}
{
  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  boost::archive::text_iarchive ia( store );
  ia >> eval_ptr;

  double energy = 0.0;
  BOOST_REQUIRE_NO_THROW( energy = eval_ptr->compute_total_potential( pman, gman ) );
  BOOST_CHECK_CLOSE( energy, expected_value, 0.000001 );
}

!!!1424304.cpp!!!	lennard_jones_evaluator_d8r1_v2_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

std::stringstream store;
double expected_value = 0.0;
{
  std::map< std::string, std::string > params;
  params[ "epsilon" ] = "Na 1.0 Cl 1.0";
  params[ "sigma" ] = "Na 2.0 Cl 3.0";
  std::unique_ptr< evaluator::base_evaluator > eval_ptr( evaluator::lennard_jones::make_evaluator( params ) );
  evaluator::lennard_jones* llp = dynamic_cast< evaluator::lennard_jones* >( eval_ptr.get() );
  BOOST_REQUIRE( nullptr != llp );

  eval_ptr->prepare( pman, gman, eman );

  const double r1_nc6 = std::pow( 2.5, 6 );
  const double r1_nc = r1_nc6 * ( r1_nc6 - 1.0 );
  const double r2_nn6 = 8.0;
  const double r2_nn = r2_nn6 * ( r2_nn6 - 1.0 );
  const double r2_cc6 = 729.0 / 8.0;
  const double r2_cc = r2_cc6 * ( r2_cc6 - 1.0 );
  const double r3_cn6 = std::pow( 2.5, 6 ) / 27.0;
  const double r3_cn = r3_cn6 * ( r3_cn6 - 1.0 );
 
  expected_value = 6 * ( 2 * r1_nc + r2_nn + r2_cc ) + 4 * r3_cn;

  double energy = 0.0;
  BOOST_REQUIRE_NO_THROW( energy = eval_ptr->compute_total_potential( pman, gman ) );
  BOOST_CHECK_CLOSE( energy, expected_value, 0.000001 );

  boost::archive::text_oarchive oa( store );
  oa << eval_ptr;
}
{
  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  boost::archive::text_iarchive ia( store );
  ia >> eval_ptr;

  double energy = 0.0;
  BOOST_REQUIRE_NO_THROW( energy = eval_ptr->compute_total_potential( pman, gman ) );
  BOOST_CHECK_CLOSE( energy, expected_value, 0.000001 );
}

!!!1424560.cpp!!!	lennard_jones_evaluator_d8r1_v3_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

std::stringstream store;
double expected_value = 0.0;
{
  std::map< std::string, std::string > params;
  params[ "epsilon" ] = "Na 0.5 Cl 0.3";
  params[ "sigma" ] = "Na 1.0 Cl 1.0";
  std::unique_ptr< evaluator::base_evaluator > eval_ptr( evaluator::lennard_jones::make_evaluator( params ) );
  evaluator::lennard_jones* llp = dynamic_cast< evaluator::lennard_jones* >( eval_ptr.get() );
  BOOST_REQUIRE( nullptr != llp );

  eval_ptr->prepare( pman, gman, eman );

  const double eps_nc = std::sqrt( 0.5 * 0.3 );

  expected_value = 6.0 * ( 1/64.0 - 1/8.0 ) * ( 0.5 + 0.3 ) + 4 * eps_nc * ( 1/729.0 - 1/27.0 );

  double energy = 0.0;
  BOOST_REQUIRE_NO_THROW( energy = eval_ptr->compute_total_potential( pman, gman ) );
  BOOST_CHECK_CLOSE( energy, expected_value, 0.000001 );

  boost::archive::text_oarchive oa( store );
  oa << eval_ptr;
}
{
  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  boost::archive::text_iarchive ia( store );
  ia >> eval_ptr;

  double energy = 0.0;
  BOOST_REQUIRE_NO_THROW( energy = eval_ptr->compute_total_potential( pman, gman ) );
  BOOST_CHECK_CLOSE( energy, expected_value, 0.000001 );
}

!!!1424688.cpp!!!	lennard_jones_evaluator_d8r1_v4_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

evaluator::evaluator_manager eman;

std::stringstream store;
double expected_value = 0.0;
{
  std::map< std::string, std::string > params;
  params[ "epsilon" ] = "Na 0.5 Cl 0.3";
  params[ "sigma" ] = "Na 2.0 Cl 3.0";
  std::unique_ptr< evaluator::base_evaluator > eval_ptr( evaluator::lennard_jones::make_evaluator( params ) );
  evaluator::lennard_jones* llp = dynamic_cast< evaluator::lennard_jones* >( eval_ptr.get() );
  BOOST_REQUIRE( nullptr != llp );

  eval_ptr->prepare( pman, gman, eman );

  const double eps_nc = std::sqrt( 0.5 * 0.3 );
  const double r1_nc6 = std::pow( 2.5, 6 );
  const double r1_nc = r1_nc6 * ( r1_nc6 - 1.0 );
  const double r2_nn6 = 8.0;
  const double r2_nn = r2_nn6 * ( r2_nn6 - 1.0 );
  const double r2_cc6 = 729.0 / 8.0;
  const double r2_cc = r2_cc6 * ( r2_cc6 - 1.0 );
  const double r3_cn6 = std::pow( 2.5, 6 ) / 27.0;
  const double r3_cn = r3_cn6 * ( r3_cn6 - 1.0 );
 
  expected_value = 12 * eps_nc * r1_nc + 6 * ( 0.5 * r2_nn + 0.3 * r2_cc ) + 4 * eps_nc * ( r3_cn );

  double energy = 0.0;
  BOOST_REQUIRE_NO_THROW( energy = eval_ptr->compute_total_potential( pman, gman ) );
  BOOST_CHECK_CLOSE( energy, expected_value, 0.000001 );

  boost::archive::text_oarchive oa( store );
  oa << eval_ptr;
}
{
  std::unique_ptr< evaluator::base_evaluator > eval_ptr;
  boost::archive::text_iarchive ia( store );
  ia >> eval_ptr;

  double energy = 0.0;
  BOOST_REQUIRE_NO_THROW( energy = eval_ptr->compute_total_potential( pman, gman ) );
  BOOST_CHECK_CLOSE( energy, expected_value, 0.000001 );
}

!!!359216.cpp!!!	arc_integrator_lifetime_test() : void
{
  //  Constructor tests virtual with default ctor.
  BOOST_CHECK( std::is_default_constructible< evaluator::arc_integrator >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< evaluator::arc_integrator >::type {} );
  BOOST_CHECK( not std::is_move_constructible< evaluator::arc_integrator >::type {} );
  BOOST_CHECK( ( not std::is_assignable< evaluator::arc_integrator, evaluator::arc_integrator >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< evaluator::arc_integrator >::type {} );
}
{
  evaluator::arc_integrator acc;
  BOOST_CHECK_EQUAL( acc.index(), 0 );
  BOOST_CHECK_EQUAL( acc.nsub_other(), 0 );
  BOOST_CHECK_EQUAL( acc.nsub_self(), 0 );
  BOOST_CHECK_EQUAL( acc.za0(), 0.0 );
  BOOST_CHECK_EQUAL( acc.ra0(), 0.0 );
  BOOST_CHECK_EQUAL( acc.radius(), 0.0 );
  BOOST_CHECK_EQUAL( acc.theta1(), 0.0 );
  BOOST_CHECK_EQUAL( acc.theta2(), 0.0 );
  BOOST_CHECK_EQUAL( acc.phi1(), 0.0 );
  BOOST_CHECK_EQUAL( acc.phi2(), 0.0 );
}

const double za0( 5.0 );
const double ra0( 4.0 );
const double radius( 2.0 );
const double theta1( 1.0 );
const double theta2( 1.1 );
const double phi1( 4.3 );
const double phi2( 4.4 );
const std::size_t nsub( 10 );
std::size_t ndx( 57 );
std::stringstream store;
{
  // constructor
  std::unique_ptr< evaluator::integrator > intr_ptr( new evaluator::arc_integrator( nsub, ndx, za0, ra0, radius, theta1, theta2, phi1, phi2 ) );
  evaluator::arc_integrator const* acc_ptr = dynamic_cast< evaluator::arc_integrator* >( intr_ptr.get() );
  BOOST_REQUIRE( nullptr != acc_ptr );
  BOOST_CHECK_EQUAL( acc_ptr->index(), ndx );
  BOOST_CHECK_EQUAL( acc_ptr->nsub_other(), nsub );
  BOOST_CHECK_EQUAL( acc_ptr->nsub_self(), 6 * nsub );
  BOOST_CHECK_EQUAL( acc_ptr->za0(), za0 );
  BOOST_CHECK_EQUAL( acc_ptr->ra0(), ra0 );
  BOOST_CHECK_EQUAL( acc_ptr->radius(), radius );
  BOOST_CHECK_EQUAL( acc_ptr->theta1(), theta1 );
  BOOST_CHECK_EQUAL( acc_ptr->theta2(), theta2 );
  BOOST_CHECK_EQUAL( acc_ptr->phi1(), phi1 );
  BOOST_CHECK_EQUAL( acc_ptr->phi2(), phi2 );

  boost::archive::text_oarchive oa( store );
  oa << intr_ptr;
}
{
  std::unique_ptr< evaluator::integrator > intr_ptr;

  boost::archive::text_iarchive ia( store );
  ia >> intr_ptr;

  evaluator::arc_integrator const* acc_ptr = dynamic_cast< evaluator::arc_integrator* >( intr_ptr.get() );
  BOOST_REQUIRE( nullptr != acc_ptr );
  BOOST_CHECK_EQUAL( acc_ptr->index(), ndx );
  BOOST_CHECK_EQUAL( acc_ptr->nsub_other(), nsub );
  BOOST_CHECK_EQUAL( acc_ptr->nsub_self(), 6 * nsub );
  BOOST_CHECK_EQUAL( acc_ptr->za0(), za0 );
  BOOST_CHECK_EQUAL( acc_ptr->ra0(), ra0 );
  BOOST_CHECK_EQUAL( acc_ptr->radius(), radius );
  BOOST_CHECK_EQUAL( acc_ptr->theta1(), theta1 );
  BOOST_CHECK_EQUAL( acc_ptr->theta2(), theta2 );
  BOOST_CHECK_EQUAL( acc_ptr->phi1(), phi1 );
  BOOST_CHECK_EQUAL( acc_ptr->phi2(), phi2 );
}
!!!362160.cpp!!!	cylinder_integrator_lifetime_test() : void
{
  //  Constructor tests virtual with default ctor.
  BOOST_CHECK( std::is_default_constructible< evaluator::arc_integrator >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< evaluator::arc_integrator >::type {} );
  BOOST_CHECK( not std::is_move_constructible< evaluator::arc_integrator >::type {} );
  BOOST_CHECK( ( not std::is_assignable< evaluator::arc_integrator, evaluator::arc_integrator >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< evaluator::arc_integrator >::type {} );
}

{
  evaluator::cylinder_integrator cyl;
  BOOST_CHECK_EQUAL( cyl.index(), 0 );
  BOOST_CHECK_EQUAL( cyl.nsub_other(), 0 );
  BOOST_CHECK_EQUAL( cyl.nsub_self(), 0 );
  BOOST_CHECK_EQUAL( cyl.radius(), 0.0 );
  BOOST_CHECK_EQUAL( cyl.zmin(), 0.0 );
  BOOST_CHECK_EQUAL( cyl.zmax(), 0.0 );
  BOOST_CHECK_EQUAL( cyl.phimin(), 0.0 );
  BOOST_CHECK_EQUAL( cyl.phimax(), 0.0 );
}
const double radius( 2.0 );
const double zmin( 1.0 );
const double zmax( 1.1 );
const double phi1( 4.3 );
const double phi2( 4.4 );
const std::size_t nsub( 10 );
std::size_t ndx( 57 );
std::stringstream store;
{
  // constructor
  std::unique_ptr< evaluator::integrator > intr_ptr( new evaluator::cylinder_integrator( nsub, ndx, radius, zmin, zmax, phi1, phi2 ) );
  evaluator::cylinder_integrator const* cyl_ptr = dynamic_cast< evaluator::cylinder_integrator* >( intr_ptr.get() );
  BOOST_REQUIRE( nullptr != cyl_ptr );
  BOOST_CHECK_EQUAL( cyl_ptr->index(), ndx );
  BOOST_CHECK_EQUAL( cyl_ptr->nsub_other(), nsub );
  BOOST_CHECK_EQUAL( cyl_ptr->nsub_self(), 6 * nsub );
  BOOST_CHECK_EQUAL( cyl_ptr->radius(), radius );
  BOOST_CHECK_EQUAL( cyl_ptr->zmin(), zmin );
  BOOST_CHECK_EQUAL( cyl_ptr->zmax(), zmax );
  BOOST_CHECK_EQUAL( cyl_ptr->phimin(), phi1 );
  BOOST_CHECK_EQUAL( cyl_ptr->phimax(), phi2 );

  boost::archive::text_oarchive oa( store );
  oa << intr_ptr;
}
{
  std::unique_ptr< evaluator::integrator > intr_ptr;

  boost::archive::text_iarchive ia( store );
  ia >> intr_ptr;

  evaluator::cylinder_integrator const* cyl_ptr = dynamic_cast< evaluator::cylinder_integrator* >( intr_ptr.get() );
  BOOST_REQUIRE( nullptr != cyl_ptr );

  BOOST_CHECK_EQUAL( cyl_ptr->index(), ndx );
  BOOST_CHECK_EQUAL( cyl_ptr->nsub_other(), nsub );
  BOOST_CHECK_EQUAL( cyl_ptr->nsub_self(), 6 * nsub );
  BOOST_CHECK_EQUAL( cyl_ptr->radius(), radius );
  BOOST_CHECK_EQUAL( cyl_ptr->zmin(), zmin );
  BOOST_CHECK_EQUAL( cyl_ptr->zmax(), zmax );
  BOOST_CHECK_EQUAL( cyl_ptr->phimin(), phi1 );
  BOOST_CHECK_EQUAL( cyl_ptr->phimax(), phi2 );

}
!!!363056.cpp!!!	wall_integrator_lifetime_test() : void
{
  //  Constructor tests virtual with default ctor.
  BOOST_CHECK( std::is_default_constructible< evaluator::wall_integrator >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< evaluator::wall_integrator >::type {} );
  BOOST_CHECK( not std::is_move_constructible< evaluator::wall_integrator >::type {} );
  BOOST_CHECK( ( not std::is_assignable< evaluator::wall_integrator, evaluator::wall_integrator >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< evaluator::wall_integrator >::type {} );
}

{
  evaluator::wall_integrator wall;
  BOOST_CHECK_EQUAL( wall.index(), 0 );
  BOOST_CHECK_EQUAL( wall.nsub_other(), 0 );
  BOOST_CHECK_EQUAL( wall.nsub_self(), 0 );
  BOOST_CHECK_EQUAL( wall.z(), 0.0 );
  BOOST_CHECK_EQUAL( wall.ra0(), 0.0 );
  BOOST_CHECK_EQUAL( wall.ra1(), 0.0 );
  BOOST_CHECK_EQUAL( wall.radius(), 0.0 );
  BOOST_CHECK_EQUAL( wall.phi1(), 0.0 );
  BOOST_CHECK_EQUAL( wall.phi2(), 0.0 );
}

const double z( 4.0 );
const double ra0( 1.0 );
const double ra1( 1.1 );
const double radius( 2.0 );
const double phi1( 4.3 );
const double phi2( 4.4 );
const std::size_t nsub( 10 );
std::size_t ndx( 57 );
std::stringstream store;
{
  // constructor
  evaluator::wall_integrator wall( nsub, ndx, z, ra0, ra1, radius, phi1, phi2 );
  std::unique_ptr< evaluator::integrator > intr_ptr( new evaluator::wall_integrator( nsub, ndx, z, ra0, ra1, radius, phi1, phi2 ) );
  evaluator::wall_integrator const* wall_ptr = dynamic_cast< evaluator::wall_integrator* >( intr_ptr.get() );
  BOOST_REQUIRE( nullptr != wall_ptr );
  BOOST_CHECK_EQUAL( wall_ptr->index(), ndx );
  BOOST_CHECK_EQUAL( wall_ptr->nsub_other(), nsub );
  BOOST_CHECK_EQUAL( wall_ptr->nsub_self(), 6 * nsub );
  BOOST_CHECK_EQUAL( wall_ptr->z(), z );
  BOOST_CHECK_EQUAL( wall_ptr->ra0(), ra0 );
  BOOST_CHECK_EQUAL( wall_ptr->ra1(), ra1 );
  BOOST_CHECK_EQUAL( wall_ptr->radius(), radius );
  BOOST_CHECK_EQUAL( wall_ptr->phi1(), phi1 );
  BOOST_CHECK_EQUAL( wall_ptr->phi2(), phi2 );

  boost::archive::text_oarchive oa( store );
  oa << intr_ptr;
}
{
  std::unique_ptr< evaluator::integrator > intr_ptr;
  boost::archive::text_iarchive ia( store );
  ia >> intr_ptr;

  evaluator::wall_integrator const* wall_ptr = dynamic_cast< evaluator::wall_integrator* >( intr_ptr.get() );
  BOOST_REQUIRE( nullptr != wall_ptr );

  BOOST_CHECK_EQUAL( wall_ptr->index(), ndx );
  BOOST_CHECK_EQUAL( wall_ptr->nsub_other(), nsub );
  BOOST_CHECK_EQUAL( wall_ptr->nsub_self(), 6 * nsub );
  BOOST_CHECK_EQUAL( wall_ptr->z(), z );
  BOOST_CHECK_EQUAL( wall_ptr->ra0(), ra0 );
  BOOST_CHECK_EQUAL( wall_ptr->ra1(), ra1 );
  BOOST_CHECK_EQUAL( wall_ptr->radius(), radius );
  BOOST_CHECK_EQUAL( wall_ptr->phi1(), phi1 );
  BOOST_CHECK_EQUAL( wall_ptr->phi2(), phi2 );
}
!!!369200.cpp!!!	patch_matrix_fixture_test() : void
//XXconst double temperature( 300.0 );
//XXconst double epsw( 80.0 );
//XXconst double epspr( 10.0 );
//XXconst double zl1( 5.3 );
//XXconst double rl1( 8.8 );
//XXconst double rl4( 30.0 );
//XXconst double rlvest( 10.0 );
//XXconst double rlmemb( 5.0 );
//XXconst double dxw( 4.0 );
//XXconst double dxf( 4.0 );
//XXstd::size_t nsub( 10 );
//XXstd::size_t expect( 620 );
//XX
//XXevaluator::patch_matrix_fixture var {};
//XXBOOST_CHECK_EQUAL( var.epsw(), epsw );
//XXBOOST_CHECK_EQUAL( var.epspr(), epspr );
//XXBOOST_CHECK_EQUAL( var.dxf(), dxf );
//XXBOOST_CHECK_EQUAL( var.dxw(), dxw );
//XXBOOST_CHECK_EQUAL( var.nsub(), nsub );
//XXBOOST_CHECK_EQUAL( var.expected_grid_size(), expect );
//XXBOOST_CHECK_EQUAL( var.zl1(), zl1 );
//XXBOOST_CHECK_EQUAL( var.zl2(), zl1 + rlvest );
//XXBOOST_CHECK_EQUAL( var.zl3(), zl1 + rlvest - rlmemb );
//XXBOOST_CHECK_EQUAL( var.rl1(), rl1 );
//XXBOOST_CHECK_EQUAL( var.rl2(), rl1 + rlvest );
//XXBOOST_CHECK_EQUAL( var.rl3(), rl4 - rlmemb );
//XXBOOST_CHECK_EQUAL( var.rl4(), rl4 );
//XXBOOST_CHECK_EQUAL( var.rlvest(), rlvest );
//XXBOOST_CHECK_EQUAL( var.rlmemb(), rlmemb );
//XXBOOST_CHECK_EQUAL( var.temperature(), temperature );
!!!363184.cpp!!!	icc_surface_grid_test() : void
//XXconst double dxf( 1.1 );
//XXconst double dxw( 1.1 );
//XXconst std::size_t nsub( 6 );
//XXevaluator::patch_matrix_fixture var;
//XXstd::stringstream store;
//XXstd::stringstream log;
//XX{
//XX   // constructor
//XX   evaluator::icc_surface_grid grid;
//XX   BOOST_CHECK_EQUAL( grid.size(), 0 );
//XX   BOOST_CHECK_EQUAL( grid.empty(), true );
//XX   BOOST_CHECK_EQUAL( grid.have_integrators(), false );
//XX   BOOST_CHECK_EQUAL( grid.get_dxf(), 1.6 );
//XX   BOOST_CHECK_EQUAL( grid.get_dxw(), 1.6 );
//XX   BOOST_CHECK_EQUAL( grid.get_nsub0(), 10 );
//XX
//XX   // setters
//XX   grid.set_dxf( dxf );
//XX   BOOST_CHECK_EQUAL( grid.get_dxf(), dxf );
//XX   grid.set_dxw( dxw );
//XX   BOOST_CHECK_EQUAL( grid.get_dxw(), dxw );
//XX   grid.set_nsub0( nsub );
//XX   BOOST_CHECK_EQUAL( grid.get_nsub0(), nsub );
//XX
//XX   var.define_grid( grid, log );
//XX   // Should set dxf, dxw and nsub as
//XX   // well as define patches.
//XX   BOOST_CHECK_EQUAL( grid.get_dxf(), var.dxf() );
//XX   BOOST_CHECK_EQUAL( grid.get_dxw(), var.dxw() );
//XX   BOOST_CHECK_EQUAL( grid.get_nsub0(), var.nsub() );
//XX
//XX   log << grid.size() << "\n";
//XX   
//XX   BOOST_CHECK_NE( grid.size(), 0 );
//XX   BOOST_CHECK_EQUAL( grid.size(), var.expected_grid_size() );
//XX   BOOST_CHECK_EQUAL( grid.empty(), false );
//XX   BOOST_CHECK_EQUAL( grid.have_integrators(), true );
//XX   {
//XX      std::ofstream os( "patch.txt" );
//XX      grid.write_grid( os );
//XX   }
//XX   boost::archive::text_oarchive oa( store );
//XX   oa << grid;
//XX}
//XX{
//XX   evaluator::icc_surface_grid grid;
//XX
//XX   boost::archive::text_iarchive ia( store );
//XX   ia >> grid;
//XX
//XX   BOOST_CHECK_EQUAL( grid.get_dxf(), var.dxf() );
//XX   BOOST_CHECK_EQUAL( grid.get_dxw(), var.dxw() );
//XX   BOOST_CHECK_EQUAL( grid.get_nsub0(), var.nsub() );
//XX   BOOST_CHECK_EQUAL( grid.size(), var.expected_grid_size() );
//XX   BOOST_CHECK_EQUAL( grid.empty(), false );
//XX   BOOST_CHECK_EQUAL( grid.have_integrators(), true );
//XX}
!!!395312.cpp!!!	icc_matrix_test() : void
//XXevaluator::patch_matrix_fixture fix;
//XXstd::stringstream store;
//XXstd::stringstream iostore;
//XXstd::stringstream log;
//XXevaluator::icc_matrix::array_type amx;
//XXstd::vector< std::size_t > indx;
//XX{
//XX   evaluator::icc_matrix var;
//XX   BOOST_CHECK_EQUAL( var.size(), 0 );
//XX   BOOST_CHECK_EQUAL( var.empty(), true );
//XX
//XX   BOOST_CHECK_THROW( var.write_a_matrix( store ), std::runtime_error );
//XX
//XX   evaluator::icc_surface_grid gridder;
//XX
//XX   fix.define_grid( gridder, log );
//XX   log << gridder.size() << "\n";
//XX   
//XX   var.compute_amx( gridder, log );
//XX   {
//XX      std::ofstream os( "amx1.txt" );
//XX      var.write_a_matrix( os );
//XX   }
//XX   BOOST_CHECK_EQUAL( var.size(), gridder.size() );
//XX   BOOST_CHECK_EQUAL( var.size(), fix.expected_grid_size() );
//XX   var.lu_decompose_amx( log );
//XX   {
//XX      std::ofstream os( "amx.txt" );
//XX      var.write_a_matrix( os );
//XX   }
//XX   var.write_a_matrix( store );
//XX
//XX   boost::archive::text_oarchive oa( iostore );
//XX   oa << var;
//XX
//XX   amx.resize( boost::extents[ var.size() ][ var.size() ] );
//XX   indx.resize( var.size() );
//XX   for (std::size_t i = 0; i != var.size(); ++i)
//XX   {
//XX      std::array< std::size_t, 2 > idx;
//XX      idx[ 0 ] = i;
//XX      indx[ i ] = var.pivot( i );
//XX      for (std::size_t j = 0; j != var.size(); ++j)
//XX      {
//XX         idx[ 1 ] = j;
//XX         amx( idx ) = var.a( i, j );
//XX      }
//XX   }
//XX}
//XX{
//XX   evaluator::icc_matrix var;
//XX
//XX   BOOST_CHECK_EQUAL( var.size(), 0 );
//XX   BOOST_CHECK_EQUAL( var.empty(), true );
//XX
//XX   boost::archive::text_iarchive ia( iostore );
//XX   ia >> var;
//XX   BOOST_CHECK_EQUAL( var.size(), fix.expected_grid_size() );
//XX   BOOST_CHECK_EQUAL( var.empty(), false );
//XX   for (std::size_t i = 0; i != var.size(); ++i)
//XX   {
//XX      std::array< std::size_t, 2 > idx;
//XX      idx[ 0 ] = i;
//XX      BOOST_CHECK_EQUAL( indx[ i ], var.pivot( i ) );
//XX      for (std::size_t j = 0; j != var.size(); ++j)
//XX      {
//XX         idx[ 1 ] = j;
//XX         BOOST_CHECK_EQUAL( amx( idx ), var.a( i, j ) );
//XX      }
//XX   }
//XX}
//XX{
//XX   evaluator::icc_matrix var;
//XX
//XX   BOOST_CHECK_EQUAL( var.size(), 0 );
//XX   BOOST_CHECK_EQUAL( var.empty(), true );
//XX
//XX   var.read_a_matrix( store );
//XX   BOOST_CHECK_EQUAL( var.size(), fix.expected_grid_size() );
//XX   BOOST_CHECK_EQUAL( var.empty(), false );
//XX   for (std::size_t i = 0; i != var.size(); ++i)
//XX   {
//XX      std::array< std::size_t, 2 > idx;
//XX      idx[ 0 ] = i;
//XX      BOOST_CHECK_EQUAL( indx[ i ], var.pivot( i ) );
//XX      for (std::size_t j = 0; j != var.size(); ++j)
//XX      {
//XX         idx[ 1 ] = j;
//XX         // Allow error in the value as data was writen to only
//XX         // about 6 significant places (+/-0.0005 %)
//XX         BOOST_CHECK_CLOSE_FRACTION( amx( idx ), var.a( i, j ), 0.00051 );
//XX      }
//XX   }
//XX}
!!!410032.cpp!!!	induced_charge_test() : void
//XXevaluator::patch_matrix_fixture fix;
//XX//std::map< std::string, std::string > params;
//XXstd::stringstream store;
//XXstd::stringstream log;
//XX{
//XX   // static method test
//XX   BOOST_CHECK_EQUAL( core::strngs::fsptch(), evaluator::induced_charge::type_label_() );
//XX}
//XX// Constructor test method
//XX{
//XX   // default
//XX   evaluator::induced_charge icceval;
//XX
//XX   BOOST_CHECK_EQUAL( icceval.size(), 0 );
//XX   BOOST_CHECK_EQUAL( icceval.empty(), true );
//XX   BOOST_CHECK_EQUAL( icceval.type_label(), core::strngs::fsptch() );
//XX   BOOST_CHECK_EQUAL( icceval.get_a_matrix_filename(), "amx.dat" );
//XX   BOOST_CHECK_EQUAL( icceval.get_patch_filename(), "patch.dat" );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxf(), 1.6 );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxw(), 1.6 );
//XX   BOOST_CHECK_EQUAL( icceval.get_nsub0(), 10 );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_a_matrix_filename( "amx-test.txt" ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_a_matrix_filename(), "amx-test.txt" );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_patch_filename( "patch-test.txt" ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_patch_filename(), "patch-test.txt" );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxf( 1.25 ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxf(), 1.25 );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxw( 3.5 ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxw(), 3.5 );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_nsub0( 11 ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_nsub0(), 11 );
//XX
//XX   BOOST_CHECK_EQUAL( icceval.size(), 0 );
//XX   BOOST_CHECK_EQUAL( icceval.empty(), true );
//XX
//XX   boost::archive::text_oarchive oa( store );
//XX   oa << icceval;
//XX}
//XX// Serialization test method.
//XX{
//XX   evaluator::induced_charge icceval;
//XX
//XX   boost::archive::text_iarchive ia( store );
//XX   ia >> icceval;
//XX
//XX   BOOST_CHECK_EQUAL( icceval.size(), 0 );
//XX   BOOST_CHECK_EQUAL( icceval.empty(), true );
//XX   BOOST_CHECK_EQUAL( icceval.get_a_matrix_filename(), "amx-test.txt" );
//XX   BOOST_CHECK_EQUAL( icceval.get_patch_filename(), "patch-test.txt" );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxf(), 1.25 );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxw(), 3.5 );
//XX   BOOST_CHECK_EQUAL( icceval.get_nsub0(), 11 );
//XX
//XX}
//XX// Manual build test
//XX{
//XX   // default
//XX   evaluator::induced_charge icceval;
//XX   platform::simulator_fixture simfix;
//XX
//XX   // Set parameters as per 'fix'.
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxf( fix.dxf() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxw( fix.dxw() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_nsub0( fix.nsub() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_alfa( fix.temperature() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_permittivity( fix.epsw() ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_alfa(), fix.alfa() );
//XX   BOOST_CHECK_EQUAL( icceval.get_permittivity(), fix.epsw() );
//XX
//XX   // Build amx from data from 'fix'. We need to
//XX   // do this as simfix is not derived from channel_system.
//XX   BOOST_CHECK_NO_THROW( icceval.create_amx( fix.zl1(), fix.rl1(), fix.rl4(), fix.rlvest(), fix.rlmemb(), fix.epsw(), fix.epspr(), log ) );
//XX
//XX   // We assume this simple size test means that the surface grid and the A
//XX   // matrix are correctly built because independent tests of the surface grid
//XX   // and A matrix classes produce the correct results.
//XX   BOOST_CHECK_EQUAL( icceval.size(), fix.expected_grid_size() );
//XX}
//XX{
//XX   // Construction as if from an input file with no parameters
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_dxf(), 1.6);
//XX
//XX   // write_document test
//XX   core::input_document wr( 1 );
//XX   bep->write_document( wr );
//XX   BOOST_CHECK_EQUAL( wr.size(), 1  );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].label(), core::strngs::evaluator_label() );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fstype() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fstype() ), core::strngs::fsptch() );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fsdxw() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fsdxw() ), std::to_string( 1.6 ) );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fsdxf() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fsdxf() ), std::to_string( 1.6 ) );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fsnsub() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fsnsub() ), std::to_string( 10 ) );
//XX}
//XX{
//XX   // Construction as if from an input file with valid parameters
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsdxf() ] = "4.0";
//XX   params[ core::strngs::fsdxw() ] = "6.0";
//XX   params[ core::strngs::fsnsub() ] = "50";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_dxf(), 4.0 );
//XX   BOOST_CHECK_EQUAL( llp->get_dxw(), 6.0 );
//XX   BOOST_CHECK_EQUAL( llp->get_nsub0(), 50 );
//XX}
//XX{
//XX   // Construction as if from an input file with valid parameters
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsdxf() ] = "4";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_dxf(), 4.0 );
//XX}
//XX{
//XX   // Construction as if from an input file with invalid parameters : invalid value
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsdxf() ] = "four";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ), std::runtime_error );
//XX}
//XX{
//XX   // Construction as if from an input file with invalid parameters : invalid name
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsiwid() ] = "4.0";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ), std::runtime_error );
//XX}
//XX{
//XX   // Construction as if from an input file with invalid parameters we would
//XX   // like to be valid
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ "amxfile" ] = "amx.txt";
//XX   params[ "patchfile" ] = "patch.txt";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ), std::runtime_error );
//XX}
!!!421168.cpp!!!	legendre_test() : void
//XX// In order to test the ICC code an analytically tractable problem
//XX// is a single charge near a sphere.
//XX//
//XX// CHARGE INSIDE
//XX//
//XX//std::stringstream store;
//XX{
//XX   // default
//XX   platform::simulator_fixture simfix;
//XX   std::map< std::string, std::string > params;
//XX   const double inside_eps{ 10.0 };
//XX   const double outside_eps{ 80.0 };
//XX   const double temperature{ 300.0 };
//XX   const double ion_charge{ 1.0 };
//XX   const double dxf{ 1.6 };
//XX   const double dxw{ 1.6 };
//XX   const std::size_t nsub{ 20 };
//XX   const double sphere_radius{ 10.0 };
//XX
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX
//XX   simfix.sim->set_solvent_permittivity( outside_eps );
//XX
//XX   particle::coordinate external_coord{ 0.0, 0.0, 0.0 };
//XX   // Add specie and particle to simulation
//XX   {
//XX      particle::specie spc;
//XX      spc.set_label( "Na" );
//XX      spc.set_valency( ion_charge );
//XX      spc.set_radius( 1.0 );
//XX      spc.set_rate( 1.0 );
//XX      spc.set_excess_potential( 0.0 );
//XX      spc.set_concentration( 0.055 );
//XX      spc.set_type( particle::specie::SOLUTE );
//XX      spc.append_position( external_coord );
//XX      spc.set_count( 1 );
//XX      simfix.sim->add_specie( spc );
//XX   }
//XX
//XX   simfix.sim->generate_simulation( std::cout );
//XX
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().size(), 1 );
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().x( 0 ), external_coord.x );
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().y( 0 ), external_coord.y );
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().z( 0 ), external_coord.z );
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().eps( 0 ), outside_eps );
//XX   const_cast< particle::ensemble& >( simfix.sim->get_ensemble() ).set_eps( 0, inside_eps );
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().eps( 0 ), inside_eps );
//XX
//XX   std::unique_ptr< evaluator::icc_surface_grid > gridder( new evaluator::icc_surface_grid );
//XX
//XX   // Create a sphere.
//XX   gridder->set_dxf( dxf );
//XX   gridder->set_dxw( dxw );
//XX   gridder->set_nsub0( nsub );
//XX
//XX   gridder->add_arc( 0.0, 0.0, sphere_radius, 0.0, core::constants::pi()/2, inside_eps, outside_eps, 10, 10, true, std::cout );
//XX   gridder->add_arc( 0.0, 0.0, sphere_radius,  core::constants::pi()/2, core::constants::pi(), inside_eps, outside_eps, 10, 10, true, std::cout );
//XX
//XX   {
//XX      std::ofstream circle( "circle.txt" );
//XX      gridder->write_grid( circle );
//XX   }
//XX   const std::size_t gsize = gridder->size();
//XX   std::cout << " Number of tiles : " << gsize << "\n";
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX   BOOST_REQUIRE( llp != nullptr );
//XX
//XX   // Swap test grid into evaluator.
//XX   const_cast< evaluator::induced_charge* >(llp)->create_amx( gridder, std::cout );
//XX
//XX   BOOST_REQUIRE_EQUAL( gsize, llp->size() );
//XX
//XX   const_cast< evaluator::induced_charge* >(llp)->set_alfa( temperature );
//XX   const_cast< evaluator::induced_charge* >(llp)->set_permittivity( outside_eps );
//XX
//XX   // Calculate the initial induced charge
//XX   const_cast< evaluator::induced_charge* >(llp)->compute_initial_c_h( simfix.sim->get_species(), simfix.sim->get_ensemble() );
//XX
//XX   {
//XX      std::ofstream chrg( "charge_in.txt" );
//XX      chrg << "# tiles : " << llp->size() << "\n";
//XX      chrg << "# external charge : " << ion_charge << "\n";
//XX      chrg << "# external location : " << external_coord << "\n";
//XX      for( std::size_t ii = 0; ii != llp->size(); ++ii)
//XX      {
//XX         chrg << llp->surface_charge( ii ) <<  " " << llp->surface_area( ii ) <<  " "  << llp->field( ii ) <<  "\n";
//XX      }
//XX   }
//XX
//XX   {
//XX      double area, chrg;
//XX      llp->compute_total_surface_charge( chrg, area );
//XX
//XX      std::cout << "Total surface area = " << area << "\n";
//XX      BOOST_CHECK_CLOSE_FRACTION( area, (4*core::constants::pi()*sphere_radius*sphere_radius), 0.0001 );
//XX      std::cout << "Change in eps = " << (inside_eps - outside_eps) << "\n";
//XX      std::cout << "Average eps = " << ((inside_eps + outside_eps)/2) << "\n";
//XX      std::cout << "Ratio 1 delta_e' = " << (2*(inside_eps - outside_eps)/(inside_eps + outside_eps)) << "\n";
//XX      std::cout << "Ratio 2 (e_i.e_o)/(e_i - e_o) = " << (inside_eps * outside_eps/(inside_eps - outside_eps)) << "\n";
//XX      std::cout << "Total surface charge = " << chrg << "\n";
//XX      chrg *= inside_eps * outside_eps/(inside_eps - outside_eps);
//XX      std::cout << "Estimate of original charge from surface charge = " << chrg << "\n";
//XX      BOOST_CHECK_CLOSE_FRACTION( chrg, ion_charge, 0.01 );
//XX
//XX      //llp->compute_inner_surface_charge( chrg, area );
//XX      //BOOST_CHECK_CLOSE_FRACTION( chrg, ion_charge, 0.001 );
//XX      //std::cout << "Inner surface charge = " << chrg << "\n";
//XX   }
//XX}
//XX//XX  //
//XX//XX  //  CHARGE OUTSIDE
//XX//XX  //
//XX//XX  {
//XX//XX     // default
//XX//XX     platform::simulator_fixture simfix;
//XX//XX     std::map< std::string, std::string > params;
//XX//XX     // Empty parameter list allowed
//XX//XX     BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX//XX
//XX//XX     particle::coordinate external_coord{ 0.0, 0.0, 15.0 };
//XX//XX     // Add specie and particle to simulation
//XX//XX     {
//XX//XX        particle::specie spc;
//XX//XX        spc.set_label( "Na" );
//XX//XX        spc.set_valency( 1.0 );
//XX//XX        spc.set_radius( 1.0 );
//XX//XX        spc.set_rate( 1.0 );
//XX//XX        spc.set_excess_potential( 0.0 );
//XX//XX        spc.set_concentration( 0.055 );
//XX//XX        spc.set_type( particle::specie::SOLUTE );
//XX//XX        spc.append_position( external_coord );
//XX//XX        spc.set_count( 1 );
//XX//XX        simfix.sim->add_specie( spc );
//XX//XX     }
//XX//XX
//XX//XX     simfix.sim->generate_simulation( std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().size(), 1 );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().x( 0 ), external_coord.x );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().y( 0 ), external_coord.y );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().z( 0 ), external_coord.z );
//XX//XX
//XX//XX     std::unique_ptr< evaluator::icc_surface_grid > gridder( new evaluator::icc_surface_grid );
//XX//XX
//XX//XX     // Create a sphere.
//XX//XX     const double epsw = 80.0;
//XX//XX     const double temperature = 300.0;
//XX//XX     const double epspr = 10.0;
//XX//XX     const double deps =  2 * (epspr - epsw) / (epspr + epsw );
//XX//XX     gridder->add_arc( 0.0, 0.0, 10.0, 0.0, core::constants::pi()/2, deps, 10, 10, true, std::cout );
//XX//XX     gridder->add_arc( 0.0, 0.0, 10.0,  core::constants::pi()/2, core::constants::pi(), deps, 10, 10, true, std::cout );
//XX//XX
//XX//XX     const std::size_t gsize = gridder->size();
//XX//XX
//XX//XX     evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX//XX     evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX//XX     BOOST_REQUIRE( llp != nullptr );
//XX//XX
//XX//XX     // Swap test grid into evaluator.
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->create_amx( gridder, std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( gsize, llp->size() );
//XX//XX
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_alfa( temperature );
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_permittivity( epsw );
//XX//XX
//XX//XX     // Calculate the initial induced charge
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->compute_initial_c_h( simfix.sim->get_species(), simfix.sim->get_ensemble() );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream chrg( "charge_out.txt" );
//XX//XX        chrg << "# tiles : " << llp->size() << "\n";
//XX//XX        chrg << "# external charge : +1.0\n";
//XX//XX        chrg << "# external location : " << external_coord << "\n";
//XX//XX        for( std::size_t ii = 0; ii != llp->size(); ++ii)
//XX//XX        {
//XX//XX           chrg << llp->surface_charge( ii ) <<  " " << llp->surface_area( ii ) <<  " " << llp->field( ii ) <<  "\n";
//XX//XX        }
//XX//XX     }
//XX//XX
//XX//XX     {
//XX//XX        double area, chrg;
//XX//XX        llp->compute_total_surface_charge( chrg, area );
//XX//XX        std::cout << "Total surface charge = " << chrg << "\n";
//XX//XX        std::cout << "Total surface area = " << area << "\n";
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( chrg, 0.0, 0.0001 );
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( area, 4*core::constants::pi()*100.0, 0.0001 );
//XX//XX     }
//XX//XX  }
//XX//XX  //
//XX//XX  //  CHARGE AT CENTRE
//XX//XX  //
//XX//XX  {
//XX//XX     // default
//XX//XX     platform::simulator_fixture simfix;
//XX//XX     std::map< std::string, std::string > params;
//XX//XX     // Empty parameter list allowed
//XX//XX     BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX//XX
//XX//XX     particle::coordinate external_coord{ 0.0, 0.0, 0.0 };
//XX//XX     // Add specie and particle to simulation
//XX//XX     {
//XX//XX        particle::specie spc;
//XX//XX        spc.set_label( "Na" );
//XX//XX        spc.set_valency( 1.0 );
//XX//XX        spc.set_radius( 1.0 );
//XX//XX        spc.set_rate( 1.0 );
//XX//XX        spc.set_excess_potential( 0.0 );
//XX//XX        spc.set_concentration( 0.055 );
//XX//XX        spc.set_type( particle::specie::SOLUTE );
//XX//XX        spc.append_position( external_coord );
//XX//XX        spc.set_count( 1 );
//XX//XX        simfix.sim->add_specie( spc );
//XX//XX     }
//XX//XX
//XX//XX     simfix.sim->generate_simulation( std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().size(), 1 );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().x( 0 ), external_coord.x );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().y( 0 ), external_coord.y );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().z( 0 ), external_coord.z );
//XX//XX
//XX//XX     std::unique_ptr< evaluator::icc_surface_grid > gridder( new evaluator::icc_surface_grid );
//XX//XX
//XX//XX     gridder->set_dxf( 1.0 );
//XX//XX     gridder->set_dxw( 1.0 );
//XX//XX     // Create a sphere.
//XX//XX     const double epsw = 80.0;
//XX//XX     const double temperature = 300.0;
//XX//XX     const double epspr = 10.0;
//XX//XX     const double deps =  2 * (epspr - epsw) / (epspr + epsw );
//XX//XX     gridder->add_arc( 0.0, 0.0, 10.0, 0.0, core::constants::pi()/2, deps, 10, 10, true, std::cout );
//XX//XX     gridder->add_arc( 0.0, 0.0, 10.0,  core::constants::pi()/2, core::constants::pi(), deps, 10, 10, true, std::cout );
//XX//XX
//XX//XX     const std::size_t gsize = gridder->size();
//XX//XX
//XX//XX     evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX//XX     evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX//XX     BOOST_REQUIRE( llp != nullptr );
//XX//XX
//XX//XX     // Swap test grid into evaluator.
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->create_amx( gridder, std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( gsize, llp->size() );
//XX//XX
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_alfa( temperature );
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_permittivity( epsw );
//XX//XX
//XX//XX     // Calculate the initial induced charge
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->compute_initial_c_h( simfix.sim->get_species(), simfix.sim->get_ensemble() );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream chrg( "charge_ctr.txt" );
//XX//XX        chrg << "# tiles : " << llp->size() << "\n";
//XX//XX        chrg << "# external charge : +1.0\n";
//XX//XX        chrg << "# external location : " << external_coord << "\n";
//XX//XX        for( std::size_t ii = 0; ii != llp->size(); ++ii)
//XX//XX        {
//XX//XX           chrg << llp->surface_charge( ii ) <<  " " << llp->surface_area( ii ) <<  " " << llp->field( ii ) <<  "\n";
//XX//XX        }
//XX//XX     }
//XX//XX
//XX//XX     {
//XX//XX        double area, chrg;
//XX//XX        llp->compute_total_surface_charge( chrg, area );
//XX//XX        std::cout << "Total surface charge = " << chrg << "\n";
//XX//XX        std::cout << "Total surface area = " << area << "\n";
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( chrg, 0.0, 0.0001 );
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( area, 4*core::constants::pi()*100.0, 0.0001 );
//XX//XX     }
//XX//XX  }
//XX//XX  //
//XX//XX  //  CHARGE AWAY FROM WALL
//XX//XX  //
//XX//XX  {
//XX//XX     // default
//XX//XX     platform::simulator_fixture simfix;
//XX//XX     std::map< std::string, std::string > params;
//XX//XX     // Empty parameter list allowed
//XX//XX     BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX//XX
//XX//XX     particle::coordinate external_coord{ 0.0, 0.0, 12.0 };
//XX//XX     // Add specie and particle to simulation
//XX//XX     {
//XX//XX        particle::specie spc;
//XX//XX        spc.set_label( "Na" );
//XX//XX        spc.set_valency( 1.0 );
//XX//XX        spc.set_radius( 1.0 );
//XX//XX        spc.set_rate( 1.0 );
//XX//XX        spc.set_excess_potential( 0.0 );
//XX//XX        spc.set_concentration( 0.055 );
//XX//XX        spc.set_type( particle::specie::SOLUTE );
//XX//XX        spc.append_position( external_coord );
//XX//XX        spc.set_count( 1 );
//XX//XX        simfix.sim->add_specie( spc );
//XX//XX     }
//XX//XX
//XX//XX     simfix.sim->generate_simulation( std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().size(), 1 );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().x( 0 ), external_coord.x );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().y( 0 ), external_coord.y );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().z( 0 ), external_coord.z );
//XX//XX
//XX//XX     std::unique_ptr< evaluator::icc_surface_grid > gridder( new evaluator::icc_surface_grid );
//XX//XX
//XX//XX     // Create a sphere.
//XX//XX     const double epsw = 80.0;
//XX//XX     const double temperature = 300.0;
//XX//XX     const double epspr = 10.0;
//XX//XX     const double deps =  2 * (epspr - epsw) / (epspr + epsw );
//XX//XX     gridder->add_wall( 0.0, 0.0, 30.0, deps, 10, 10, true, std::cout );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream gridos( "wall.txt" );
//XX//XX        gridder->write_grid( gridos );
//XX//XX     }
//XX//XX
//XX//XX     const std::size_t gsize = gridder->size();
//XX//XX
//XX//XX     evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX//XX     evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX//XX     BOOST_REQUIRE( llp != nullptr );
//XX//XX
//XX//XX     // Swap test grid into evaluator.
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->create_amx( gridder, std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( gsize, llp->size() );
//XX//XX
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_alfa( temperature );
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_permittivity( epsw );
//XX//XX
//XX//XX     // Calculate the initial induced charge
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->compute_initial_c_h( simfix.sim->get_species(), simfix.sim->get_ensemble() );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream chrg( "charge_wall.txt" );
//XX//XX        chrg << "# tiles : " << llp->size() << "\n";
//XX//XX        chrg << "# external charge : +1.0\n";
//XX//XX        chrg << "# external location : " << external_coord << "\n";
//XX//XX        for( std::size_t ii = 0; ii != llp->size(); ++ii)
//XX//XX        {
//XX//XX           chrg << llp->surface_charge( ii ) <<  " " << llp->surface_area( ii ) <<  " " << llp->field( ii ) <<  "\n";
//XX//XX        }
//XX//XX     }
//XX//XX
//XX//XX     {
//XX//XX        double area, chrg;
//XX//XX        llp->compute_total_surface_charge( chrg, area );
//XX//XX        std::cout << "Total surface charge = " << chrg << "\n";
//XX//XX        std::cout << "Total surface area = " << area << "\n";
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( chrg, 0.0, 0.0001 );
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( area, core::constants::pi()*900.0, 0.0001 );
//XX//XX     }
//XX//XX  }
//XX//XX  //
//XX//XX  //  CHARGE AT CENTRE OF CYLINDER
//XX//XX  //
//XX//XX  {
//XX//XX     // default
//XX//XX     platform::simulator_fixture simfix;
//XX//XX     std::map< std::string, std::string > params;
//XX//XX     // Empty parameter list allowed
//XX//XX     BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX//XX
//XX//XX     particle::coordinate external_coord{ 0.0, 0.0, 0.0 };
//XX//XX     // Add specie and particle to simulation
//XX//XX     {
//XX//XX        particle::specie spc;
//XX//XX        spc.set_label( "Na" );
//XX//XX        spc.set_valency( 1.0 );
//XX//XX        spc.set_radius( 1.0 );
//XX//XX        spc.set_rate( 1.0 );
//XX//XX        spc.set_excess_potential( 0.0 );
//XX//XX        spc.set_concentration( 0.055 );
//XX//XX        spc.set_type( particle::specie::SOLUTE );
//XX//XX        spc.append_position( external_coord );
//XX//XX        spc.set_count( 1 );
//XX//XX        simfix.sim->add_specie( spc );
//XX//XX     }
//XX//XX
//XX//XX     simfix.sim->generate_simulation( std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().size(), 1 );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().x( 0 ), external_coord.x );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().y( 0 ), external_coord.y );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().z( 0 ), external_coord.z );
//XX//XX
//XX//XX     std::unique_ptr< evaluator::icc_surface_grid > gridder( new evaluator::icc_surface_grid );
//XX//XX
//XX//XX     // Create a sphere.
//XX//XX     const double epsw = 80.0;
//XX//XX     const double temperature = 300.0;
//XX//XX     const double epspr = 10.0;
//XX//XX     const double deps =  2 * (epspr - epsw) / (epspr + epsw );
//XX//XX     gridder->add_line( -20.0, 20.0, 10.0, deps, 10, 10, true, std::cout );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream gridos( "cylinder.txt" );
//XX//XX        gridder->write_grid( gridos );
//XX//XX     }
//XX//XX
//XX//XX     const std::size_t gsize = gridder->size();
//XX//XX
//XX//XX     evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX//XX     evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX//XX     BOOST_REQUIRE( llp != nullptr );
//XX//XX
//XX//XX     // Swap test grid into evaluator.
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->create_amx( gridder, std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( gsize, llp->size() );
//XX//XX
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_alfa( temperature );
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_permittivity( epsw );
//XX//XX
//XX//XX     // Calculate the initial induced charge
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->compute_initial_c_h( simfix.sim->get_species(), simfix.sim->get_ensemble() );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream chrg( "charge_cyl.txt" );
//XX//XX        chrg << "# tiles : " << llp->size() << "\n";
//XX//XX        chrg << "# external charge : +1.0\n";
//XX//XX        chrg << "# external location : " << external_coord << "\n";
//XX//XX        for( std::size_t ii = 0; ii != llp->size(); ++ii)
//XX//XX        {
//XX//XX           chrg << llp->surface_charge( ii ) <<  " " << llp->surface_area( ii ) <<  " " << llp->field( ii ) <<  "\n";
//XX//XX        }
//XX//XX     }
//XX//XX
//XX//XX     {
//XX//XX        double area, chrg;
//XX//XX        llp->compute_total_surface_charge( chrg, area );
//XX//XX        std::cout << "Total surface charge = " << chrg << "\n";
//XX//XX        std::cout << "Total surface area = " << area << "\n";
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( chrg, 0.0, 0.0001 );
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( area, 2*core::constants::pi()*40.0*10, 0.0001 );
//XX//XX     }
//XX//XX  }
!!!1369520.cpp!!!	evaluator_meta_lifetime_test() : void
{
  //  Constructor tests
  BOOST_CHECK( not std::is_default_constructible< evaluator::evaluator_meta >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< evaluator::evaluator_meta >::type {} );
  BOOST_CHECK( not std::is_move_constructible< evaluator::evaluator_meta >::type {} );
  BOOST_CHECK( ( not std::is_assignable< evaluator::evaluator_meta, evaluator::evaluator_meta >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< evaluator::evaluator_meta >::type {} );
}
const std::string meta_label( "evaluator" );
{
  boost::shared_ptr< evaluator::evaluator_manager > eman( new evaluator::evaluator_manager{} );
  evaluator::evaluator_meta meta( eman );
  BOOST_CHECK_EQUAL( meta.required(), true );
  BOOST_CHECK_EQUAL( meta.multiple(), true );
  BOOST_CHECK_EQUAL( meta.section_label(), core::strngs::evaluator_label() );
  BOOST_CHECK_EQUAL( meta.size(), 0 );
  BOOST_CHECK( meta.empty() );

  meta.add_definition( std::unique_ptr< evaluator::evaluator_definition >( new evaluator::evaluator_definition( "coloumb", "blah blab blech.", [](std::map<std::string, std::string>)->std::unique_ptr< evaluator::base_evaluator>{ return std::unique_ptr< evaluator::base_evaluator>{}; }) ) );
  
  BOOST_CHECK_EQUAL( meta.size(), 1 );
  BOOST_CHECK( not meta.empty() );
  BOOST_CHECK( meta.has_definition( "coloumb" ) );

}

!!!1401520.cpp!!!	evaluator_meta_coulomb_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::coulomb::add_definition( *m );

  core::input_help hlpr;
  m->publish_help( hlpr );
  {
    std::stringstream ss;
    hlpr.write( ss );
    BOOST_CHECK( ss.str().find( "coulomb" ) < ss.str().size() );
  }
  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"coulomb\"\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE_EQUAL( mngr->size(), 1ul );
BOOST_CHECK_EQUAL( mngr->get_evaluators()[ 0 ].type_label(), "coulomb" );

std::string canon( "evaluator\ntype coulomb\nend\n" );

core::input_document wrtr( 1ul );
mngr->write_document( wrtr );
std::stringstream idoc;
wrtr.write( idoc );
const std::string sdoc( idoc.str() );
BOOST_CHECK_LE( sdoc.find( canon ), sdoc.size() );
!!!1409072.cpp!!!	input_unknown_parameter_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::coulomb::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype coulomb\nmobk 4.5\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Parameter \"mobk\" is not valid in a evaluator \"coulomb\" type section." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1408432.cpp!!!	input_no_type_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::coulomb::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Required parameter \"type\" was not found in a evaluator section." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1408560.cpp!!!	input_type_no_value_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::coulomb::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype #localizer\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Parameter \"type\" requires a value in a evaluator section." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1401904.cpp!!!	input_type_bad_value_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::coulomb::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype localizer\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Parameter \"type\" value (localizer) does not name a valid evaluator subtype (see documentation)." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1408688.cpp!!!	evaluator_meta_localizer_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::localizer::add_definition( *m );

  core::input_help hlpr;
  m->publish_help( hlpr );
  {
    std::stringstream ss;
    hlpr.write( ss );
    BOOST_CHECK( ss.str().find( "localize" ) < ss.str().size() );
    BOOST_CHECK( ss.str().find( "mobk" ) < ss.str().size() );
  }
  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"localize\"\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE_EQUAL( mngr->size(), 1ul );
BOOST_CHECK_EQUAL( mngr->get_evaluators()[ 0 ].type_label(), "localize" );

std::string canon( "evaluator\nmobk 4.500000\ntype localize\nend\n" );

core::input_document wrtr( 1ul );
mngr->write_document( wrtr );
std::stringstream idoc;
wrtr.write( idoc );
const std::string sdoc( idoc.str() );
BOOST_CHECK_LE( sdoc.find( canon ), sdoc.size() );

!!!1408944.cpp!!!	input_localizer_no_mobk_value_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::localizer::add_definition( *m );
  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"localize\"\nmobk #one\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "localize \"mobk\" parameter requires a value." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1401776.cpp!!!	input_localizer_bad_mobk_value_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::localizer::add_definition( *m );
  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"localize\"\nmobk one\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "localize \"mobk\" parameter value (one) is not a number" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1425840.cpp!!!	evaluator_meta_lennard_jones_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::lennard_jones::add_definition( *m );

  core::input_help hlpr;
  m->publish_help( hlpr );
  {
    std::stringstream ss;
    hlpr.write( ss );
    BOOST_CHECK( ss.str().find( "lennard-jones" ) < ss.str().size() );
    BOOST_CHECK( ss.str().find( "epsilon" ) < ss.str().size() );
    BOOST_CHECK( ss.str().find( "sigma" ) < ss.str().size() );
  }
  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"lennard-jones\"\nepsilon Na 0.5 Cl 0.3\nsigma \"Na\" 2.0 Cl 3.0\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

BOOST_REQUIRE_EQUAL( mngr->size(), 1ul );
BOOST_CHECK_EQUAL( mngr->get_evaluators()[ 0 ].type_label(), "lennard-jones" );

std::string canon( "evaluator\nepsilon Cl 0.3 Na 0.5\nsigma Cl 3 Na 2\ntype lennard-jones\nend\n" );

core::input_document wrtr( 1ul );
mngr->write_document( wrtr );
std::stringstream idoc;
wrtr.write( idoc );
const std::string sdoc( idoc.str() );
// std::cout << sdoc << "\n";
BOOST_CHECK_LE( sdoc.find( canon ), sdoc.size() );

!!!1425968.cpp!!!	input_lennard_jones_unknown_parameter_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::lennard_jones::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"lennard-jones\"\nepsilon Na 0.5 Cl 0.3\nmobk \"Na\" 2.0 Cl 3.0\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Parameter \"mobk\" is not valid in a evaluator \"lennard-jones\" type section." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1426096.cpp!!!	input_lennard_jones_different_size_list_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::lennard_jones::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"lennard-jones\"\nepsilon Na 1.0 #Cl 1.0\nsigma \"Na\" 1.0 Cl 1.0\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Parameter \"epsilon\" value (Na 1.0) has a different size list to parameter \"sigma\" value (\"Na\" 1.0 Cl 1.0) in a evaluator section." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1426224.cpp!!!	input_lennard_jones_no_epsilon_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::lennard_jones::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"lennard-jones\"\n#epsilon Na 1.0 Cl 1.0\nsigma \"Na\" 1.0 Cl 1.0\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Required parameter \"epsilon\" was not found in a evaluator section." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1426352.cpp!!!	input_lennard_jones_no_sigma_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::lennard_jones::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"lennard-jones\"\nepsilon Na 1.0 Cl 1.0\n#sigma \"Na\" 1.0 Cl 1.0\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Required parameter \"sigma\" was not found in a evaluator section." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1426480.cpp!!!	input_lennard_jones_different_species_in_list_test() : void
// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::lennard_jones::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"lennard-jones\"\nepsilon Na 1.0 Cl 1.0\nsigma \"Ca\" 1.0 Cl 1.0\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Parameter \"epsilon\" value (Na 1.0 Cl 1.0) has a different specie labels in the list to parameter \"sigma\" value (\"Ca\" 1.0 Cl 1.0) in a evaluator section." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1426608.cpp!!!	input_lennard_jones_different_species_to_pman_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::lennard_jones::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"lennard-jones\"\nepsilon Ca 1.0 Cl 1.0\nsigma \"Ca\" 1.0 Cl 1.0\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
try
{
  mngr->prepare( pman, gman );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Missing epsilon and sigma values for \"Na\" specie in Lennard-Jones potential evaluator." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1426736.cpp!!!	input_lennard_jones_extra_species_to_pman_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::lennard_jones::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"lennard-jones\"\nepsilon Na 1.0 Ca 1.0 Cl 1.0\nsigma \"Ca\" 1.0 \"Na\" 1.0 Cl 1.0\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
try
{
  mngr->prepare( pman, gman );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Less species than epsilon and sigma values in Lennard-Jones potential evaluator." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1424816.cpp!!!	input_lennard_jones_missing_species_to_pman_test() : void
// Build basic system.
particle::particle_manager pman;
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 1.0 ) );
  pman.add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.1 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 1.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 1.0 ) );
  spc1.append_position( particle::coordinate( 1.0, 1.0, 1.0 ) );
  pman.add_specie( spc1 );
}
pman.add_predefined_particles();
BOOST_REQUIRE_EQUAL( pman.specie_count(), 2 );
BOOST_REQUIRE_EQUAL( pman.get_ensemble().count(), 8 );

boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
geometry::geometry_manager gman( sys_rgn );

// Test read input (specie meta)
boost::shared_ptr< evaluator::evaluator_manager > mngr( new evaluator::evaluator_manager {} );
core::input_delegater dg( 1 );
{
  boost::shared_ptr< evaluator::evaluator_meta > m( new evaluator::evaluator_meta( mngr ) );
  evaluator::lennard_jones::add_definition( *m );

  dg.add_input_delegate( m );
}

std::string canon_input( "evaluator\ntype \"lennard-jones\"\nepsilon Cl 1.0\nsigma Cl 1.0\nend\n\n" );

core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );
BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
try
{
  mngr->prepare( pman, gman );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "More species than epsilon and sigma values in Lennard-Jones potential evaluator." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
