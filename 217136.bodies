class evaluator_test
!!!848944.cpp!!!	evaluator_manager_lifetime() : void
//std::map< std::string, std::string > params;
std::stringstream store;
std::stringstream log;
{
  //  Constructor tests
  BOOST_CHECK( std::is_default_constructible< evaluator::evaluator_manager >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< evaluator::evaluator_manager >::type {} );
  BOOST_CHECK( not std::is_move_constructible< evaluator::evaluator_manager >::type {} );
  BOOST_CHECK( ( not std::is_assignable< evaluator::evaluator_manager, evaluator::evaluator_manager >::type {} ) );
  BOOST_CHECK( not std::has_virtual_destructor< evaluator::evaluator_manager >::type {} );
}
{
  evaluator::evaluator_manager mgr;
  BOOST_CHECK_EQUAL( mgr.size(), 0 );
  BOOST_CHECK( mgr.empty() );
}
// Constructor test method
{
  // default
  evaluator::evaluator_manager mgr;
//XX
//XX   BOOST_CHECK_EQUAL( icceval.size(), 0 );
//XX   BOOST_CHECK_EQUAL( icceval.empty(), true );
//XX   BOOST_CHECK_EQUAL( icceval.type_label(), core::strngs::fsptch() );
//XX   BOOST_CHECK_EQUAL( icceval.get_a_matrix_filename(), "amx.dat" );
//XX   BOOST_CHECK_EQUAL( icceval.get_patch_filename(), "patch.dat" );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxf(), 1.6 );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxw(), 1.6 );
//XX   BOOST_CHECK_EQUAL( icceval.get_nsub0(), 10 );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_a_matrix_filename( "amx-test.txt" ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_a_matrix_filename(), "amx-test.txt" );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_patch_filename( "patch-test.txt" ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_patch_filename(), "patch-test.txt" );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxf( 1.25 ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxf(), 1.25 );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxw( 3.5 ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxw(), 3.5 );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_nsub0( 11 ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_nsub0(), 11 );
//XX
//XX   BOOST_CHECK_EQUAL( icceval.size(), 0 );
//XX   BOOST_CHECK_EQUAL( icceval.empty(), true );
//XX
  boost::archive::text_oarchive oa( store );
  oa << mgr;
}
// Serialization test method.
{
  evaluator::evaluator_manager mgr;

  boost::archive::text_iarchive ia( store );
  ia >> mgr;
  BOOST_CHECK_EQUAL( mgr.size(), 0 );
  BOOST_CHECK( mgr.empty() );
//XX
//XX   BOOST_CHECK_EQUAL( icceval.size(), 0 );
//XX   BOOST_CHECK_EQUAL( icceval.empty(), true );
//XX   BOOST_CHECK_EQUAL( icceval.get_a_matrix_filename(), "amx-test.txt" );
//XX   BOOST_CHECK_EQUAL( icceval.get_patch_filename(), "patch-test.txt" );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxf(), 1.25 );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxw(), 3.5 );
//XX   BOOST_CHECK_EQUAL( icceval.get_nsub0(), 11 );
//XX
}
//XX// Manual build test
//XX{
//XX   // default
//XX   evaluator::induced_charge icceval;
//XX   platform::simulator_fixture simfix;
//XX
//XX   // Set parameters as per 'fix'.
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxf( fix.dxf() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxw( fix.dxw() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_nsub0( fix.nsub() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_alfa( fix.temperature() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_permittivity( fix.epsw() ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_alfa(), fix.alfa() );
//XX   BOOST_CHECK_EQUAL( icceval.get_permittivity(), fix.epsw() );
//XX
//XX   // Build amx from data from 'fix'. We need to
//XX   // do this as simfix is not derived from channel_system.
//XX   BOOST_CHECK_NO_THROW( icceval.create_amx( fix.zl1(), fix.rl1(), fix.rl4(), fix.rlvest(), fix.rlmemb(), fix.epsw(), fix.epspr(), log ) );
//XX
//XX   // We assume this simple size test means that the surface grid and the A
//XX   // matrix are correctly built because independent tests of the surface grid
//XX   // and A matrix classes produce the correct results.
//XX   BOOST_CHECK_EQUAL( icceval.size(), fix.expected_grid_size() );
//XX}
//XX{
//XX   // Construction as if from an input file with no parameters
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_dxf(), 1.6);
//XX
//XX   // write_document test
//XX   core::input_document wr( 1 );
//XX   bep->write_document( wr );
//XX   BOOST_CHECK_EQUAL( wr.size(), 1  );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].label(), core::strngs::evaluator_label() );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fstype() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fstype() ), core::strngs::fsptch() );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fsdxw() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fsdxw() ), std::to_string( 1.6 ) );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fsdxf() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fsdxf() ), std::to_string( 1.6 ) );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fsnsub() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fsnsub() ), std::to_string( 10 ) );
//XX}
//XX{
//XX   // Construction as if from an input file with valid parameters
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsdxf() ] = "4.0";
//XX   params[ core::strngs::fsdxw() ] = "6.0";
//XX   params[ core::strngs::fsnsub() ] = "50";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_dxf(), 4.0 );
//XX   BOOST_CHECK_EQUAL( llp->get_dxw(), 6.0 );
//XX   BOOST_CHECK_EQUAL( llp->get_nsub0(), 50 );
//XX}
//XX{
//XX   // Construction as if from an input file with valid parameters
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsdxf() ] = "4";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_dxf(), 4.0 );
//XX}
//XX{
//XX   // Construction as if from an input file with invalid parameters : invalid value
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsdxf() ] = "four";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ), std::runtime_error );
//XX}
//XX{
//XX   // Construction as if from an input file with invalid parameters : invalid name
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsiwid() ] = "4.0";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ), std::runtime_error );
//XX}
//XX{
//XX   // Construction as if from an input file with invalid parameters we would
//XX   // like to be valid
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ "amxfile" ] = "amx.txt";
//XX   params[ "patchfile" ] = "patch.txt";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ), std::runtime_error );
//XX}

!!!311600.cpp!!!	localizer_test() : void
//XXconst double spring_factor( 2.0 );
//XXauto set_atom = [](trial::change_atom &a, bool b1, bool b2, std::size_t idx, particle::coordinate p1, particle::coordinate p2, double eps1, double eps2)->void{
//XX  a.do_old = b1;
//XX  a.do_new = b2;
//XX  a.index = idx;
//XX  a.old_position = p1;
//XX  a.new_position = p2;
//XX  a.eps_old = eps1;
//XX  a.eps_new = eps2;
//XX};
//XXstd::stringstream store;
//XX{
//XX   // static method test
//XX   BOOST_CHECK_EQUAL( core::strngs::localizer_label(), evaluator::localizer::type_label_() );
//XX}
//XX// Constructor test methods
//XX{
//XX   // default
//XX   evaluator::localizer ll;
//XX   BOOST_CHECK_EQUAL( ll.get_spring_factor(), 4.5 );
//XX   BOOST_CHECK_EQUAL( core::strngs::localizer_label(), ll.type_label() );
//XX   ll.set_spring_factor( spring_factor );
//XX   BOOST_CHECK_EQUAL( ll.get_spring_factor(), spring_factor );
//XX
//XX   {
//XX      // copy ctor
//XX      evaluator::localizer lcopy( ll );
//XX      BOOST_CHECK_EQUAL( ll.get_spring_factor(), spring_factor );
//XX      BOOST_CHECK_EQUAL( lcopy.get_spring_factor(), spring_factor );
//XX   }
//XX   {
//XX      // assignment
//XX      evaluator::localizer lcopy;
//XX      BOOST_CHECK_EQUAL( lcopy.get_spring_factor(), 4.5 );
//XX      lcopy = ll;
//XX      BOOST_CHECK_EQUAL( ll.get_spring_factor(), spring_factor );
//XX      BOOST_CHECK_EQUAL( lcopy.get_spring_factor(), spring_factor );
//XX   }
//XX   {
//XX      // move ctor
//XX      evaluator::localizer lcopy( std::move( evaluator::localizer( ll ) ) );
//XX      BOOST_CHECK_EQUAL( ll.get_spring_factor(), spring_factor );
//XX      BOOST_CHECK_EQUAL( lcopy.get_spring_factor(), spring_factor );
//XX   }
//XX   {
//XX      // swap ctor
//XX      evaluator::localizer lcopy( ll );
//XX      BOOST_CHECK_EQUAL( ll.get_spring_factor(), spring_factor );
//XX      evaluator::localizer lswap;
//XX      BOOST_CHECK_EQUAL( lswap.get_spring_factor(), 4.5 );
//XX      lcopy.swap( lswap );
//XX      BOOST_CHECK_EQUAL( lcopy.get_spring_factor(), 4.5 );
//XX      BOOST_CHECK_EQUAL( lswap.get_spring_factor(), spring_factor );
//XX      lswap.swap( lcopy );
//XX      BOOST_CHECK_EQUAL( lswap.get_spring_factor(), 4.5 );
//XX      BOOST_CHECK_EQUAL( lcopy.get_spring_factor(), spring_factor );
//XX      std::swap( lcopy, lswap );
//XX      BOOST_CHECK_EQUAL( lcopy.get_spring_factor(), 4.5 );
//XX      BOOST_CHECK_EQUAL( lswap.get_spring_factor(), spring_factor );
//XX   }
//XX   // serialize
//XX   boost::archive::text_oarchive oa( store );
//XX   oa << ll;
//XX}
//XX{
//XX   evaluator::localizer ll;
//XX   BOOST_CHECK_EQUAL( ll.get_spring_factor(), 4.5 );
//XX   // deserialize
//XX   boost::archive::text_iarchive ia( store );
//XX   ia >> ll;
//XX   BOOST_CHECK_EQUAL( ll.get_spring_factor(), spring_factor );
//XX}
//XX{
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   // Empty parameter list allowed
//XX   BOOST_CHECK_NO_THROW( evaluator::localizer::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::localizer const* llp = dynamic_cast< evaluator::localizer const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_spring_factor(), 4.5 );
//XX
//XX   // write_document test
//XX   core::input_document wr( 1 );
//XX   bep->write_document( wr );
//XX   BOOST_CHECK_EQUAL( wr.size(), 1  );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].label(), core::strngs::evaluator_label() );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fstype() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fstype() ), core::strngs::localizer_label() );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fskmob() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fskmob() ), std::to_string( 4.5 ) );
//XX}
//XX{
//XX   platform::simulator_fixture simfix;
//XX   std::map< std::string, std::string > params;
//XX   params.insert( std::make_pair( core::strngs::fskmob(), "1.0" ) );
//XX
//XX   // One arg list with "mobk"
//XX   BOOST_CHECK_NO_THROW( evaluator::localizer::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::localizer const* llp = dynamic_cast< evaluator::localizer const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_spring_factor(), 1.0 );
//XX
//XX   // write_document test
//XX   core::input_document wr( 1 );
//XX   bep->write_document( wr );
//XX   BOOST_CHECK_EQUAL( wr.size(), 1  );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].label(), core::strngs::evaluator_label() );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fstype() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fstype() ), core::strngs::localizer_label() );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fskmob() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fskmob() ), std::to_string( 1.0 ) );
//XX
//XX   // write description
//XX   std::stringstream desc;
//XX   bep->description( desc );
//XX   // 0 = evaluator, 1 = type, 2 = kmob, 3 = kmob value
//XX   std::bitset< 3 > flags;
//XX   flags.set();
//XX   // Parse description
//XX   while( true )
//XX   {
//XX      std::string line;
//XX      std::getline( desc, line );
//XX      // DEBUG : std::cout << "LINE[" << line << "]\n";
//XX      if ( desc.eof() )
//XX      {
//XX         break;
//XX      }
//XX      if ( line.empty() )
//XX      {
//XX         continue;
//XX      }
//XX      if ( line.find( core::strngs::evaluator_label() ) != std::string::npos )
//XX      {
//XX         flags.set( 0, true );
//XX         if ( line.find( core::strngs::localizer_label() ) != std::string::npos )
//XX         {
//XX            flags.set( 1, true );
//XX         }
//XX      }
//XX      if ( line.find( core::strngs::fskmob() ) != std::string::npos )
//XX      {
//XX         flags.set( 2, true );
//XX         if ( line.find( core::strngs::localizer_label() ) != std::string::npos )
//XX         {
//XX            const std::size_t split_pos { line.find(':') };
//XX            BOOST_REQUIRE( std::string::npos != split_pos );
//XX            std::stringstream ss( line.substr( split_pos ) );
//XX            double value;
//XX            ss >> value;
//XX            BOOST_CHECK_EQUAL( value, 1.0 );
//XX         }
//XX      }
//XX   }
//XX   BOOST_CHECK_MESSAGE( flags[ 0 ], core::strngs::evaluator_label() << " not found." );
//XX   BOOST_CHECK_MESSAGE( flags[ 1 ], core::strngs::localizer_label() << " not found." );
//XX   BOOST_CHECK_MESSAGE( flags[ 2 ], core::strngs::fskmob() << " not found." );
//XX}
//XX{
//XX   platform::simulator_fixture simfix;
//XX   std::map< std::string, std::string > params;
//XX   params.insert( std::make_pair( "rate", "1.0" ) );
//XX
//XX   // ERROR One arg list not "mobk"
//XX   BOOST_CHECK_THROW( evaluator::localizer::make_evaluator( params, *simfix.sim ), std::runtime_error );
//XX}
//XX{
//XX   platform::simulator_fixture simfix;
//XX   simfix.add_solute_species();
//XX
//XX   simfix.add_localized_species();
//XX
//XX   std::map< std::string, std::string > params;
//XX   params.insert( std::make_pair( core::strngs::fskmob(), "1.0" ) );
//XX
//XX   BOOST_CHECK_NO_THROW( evaluator::localizer::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::localizer const* llp = dynamic_cast< evaluator::localizer const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_spring_factor(), 1.0 );
//XX
//XX   {
//XX      std::stringstream dummy_log;
//XX      simfix.sim->generate_simulation( dummy_log );
//XX   }
//XX
//XX   // find first localized particle.
//XX   std::size_t mobidx( simfix.sim->get_ensemble().size() );
//XX   for (std::size_t ispec = 0; ispec != simfix.sim->specie_count(); ++ispec)
//XX   {
//XX      if ( simfix.sim->get_specie(ispec).is_localized() and simfix.sim->get_specie(ispec).count() > 0)
//XX      {
//XX         mobidx = simfix.sim->get_ensemble().nth_specie_index(ispec, 0);
//XX         break;
//XX      }
//XX   }
//XX   BOOST_REQUIRE(mobidx != simfix.sim->get_ensemble().size());
//XX
//XX   BOOST_CHECK_EQUAL(simfix.sim->energy(), 0.0);
//XX
//XX   {
//XX      // Move particle zero distance
//XX      test_choice choice;
//XX      trial::change_set move( choice );
//XX      trial::change_atom atm(simfix.sim->get_ensemble().key(mobidx));
//XX      set_atom(atm, true, true, mobidx, simfix.sim->get_ensemble().position(mobidx), simfix.sim->get_ensemble().position(mobidx), simfix.sim->get_ensemble().eps(mobidx), simfix.sim->get_ensemble().eps(mobidx));
//XX      move.add_atom(atm);
//XX
//XX      // Calculate distance vectors.
//XX      for (auto & atom : move)
//XX      {
//XX        if (atom.do_old)
//XX        {
//XX          simfix.sim->compute_distances( atom.old_position, simfix.sim->get_ensemble().get_coordinates(), atom.old_rij, simfix.sim->get_ensemble().size(), 0 );
//XX        }
//XX        if (atom.do_new)
//XX        {
//XX          simfix.sim->compute_distances( atom.new_position, simfix.sim->get_ensemble().get_coordinates(), atom.new_rij, simfix.sim->get_ensemble().size(), 0 );
//XX        }
//XX      }
//XX      // Calculate energy
//XX      for ( auto const& evaluator : simfix.sim->get_evaluators() )
//XX      {
//XX        evaluator.compute_potential( simfix.sim->get_species(), simfix.sim->get_ensemble(), move, 0 );
//XX        if ( move.fail() ) break;
//XX      }
//XX
//XX      BOOST_CHECK_EQUAL( move.energy(), 0.0 );
//XX   }
//XX   {
//XX      // Move particle 1 angstrom distance
//XX      test_choice choice;
//XX      trial::change_set move( choice );
//XX      const particle::coordinate pstart( simfix.sim->get_ensemble().position( mobidx ) );
//XX      const particle::coordinate pend( pstart.x + 0.6, pstart.y, pstart.z - 0.8 );
//XX      trial::change_atom atm(simfix.sim->get_ensemble().key(mobidx));
//XX      set_atom(atm, true, true, mobidx, pstart, pend, simfix.sim->get_ensemble().eps(mobidx), simfix.sim->get_ensemble().eps(mobidx));
//XX      move.add_atom(atm);
//XX
//XX      const double distance( std::sqrt( std::pow( pstart.x - pend.x, 2 )
//XX               + std::pow( pstart.y - pend.y, 2 ) + std::pow( pstart.z - pend.z, 2 ) ) );
//XX
//XX      BOOST_CHECK_CLOSE_FRACTION( distance, 1.0, 0.0000000001 );
//XX      // U = 1/2 k x^2 : spring factor == 1/2 k
//XX      const double delta_energy( 1.0 );
//XX
//XX      // Calculate distance vectors.
//XX      for ( auto & atom : move )
//XX      {
//XX        if (atom.do_old)
//XX        {
//XX          simfix.sim->compute_distances( atom.old_position, simfix.sim->get_ensemble().get_coordinates(), atom.old_rij, simfix.sim->get_ensemble().size(), 0 );
//XX        }
//XX        if (atom.do_new)
//XX        {
//XX          simfix.sim->compute_distances( atom.new_position, simfix.sim->get_ensemble().get_coordinates(), atom.new_rij, simfix.sim->get_ensemble().size(), 0 );
//XX        }
//XX      }
//XX      // Calculate energy
//XX      for ( auto const& evaluator : simfix.sim->get_evaluators() )
//XX      {
//XX        evaluator.compute_potential( simfix.sim->get_species(), simfix.sim->get_ensemble(), move, 0 );
//XX        if ( move.fail() ) break;
//XX      }
//XX
//XX      BOOST_REQUIRE( not move.fail() );
//XX      BOOST_CHECK_CLOSE_FRACTION( move.energy(), delta_energy, 0.0000000001 );
//XX   }
//XX   {
//XX      // Move particle 0.5 angstrom distance
//XX      test_choice choice;
//XX      trial::change_set move( choice );
//XX      const particle::coordinate pstart( simfix.sim->get_ensemble().position( mobidx ) );
//XX      const particle::coordinate pend( pstart.x + 0.3, pstart.y - 0.4, pstart.z );
//XX      trial::change_atom atm(simfix.sim->get_ensemble().key( mobidx ));
//XX      set_atom(atm, true, true, mobidx, pstart, pend, simfix.sim->get_ensemble().eps(mobidx), simfix.sim->get_ensemble().eps(mobidx));
//XX      move.add_atom( atm );
//XX
//XX      const double distance( std::sqrt( std::pow( pstart.x - pend.x, 2 )
//XX               + std::pow( pstart.y - pend.y, 2 ) + std::pow( pstart.z - pend.z, 2 ) ) );
//XX      BOOST_CHECK_CLOSE_FRACTION( distance, 0.5, 0.0000000001 );
//XX
//XX      // U = 1/2 k x^2 : spring factor == 1/2 k
//XX      const double delta_energy( 0.25 );
//XX
//XX      // Skip distance vectors.
//XX
//XX      // Calculate energy
//XX      for ( auto const& evaluator : simfix.sim->get_evaluators() )
//XX      {
//XX        evaluator.compute_potential( simfix.sim->get_species(), simfix.sim->get_ensemble(), move, 0 );
//XX        if ( move.fail() ) break;
//XX      }
//XX
//XX      BOOST_REQUIRE( not move.fail() );
//XX      BOOST_CHECK_CLOSE_FRACTION( move.energy(), delta_energy, 0.0000000001 );
//XX   }
//XX   {
//XX      // Move particle outside localization cutoff distance
//XX      test_choice choice;
//XX      trial::change_set move( choice );
//XX      const particle::coordinate pstart( simfix.sim->get_ensemble().position( mobidx ) );
//XX      const particle::centroid pctr( simfix.sim->get_specie( simfix.sim->get_ensemble().key( mobidx ) ).get_localization_data( 0 ) );
//XX      const particle::coordinate pend( pstart.x + pctr.r * 1.1, pstart.y, pstart.z );
//XX      trial::change_atom atm(simfix.sim->get_ensemble().key(mobidx));
//XX      set_atom(atm, true, true, mobidx, pstart, pend, simfix.sim->get_ensemble().eps(mobidx), simfix.sim->get_ensemble().eps(mobidx));
//XX      move.add_atom(atm);
//XX
//XX      const double distance( std::sqrt( std::pow( pstart.x - pend.x, 2 )
//XX               + std::pow( pstart.y - pend.y, 2 ) + std::pow( pstart.z - pend.z, 2 ) ) );
//XX
//XX      BOOST_CHECK_CLOSE_FRACTION( distance, pctr.r * 1.1, 0.0000000001 );
//XX
//XX      // Calculate distance vectors.
//XX      for ( auto & atom : move )
//XX      {
//XX        if (atom.do_old)
//XX        {
//XX          simfix.sim->compute_distances( atom.old_position, simfix.sim->get_ensemble().get_coordinates(), atom.old_rij, simfix.sim->get_ensemble().size(), 0 );
//XX        }
//XX        if (atom.do_new)
//XX        {
//XX          simfix.sim->compute_distances( atom.new_position, simfix.sim->get_ensemble().get_coordinates(), atom.new_rij, simfix.sim->get_ensemble().size(), 0 );
//XX        }
//XX      }
//XX      // Calculate energy
//XX      for ( auto const& evaluator : simfix.sim->get_evaluators() )
//XX      {
//XX        evaluator.compute_potential( simfix.sim->get_species(), simfix.sim->get_ensemble(), move, 0 );
//XX        if ( move.fail() ) break;
//XX      }
//XX
//XX      BOOST_REQUIRE( move.fail() );
//XX   }
//XX
//XX}
!!!359216.cpp!!!	arc_integrator_test() : void
//XXconst double za0( 5.0 );
//XXconst double ra0( 4.0 );
//XXconst double radius( 2.0 );
//XXconst double theta1( 1.0 );
//XXconst double theta2( 1.1 );
//XXconst double phi1( 4.3 );
//XXconst double phi2( 4.4 );
//XXconst std::size_t nsub( 10 );
//XXstd::size_t ndx( 57 );
//XXstd::stringstream store;
//XX{
//XX   // constructor
//XX   evaluator::arc_integrator acc( nsub, ndx, za0, ra0, radius, theta1, theta2, phi1, phi2 );
//XX   BOOST_CHECK_EQUAL( acc.index(), ndx );
//XX   BOOST_CHECK_EQUAL( acc.nsub_other(), nsub );
//XX   BOOST_CHECK_EQUAL( acc.nsub_self(), 6 * nsub );
//XX   BOOST_CHECK_EQUAL( acc.za0(), za0 );
//XX   BOOST_CHECK_EQUAL( acc.ra0(), ra0 );
//XX   BOOST_CHECK_EQUAL( acc.radius(), radius );
//XX   BOOST_CHECK_EQUAL( acc.theta1(), theta1 );
//XX   BOOST_CHECK_EQUAL( acc.theta2(), theta2 );
//XX   BOOST_CHECK_EQUAL( acc.phi1(), phi1 );
//XX   BOOST_CHECK_EQUAL( acc.phi2(), phi2 );
//XX
//XX   boost::archive::text_oarchive oa( store );
//XX   oa << acc;
//XX}
//XX{
//XX   evaluator::arc_integrator acc;
//XX   BOOST_CHECK_EQUAL( acc.index(), 0 );
//XX   BOOST_CHECK_EQUAL( acc.nsub_other(), 0 );
//XX   BOOST_CHECK_EQUAL( acc.nsub_self(), 0 );
//XX   BOOST_CHECK_EQUAL( acc.za0(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.ra0(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.radius(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.theta1(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.theta2(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.phi1(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.phi2(), 0.0 );
//XX
//XX   boost::archive::text_iarchive ia( store );
//XX   ia >> acc;
//XX
//XX   BOOST_CHECK_EQUAL( acc.index(), ndx );
//XX   BOOST_CHECK_EQUAL( acc.nsub_other(), nsub );
//XX   BOOST_CHECK_EQUAL( acc.nsub_self(), 6 * nsub );
//XX   BOOST_CHECK_EQUAL( acc.za0(), za0 );
//XX   BOOST_CHECK_EQUAL( acc.ra0(), ra0 );
//XX   BOOST_CHECK_EQUAL( acc.radius(), radius );
//XX   BOOST_CHECK_EQUAL( acc.theta1(), theta1 );
//XX   BOOST_CHECK_EQUAL( acc.theta2(), theta2 );
//XX   BOOST_CHECK_EQUAL( acc.phi1(), phi1 );
//XX   BOOST_CHECK_EQUAL( acc.phi2(), phi2 );
//XX}
//XX
!!!362160.cpp!!!	cylinder_integrator_test() : void
//XXconst double radius( 2.0 );
//XXconst double zmin( 1.0 );
//XXconst double zmax( 1.1 );
//XXconst double phi1( 4.3 );
//XXconst double phi2( 4.4 );
//XXconst std::size_t nsub( 10 );
//XXstd::size_t ndx( 57 );
//XXstd::stringstream store;
//XX{
//XX   // constructor
//XX   evaluator::cylinder_integrator acc( nsub, ndx, radius, zmin, zmax, phi1, phi2 );
//XX   BOOST_CHECK_EQUAL( acc.index(), ndx );
//XX   BOOST_CHECK_EQUAL( acc.nsub_other(), nsub );
//XX   BOOST_CHECK_EQUAL( acc.nsub_self(), 6 * nsub );
//XX   BOOST_CHECK_EQUAL( acc.radius(), radius );
//XX   BOOST_CHECK_EQUAL( acc.zmin(), zmin );
//XX   BOOST_CHECK_EQUAL( acc.zmax(), zmax );
//XX   BOOST_CHECK_EQUAL( acc.phimin(), phi1 );
//XX   BOOST_CHECK_EQUAL( acc.phimax(), phi2 );
//XX
//XX   boost::archive::text_oarchive oa( store );
//XX   oa << acc;
//XX}
//XX{
//XX   evaluator::cylinder_integrator acc;
//XX   BOOST_CHECK_EQUAL( acc.index(), 0 );
//XX   BOOST_CHECK_EQUAL( acc.nsub_other(), 0 );
//XX   BOOST_CHECK_EQUAL( acc.nsub_self(), 0 );
//XX   BOOST_CHECK_EQUAL( acc.radius(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.zmin(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.zmax(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.phimin(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.phimax(), 0.0 );
//XX
//XX   boost::archive::text_iarchive ia( store );
//XX   ia >> acc;
//XX
//XX   BOOST_CHECK_EQUAL( acc.index(), ndx );
//XX   BOOST_CHECK_EQUAL( acc.nsub_other(), nsub );
//XX   BOOST_CHECK_EQUAL( acc.nsub_self(), 6 * nsub );
//XX   BOOST_CHECK_EQUAL( acc.radius(), radius );
//XX   BOOST_CHECK_EQUAL( acc.zmin(), zmin );
//XX   BOOST_CHECK_EQUAL( acc.zmax(), zmax );
//XX   BOOST_CHECK_EQUAL( acc.phimin(), phi1 );
//XX   BOOST_CHECK_EQUAL( acc.phimax(), phi2 );
//XX
//XX}
//XX
!!!363056.cpp!!!	wall_integrator_test() : void
//XXconst double z( 4.0 );
//XXconst double ra0( 1.0 );
//XXconst double ra1( 1.1 );
//XXconst double radius( 2.0 );
//XXconst double phi1( 4.3 );
//XXconst double phi2( 4.4 );
//XXconst std::size_t nsub( 10 );
//XXstd::size_t ndx( 57 );
//XXstd::stringstream store;
//XX{
//XX   // constructor
//XX   evaluator::wall_integrator acc( nsub, ndx, z, ra0, ra1, radius, phi1, phi2 );
//XX   BOOST_CHECK_EQUAL( acc.index(), ndx );
//XX   BOOST_CHECK_EQUAL( acc.nsub_other(), nsub );
//XX   BOOST_CHECK_EQUAL( acc.nsub_self(), 6 * nsub );
//XX   BOOST_CHECK_EQUAL( acc.z(), z );
//XX   BOOST_CHECK_EQUAL( acc.ra0(), ra0 );
//XX   BOOST_CHECK_EQUAL( acc.ra1(), ra1 );
//XX   BOOST_CHECK_EQUAL( acc.radius(), radius );
//XX   BOOST_CHECK_EQUAL( acc.phi1(), phi1 );
//XX   BOOST_CHECK_EQUAL( acc.phi2(), phi2 );
//XX
//XX   boost::archive::text_oarchive oa( store );
//XX   oa << acc;
//XX}
//XX{
//XX   evaluator::wall_integrator acc;
//XX   BOOST_CHECK_EQUAL( acc.index(), 0 );
//XX   BOOST_CHECK_EQUAL( acc.nsub_other(), 0 );
//XX   BOOST_CHECK_EQUAL( acc.nsub_self(), 0 );
//XX   BOOST_CHECK_EQUAL( acc.z(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.ra0(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.ra1(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.radius(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.phi1(), 0.0 );
//XX   BOOST_CHECK_EQUAL( acc.phi2(), 0.0 );
//XX
//XX   boost::archive::text_iarchive ia( store );
//XX   ia >> acc;
//XX
//XX   BOOST_CHECK_EQUAL( acc.index(), ndx );
//XX   BOOST_CHECK_EQUAL( acc.nsub_other(), nsub );
//XX   BOOST_CHECK_EQUAL( acc.nsub_self(), 6 * nsub );
//XX   BOOST_CHECK_EQUAL( acc.z(), z );
//XX   BOOST_CHECK_EQUAL( acc.ra0(), ra0 );
//XX   BOOST_CHECK_EQUAL( acc.ra1(), ra1 );
//XX   BOOST_CHECK_EQUAL( acc.radius(), radius );
//XX   BOOST_CHECK_EQUAL( acc.phi1(), phi1 );
//XX   BOOST_CHECK_EQUAL( acc.phi2(), phi2 );
//XX}
//XX
!!!369200.cpp!!!	patch_matrix_fixture_test() : void
//XXconst double temperature( 300.0 );
//XXconst double epsw( 80.0 );
//XXconst double epspr( 10.0 );
//XXconst double zl1( 5.3 );
//XXconst double rl1( 8.8 );
//XXconst double rl4( 30.0 );
//XXconst double rlvest( 10.0 );
//XXconst double rlmemb( 5.0 );
//XXconst double dxw( 4.0 );
//XXconst double dxf( 4.0 );
//XXstd::size_t nsub( 10 );
//XXstd::size_t expect( 620 );
//XX
//XXevaluator::patch_matrix_fixture var {};
//XXBOOST_CHECK_EQUAL( var.epsw(), epsw );
//XXBOOST_CHECK_EQUAL( var.epspr(), epspr );
//XXBOOST_CHECK_EQUAL( var.dxf(), dxf );
//XXBOOST_CHECK_EQUAL( var.dxw(), dxw );
//XXBOOST_CHECK_EQUAL( var.nsub(), nsub );
//XXBOOST_CHECK_EQUAL( var.expected_grid_size(), expect );
//XXBOOST_CHECK_EQUAL( var.zl1(), zl1 );
//XXBOOST_CHECK_EQUAL( var.zl2(), zl1 + rlvest );
//XXBOOST_CHECK_EQUAL( var.zl3(), zl1 + rlvest - rlmemb );
//XXBOOST_CHECK_EQUAL( var.rl1(), rl1 );
//XXBOOST_CHECK_EQUAL( var.rl2(), rl1 + rlvest );
//XXBOOST_CHECK_EQUAL( var.rl3(), rl4 - rlmemb );
//XXBOOST_CHECK_EQUAL( var.rl4(), rl4 );
//XXBOOST_CHECK_EQUAL( var.rlvest(), rlvest );
//XXBOOST_CHECK_EQUAL( var.rlmemb(), rlmemb );
//XXBOOST_CHECK_EQUAL( var.temperature(), temperature );
!!!363184.cpp!!!	icc_surface_grid_test() : void
//XXconst double dxf( 1.1 );
//XXconst double dxw( 1.1 );
//XXconst std::size_t nsub( 6 );
//XXevaluator::patch_matrix_fixture var;
//XXstd::stringstream store;
//XXstd::stringstream log;
//XX{
//XX   // constructor
//XX   evaluator::icc_surface_grid grid;
//XX   BOOST_CHECK_EQUAL( grid.size(), 0 );
//XX   BOOST_CHECK_EQUAL( grid.empty(), true );
//XX   BOOST_CHECK_EQUAL( grid.have_integrators(), false );
//XX   BOOST_CHECK_EQUAL( grid.get_dxf(), 1.6 );
//XX   BOOST_CHECK_EQUAL( grid.get_dxw(), 1.6 );
//XX   BOOST_CHECK_EQUAL( grid.get_nsub0(), 10 );
//XX
//XX   // setters
//XX   grid.set_dxf( dxf );
//XX   BOOST_CHECK_EQUAL( grid.get_dxf(), dxf );
//XX   grid.set_dxw( dxw );
//XX   BOOST_CHECK_EQUAL( grid.get_dxw(), dxw );
//XX   grid.set_nsub0( nsub );
//XX   BOOST_CHECK_EQUAL( grid.get_nsub0(), nsub );
//XX
//XX   var.define_grid( grid, log );
//XX   // Should set dxf, dxw and nsub as
//XX   // well as define patches.
//XX   BOOST_CHECK_EQUAL( grid.get_dxf(), var.dxf() );
//XX   BOOST_CHECK_EQUAL( grid.get_dxw(), var.dxw() );
//XX   BOOST_CHECK_EQUAL( grid.get_nsub0(), var.nsub() );
//XX
//XX   log << grid.size() << "\n";
//XX   
//XX   BOOST_CHECK_NE( grid.size(), 0 );
//XX   BOOST_CHECK_EQUAL( grid.size(), var.expected_grid_size() );
//XX   BOOST_CHECK_EQUAL( grid.empty(), false );
//XX   BOOST_CHECK_EQUAL( grid.have_integrators(), true );
//XX   {
//XX      std::ofstream os( "patch.txt" );
//XX      grid.write_grid( os );
//XX   }
//XX   boost::archive::text_oarchive oa( store );
//XX   oa << grid;
//XX}
//XX{
//XX   evaluator::icc_surface_grid grid;
//XX
//XX   boost::archive::text_iarchive ia( store );
//XX   ia >> grid;
//XX
//XX   BOOST_CHECK_EQUAL( grid.get_dxf(), var.dxf() );
//XX   BOOST_CHECK_EQUAL( grid.get_dxw(), var.dxw() );
//XX   BOOST_CHECK_EQUAL( grid.get_nsub0(), var.nsub() );
//XX   BOOST_CHECK_EQUAL( grid.size(), var.expected_grid_size() );
//XX   BOOST_CHECK_EQUAL( grid.empty(), false );
//XX   BOOST_CHECK_EQUAL( grid.have_integrators(), true );
//XX}
!!!395312.cpp!!!	icc_matrix_test() : void
//XXevaluator::patch_matrix_fixture fix;
//XXstd::stringstream store;
//XXstd::stringstream iostore;
//XXstd::stringstream log;
//XXevaluator::icc_matrix::array_type amx;
//XXstd::vector< std::size_t > indx;
//XX{
//XX   evaluator::icc_matrix var;
//XX   BOOST_CHECK_EQUAL( var.size(), 0 );
//XX   BOOST_CHECK_EQUAL( var.empty(), true );
//XX
//XX   BOOST_CHECK_THROW( var.write_a_matrix( store ), std::runtime_error );
//XX
//XX   evaluator::icc_surface_grid gridder;
//XX
//XX   fix.define_grid( gridder, log );
//XX   log << gridder.size() << "\n";
//XX   
//XX   var.compute_amx( gridder, log );
//XX   {
//XX      std::ofstream os( "amx1.txt" );
//XX      var.write_a_matrix( os );
//XX   }
//XX   BOOST_CHECK_EQUAL( var.size(), gridder.size() );
//XX   BOOST_CHECK_EQUAL( var.size(), fix.expected_grid_size() );
//XX   var.lu_decompose_amx( log );
//XX   {
//XX      std::ofstream os( "amx.txt" );
//XX      var.write_a_matrix( os );
//XX   }
//XX   var.write_a_matrix( store );
//XX
//XX   boost::archive::text_oarchive oa( iostore );
//XX   oa << var;
//XX
//XX   amx.resize( boost::extents[ var.size() ][ var.size() ] );
//XX   indx.resize( var.size() );
//XX   for (std::size_t i = 0; i != var.size(); ++i)
//XX   {
//XX      std::array< std::size_t, 2 > idx;
//XX      idx[ 0 ] = i;
//XX      indx[ i ] = var.pivot( i );
//XX      for (std::size_t j = 0; j != var.size(); ++j)
//XX      {
//XX         idx[ 1 ] = j;
//XX         amx( idx ) = var.a( i, j );
//XX      }
//XX   }
//XX}
//XX{
//XX   evaluator::icc_matrix var;
//XX
//XX   BOOST_CHECK_EQUAL( var.size(), 0 );
//XX   BOOST_CHECK_EQUAL( var.empty(), true );
//XX
//XX   boost::archive::text_iarchive ia( iostore );
//XX   ia >> var;
//XX   BOOST_CHECK_EQUAL( var.size(), fix.expected_grid_size() );
//XX   BOOST_CHECK_EQUAL( var.empty(), false );
//XX   for (std::size_t i = 0; i != var.size(); ++i)
//XX   {
//XX      std::array< std::size_t, 2 > idx;
//XX      idx[ 0 ] = i;
//XX      BOOST_CHECK_EQUAL( indx[ i ], var.pivot( i ) );
//XX      for (std::size_t j = 0; j != var.size(); ++j)
//XX      {
//XX         idx[ 1 ] = j;
//XX         BOOST_CHECK_EQUAL( amx( idx ), var.a( i, j ) );
//XX      }
//XX   }
//XX}
//XX{
//XX   evaluator::icc_matrix var;
//XX
//XX   BOOST_CHECK_EQUAL( var.size(), 0 );
//XX   BOOST_CHECK_EQUAL( var.empty(), true );
//XX
//XX   var.read_a_matrix( store );
//XX   BOOST_CHECK_EQUAL( var.size(), fix.expected_grid_size() );
//XX   BOOST_CHECK_EQUAL( var.empty(), false );
//XX   for (std::size_t i = 0; i != var.size(); ++i)
//XX   {
//XX      std::array< std::size_t, 2 > idx;
//XX      idx[ 0 ] = i;
//XX      BOOST_CHECK_EQUAL( indx[ i ], var.pivot( i ) );
//XX      for (std::size_t j = 0; j != var.size(); ++j)
//XX      {
//XX         idx[ 1 ] = j;
//XX         // Allow error in the value as data was writen to only
//XX         // about 6 significant places (+/-0.0005 %)
//XX         BOOST_CHECK_CLOSE_FRACTION( amx( idx ), var.a( i, j ), 0.00051 );
//XX      }
//XX   }
//XX}
!!!410032.cpp!!!	induced_charge_test() : void
//XXevaluator::patch_matrix_fixture fix;
//XX//std::map< std::string, std::string > params;
//XXstd::stringstream store;
//XXstd::stringstream log;
//XX{
//XX   // static method test
//XX   BOOST_CHECK_EQUAL( core::strngs::fsptch(), evaluator::induced_charge::type_label_() );
//XX}
//XX// Constructor test method
//XX{
//XX   // default
//XX   evaluator::induced_charge icceval;
//XX
//XX   BOOST_CHECK_EQUAL( icceval.size(), 0 );
//XX   BOOST_CHECK_EQUAL( icceval.empty(), true );
//XX   BOOST_CHECK_EQUAL( icceval.type_label(), core::strngs::fsptch() );
//XX   BOOST_CHECK_EQUAL( icceval.get_a_matrix_filename(), "amx.dat" );
//XX   BOOST_CHECK_EQUAL( icceval.get_patch_filename(), "patch.dat" );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxf(), 1.6 );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxw(), 1.6 );
//XX   BOOST_CHECK_EQUAL( icceval.get_nsub0(), 10 );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_a_matrix_filename( "amx-test.txt" ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_a_matrix_filename(), "amx-test.txt" );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_patch_filename( "patch-test.txt" ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_patch_filename(), "patch-test.txt" );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxf( 1.25 ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxf(), 1.25 );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxw( 3.5 ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxw(), 3.5 );
//XX
//XX   BOOST_CHECK_NO_THROW( icceval.set_nsub0( 11 ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_nsub0(), 11 );
//XX
//XX   BOOST_CHECK_EQUAL( icceval.size(), 0 );
//XX   BOOST_CHECK_EQUAL( icceval.empty(), true );
//XX
//XX   boost::archive::text_oarchive oa( store );
//XX   oa << icceval;
//XX}
//XX// Serialization test method.
//XX{
//XX   evaluator::induced_charge icceval;
//XX
//XX   boost::archive::text_iarchive ia( store );
//XX   ia >> icceval;
//XX
//XX   BOOST_CHECK_EQUAL( icceval.size(), 0 );
//XX   BOOST_CHECK_EQUAL( icceval.empty(), true );
//XX   BOOST_CHECK_EQUAL( icceval.get_a_matrix_filename(), "amx-test.txt" );
//XX   BOOST_CHECK_EQUAL( icceval.get_patch_filename(), "patch-test.txt" );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxf(), 1.25 );
//XX   BOOST_CHECK_EQUAL( icceval.get_dxw(), 3.5 );
//XX   BOOST_CHECK_EQUAL( icceval.get_nsub0(), 11 );
//XX
//XX}
//XX// Manual build test
//XX{
//XX   // default
//XX   evaluator::induced_charge icceval;
//XX   platform::simulator_fixture simfix;
//XX
//XX   // Set parameters as per 'fix'.
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxf( fix.dxf() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_dxw( fix.dxw() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_nsub0( fix.nsub() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_alfa( fix.temperature() ) );
//XX   BOOST_CHECK_NO_THROW( icceval.set_permittivity( fix.epsw() ) );
//XX   BOOST_CHECK_EQUAL( icceval.get_alfa(), fix.alfa() );
//XX   BOOST_CHECK_EQUAL( icceval.get_permittivity(), fix.epsw() );
//XX
//XX   // Build amx from data from 'fix'. We need to
//XX   // do this as simfix is not derived from channel_system.
//XX   BOOST_CHECK_NO_THROW( icceval.create_amx( fix.zl1(), fix.rl1(), fix.rl4(), fix.rlvest(), fix.rlmemb(), fix.epsw(), fix.epspr(), log ) );
//XX
//XX   // We assume this simple size test means that the surface grid and the A
//XX   // matrix are correctly built because independent tests of the surface grid
//XX   // and A matrix classes produce the correct results.
//XX   BOOST_CHECK_EQUAL( icceval.size(), fix.expected_grid_size() );
//XX}
//XX{
//XX   // Construction as if from an input file with no parameters
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_dxf(), 1.6);
//XX
//XX   // write_document test
//XX   core::input_document wr( 1 );
//XX   bep->write_document( wr );
//XX   BOOST_CHECK_EQUAL( wr.size(), 1  );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].label(), core::strngs::evaluator_label() );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fstype() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fstype() ), core::strngs::fsptch() );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fsdxw() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fsdxw() ), std::to_string( 1.6 ) );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fsdxf() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fsdxf() ), std::to_string( 1.6 ) );
//XX   BOOST_CHECK( wr[ 0 ].has_entry( core::strngs::fsnsub() ) );
//XX   BOOST_CHECK_EQUAL( wr[ 0 ].get_entry( core::strngs::fsnsub() ), std::to_string( 10 ) );
//XX}
//XX{
//XX   // Construction as if from an input file with valid parameters
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsdxf() ] = "4.0";
//XX   params[ core::strngs::fsdxw() ] = "6.0";
//XX   params[ core::strngs::fsnsub() ] = "50";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_dxf(), 4.0 );
//XX   BOOST_CHECK_EQUAL( llp->get_dxw(), 6.0 );
//XX   BOOST_CHECK_EQUAL( llp->get_nsub0(), 50 );
//XX}
//XX{
//XX   // Construction as if from an input file with valid parameters
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsdxf() ] = "4";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX   BOOST_REQUIRE( nullptr != llp );
//XX   BOOST_CHECK_EQUAL( llp->get_dxf(), 4.0 );
//XX}
//XX{
//XX   // Construction as if from an input file with invalid parameters : invalid value
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsdxf() ] = "four";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ), std::runtime_error );
//XX}
//XX{
//XX   // Construction as if from an input file with invalid parameters : invalid name
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ core::strngs::fsiwid() ] = "4.0";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ), std::runtime_error );
//XX}
//XX{
//XX   // Construction as if from an input file with invalid parameters we would
//XX   // like to be valid
//XX   platform::simulator_fixture simfix;
//XX
//XX   std::map< std::string, std::string > params;
//XX   params[ "amxfile" ] = "amx.txt";
//XX   params[ "patchfile" ] = "patch.txt";
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ), std::runtime_error );
//XX}
!!!421168.cpp!!!	legendre_test() : void
//XX// In order to test the ICC code an analytically tractable problem
//XX// is a single charge near a sphere.
//XX//
//XX// CHARGE INSIDE
//XX//
//XX//std::stringstream store;
//XX{
//XX   // default
//XX   platform::simulator_fixture simfix;
//XX   std::map< std::string, std::string > params;
//XX   const double inside_eps{ 10.0 };
//XX   const double outside_eps{ 80.0 };
//XX   const double temperature{ 300.0 };
//XX   const double ion_charge{ 1.0 };
//XX   const double dxf{ 1.6 };
//XX   const double dxw{ 1.6 };
//XX   const std::size_t nsub{ 20 };
//XX   const double sphere_radius{ 10.0 };
//XX
//XX   // Empty parameter list allowed
//XX   BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX
//XX   simfix.sim->set_solvent_permittivity( outside_eps );
//XX
//XX   particle::coordinate external_coord{ 0.0, 0.0, 0.0 };
//XX   // Add specie and particle to simulation
//XX   {
//XX      particle::specie spc;
//XX      spc.set_label( "Na" );
//XX      spc.set_valency( ion_charge );
//XX      spc.set_radius( 1.0 );
//XX      spc.set_rate( 1.0 );
//XX      spc.set_excess_potential( 0.0 );
//XX      spc.set_concentration( 0.055 );
//XX      spc.set_type( particle::specie::SOLUTE );
//XX      spc.append_position( external_coord );
//XX      spc.set_count( 1 );
//XX      simfix.sim->add_specie( spc );
//XX   }
//XX
//XX   simfix.sim->generate_simulation( std::cout );
//XX
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().size(), 1 );
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().x( 0 ), external_coord.x );
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().y( 0 ), external_coord.y );
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().z( 0 ), external_coord.z );
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().eps( 0 ), outside_eps );
//XX   const_cast< particle::ensemble& >( simfix.sim->get_ensemble() ).set_eps( 0, inside_eps );
//XX   BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().eps( 0 ), inside_eps );
//XX
//XX   std::unique_ptr< evaluator::icc_surface_grid > gridder( new evaluator::icc_surface_grid );
//XX
//XX   // Create a sphere.
//XX   gridder->set_dxf( dxf );
//XX   gridder->set_dxw( dxw );
//XX   gridder->set_nsub0( nsub );
//XX
//XX   gridder->add_arc( 0.0, 0.0, sphere_radius, 0.0, core::constants::pi()/2, inside_eps, outside_eps, 10, 10, true, std::cout );
//XX   gridder->add_arc( 0.0, 0.0, sphere_radius,  core::constants::pi()/2, core::constants::pi(), inside_eps, outside_eps, 10, 10, true, std::cout );
//XX
//XX   {
//XX      std::ofstream circle( "circle.txt" );
//XX      gridder->write_grid( circle );
//XX   }
//XX   const std::size_t gsize = gridder->size();
//XX   std::cout << " Number of tiles : " << gsize << "\n";
//XX
//XX   evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX   evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX   BOOST_REQUIRE( llp != nullptr );
//XX
//XX   // Swap test grid into evaluator.
//XX   const_cast< evaluator::induced_charge* >(llp)->create_amx( gridder, std::cout );
//XX
//XX   BOOST_REQUIRE_EQUAL( gsize, llp->size() );
//XX
//XX   const_cast< evaluator::induced_charge* >(llp)->set_alfa( temperature );
//XX   const_cast< evaluator::induced_charge* >(llp)->set_permittivity( outside_eps );
//XX
//XX   // Calculate the initial induced charge
//XX   const_cast< evaluator::induced_charge* >(llp)->compute_initial_c_h( simfix.sim->get_species(), simfix.sim->get_ensemble() );
//XX
//XX   {
//XX      std::ofstream chrg( "charge_in.txt" );
//XX      chrg << "# tiles : " << llp->size() << "\n";
//XX      chrg << "# external charge : " << ion_charge << "\n";
//XX      chrg << "# external location : " << external_coord << "\n";
//XX      for( std::size_t ii = 0; ii != llp->size(); ++ii)
//XX      {
//XX         chrg << llp->surface_charge( ii ) <<  " " << llp->surface_area( ii ) <<  " "  << llp->field( ii ) <<  "\n";
//XX      }
//XX   }
//XX
//XX   {
//XX      double area, chrg;
//XX      llp->compute_total_surface_charge( chrg, area );
//XX
//XX      std::cout << "Total surface area = " << area << "\n";
//XX      BOOST_CHECK_CLOSE_FRACTION( area, (4*core::constants::pi()*sphere_radius*sphere_radius), 0.0001 );
//XX      std::cout << "Change in eps = " << (inside_eps - outside_eps) << "\n";
//XX      std::cout << "Average eps = " << ((inside_eps + outside_eps)/2) << "\n";
//XX      std::cout << "Ratio 1 delta_e' = " << (2*(inside_eps - outside_eps)/(inside_eps + outside_eps)) << "\n";
//XX      std::cout << "Ratio 2 (e_i.e_o)/(e_i - e_o) = " << (inside_eps * outside_eps/(inside_eps - outside_eps)) << "\n";
//XX      std::cout << "Total surface charge = " << chrg << "\n";
//XX      chrg *= inside_eps * outside_eps/(inside_eps - outside_eps);
//XX      std::cout << "Estimate of original charge from surface charge = " << chrg << "\n";
//XX      BOOST_CHECK_CLOSE_FRACTION( chrg, ion_charge, 0.01 );
//XX
//XX      //llp->compute_inner_surface_charge( chrg, area );
//XX      //BOOST_CHECK_CLOSE_FRACTION( chrg, ion_charge, 0.001 );
//XX      //std::cout << "Inner surface charge = " << chrg << "\n";
//XX   }
//XX}
//XX//XX  //
//XX//XX  //  CHARGE OUTSIDE
//XX//XX  //
//XX//XX  {
//XX//XX     // default
//XX//XX     platform::simulator_fixture simfix;
//XX//XX     std::map< std::string, std::string > params;
//XX//XX     // Empty parameter list allowed
//XX//XX     BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX//XX
//XX//XX     particle::coordinate external_coord{ 0.0, 0.0, 15.0 };
//XX//XX     // Add specie and particle to simulation
//XX//XX     {
//XX//XX        particle::specie spc;
//XX//XX        spc.set_label( "Na" );
//XX//XX        spc.set_valency( 1.0 );
//XX//XX        spc.set_radius( 1.0 );
//XX//XX        spc.set_rate( 1.0 );
//XX//XX        spc.set_excess_potential( 0.0 );
//XX//XX        spc.set_concentration( 0.055 );
//XX//XX        spc.set_type( particle::specie::SOLUTE );
//XX//XX        spc.append_position( external_coord );
//XX//XX        spc.set_count( 1 );
//XX//XX        simfix.sim->add_specie( spc );
//XX//XX     }
//XX//XX
//XX//XX     simfix.sim->generate_simulation( std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().size(), 1 );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().x( 0 ), external_coord.x );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().y( 0 ), external_coord.y );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().z( 0 ), external_coord.z );
//XX//XX
//XX//XX     std::unique_ptr< evaluator::icc_surface_grid > gridder( new evaluator::icc_surface_grid );
//XX//XX
//XX//XX     // Create a sphere.
//XX//XX     const double epsw = 80.0;
//XX//XX     const double temperature = 300.0;
//XX//XX     const double epspr = 10.0;
//XX//XX     const double deps =  2 * (epspr - epsw) / (epspr + epsw );
//XX//XX     gridder->add_arc( 0.0, 0.0, 10.0, 0.0, core::constants::pi()/2, deps, 10, 10, true, std::cout );
//XX//XX     gridder->add_arc( 0.0, 0.0, 10.0,  core::constants::pi()/2, core::constants::pi(), deps, 10, 10, true, std::cout );
//XX//XX
//XX//XX     const std::size_t gsize = gridder->size();
//XX//XX
//XX//XX     evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX//XX     evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX//XX     BOOST_REQUIRE( llp != nullptr );
//XX//XX
//XX//XX     // Swap test grid into evaluator.
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->create_amx( gridder, std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( gsize, llp->size() );
//XX//XX
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_alfa( temperature );
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_permittivity( epsw );
//XX//XX
//XX//XX     // Calculate the initial induced charge
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->compute_initial_c_h( simfix.sim->get_species(), simfix.sim->get_ensemble() );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream chrg( "charge_out.txt" );
//XX//XX        chrg << "# tiles : " << llp->size() << "\n";
//XX//XX        chrg << "# external charge : +1.0\n";
//XX//XX        chrg << "# external location : " << external_coord << "\n";
//XX//XX        for( std::size_t ii = 0; ii != llp->size(); ++ii)
//XX//XX        {
//XX//XX           chrg << llp->surface_charge( ii ) <<  " " << llp->surface_area( ii ) <<  " " << llp->field( ii ) <<  "\n";
//XX//XX        }
//XX//XX     }
//XX//XX
//XX//XX     {
//XX//XX        double area, chrg;
//XX//XX        llp->compute_total_surface_charge( chrg, area );
//XX//XX        std::cout << "Total surface charge = " << chrg << "\n";
//XX//XX        std::cout << "Total surface area = " << area << "\n";
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( chrg, 0.0, 0.0001 );
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( area, 4*core::constants::pi()*100.0, 0.0001 );
//XX//XX     }
//XX//XX  }
//XX//XX  //
//XX//XX  //  CHARGE AT CENTRE
//XX//XX  //
//XX//XX  {
//XX//XX     // default
//XX//XX     platform::simulator_fixture simfix;
//XX//XX     std::map< std::string, std::string > params;
//XX//XX     // Empty parameter list allowed
//XX//XX     BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX//XX
//XX//XX     particle::coordinate external_coord{ 0.0, 0.0, 0.0 };
//XX//XX     // Add specie and particle to simulation
//XX//XX     {
//XX//XX        particle::specie spc;
//XX//XX        spc.set_label( "Na" );
//XX//XX        spc.set_valency( 1.0 );
//XX//XX        spc.set_radius( 1.0 );
//XX//XX        spc.set_rate( 1.0 );
//XX//XX        spc.set_excess_potential( 0.0 );
//XX//XX        spc.set_concentration( 0.055 );
//XX//XX        spc.set_type( particle::specie::SOLUTE );
//XX//XX        spc.append_position( external_coord );
//XX//XX        spc.set_count( 1 );
//XX//XX        simfix.sim->add_specie( spc );
//XX//XX     }
//XX//XX
//XX//XX     simfix.sim->generate_simulation( std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().size(), 1 );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().x( 0 ), external_coord.x );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().y( 0 ), external_coord.y );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().z( 0 ), external_coord.z );
//XX//XX
//XX//XX     std::unique_ptr< evaluator::icc_surface_grid > gridder( new evaluator::icc_surface_grid );
//XX//XX
//XX//XX     gridder->set_dxf( 1.0 );
//XX//XX     gridder->set_dxw( 1.0 );
//XX//XX     // Create a sphere.
//XX//XX     const double epsw = 80.0;
//XX//XX     const double temperature = 300.0;
//XX//XX     const double epspr = 10.0;
//XX//XX     const double deps =  2 * (epspr - epsw) / (epspr + epsw );
//XX//XX     gridder->add_arc( 0.0, 0.0, 10.0, 0.0, core::constants::pi()/2, deps, 10, 10, true, std::cout );
//XX//XX     gridder->add_arc( 0.0, 0.0, 10.0,  core::constants::pi()/2, core::constants::pi(), deps, 10, 10, true, std::cout );
//XX//XX
//XX//XX     const std::size_t gsize = gridder->size();
//XX//XX
//XX//XX     evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX//XX     evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX//XX     BOOST_REQUIRE( llp != nullptr );
//XX//XX
//XX//XX     // Swap test grid into evaluator.
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->create_amx( gridder, std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( gsize, llp->size() );
//XX//XX
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_alfa( temperature );
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_permittivity( epsw );
//XX//XX
//XX//XX     // Calculate the initial induced charge
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->compute_initial_c_h( simfix.sim->get_species(), simfix.sim->get_ensemble() );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream chrg( "charge_ctr.txt" );
//XX//XX        chrg << "# tiles : " << llp->size() << "\n";
//XX//XX        chrg << "# external charge : +1.0\n";
//XX//XX        chrg << "# external location : " << external_coord << "\n";
//XX//XX        for( std::size_t ii = 0; ii != llp->size(); ++ii)
//XX//XX        {
//XX//XX           chrg << llp->surface_charge( ii ) <<  " " << llp->surface_area( ii ) <<  " " << llp->field( ii ) <<  "\n";
//XX//XX        }
//XX//XX     }
//XX//XX
//XX//XX     {
//XX//XX        double area, chrg;
//XX//XX        llp->compute_total_surface_charge( chrg, area );
//XX//XX        std::cout << "Total surface charge = " << chrg << "\n";
//XX//XX        std::cout << "Total surface area = " << area << "\n";
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( chrg, 0.0, 0.0001 );
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( area, 4*core::constants::pi()*100.0, 0.0001 );
//XX//XX     }
//XX//XX  }
//XX//XX  //
//XX//XX  //  CHARGE AWAY FROM WALL
//XX//XX  //
//XX//XX  {
//XX//XX     // default
//XX//XX     platform::simulator_fixture simfix;
//XX//XX     std::map< std::string, std::string > params;
//XX//XX     // Empty parameter list allowed
//XX//XX     BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX//XX
//XX//XX     particle::coordinate external_coord{ 0.0, 0.0, 12.0 };
//XX//XX     // Add specie and particle to simulation
//XX//XX     {
//XX//XX        particle::specie spc;
//XX//XX        spc.set_label( "Na" );
//XX//XX        spc.set_valency( 1.0 );
//XX//XX        spc.set_radius( 1.0 );
//XX//XX        spc.set_rate( 1.0 );
//XX//XX        spc.set_excess_potential( 0.0 );
//XX//XX        spc.set_concentration( 0.055 );
//XX//XX        spc.set_type( particle::specie::SOLUTE );
//XX//XX        spc.append_position( external_coord );
//XX//XX        spc.set_count( 1 );
//XX//XX        simfix.sim->add_specie( spc );
//XX//XX     }
//XX//XX
//XX//XX     simfix.sim->generate_simulation( std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().size(), 1 );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().x( 0 ), external_coord.x );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().y( 0 ), external_coord.y );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().z( 0 ), external_coord.z );
//XX//XX
//XX//XX     std::unique_ptr< evaluator::icc_surface_grid > gridder( new evaluator::icc_surface_grid );
//XX//XX
//XX//XX     // Create a sphere.
//XX//XX     const double epsw = 80.0;
//XX//XX     const double temperature = 300.0;
//XX//XX     const double epspr = 10.0;
//XX//XX     const double deps =  2 * (epspr - epsw) / (epspr + epsw );
//XX//XX     gridder->add_wall( 0.0, 0.0, 30.0, deps, 10, 10, true, std::cout );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream gridos( "wall.txt" );
//XX//XX        gridder->write_grid( gridos );
//XX//XX     }
//XX//XX
//XX//XX     const std::size_t gsize = gridder->size();
//XX//XX
//XX//XX     evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX//XX     evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX//XX     BOOST_REQUIRE( llp != nullptr );
//XX//XX
//XX//XX     // Swap test grid into evaluator.
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->create_amx( gridder, std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( gsize, llp->size() );
//XX//XX
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_alfa( temperature );
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_permittivity( epsw );
//XX//XX
//XX//XX     // Calculate the initial induced charge
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->compute_initial_c_h( simfix.sim->get_species(), simfix.sim->get_ensemble() );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream chrg( "charge_wall.txt" );
//XX//XX        chrg << "# tiles : " << llp->size() << "\n";
//XX//XX        chrg << "# external charge : +1.0\n";
//XX//XX        chrg << "# external location : " << external_coord << "\n";
//XX//XX        for( std::size_t ii = 0; ii != llp->size(); ++ii)
//XX//XX        {
//XX//XX           chrg << llp->surface_charge( ii ) <<  " " << llp->surface_area( ii ) <<  " " << llp->field( ii ) <<  "\n";
//XX//XX        }
//XX//XX     }
//XX//XX
//XX//XX     {
//XX//XX        double area, chrg;
//XX//XX        llp->compute_total_surface_charge( chrg, area );
//XX//XX        std::cout << "Total surface charge = " << chrg << "\n";
//XX//XX        std::cout << "Total surface area = " << area << "\n";
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( chrg, 0.0, 0.0001 );
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( area, core::constants::pi()*900.0, 0.0001 );
//XX//XX     }
//XX//XX  }
//XX//XX  //
//XX//XX  //  CHARGE AT CENTRE OF CYLINDER
//XX//XX  //
//XX//XX  {
//XX//XX     // default
//XX//XX     platform::simulator_fixture simfix;
//XX//XX     std::map< std::string, std::string > params;
//XX//XX     // Empty parameter list allowed
//XX//XX     BOOST_REQUIRE_NO_THROW( evaluator::induced_charge::make_evaluator( params, *simfix.sim ) );
//XX//XX
//XX//XX     particle::coordinate external_coord{ 0.0, 0.0, 0.0 };
//XX//XX     // Add specie and particle to simulation
//XX//XX     {
//XX//XX        particle::specie spc;
//XX//XX        spc.set_label( "Na" );
//XX//XX        spc.set_valency( 1.0 );
//XX//XX        spc.set_radius( 1.0 );
//XX//XX        spc.set_rate( 1.0 );
//XX//XX        spc.set_excess_potential( 0.0 );
//XX//XX        spc.set_concentration( 0.055 );
//XX//XX        spc.set_type( particle::specie::SOLUTE );
//XX//XX        spc.append_position( external_coord );
//XX//XX        spc.set_count( 1 );
//XX//XX        simfix.sim->add_specie( spc );
//XX//XX     }
//XX//XX
//XX//XX     simfix.sim->generate_simulation( std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().size(), 1 );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().x( 0 ), external_coord.x );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().y( 0 ), external_coord.y );
//XX//XX     BOOST_REQUIRE_EQUAL( simfix.sim->get_ensemble().z( 0 ), external_coord.z );
//XX//XX
//XX//XX     std::unique_ptr< evaluator::icc_surface_grid > gridder( new evaluator::icc_surface_grid );
//XX//XX
//XX//XX     // Create a sphere.
//XX//XX     const double epsw = 80.0;
//XX//XX     const double temperature = 300.0;
//XX//XX     const double epspr = 10.0;
//XX//XX     const double deps =  2 * (epspr - epsw) / (epspr + epsw );
//XX//XX     gridder->add_line( -20.0, 20.0, 10.0, deps, 10, 10, true, std::cout );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream gridos( "cylinder.txt" );
//XX//XX        gridder->write_grid( gridos );
//XX//XX     }
//XX//XX
//XX//XX     const std::size_t gsize = gridder->size();
//XX//XX
//XX//XX     evaluator::base_evaluator const* bep( &(*simfix.sim->get_evaluators().begin()) );
//XX//XX     evaluator::induced_charge const* llp = dynamic_cast< evaluator::induced_charge const* >( bep );
//XX//XX     BOOST_REQUIRE( llp != nullptr );
//XX//XX
//XX//XX     // Swap test grid into evaluator.
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->create_amx( gridder, std::cout );
//XX//XX
//XX//XX     BOOST_REQUIRE_EQUAL( gsize, llp->size() );
//XX//XX
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_alfa( temperature );
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->set_permittivity( epsw );
//XX//XX
//XX//XX     // Calculate the initial induced charge
//XX//XX     const_cast< evaluator::induced_charge* >(llp)->compute_initial_c_h( simfix.sim->get_species(), simfix.sim->get_ensemble() );
//XX//XX
//XX//XX     {
//XX//XX        std::ofstream chrg( "charge_cyl.txt" );
//XX//XX        chrg << "# tiles : " << llp->size() << "\n";
//XX//XX        chrg << "# external charge : +1.0\n";
//XX//XX        chrg << "# external location : " << external_coord << "\n";
//XX//XX        for( std::size_t ii = 0; ii != llp->size(); ++ii)
//XX//XX        {
//XX//XX           chrg << llp->surface_charge( ii ) <<  " " << llp->surface_area( ii ) <<  " " << llp->field( ii ) <<  "\n";
//XX//XX        }
//XX//XX     }
//XX//XX
//XX//XX     {
//XX//XX        double area, chrg;
//XX//XX        llp->compute_total_surface_charge( chrg, area );
//XX//XX        std::cout << "Total surface charge = " << chrg << "\n";
//XX//XX        std::cout << "Total surface area = " << area << "\n";
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( chrg, 0.0, 0.0001 );
//XX//XX        BOOST_CHECK_CLOSE_FRACTION( area, 2*core::constants::pi()*40.0*10, 0.0001 );
//XX//XX     }
//XX//XX  }
