class observable_test_suite
!!!1505584.cpp!!!	mockup_particle_manager() : particle_manager
boost::shared_ptr< particle::particle_manager > pman( new particle::particle_manager );
{
  particle::specie spc1;
  spc1.set_label( "CA" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.11 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::MOBILE );
  spc1.append_position( particle::coordinate( 2.0, 2.0, 0.0 ), particle::centroid( 3.0, 2.0, 2.0, 0.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "CO" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::FLEXIBLE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 2.0 ), particle::centroid( 3.0, 0.0, 0.0, 2.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "OX" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::CHANNEL_ONLY );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 2.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 0.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 2.0, 0.0 ) );
  pman->add_specie( spc1 );
}
pman->add_predefined_particles();
return pman;
!!!1505456.cpp!!!	mockup_geometry_manager() : geometry_manager
boost::shared_ptr< geometry::base_region > regn( new geometry::periodic_cube_region( "cell", 5.0 ) );
boost::shared_ptr< geometry::geometry_manager > gman( new geometry::geometry_manager( regn ) );
{
  boost::shared_ptr< geometry::base_region > bulk( new geometry::cube_region( "bulk", 4.0, particle::coordinate( 0.0, 0.0, 0.0 ), true ) );
  gman->add_region( bulk );
}
return gman;
!!!1484848.cpp!!!	base_observable_method_test(inout obs : base_observable, in label : string) : void
std::stringstream store;
std::string description;
std::string document;
{
  BOOST_CHECK_EQUAL( label, obs->get_label() );
  {
    std::stringstream desc;
    obs->description( desc );
    description = desc.str();
  }
  {
    std::stringstream doc;
    core::input_document idoc( 1ul );
    obs->write_document( idoc );
    idoc.write( doc );
    document = doc.str();
    BOOST_CHECK_LT( document.find( label ), document.size() );
  }
  boost::archive::text_oarchive oa( store );
  oa << obs;
}
{
  boost::shared_ptr< observable::base_observable > copy;
  boost::archive::text_iarchive ia( store );
  ia >> copy;
  BOOST_CHECK_EQUAL( label, copy->get_label() );
  {
    std::stringstream desc;
    copy->description( desc );
  }
  {
    std::stringstream doc;
    core::input_document idoc( 1ul );
    copy->write_document( idoc );
    idoc.write( doc );
    BOOST_CHECK_EQUAL( document, doc.str() );
  }
}

!!!1348016.cpp!!!	sampler_definition_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::sampler_definition >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::sampler_definition >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::sampler_definition >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::sampler_definition, observable::sampler_definition >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::sampler_definition >::type{} );
}
{
  // default ctor
  observable::sampler_definition tmp( "acceptance", []( std::map< std::string, std::string >const& a )->boost::shared_ptr< observable::sampled_observable >{
    return boost::shared_ptr< observable::sampled_observable >{};
  } );

  BOOST_CHECK( tmp.empty() );
  BOOST_CHECK_EQUAL( tmp.size(), 0ul );
  BOOST_CHECK_EQUAL( tmp.label(), "acceptance" );
}
!!!1348144.cpp!!!	tracked_definition_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::tracked_definition >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::tracked_definition >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::tracked_definition >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::tracked_definition, observable::tracked_definition >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::tracked_definition >::type{} );
}
{
  // default ctor
  observable::tracked_definition tmp( "acceptance", []( std::map< std::string, std::string >const& a )->boost::shared_ptr< observable::tracked_observable >{
    return boost::shared_ptr< observable::tracked_observable >{};
  } );

  BOOST_CHECK( tmp.empty() );
  BOOST_CHECK_EQUAL( tmp.size(), 0ul );
  BOOST_CHECK_EQUAL( tmp.label(), "acceptance" );
}
!!!1348272.cpp!!!	sampler_meta_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::sampler_meta >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::sampler_meta >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::sampler_meta >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::sampler_meta, observable::sampler_meta >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::sampler_meta >::type{} );
}
{
  // default ctor
  boost::shared_ptr< observable::report_manager > oman( new observable::report_manager );
  observable::sampler_meta tmp( oman );

  //BOOST_CHECK( tmp.empty() );
  //BOOST_CHECK_EQUAL( tmp.size(), 0ul );
}
!!!1348400.cpp!!!	report_manager_lifetime_test() : void
//XX{
//XX  // Static Lifetime method tests: virtual pattern
//XX
//XX  BOOST_CHECK( not std::is_default_constructible< observable::report_manager >::type{} );
//XX  BOOST_CHECK( not std::is_copy_constructible< observable::report_manager >::type{} );
//XX  BOOST_CHECK( not std::is_move_constructible< observable::report_manager >::type{} );
//XX  BOOST_CHECK( ( not std::is_assignable< observable::report_manager, observable::report_manager >::type{} ) );
//XX  BOOST_CHECK( not std::has_virtual_destructor< observable::report_manager >::type{} );
//XX}
//XX{
//XX  // default ctor
//XX  observable::report_manager tmp;
//XX
//XX  BOOST_CHECK( tmp.empty() );
//XX  BOOST_CHECK_EQUAL( tmp.size(), 0ul );
//XX}
!!!1525808.cpp!!!	acceptance_observable_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::acceptance_observable >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::acceptance_observable >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::acceptance_observable >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::acceptance_observable, observable::acceptance_observable >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::acceptance_observable >::type{} );
}
{
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::tracked_observable > var( observable::acceptance_observable::make_sampler( params ) );

  observable_test_suite::base_observable_method_test( var, "trial-rate" );
}
!!!1525680.cpp!!!	acceptance_observable_method_test() : void
{
  boost::shared_ptr< particle::particle_manager > pman = observable_test_suite::mockup_particle_manager();
  boost::shared_ptr< geometry::geometry_manager > gman = observable_test_suite::mockup_geometry_manager();
  utility::memory_sink sink;
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::tracked_observable > var( observable::acceptance_observable::make_sampler( params ) );

  observable::acceptance_observable *pvar = dynamic_cast< observable::acceptance_observable* >( var.get() );

  BOOST_REQUIRE( pvar != nullptr );

  std::vector< particle::change_hash > dummy_trials;
  dummy_trials.push_back( { 0, 1, 1, 0 } ); // A 1 0
  dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 0 1
  dummy_trials.push_back( { 0, 1, 1, 1 } ); // C 1 0
  dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 0 0
  dummy_trials.push_back( { 0, 1, 1, 1 } ); // C 1 1
  dummy_trials.push_back( { 0, 1, 1, 0 } ); // A 0 0
  dummy_trials.push_back( { 0, 1, 1, 0 } ); // A 1 0
  dummy_trials.push_back( { 0, 1, 1, 1 } ); // C 0 1
  dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 1 0
  dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 0 0
  // Out first set of dummy trials
  {
    typedef boost::tuples::tuple< particle::change_hash, std::size_t, std::size_t, double, double > result_t;
    std::vector< result_t > dummy_results;
    dummy_results.push_back( result_t( { 0, 1, 1, 0 }, 2, 3, 0.66666666666667, 0.3 ) );
    dummy_results.push_back( result_t( { 1, 1, 1, 0 }, 1, 4, 0.25, 0.4 ) );
    dummy_results.push_back( result_t( { 0, 1, 1, 1 }, 2, 3, 0.66666666666667, 0.3 ) );

    std::size_t counter = 0;
    for( auto id : dummy_trials )
    {
      particle::change_set tmp;
      tmp.id( id );
      if( ( counter % 2 ) == 0 )
      {
        tmp.set_accept( true );
      }
      var->on_trial_end( tmp );
      ++counter;
    }
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_sample( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).first, boost::tuples::get< 1 >( res ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).second, boost::tuples::get< 2 >( res ) );
    }
    var->on_sample( *pman, *gman );
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_datum( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.mean(), boost::tuples::get< 3 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.count(), 1ul );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.mean(), boost::tuples::get< 4 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.count(), 1ul );
    }
  }
  {
    std::stringstream out;
    var->on_report( out, sink );
    // std::cout << out.str() << "\n";
    BOOST_REQUIRE( sink.exists( "acceptance.dat" ) );
    // std::string buf;
    // sink.read( "acceptance.dat", buf );
    // std::cout << buf << "\n";
  }
  // Second set of dummy trials
  {
    typedef boost::tuples::tuple< particle::change_hash, std::size_t, std::size_t, double, double, double, double > result_t;
    std::vector< result_t > dummy_results;
    dummy_results.push_back( result_t( { 0, 1, 1, 0 }, 0, 3, 0.33333333333333, 0.2222222222222, 0.3, 0.0 ) );
    dummy_results.push_back( result_t( { 1, 1, 1, 0 }, 1, 4, 0.25, 0.0, 0.4, 0.0 ) );
    dummy_results.push_back( result_t( { 0, 1, 1, 1 }, 2, 3, 0.66666666666667, 0.0, 0.3, 0.0 ) );

    std::size_t counter = 0;
    for( auto id : dummy_trials )
    {
      particle::change_set tmp;
      tmp.id( id );
      if( ( counter % 3 ) == 1 )
      {
        tmp.set_accept( true );
      }
      var->on_trial_end( tmp );
      ++counter;
    }
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_sample( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).first, boost::tuples::get< 1 >( res ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).second, boost::tuples::get< 2 >( res ) );
    }
    var->on_sample( *pman, *gman );
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_datum( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.mean(), boost::tuples::get< 3 >( res ), 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.variance(), boost::tuples::get< 4 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.count(), 2ul );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.mean(), boost::tuples::get< 5 >( res ), 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.variance(), boost::tuples::get< 6 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.count(), 2ul );
    }
  }
  {
    std::stringstream out;
    var->on_report( out, sink );
    // std::cout << out.str() << "\n";
    BOOST_REQUIRE( sink.exists( "acceptance.dat" ) );
    // std::string buf;
    // sink.read( "acceptance.dat", buf );
    // std::cout << buf << "\n";
  }
  // Third set of dummy trials with new id keys
  //0 dummy_trials.push_back( { 0, 1, 1, 0 } ); // A 1
  dummy_trials[ 1 ] = { 1, 1, 1, 1 };           // D 0
  //2 dummy_trials.push_back( { 0, 1, 1, 1 } ); // C 1
  //3 dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 0
  //4 dummy_trials.push_back( { 0, 1, 1, 1 } ); // C 1
  dummy_trials[ 5 ] = { 1, 1, 1, 1 };           // D 0
  //6 dummy_trials.push_back( { 0, 1, 1, 0 } ); // A 1
  dummy_trials[ 7 ] = { 1, 1, 1, 1 };            // D 0
  //8 dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 1
  //9 dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 0
  // Out first set of dummy trials
  {
    typedef boost::tuples::tuple< particle::change_hash, std::size_t, std::size_t, double, double, double, double > result_t;
    std::vector< result_t > dummy_results;
    dummy_results.push_back( result_t( { 0, 1, 1, 0 }, 2, 2, 0.55555555555555558, 0.2592592592592593, 8.0/30.0, 0.00333333333333333 ) );
    dummy_results.push_back( result_t( { 1, 1, 1, 0 }, 1, 3, 0.27777777777777778, 0.002314814814814815, 11.0/30.0, 0.00333333333333333 ) );
    dummy_results.push_back( result_t( { 0, 1, 1, 1 }, 2, 2, 0.77777777777777779, 0.03703703703703704, 8.0/30.0, 0.00333333333333333 ) );
    dummy_results.push_back( result_t( { 1, 1, 1, 1 }, 0, 3, 0.0, 0.0, 0.1, 0.03 ) );

    std::size_t counter = 0;
    for( auto id : dummy_trials )
    {
      particle::change_set tmp;
      tmp.id( id );
      if( ( counter % 2 ) == 0 )
      {
        tmp.set_accept( true );
      }
      var->on_trial_end( tmp );
      ++counter;
    }
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_sample( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).first, boost::tuples::get< 1 >( res ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).second, boost::tuples::get< 2 >( res ) );
    }
    var->on_sample( *pman, *gman );
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_datum( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.mean(), boost::tuples::get< 3 >( res ), 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.variance(), boost::tuples::get< 4 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.count(), 3ul );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.mean(), boost::tuples::get< 5 >( res ), 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.variance(), boost::tuples::get< 6 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.count(), 3ul );
    }
  }
  {
    std::stringstream out;
    std::string canon_log = "          Trial  Accept.av Accept.var   Trial.av  Trial.var\n   (0, 1, 1, 0) 0.55555556 0.25925926 0.26666667 0.00333333\n   (0, 1, 1, 1) 0.77777778 0.03703704 0.26666667 0.00333333\n   (1, 1, 1, 0) 0.27777778 0.00231481 0.36666667 0.00333333\n   (1, 1, 1, 1) 0.00000000 0.00000000 0.10000000 0.03000000";
    std::string canon_rep = "# UUID:  \n# TITLE: \"Trial acceptance and rate data.\" \n# FIELDS: TRIAL ACCEPT.MEAN ACCEPT.VAR ATTEMPT.MEAN ATTEMPT.VARIANCE \n# UNITS: CHANGE_HASH RATE RATE RATE RATE \n(0, 1, 1, 0) 0.555556 0.259259 0.266667 0.00333333 \n(0, 1, 1, 1) 0.777778 0.037037 0.266667 0.00333333 \n(1, 1, 1, 0) 0.277778 0.00231481 0.366667 0.00333333 \n(1, 1, 1, 1) 0 0 0.1 0.03 ";
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    BOOST_CHECK_LT( out.str().find( canon_log ), out.str().size() );
    BOOST_REQUIRE( sink.exists( "acceptance.dat" ) );
    std::string buf;
    sink.read( "acceptance.dat", buf );
    BOOST_CHECK_LT( buf.find( canon_rep ), buf.size() );
    // std::cout << buf << "\n";
  }
}


!!!1498928.cpp!!!	specie_count_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::specie_count >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::specie_count >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::specie_count >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::specie_count, observable::specie_count >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::specie_count >::type{} );
}
{
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::base_observable > var( observable::specie_count::make_sampler( params ) );

  observable_test_suite::base_observable_method_test( var, "specie-count" );
}
!!!1498800.cpp!!!	specie_count_method_test() : void
{
  boost::shared_ptr< particle::particle_manager > pman = observable_test_suite::mockup_particle_manager();
  boost::shared_ptr< geometry::geometry_manager > gman = observable_test_suite::mockup_geometry_manager();
  boost::shared_ptr< observable::report_manager > rman( new observable::report_manager );
  utility::memory_sink sink;
  std::vector< double > means( pman->specie_count() );
  for( std::size_t ispec = 0; ispec != pman->specie_count(); ++ispec )
  {
    means[ ispec ] = double( pman->get_ensemble().specie_count( ispec ) );
  }
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::base_observable > var( observable::specie_count::make_sampler( params ) );

  observable::specie_count *pvar = dynamic_cast< observable::specie_count* >( var.get() );

  BOOST_REQUIRE( pvar != nullptr );
  
  var->prepare( *pman, *gman, *rman );

  // first sample and report
  {
    var->on_sample( *pman, *gman );
    BOOST_REQUIRE_LE( pvar->size(), pman->specie_count() );
    for( std::size_t idx = 0; idx != pvar->size(); ++idx )
    {
      const std::size_t ispec = pvar->specie_key( idx );
      BOOST_CHECK_CLOSE( pvar->mean( idx ), means[ ispec ], 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->variance( idx ), 0.0, 0.00000001 );
    }
  }
  {
    BOOST_REQUIRE( not sink.exists( "specie-count.dat" ) );
    std::stringstream out;
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    BOOST_REQUIRE( sink.exists( "specie-count.dat" ) );
    //std::string buf;
    //sink.read( "specie-count.dat", buf );
    //std::cout << buf << "\n";
  }
  // second sample and report
  {
    var->on_sample( *pman, *gman );
    for( std::size_t idx = 0; idx != pvar->size(); ++idx )
    {
      const std::size_t ispec = pvar->specie_key( idx );
      BOOST_CHECK_CLOSE( pvar->mean( idx ), means[ ispec ], 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->variance( idx ), 0.0, 0.00000001 );
    }
  }
  {
    std::stringstream out;
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    //std::string buf;
    //sink.read( "specie-count.dat", buf );
    //std::cout << buf << "\n";
  }
  // need to add/convert a particle
  {
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 2 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 1 );
    // convert a 3 to a 4
    const std::size_t idx = pman->get_ensemble().nth_specie_index( 3, 0 );
    particle::change_set exc;
    particle::change_atom a1, a2;
    a1.key = 3;
    a2.key = 4;
    a1.index = idx;
    a2.index = pman->get_ensemble().size();
    a1.old_position = pman->get_ensemble().position( idx );
    a1.do_old = true;
    a1.do_new = false;
    a2.new_position = pman->get_ensemble().position( idx );
    a2.do_new = true;
    a2.do_old = false;
    exc.add_atom( a1 );
    exc.add_atom( a2 );
    pman->commit( exc );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 1 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 2 );

    var->on_sample( *pman, *gman );

    means[ 3 ] = 1.6666666666666667;
    means[ 4 ] = 1.3333333333333333;
    for( std::size_t idx = 0; idx != pvar->size(); ++idx )
    {
      const std::size_t ispec = pvar->specie_key( idx );
      BOOST_CHECK_CLOSE( pvar->mean( idx ), means[ ispec ], 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->variance( idx ), 0.3333333333333333, 0.00000001 );
    }
  }
  {
    std::stringstream out;
    std::string canon_log = " SPC    <COUNT>        VAR       <[]>\n   3    1.66667     0.3333  0.1254612\n   4    1.33333     0.3333  0.1003690";
    std::string canon_rep = "# UUID:  \n# TITLE: \"Time series specie counts\" \n# FIELDS: INDEX SPC[3]_MEAN SPC[3]_VAR SPC[4]_MEAN SPC[4]_VAR \n# UNITS: ORDINAL COUNT COUNT COUNT COUNT \n1 2 0 1 0 \n2 2 0 1 0 \n3 1.66667 0.333333 1.33333 0.333333 ";
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    BOOST_CHECK_LT( out.str().find( canon_log ), out.str().size() );
    std::string buf;
    sink.read( "specie-count.dat", buf );
    BOOST_CHECK_LT( buf.find( canon_rep ), buf.size() );
    //std::cout << buf << "\n";
  }
}
