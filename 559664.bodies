class observable_test_suite
!!!1505584.cpp!!!	mockup_particle_manager() : particle_manager
boost::shared_ptr< particle::particle_manager > pman( new particle::particle_manager );
{
  particle::specie spc1;
  spc1.set_label( "CA" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.11 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::MOBILE );
  spc1.append_position( particle::coordinate( 2.0, 2.0, 0.0 ), particle::centroid( 3.0, 2.0, 2.0, 0.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "CO" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::FLEXIBLE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 2.0 ), particle::centroid( 3.0, 0.0, 0.0, 2.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "OX" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::CHANNEL_ONLY );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 2.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Na" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.12 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( 1.0 );
  spc1.set_excess_potential( 0.123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
  spc1.append_position( particle::coordinate( 2.0, 0.0, 0.0 ) );
  pman->add_specie( spc1 );
}
{
  particle::specie spc1;
  spc1.set_label( "Cl" );
  spc1.set_concentration( 1.0 );
  spc1.set_radius( 0.2 );
  spc1.set_rate( 0.2 );
  spc1.set_valency( -1.0 );
  spc1.set_excess_potential( 0.3123 );
  spc1.set_type( particle::specie::SOLUTE );
  spc1.append_position( particle::coordinate( 0.0, 2.0, 0.0 ) );
  pman->add_specie( spc1 );
}
pman->add_predefined_particles();
return pman;
!!!1505456.cpp!!!	mockup_geometry_manager() : geometry_manager
boost::shared_ptr< geometry::base_region > regn( new geometry::periodic_cube_region( "cell", 5.0 ) );
boost::shared_ptr< geometry::geometry_manager > gman( new geometry::geometry_manager( regn ) );
{
  boost::shared_ptr< geometry::base_region > bulk( new geometry::cube_region( "bulk", 4.0, particle::coordinate( 0.0, 0.0, 0.0 ), true ) );
  gman->add_region( bulk );
}
return gman;
!!!1622192.cpp!!!	mockup_evaluator_manager() : evaluator_manager
boost::shared_ptr< evaluator::evaluator_manager > eman( new evaluator::evaluator_manager );
std::map< std::string, std::string > param;
eman->add_evaluator( evaluator::coulomb::make_evaluator( param ) );
return eman;
!!!1484848.cpp!!!	base_observable_method_test(inout obs : base_observable, in label : string) : void
std::stringstream store;
std::string description;
std::string document;
{
  BOOST_CHECK_EQUAL( label, obs->get_label() );
  {
    std::stringstream desc;
    obs->description( desc );
    description = desc.str();
  }
  {
    std::stringstream doc;
    core::input_document idoc( 1ul );
    obs->write_document( idoc );
    idoc.write( doc );
    document = doc.str();
    BOOST_CHECK_LT( document.find( label ), document.size() );
  }
  boost::archive::text_oarchive oa( store );
  oa << obs;
}
{
  boost::shared_ptr< observable::base_observable > copy;
  boost::archive::text_iarchive ia( store );
  ia >> copy;
  BOOST_CHECK_EQUAL( label, copy->get_label() );
  {
    std::stringstream desc;
    copy->description( desc );
  }
  {
    std::stringstream doc;
    core::input_document idoc( 1ul );
    copy->write_document( idoc );
    idoc.write( doc );
    BOOST_CHECK_EQUAL( document, doc.str() );
  }
}

!!!1348016.cpp!!!	sampler_definition_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::sampler_definition >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::sampler_definition >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::sampler_definition >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::sampler_definition, observable::sampler_definition >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::sampler_definition >::type{} );
}
{
  // default ctor
  observable::sampler_definition tmp( "acceptance", []( std::map< std::string, std::string >const& a )->boost::shared_ptr< observable::sampled_observable >{
    return boost::shared_ptr< observable::sampled_observable >{};
  } );

  BOOST_CHECK( tmp.empty() );
  BOOST_CHECK_EQUAL( tmp.size(), 0ul );
  BOOST_CHECK_EQUAL( tmp.label(), "acceptance" );
}
!!!1348144.cpp!!!	tracked_definition_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::tracked_definition >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::tracked_definition >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::tracked_definition >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::tracked_definition, observable::tracked_definition >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::tracked_definition >::type{} );
}
{
  // default ctor
  observable::tracked_definition tmp( "acceptance", []( std::map< std::string, std::string >const& a )->boost::shared_ptr< observable::tracked_observable >{
    return boost::shared_ptr< observable::tracked_observable >{};
  } );

  BOOST_CHECK( tmp.empty() );
  BOOST_CHECK_EQUAL( tmp.size(), 0ul );
  BOOST_CHECK_EQUAL( tmp.label(), "acceptance" );
}
!!!1348272.cpp!!!	sampler_meta_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::sampler_meta >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::sampler_meta >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::sampler_meta >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::sampler_meta, observable::sampler_meta >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::sampler_meta >::type{} );
}
{
  // default ctor
  boost::shared_ptr< observable::report_manager > oman( new observable::report_manager );
  observable::sampler_meta tmp( oman );

  //BOOST_CHECK( tmp.empty() );
  //BOOST_CHECK_EQUAL( tmp.size(), 0ul );
}
!!!1348400.cpp!!!	report_manager_lifetime_test() : void
//XX{
//XX  // Static Lifetime method tests: virtual pattern
//XX
//XX  BOOST_CHECK( not std::is_default_constructible< observable::report_manager >::type{} );
//XX  BOOST_CHECK( not std::is_copy_constructible< observable::report_manager >::type{} );
//XX  BOOST_CHECK( not std::is_move_constructible< observable::report_manager >::type{} );
//XX  BOOST_CHECK( ( not std::is_assignable< observable::report_manager, observable::report_manager >::type{} ) );
//XX  BOOST_CHECK( not std::has_virtual_destructor< observable::report_manager >::type{} );
//XX}
//XX{
//XX  // default ctor
//XX  observable::report_manager tmp;
//XX
//XX  BOOST_CHECK( tmp.empty() );
//XX  BOOST_CHECK_EQUAL( tmp.size(), 0ul );
//XX}
!!!1525808.cpp!!!	acceptance_observable_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::acceptance_observable >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::acceptance_observable >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::acceptance_observable >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::acceptance_observable, observable::acceptance_observable >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::acceptance_observable >::type{} );
}
{
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::tracked_observable > var( observable::acceptance_observable::make_sampler( params ) );

  observable_test_suite::base_observable_method_test( var, "trial-rate" );
}
!!!1525680.cpp!!!	acceptance_observable_method_test() : void
{
  boost::shared_ptr< particle::particle_manager > pman = observable_test_suite::mockup_particle_manager();
  boost::shared_ptr< evaluator::evaluator_manager > eman = observable_test_suite::mockup_evaluator_manager();
  boost::shared_ptr< geometry::geometry_manager > gman = observable_test_suite::mockup_geometry_manager();
  utility::memory_sink sink;
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::tracked_observable > var( observable::acceptance_observable::make_sampler( params ) );

  observable::acceptance_observable *pvar = dynamic_cast< observable::acceptance_observable* >( var.get() );

  BOOST_REQUIRE( pvar != nullptr );

  std::vector< particle::change_hash > dummy_trials;
  dummy_trials.push_back( { 0, 1, 1, 0 } ); // A 1 0
  dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 0 1
  dummy_trials.push_back( { 0, 1, 1, 1 } ); // C 1 0
  dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 0 0
  dummy_trials.push_back( { 0, 1, 1, 1 } ); // C 1 1
  dummy_trials.push_back( { 0, 1, 1, 0 } ); // A 0 0
  dummy_trials.push_back( { 0, 1, 1, 0 } ); // A 1 0
  dummy_trials.push_back( { 0, 1, 1, 1 } ); // C 0 1
  dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 1 0
  dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 0 0
  // Out first set of dummy trials
  {
    typedef boost::tuples::tuple< particle::change_hash, std::size_t, std::size_t, double, double > result_t;
    std::vector< result_t > dummy_results;
    dummy_results.push_back( result_t( { 0, 1, 1, 0 }, 2, 3, 0.66666666666667, 0.3 ) );
    dummy_results.push_back( result_t( { 1, 1, 1, 0 }, 1, 4, 0.25, 0.4 ) );
    dummy_results.push_back( result_t( { 0, 1, 1, 1 }, 2, 3, 0.66666666666667, 0.3 ) );

    std::size_t counter = 0;
    for( auto id : dummy_trials )
    {
      particle::change_set tmp;
      tmp.id( id );
      if( ( counter % 2 ) == 0 )
      {
        tmp.set_accept( true );
      }
      var->on_trial_end( tmp );
      ++counter;
    }
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_sample( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).first, boost::tuples::get< 1 >( res ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).second, boost::tuples::get< 2 >( res ) );
    }
    var->on_sample( *pman, *gman, *eman );
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_datum( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.mean(), boost::tuples::get< 3 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.count(), 1ul );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.mean(), boost::tuples::get< 4 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.count(), 1ul );
    }
  }
  {
    std::stringstream out;
    var->on_report( out, sink );
    // std::cout << out.str() << "\n";
    BOOST_REQUIRE( sink.exists( "acceptance.dat" ) );
    // std::string buf;
    // sink.read( "acceptance.dat", buf );
    // std::cout << buf << "\n";
  }
  // Second set of dummy trials
  {
    typedef boost::tuples::tuple< particle::change_hash, std::size_t, std::size_t, double, double, double, double > result_t;
    std::vector< result_t > dummy_results;
    dummy_results.push_back( result_t( { 0, 1, 1, 0 }, 0, 3, 0.33333333333333, 0.2222222222222, 0.3, 0.0 ) );
    dummy_results.push_back( result_t( { 1, 1, 1, 0 }, 1, 4, 0.25, 0.0, 0.4, 0.0 ) );
    dummy_results.push_back( result_t( { 0, 1, 1, 1 }, 2, 3, 0.66666666666667, 0.0, 0.3, 0.0 ) );

    std::size_t counter = 0;
    for( auto id : dummy_trials )
    {
      particle::change_set tmp;
      tmp.id( id );
      if( ( counter % 3 ) == 1 )
      {
        tmp.set_accept( true );
      }
      var->on_trial_end( tmp );
      ++counter;
    }
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_sample( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).first, boost::tuples::get< 1 >( res ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).second, boost::tuples::get< 2 >( res ) );
    }
    var->on_sample( *pman, *gman, *eman );
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_datum( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.mean(), boost::tuples::get< 3 >( res ), 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.variance(), boost::tuples::get< 4 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.count(), 2ul );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.mean(), boost::tuples::get< 5 >( res ), 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.variance(), boost::tuples::get< 6 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.count(), 2ul );
    }
  }
  {
    std::stringstream out;
    var->on_report( out, sink );
    // std::cout << out.str() << "\n";
    BOOST_REQUIRE( sink.exists( "acceptance.dat" ) );
    // std::string buf;
    // sink.read( "acceptance.dat", buf );
    // std::cout << buf << "\n";
  }
  // Third set of dummy trials with new id keys
  //0 dummy_trials.push_back( { 0, 1, 1, 0 } ); // A 1
  dummy_trials[ 1 ] = { 1, 1, 1, 1 };           // D 0
  //2 dummy_trials.push_back( { 0, 1, 1, 1 } ); // C 1
  //3 dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 0
  //4 dummy_trials.push_back( { 0, 1, 1, 1 } ); // C 1
  dummy_trials[ 5 ] = { 1, 1, 1, 1 };           // D 0
  //6 dummy_trials.push_back( { 0, 1, 1, 0 } ); // A 1
  dummy_trials[ 7 ] = { 1, 1, 1, 1 };            // D 0
  //8 dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 1
  //9 dummy_trials.push_back( { 1, 1, 1, 0 } ); // B 0
  // Out first set of dummy trials
  {
    typedef boost::tuples::tuple< particle::change_hash, std::size_t, std::size_t, double, double, double, double > result_t;
    std::vector< result_t > dummy_results;
    dummy_results.push_back( result_t( { 0, 1, 1, 0 }, 2, 2, 0.55555555555555558, 0.2592592592592593, 8.0/30.0, 0.00333333333333333 ) );
    dummy_results.push_back( result_t( { 1, 1, 1, 0 }, 1, 3, 0.27777777777777778, 0.002314814814814815, 11.0/30.0, 0.00333333333333333 ) );
    dummy_results.push_back( result_t( { 0, 1, 1, 1 }, 2, 2, 0.77777777777777779, 0.03703703703703704, 8.0/30.0, 0.00333333333333333 ) );
    dummy_results.push_back( result_t( { 1, 1, 1, 1 }, 0, 3, 0.0, 0.0, 0.1, 0.03 ) );

    std::size_t counter = 0;
    for( auto id : dummy_trials )
    {
      particle::change_set tmp;
      tmp.id( id );
      if( ( counter % 2 ) == 0 )
      {
        tmp.set_accept( true );
      }
      var->on_trial_end( tmp );
      ++counter;
    }
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_sample( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).first, boost::tuples::get< 1 >( res ) );
      BOOST_CHECK_EQUAL( pvar->get_sample( boost::tuples::get< 0 >( res ) ).second, boost::tuples::get< 2 >( res ) );
    }
    var->on_sample( *pman, *gman, *eman );
    for( auto const& res : dummy_results )
    {
      BOOST_REQUIRE( pvar->has_datum( boost::tuples::get< 0 >( res ) ) );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.mean(), boost::tuples::get< 3 >( res ), 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.variance(), boost::tuples::get< 4 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).first.count(), 3ul );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.mean(), boost::tuples::get< 5 >( res ), 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.variance(), boost::tuples::get< 6 >( res ), 0.00000001 );
      BOOST_CHECK_EQUAL( pvar->get_datum( boost::tuples::get< 0 >( res ) ).second.count(), 3ul );
    }
  }
  {
    std::stringstream out;
    std::string canon_log = "          Trial  Accept.av Accept.var   Trial.av  Trial.var\n   (0, 1, 1, 0) 0.55555556 0.25925926 0.26666667 0.00333333\n   (0, 1, 1, 1) 0.77777778 0.03703704 0.26666667 0.00333333\n   (1, 1, 1, 0) 0.27777778 0.00231481 0.36666667 0.00333333\n   (1, 1, 1, 1) 0.00000000 0.00000000 0.10000000 0.03000000";
    std::string canon_rep = "# UUID:  \n# TITLE: \"Trial acceptance and rate data.\" \n# FIELDS: TRIAL ACCEPT.MEAN ACCEPT.VAR ATTEMPT.MEAN ATTEMPT.VARIANCE \n# UNITS: CHANGE_HASH RATE RATE RATE RATE \n(0, 1, 1, 0) 0.555556 0.259259 0.266667 0.00333333 \n(0, 1, 1, 1) 0.777778 0.037037 0.266667 0.00333333 \n(1, 1, 1, 0) 0.277778 0.00231481 0.366667 0.00333333 \n(1, 1, 1, 1) 0 0 0.1 0.03 ";
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    BOOST_CHECK_LT( out.str().find( canon_log ), out.str().size() );
    BOOST_REQUIRE( sink.exists( "acceptance.dat" ) );
    std::string buf;
    sink.read( "acceptance.dat", buf );
    BOOST_CHECK_LT( buf.find( canon_rep ), buf.size() );
    // std::cout << buf << "\n";
  }
}


!!!1541808.cpp!!!	specie_count_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::specie_count >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::specie_count >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::specie_count >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::specie_count, observable::specie_count >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::specie_count >::type{} );
}
{
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::base_observable > var( observable::specie_count::make_sampler( params ) );

  observable_test_suite::base_observable_method_test( var, "specie-count" );
}
!!!1541680.cpp!!!	specie_count_method_test() : void
{
  boost::shared_ptr< particle::particle_manager > pman = observable_test_suite::mockup_particle_manager();
  boost::shared_ptr< evaluator::evaluator_manager > eman = observable_test_suite::mockup_evaluator_manager();
  boost::shared_ptr< geometry::geometry_manager > gman = observable_test_suite::mockup_geometry_manager();
  boost::shared_ptr< observable::report_manager > rman( new observable::report_manager );
  utility::memory_sink sink;
  std::vector< double > means( pman->specie_count() );
  for( std::size_t ispec = 0; ispec != pman->specie_count(); ++ispec )
  {
    means[ ispec ] = double( pman->get_ensemble().specie_count( ispec ) );
  }
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::base_observable > var( observable::specie_count::make_sampler( params ) );

  observable::specie_count *pvar = dynamic_cast< observable::specie_count* >( var.get() );

  BOOST_REQUIRE( pvar != nullptr );
  
  var->prepare( *pman, *gman, *eman, *rman );

  // first sample and report
  {
    var->on_sample( *pman, *gman, *eman );
    BOOST_REQUIRE_LE( pvar->size(), pman->specie_count() );
    for( std::size_t idx = 0; idx != pvar->size(); ++idx )
    {
      const std::size_t ispec = pvar->specie_key( idx );
      BOOST_CHECK_CLOSE( pvar->mean( idx ), means[ ispec ], 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->variance( idx ), 0.0, 0.00000001 );
    }
  }
  {
    BOOST_REQUIRE( not sink.exists( "specie-count.dat" ) );
    std::stringstream out;
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    BOOST_REQUIRE( sink.exists( "specie-count.dat" ) );
    //std::string buf;
    //sink.read( "specie-count.dat", buf );
    //std::cout << buf << "\n";
  }
  // second sample and report
  {
    var->on_sample( *pman, *gman, *eman );
    for( std::size_t idx = 0; idx != pvar->size(); ++idx )
    {
      const std::size_t ispec = pvar->specie_key( idx );
      BOOST_CHECK_CLOSE( pvar->mean( idx ), means[ ispec ], 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->variance( idx ), 0.0, 0.00000001 );
    }
  }
  {
    std::stringstream out;
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    //std::string buf;
    //sink.read( "specie-count.dat", buf );
    //std::cout << buf << "\n";
  }
  // need to add/convert a particle
  {
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 2 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 1 );
    // convert a 3 to a 4
    const std::size_t idx = pman->get_ensemble().nth_specie_index( 3, 0 );
    particle::change_set exc;
    particle::change_atom a1, a2;
    a1.key = 3;
    a2.key = 4;
    a1.index = idx;
    a2.index = pman->get_ensemble().size();
    a1.old_position = pman->get_ensemble().position( idx );
    a1.do_old = true;
    a1.do_new = false;
    a2.new_position = pman->get_ensemble().position( idx );
    a2.do_new = true;
    a2.do_old = false;
    exc.add_atom( a1 );
    exc.add_atom( a2 );
    pman->commit( exc );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 1 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 2 );

    var->on_sample( *pman, *gman, *eman );

    means[ 3 ] = 1.6666666666666667;
    means[ 4 ] = 1.3333333333333333;
    for( std::size_t idx = 0; idx != pvar->size(); ++idx )
    {
      const std::size_t ispec = pvar->specie_key( idx );
      BOOST_CHECK_CLOSE( pvar->mean( idx ), means[ ispec ], 0.00000001 );
      BOOST_CHECK_CLOSE( pvar->variance( idx ), 0.3333333333333333, 0.00000001 );
    }
  }
  {
    std::stringstream out;
    std::string canon_log = " SPC    <COUNT>        VAR       <[]>\n   3    1.66667     0.3333  0.1254612\n   4    1.33333     0.3333  0.1003690";
    std::string canon_rep = "# UUID:  \n# TITLE: \"Time series specie counts\" \n# FIELDS: INDEX SPC[3]_MEAN SPC[3]_VAR SPC[4]_MEAN SPC[4]_VAR \n# UNITS: ORDINAL COUNT COUNT COUNT COUNT \n1 2 0 1 0 \n2 2 0 1 0 \n3 1.66667 0.333333 1.33333 0.333333 ";
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    BOOST_CHECK_LT( out.str().find( canon_log ), out.str().size() );
    std::string buf;
    sink.read( "specie-count.dat", buf );
    BOOST_CHECK_LT( buf.find( canon_rep ), buf.size() );
    //std::cout << buf << "\n";
  }
}
!!!1498928.cpp!!!	specie_region_count_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::specie_region_count >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::specie_region_count >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::specie_region_count >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::specie_region_count, observable::specie_region_count >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::specie_region_count >::type{} );
}
{
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::base_observable > var( observable::specie_region_count::make_sampler( params ) );

  observable_test_suite::base_observable_method_test( var, "specie-region-count" );
}
!!!1498800.cpp!!!	specie_region_count_method_test() : void
const std::string filename( "specie-region-count.dat" );
{
  boost::shared_ptr< particle::particle_manager > pman = observable_test_suite::mockup_particle_manager();
  boost::shared_ptr< evaluator::evaluator_manager > eman = observable_test_suite::mockup_evaluator_manager();
  boost::shared_ptr< geometry::geometry_manager > gman = observable_test_suite::mockup_geometry_manager();
  boost::shared_ptr< observable::report_manager > rman( new observable::report_manager );
  utility::memory_sink sink;
  std::vector< double > means( pman->specie_count() );
  std::vector< double > vars( pman->specie_count(), 0.0 );
  for( std::size_t ispec = 0; ispec != pman->specie_count(); ++ispec )
  {
    means[ ispec ] = double( pman->get_ensemble().specie_count( ispec ) );
  }
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::base_observable > var( observable::specie_region_count::make_sampler( params ) );

  observable::specie_region_count *pvar = dynamic_cast< observable::specie_region_count* >( var.get() );

  BOOST_REQUIRE( pvar != nullptr );

  var->prepare( *pman, *gman, *eman, *rman );
  BOOST_REQUIRE_EQUAL( pvar->size(), pman->specie_count() * gman->region_count() );

  // first sample and report
  {
    var->on_sample( *pman, *gman, *eman );
    for( std::size_t ireg = 0; ireg != gman->region_count(); ++ireg )
    {
      const std::size_t offset = ireg * pman->specie_count();
      for( std::size_t ispec = 0; ispec != pman->specie_count(); ++ispec )
      {
        BOOST_CHECK_CLOSE( pvar->mean( offset + ispec ), means[ ispec ], 0.00000001 );
        BOOST_CHECK_CLOSE( pvar->variance( offset + ispec ), vars[ ispec ], 0.00000001 );
      }
    }
  }
  {
    BOOST_REQUIRE( not sink.exists( filename ) );
    std::stringstream out;
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    BOOST_REQUIRE( sink.exists( filename ) );
    //std::string buf;
    //sink.read( "specie-count.dat", buf );
    //std::cout << buf << "\n";
  }
  // second sample and report
  {
    var->on_sample( *pman, *gman, *eman );
    for( std::size_t ireg = 0; ireg != gman->region_count(); ++ireg )
    {
      const std::size_t offset = ireg * pman->specie_count();
      for( std::size_t ispec = 0; ispec != pman->specie_count(); ++ispec )
      {
        BOOST_CHECK_CLOSE( pvar->mean( offset + ispec ), means[ ispec ], 0.00000001 );
        BOOST_CHECK_CLOSE( pvar->variance( offset + ispec ), vars[ ispec ], 0.00000001 );
      }
    }
  }
  {
    std::stringstream out;
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    //std::string buf;
    //sink.read( "specie-count.dat", buf );
    //std::cout << buf << "\n";
  }
  // need to add/convert a particle
  {
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 2 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 1 );
    // convert a 3 to a 4
    const std::size_t idx = pman->get_ensemble().nth_specie_index( 3, 0 );
    particle::change_set exc;
    particle::change_atom a1, a2;
    a1.key = 3;
    a2.key = 4;
    a1.index = idx;
    a2.index = pman->get_ensemble().size();
    a1.old_position = pman->get_ensemble().position( idx );
    a1.do_old = true;
    a1.do_new = false;
    a2.new_position = pman->get_ensemble().position( idx );
    a2.do_new = true;
    a2.do_old = false;
    exc.add_atom( a1 );
    exc.add_atom( a2 );
    pman->commit( exc );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 1 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 2 );

    var->on_sample( *pman, *gman, *eman );

    means[ 3 ] = 1.6666666666666667;
    means[ 4 ] = 1.3333333333333333;
    vars[ 3 ] = 0.3333333333333333;
    vars[ 4 ] = 0.3333333333333333;
    for( std::size_t ireg = 0; ireg != gman->region_count(); ++ireg )
    {
      const std::size_t offset = ireg * pman->specie_count();
      for( std::size_t ispec = 0; ispec != pman->specie_count(); ++ispec )
      {
        BOOST_CHECK_CLOSE( pvar->mean( offset + ispec ), means[ ispec ], 0.00000001 );
        BOOST_CHECK_CLOSE( pvar->variance( offset + ispec ), vars[ ispec ], 0.00000001 );
      }
    }
  }
  {
    std::stringstream out;
    std::string canon_log = " REG SPC    <COUNT>        VAR       <[]>\n   0   0    1.00000     0.0000  0.0752767\n   0   1    1.00000     0.0000  0.0752767\n   0   2    1.00000     0.0000  0.0752767\n   0   3    1.66667     0.3333  0.1254612\n   0   4    1.33333     0.3333  0.1003690\n   1   0    1.00000     0.0000  0.0385417\n   1   1    1.00000     0.0000  0.0385417\n   1   2    1.00000     0.0000  0.0385417\n   1   3    1.66667     0.3333  0.0642362\n   1   4    1.33333     0.3333  0.0513889";

    std::string canon_rep = "# UUID:  \n# TITLE: \"Time series pre-region specie counts\" \n# FIELDS: INDEX REGSPC[0,0]_MEAN REGSPC[0,0]_VAR REGSPC[0,1]_MEAN REGSPC[0,1]_VAR REGSPC[0,2]_MEAN REGSPC[0,2]_VAR REGSPC[0,3]_MEAN REGSPC[0,3]_VAR REGSPC[0,4]_MEAN REGSPC[0,4]_VAR REGSPC[1,0]_MEAN REGSPC[1,0]_VAR REGSPC[1,1]_MEAN REGSPC[1,1]_VAR REGSPC[1,2]_MEAN REGSPC[1,2]_VAR REGSPC[1,3]_MEAN REGSPC[1,3]_VAR REGSPC[1,4]_MEAN REGSPC[1,4]_VAR \n# UNITS: ORDINAL COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT COUNT \n1 1 0 1 0 1 0 2 0 1 0 1 0 1 0 1 0 2 0 1 0 \n2 1 0 1 0 1 0 2 0 1 0 1 0 1 0 1 0 2 0 1 0 \n3 1 0 1 0 1 0 1.66667 0.333333 1.33333 0.333333 1 0 1 0 1 0 1.66667 0.333333 1.33333 0.333333 ";

    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    BOOST_CHECK_LT( out.str().find( canon_log ), out.str().size() );
    std::string buf;
    sink.read( filename, buf );
    BOOST_CHECK_LT( buf.find( canon_rep ), buf.size() );
    //std::cout << buf << "\n";
  }
}

!!!1549104.cpp!!!	density_zaxis_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::density_zaxis >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::density_zaxis >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::density_zaxis >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::density_zaxis, observable::density_zaxis >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::density_zaxis >::type{} );
}
{
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::base_observable > var( observable::density_zaxis::make_sampler( params ) );

  observable_test_suite::base_observable_method_test( var, "population-zaxis" );
}
!!!1548976.cpp!!!	density_zaxis_method_test() : void
const std::vector< std::string > filenames { { "gz-CA.dat", "gz-CO.dat", "gz-OX.dat", "gz-Na.dat", "gz-Cl.dat" } };
{
  boost::shared_ptr< particle::particle_manager > pman = observable_test_suite::mockup_particle_manager();
  boost::shared_ptr< evaluator::evaluator_manager > eman = observable_test_suite::mockup_evaluator_manager();
  boost::shared_ptr< geometry::geometry_manager > gman = observable_test_suite::mockup_geometry_manager();
  boost::shared_ptr< observable::report_manager > rman( new observable::report_manager );
  utility::memory_sink sink;
  // factory ctor
  std::map< std::string, std::string > params;
  params.insert( std::make_pair( "stepsize", "0.5" ) );
  boost::shared_ptr< observable::base_observable > var( observable::density_zaxis::make_sampler( params ) );

  observable::density_zaxis *pvar = dynamic_cast< observable::density_zaxis* >( var.get() );

  BOOST_REQUIRE( pvar != nullptr );

  var->prepare( *pman, *gman, *eman, *rman );
  BOOST_REQUIRE_EQUAL( pvar->size(), pman->specie_count() );

  // first sample and report
  var->on_sample( *pman, *gman, *eman );
  {
    for( auto filename : filenames )
    {
      BOOST_REQUIRE( not sink.exists( filename ) );
    }
    std::stringstream out;
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    for( auto filename : filenames )
    {
      BOOST_REQUIRE( sink.exists( filename ) );
    }
    //std::string buf;
    //sink.read( "specie-count.dat", buf );
    //std::cout << buf << "\n";
  }
  // second sample and report
  var->on_sample( *pman, *gman, *eman );
  {
    std::stringstream out;
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    //std::string buf;
    //sink.read( "specie-count.dat", buf );
    //std::cout << buf << "\n";
  }
  // need to add/convert a particle
  {
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 2 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 1 );
    // convert a 3 to a 4
    const std::size_t idx = pman->get_ensemble().nth_specie_index( 3, 0 );
    particle::change_set exc;
    particle::change_atom a1, a2;
    a1.key = 3;
    a2.key = 4;
    a1.index = idx;
    a2.index = pman->get_ensemble().size();
    a1.old_position = pman->get_ensemble().position( idx );
    a1.do_old = true;
    a1.do_new = false;
    a2.new_position = pman->get_ensemble().position( idx );
    a2.do_new = true;
    a2.do_old = false;
    exc.add_atom( a1 );
    exc.add_atom( a2 );
    pman->commit( exc );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 1 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 2 );

    var->on_sample( *pman, *gman, *eman );
  }
  {
    std::stringstream out;
    const std::string uuid_head { "# UUID:" };
    const std::string label_head { "# FIELDS: ZMIN ZMAX ZMID PMEAN PVAR \n# UNITS: ANGSTROM ANGSTROM ANGSTROM COUNT COUNT**2" };

    std::vector< std::string > canon_titles { {
        "# TITLE: \"Z-axial distribution histogram for specie 0\"",
        "# TITLE: \"Z-axial distribution histogram for specie 1\"",
        "# TITLE: \"Z-axial distribution histogram for specie 2\"",
        "# TITLE: \"Z-axial distribution histogram for specie 3\"",
        "# TITLE: \"Z-axial distribution histogram for specie 4\""
      }
    };
    std::vector< std::string > interesting_rows { {
        "0 0.5 0.25 1 0",
        "2 2.5 2.25 1 0",
        "2 2.5 2.25 1 0",
        "0 0.5 0.25 1.66667 0.333333",
        "0 0.5 0.25 1.33333 0.333333"
      }
    };

    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    // should be no output on "out"
    BOOST_CHECK_EQUAL( out.str().size(), 0 );
    std::string buf;
    for( std::size_t idx = 0; idx != filenames.size(); ++idx )
    {
      sink.read( filenames[ idx ], buf );
      BOOST_CHECK_LT( buf.find( uuid_head ), buf.size() );
      BOOST_CHECK_LT( buf.find( label_head ), buf.size() );
      BOOST_CHECK_LT( buf.find( canon_titles[ idx ] ), buf.size() );
      BOOST_CHECK_LT( buf.find( interesting_rows[ idx ] ), buf.size() );
      //std::cout << buf << "\n";
    }
  }
}
!!!1557040.cpp!!!	metropolis_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::metropolis_sampler >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::metropolis_sampler >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::metropolis_sampler >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::metropolis_sampler, observable::metropolis_sampler >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::metropolis_sampler >::type{} );
}
{
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::base_observable > var( observable::metropolis_sampler::make_sampler( params ) );

  observable_test_suite::base_observable_method_test( var, "metropolis" );
}
!!!1563568.cpp!!!	metropolis_method_test() : void
const std::string filename = "metropolis.dat";
{
  boost::shared_ptr< particle::particle_manager > pman = observable_test_suite::mockup_particle_manager();
  boost::shared_ptr< evaluator::evaluator_manager > eman = observable_test_suite::mockup_evaluator_manager();
  boost::shared_ptr< geometry::geometry_manager > gman = observable_test_suite::mockup_geometry_manager();
  boost::shared_ptr< observable::report_manager > rman( new observable::report_manager );
  utility::memory_sink sink;
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::tracked_observable > var( observable::metropolis_sampler::make_sampler( params ) );

  observable::metropolis_sampler *pvar = dynamic_cast< observable::metropolis_sampler* >( var.get() );

  BOOST_REQUIRE( pvar != nullptr );

  var->prepare( *pman, *gman, *eman, *rman );
  BOOST_CHECK_EQUAL( pvar->boltzmann_factor().count(), 0ul );
  BOOST_CHECK_EQUAL( pvar->energy_change().count(), 0ul );
  BOOST_CHECK_EQUAL( pvar->energy().count(), 0ul );
  BOOST_CHECK_EQUAL( pvar->energy().size(), 100ul );

  // Energy of dummy trials
  std::vector< double > dummy_trials { 0.9, 1.3, 0.1, 2., 0.0, 4.2, 0.6  };
  // Out first set of dummy trials
  {
    for( auto energy : dummy_trials )
    {
      particle::change_set tmp;
      tmp.id( { 0ul, 1ul, 1ul, 0ul } );
      particle::change_atom at;
      at.energy_new = energy;
      tmp.add_atom( at );
      var->on_trial_end( tmp );
    }
    // first sample and report
    var->on_sample( *pman, *gman, *eman );
    BOOST_REQUIRE( not sink.exists( filename ) );
    std::stringstream out;
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    BOOST_REQUIRE( sink.exists( filename ) );
    //std::string buf;
    //sink.read( filename, buf );
    //std::cout << buf << "\n";
  }
  // second sample and report
  {
    for( auto energy : dummy_trials )
    {
      particle::change_set tmp;
      tmp.id( { 0ul, 1ul, 1ul, 0ul } );
      particle::change_atom at;
      at.energy_new = energy * 1.1;
      tmp.add_atom( at );
      var->on_trial_end( tmp );
    }
    var->on_sample( *pman, *gman, *eman );
    {
      std::stringstream out;
      var->on_report( out, sink );
      //std::cout << out.str() << "\n";
      //std::string buf;
      //sink.read( "specie-count.dat", buf );
      //std::cout << buf << "\n";
    }
  }
  // need to add/convert a particle
  {
    // convert a 3 to a 4
    const std::size_t idx = pman->get_ensemble().nth_specie_index( 3, 0 );
    particle::change_set exc;
    particle::change_atom a1, a2;
    a1.key = 3;
    a2.key = 4;
    a1.index = idx;
    a2.index = pman->get_ensemble().size();
    a1.old_position = pman->get_ensemble().position( idx );
    a1.do_old = true;
    a1.energy_old = 4.5;
    a1.do_new = false;
    a2.new_position = pman->get_ensemble().position( idx );
    a2.do_new = true;
    a1.energy_new = 4.5;
    a2.do_old = false;
    exc.add_atom( a1 );
    exc.add_atom( a2 );
    var->on_trial_end( exc );
    for( auto energy : dummy_trials )
    {
      particle::change_set tmp;
      tmp.id( { 0ul, 1ul, 1ul, 0ul } );
      particle::change_atom at;
      at.energy_new = energy * 0.9;
      tmp.add_atom( at );
      var->on_trial_end( tmp );
    }

    var->on_sample( *pman, *gman, *eman );

    std::stringstream out;
    const std::string canon_out { "metropolis : P_mean       = 0.49397 var = 0.132581\n           : -log(P_mean) = 0.705281 var = -2.02056\n----------------------------------------------------------------------" };
    const std::string uuid_head { "# UUID:" };
    const std::string label_head { "# FIELDS: EMIN EMAX EMID PMEAN PVAR" };

    std::string canon_title { "# TITLE: \"Energy distribution histogram\"" };
    std::vector< std::string > interesting_rows {
      "0 0.01 0.005 0.333333 0.333333",
      "0.01 0.02 0.015 0.333333 0.333333",
      "0.02 0.03 0.025 0.333333 0.333333",
      "0.11 0.12 0.115 0.333333 0.333333",
      "0.13 0.14 0.135 0.333333 0.333333",
      "0.16 0.17 0.165 0.333333 0.333333",
      "0.23 0.24 0.235 0.333333 0.333333",
      "0.27 0.28 0.275 0.333333 0.333333",
      "0.31 0.32 0.315 0.333333 0.333333",
      "0.37 0.38 0.375 0.333333 0.333333",
      "0.4 0.41 0.405 0.333333 0.333333",
      "0.44 0.45 0.445 0.333333 0.333333",
      "0.51 0.52 0.515 0.333333 0.333333",
      "0.54 0.55 0.545 0.333333 0.333333",
      "0.58 0.59 0.585 0.333333 0.333333",
      "0.89 0.9 0.895 0.333333 0.333333",
      "0.9 0.91 0.905 0.333333 0.333333",
      "0.91 0.92 0.915 0.333333 0.333333",
      "1 1.01 1.005 1.33333 0.333333"
    };
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    // should be no output on "out"
    BOOST_CHECK_LT( out.str().find( canon_out ), out.str().size() );
    std::string buf; 
    sink.read( filename, buf );
    BOOST_CHECK_LT( buf.find( uuid_head ), buf.size() );
    BOOST_CHECK_LT( buf.find( label_head ), buf.size() );
    BOOST_CHECK_LT( buf.find( canon_title ), buf.size() );
    for( auto interesting_row : interesting_rows )
    {
      BOOST_CHECK_LT( buf.find( interesting_row ), buf.size() );
    }
    //std::cout << buf << "\n";
  }
}


!!!1570864.cpp!!!	rdf_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::rdf_sampler >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::rdf_sampler >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::rdf_sampler >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::rdf_sampler, observable::rdf_sampler >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::rdf_sampler >::type{} );
}
{
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::base_observable > var( observable::rdf_sampler::make_sampler( params ) );

  observable_test_suite::base_observable_method_test( var, "rdf-specie" );
}
{
  // static methods
  BOOST_CHECK_EQUAL( observable::rdf_sampler::default_bin_width(), 0.2 );
  BOOST_CHECK_EQUAL( observable::rdf_sampler::default_width(), 20.0 );
  BOOST_CHECK_EQUAL( observable::rdf_sampler::type_label_(), "rdf-specie" );
}
!!!1571120.cpp!!!	rdf_method_test() : void
const std::vector< std::string > labels { "CA", "CO", "OX", "Na", "Cl" };
const std::vector< std::string > filenames { "rdf-CA-CA.dat", "rdf-CA-CO.dat", "rdf-CA-OX.dat", "rdf-CA-Na.dat", "rdf-CA-Cl.dat", "rdf-CO-CO.dat", "rdf-CO-OX.dat", "rdf-CO-Na.dat", "rdf-CO-Cl.dat", "rdf-OX-OX.dat", "rdf-OX-Na.dat", "rdf-OX-Cl.dat", "rdf-Na-Na.dat", "rdf-Na-Cl.dat", "rdf-Cl-Cl.dat" };
{
  boost::shared_ptr< particle::particle_manager > pman = observable_test_suite::mockup_particle_manager();
  boost::shared_ptr< evaluator::evaluator_manager > eman = observable_test_suite::mockup_evaluator_manager();
  boost::shared_ptr< geometry::geometry_manager > gman = observable_test_suite::mockup_geometry_manager();
  boost::shared_ptr< observable::report_manager > rman( new observable::report_manager );
  utility::memory_sink sink;
  // factory ctor
  std::map< std::string, std::string > params;
  params.insert( std::make_pair( "stepsize", "0.5" ) );
  params.insert( std::make_pair( "width", "10.5" ) );
  boost::shared_ptr< observable::base_observable > var( observable::rdf_sampler::make_sampler( params ) );

  observable::rdf_sampler *pvar = dynamic_cast< observable::rdf_sampler* >( var.get() );

  BOOST_REQUIRE( pvar != nullptr );
  BOOST_REQUIRE_EQUAL( pvar->stepsize(), 0.5 );
  BOOST_REQUIRE_EQUAL( pvar->width(), 10.5 );

  var->prepare( *pman, *gman, *eman, *rman );
  BOOST_REQUIRE_EQUAL( pvar->size(), (pman->specie_count() * (pman->specie_count() + 1))/2 );

  // first sample and report
  var->on_sample( *pman, *gman, *eman );
  {
    for( auto filename : filenames )
    {
      BOOST_REQUIRE( not sink.exists( filename ) );
    }
    std::stringstream out;
    var->on_report( out, sink );
    // nothing written to output
    BOOST_REQUIRE_EQUAL( out.str().size(), 0 );
    for( auto filename : filenames )
    {
      BOOST_REQUIRE( sink.exists( filename ) );
    }
    //std::string buf;
    //sink.read( "specie-count.dat", buf );
    //std::cout << buf << "\n";
  }
  // second sample and report
  var->on_sample( *pman, *gman, *eman );
  {
    std::stringstream out;
    var->on_report( out, sink );
  }
  // need to add/convert a particle
  {
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 2 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 1 );
    // convert a 3 to a 4
    const std::size_t idx = pman->get_ensemble().nth_specie_index( 3, 0 );
    particle::change_set exc;
    particle::change_atom a1, a2;
    a1.key = 3;
    a2.key = 4;
    a1.index = idx;
    a2.index = pman->get_ensemble().size();
    a1.old_position = pman->get_ensemble().position( idx );
    a1.do_old = true;
    a1.do_new = false;
    a2.new_position = pman->get_ensemble().position( idx );
    a2.do_new = true;
    a2.do_old = false;
    exc.add_atom( a1 );
    exc.add_atom( a2 );
    pman->commit( exc );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 1 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 2 );

    var->on_sample( *pman, *gman, *eman );
  }
  {
    std::stringstream out;
    const std::string uuid_head { "# UUID:" };
    const std::string label_head { "# FIELDS: RMIN RMAX RMID PMEAN PVAR \n# UNITS: ANGSTROM ANGSTROM ANGSTROM COUNT COUNT**2" };

    std::vector< std::string > canon_titles { 
        "# TITLE: \"Radial distribution histogram for species CA and CA\"",
        "# TITLE: \"Radial distribution histogram for species CA and CO\"",
        "# TITLE: \"Radial distribution histogram for species CA and OX\"",
        "# TITLE: \"Radial distribution histogram for species CA and Na\"",
        "# TITLE: \"Radial distribution histogram for species CA and Cl\"",
        "# TITLE: \"Radial distribution histogram for species CO and CO\"",
        "# TITLE: \"Radial distribution histogram for species CO and OX\"",
        "# TITLE: \"Radial distribution histogram for species CO and Na\"",
        "# TITLE: \"Radial distribution histogram for species CO and Cl\"",
        "# TITLE: \"Radial distribution histogram for species OX and OX\"",
        "# TITLE: \"Radial distribution histogram for species OX and Na\"",
        "# TITLE: \"Radial distribution histogram for species OX and Cl\"",
        "# TITLE: \"Radial distribution histogram for species Na and Na\"",
        "# TITLE: \"Radial distribution histogram for species Na and Cl\"",
        "# TITLE: \"Radial distribution histogram for species Cl and Cl\""
    };
    std::vector< std::string > interesting_rows { 
        "0.22 0.72 0.47 0 0",
        "3.23 3.73 3.48 1 0",
        "2.73 3.23 2.98 1 0",
        "2.73 3.23 2.98 0.666667 0.333333",
        "2.81 3.31 3.06 0.333333 0.333333",
        "0.24 0.74 0.49 0 0",
        "1.74 2.24 1.99 1 0",
        "1.74 2.24 1.99 0.666667 0.333333",
        "1.82 2.32 2.07 0.333333 0.333333",
        "0.24 0.74 0.49 0 0",
        "2.74 3.24 2.99 0.666667 0.333333",
        "2.82 3.32 3.07 0.333333 0.333333 \n3.32 3.82 3.57 1 0",
        "1.74 2.24 1.99 0.666667 0.333333",
        "1.82 2.32 2.07 1 0 \n2.32 2.82 2.57 0 0 \n2.82 3.32 3.07 1 0",
        "1.9 2.4 2.15 0.333333 0.333333"
    };
    BOOST_CHECK_EQUAL( filenames.size(), canon_titles.size() );
    BOOST_CHECK_EQUAL( filenames.size(), interesting_rows.size() );

    var->on_report( out, sink );
    // should be no output on "out"
    std::string buf;
    for( std::size_t idx = 0; idx != canon_titles.size(); ++idx )
    {
      sink.read( filenames[ idx ], buf );
      // std::cout << buf << "\n";
      BOOST_CHECK_LT( buf.find( uuid_head ), buf.size() );
      BOOST_CHECK_LT( buf.find( label_head ), buf.size() );
      BOOST_CHECK_LT( buf.find( canon_titles[ idx ] ), buf.size() );
      BOOST_CHECK_LT( buf.find( interesting_rows[ idx ] ), buf.size() );
    }
  }
}
!!!1615152.cpp!!!	digitizer_3d_lifetime_test() : void
{
  // Static Lifetime method tests: canonical pattern

  BOOST_CHECK( std::is_default_constructible< observable::digitizer_3d >::type{} );
  BOOST_CHECK( std::is_copy_constructible< observable::digitizer_3d >::type{} );
  BOOST_CHECK( std::is_move_constructible< observable::digitizer_3d >::type{} );
  BOOST_CHECK( ( std::is_assignable< observable::digitizer_3d, observable::digitizer_3d >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< observable::digitizer_3d >::type{} );
}
const particle::coordinate pzero{ 0.0, 0.0, 0.0 };
const particle::coordinate pminusone{ -1.0, -1.0, -1.0 };
const particle::coordinate pone{ 1.0, 1.0, 1.0 };

{
  // Default ctor
  observable::digitizer_3d var;
  BOOST_CHECK_EQUAL( var.minimum(), pzero );
  BOOST_CHECK_EQUAL( var.maximum(), pzero );
  BOOST_CHECK_EQUAL( var.size(), 0ul );
  for( int x = -10; x != 11; ++x )
  {
    const particle::coordinate pos{ double( x )/5.0, double( x )/4.0, double( x )/6.0 };
    BOOST_REQUIRE( not var.in_range( pos ) );
  }
}
std::stringstream store;
{
  // Min/Max/Count ctor
  observable::digitizer_3d var( pminusone, pone, 0.2 );
  BOOST_CHECK_EQUAL( var.minimum(), pminusone );
  BOOST_CHECK_EQUAL( var.maximum(), pone );
  BOOST_CHECK_EQUAL( var.size(), 1000ul );
  const particle::coordinate bwidth{ var.bin_width() };
  BOOST_CHECK( utility::feq( bwidth.x, 0.2 ) );
  BOOST_CHECK( utility::feq( bwidth.y, 0.2 ) );
  BOOST_CHECK( utility::feq( bwidth.z, 0.2 ) );

  boost::archive::text_oarchive oa(store);
  // write class instances to archive
  oa << var;

  {
    // copy
    observable::digitizer_3d var2( var );
    BOOST_CHECK_EQUAL( var2.minimum(), pminusone );
    BOOST_CHECK_EQUAL( var2.maximum(), pone );
    BOOST_CHECK_EQUAL( var2.size(), 1000ul );
    const particle::coordinate bwidth{ var2.bin_width() };
    BOOST_CHECK( utility::feq( bwidth.x, 0.2 ) );
    BOOST_CHECK( utility::feq( bwidth.y, 0.2 ) );
    BOOST_CHECK( utility::feq( bwidth.z, 0.2 ) );
    BOOST_CHECK( var == var2 );
  }
  {
    // assign
    observable::digitizer_3d var2;
    BOOST_CHECK_EQUAL( var2.minimum(), pzero );
    BOOST_CHECK_EQUAL( var2.maximum(), pzero );
    var2 = var;
    BOOST_CHECK_EQUAL( var2.minimum(), pminusone );
    BOOST_CHECK_EQUAL( var2.maximum(), pone );
    BOOST_CHECK_EQUAL( var2.size(), 1000ul );
    const particle::coordinate bwidth{ var2.bin_width() };
    BOOST_CHECK( utility::feq( bwidth.x, 0.2 ) );
    BOOST_CHECK( utility::feq( bwidth.y, 0.2 ) );
    BOOST_CHECK( utility::feq( bwidth.z, 0.2 ) );
    BOOST_CHECK( var == var2 );
  }
  {
    // move
    observable::digitizer_3d var1( var );
    BOOST_CHECK_EQUAL( var1.minimum(), pminusone );
    BOOST_CHECK_EQUAL( var1.maximum(), pone );
    observable::digitizer_3d var2( std::move( var1 ) );
    BOOST_CHECK_EQUAL( var2.minimum(), pminusone );
    BOOST_CHECK_EQUAL( var2.maximum(), pone );
    BOOST_CHECK_EQUAL( var2.size(), 1000ul );
    const particle::coordinate bwidth{ var2.bin_width() };
    BOOST_CHECK( utility::feq( bwidth.x, 0.2 ) );
    BOOST_CHECK( utility::feq( bwidth.y, 0.2 ) );
    BOOST_CHECK( utility::feq( bwidth.z, 0.2 ) );
    BOOST_CHECK( var == var2 );
  }
}
{
  observable::digitizer_3d var;
 
  boost::archive::text_iarchive ia(store);
  // read class instances from archive
  ia >> var;
  BOOST_CHECK_EQUAL( var.minimum(), pminusone );
  BOOST_CHECK_EQUAL( var.maximum(), pone );
  BOOST_CHECK_EQUAL( var.size(), 1000ul );
  const particle::coordinate bwidth{ var.bin_width() };
  BOOST_CHECK( utility::feq( bwidth.x, 0.2 ) );
  BOOST_CHECK( utility::feq( bwidth.y, 0.2 ) );
  BOOST_CHECK( utility::feq( bwidth.z, 0.2 ) );
} 

!!!1615024.cpp!!!	digitizer_3d_method_test() : void
{
  // Min/Max/step ctor
  observable::digitizer_3d var( {-1.0, -1.0, -1.0 }, { 1.0, 1.0, 1.0 }, 0.2 );
  BOOST_CHECK_EQUAL( var.size(), 1000ul );
  const particle::coordinate bwidth{ var.bin_width() };
  BOOST_CHECK( utility::feq( bwidth.x, 0.2 ) );
  BOOST_CHECK( utility::feq( bwidth.y, 0.2 ) );
  BOOST_CHECK( utility::feq( bwidth.z, 0.2 ) );
  for( int x = -10; x != 11; ++x )
  {
    particle::coordinate pos{ double( x )/5.0, double( x )/4.0, double( x )/6.0 };
    if( not var.in_range( pos ) )
    {
      if( -4 <= x and x < 4 )
      {
        std::stringstream ss;
        ss << pos << " should be in range!";
        BOOST_ERROR( ss.str() );
      }
    }
    else
    {
      if( -4 > x or 4 >= 5 )
      {
        std::stringstream ss;
        ss << pos << " should NOT be in range!";
        BOOST_ERROR( ss.str() );
      }
    }
  }
}
//XX{
//XX  // extend up/down
//XX  observable::digitizer_3d var( -1.0,1.0, 0.2 );
//XX  BOOST_CHECK_EQUAL( var.size(), 10ul );
//XX  std::vector< double > data;
//XX  for( int x = 5; x != 10; ++x )
//XX  {
//XX    data.push_back( double( -x )/5.0 );
//XX  }
//XX  std::size_t count = 0;
//XX  for( double x : data )
//XX  {
//XX    if( not var.in_range( double( x ) ) )
//XX    {
//XX      BOOST_REQUIRE_LT( x, var.minimum() );
//XX      const observable::digitizer_3d copy( var );
//XX      const std::size_t add = var.extend_down( x );
//XX      ++count;
//XX      BOOST_CHECK_EQUAL( copy.size() + add, var.size() );
//XX      BOOST_CHECK_LT( var.minimum(), copy.minimum() );
//XX      BOOST_CHECK( utility::feq( copy.bin_width(), var.bin_width() ) );
//XX      BOOST_CHECK( utility::feq( copy.maximum(), var.maximum() ) );
//XX      BOOST_CHECK( utility::feq( copy.width() + add * copy.bin_width(), var.width() ) );
//XX      BOOST_CHECK( utility::feq( copy.bin_minimum( 0 ), var.bin_minimum( add ) ) );
//XX      BOOST_CHECK( utility::feq( copy.bin_maximum( 0 ), var.bin_maximum( add ) ) );
//XX      BOOST_CHECK( utility::feq( copy.bin_midpoint( 0 ), var.bin_midpoint( add ) ) );
//XX      BOOST_CHECK( utility::feq( copy.bin_width(), var.bin_width() ) );
//XX    }
//XX  }
//XX  BOOST_CHECK_EQUAL( count, 4 );
//XX  for( int x = 5; x != 10; ++x )
//XX  {
//XX    data[ x - 5 ] = double( x )/5.0;
//XX  }
//XX   for( double x : data )
//XX  {
//XX    if( not var.in_range( double( x ) ) )
//XX    {
//XX      BOOST_REQUIRE_GE( x, var.maximum() );
//XX      const observable::digitizer_3d copy( var );
//XX      const std::size_t add = var.extend_up( x );
//XX      ++count;
//XX      BOOST_CHECK_EQUAL( copy.size() + add, var.size() );
//XX      BOOST_CHECK( utility::feq( var.minimum(), copy.minimum() ) );
//XX      BOOST_CHECK( utility::feq( copy.bin_width(), var.bin_width() ) );
//XX      BOOST_CHECK_LT( copy.maximum(), var.maximum() );
//XX      BOOST_CHECK( utility::feq( copy.width() + add * copy.bin_width(), var.width() ) );
//XX      BOOST_CHECK( utility::feq( copy.bin_minimum( copy.size() - 1 ), var.bin_minimum(  copy.size() - 1 ) ) );
//XX      BOOST_CHECK( utility::feq( copy.bin_maximum( copy.size() - 1 ), var.bin_maximum( copy.size() - 1 ) ) );
//XX      BOOST_CHECK( utility::feq( copy.bin_midpoint( copy.size() - 1 ), var.bin_midpoint( copy.size() - 1 ) ) );
//XX      BOOST_CHECK( utility::feq( copy.bin_width(), var.bin_width() ) );
//XX    }
//XX  }
//XX  BOOST_CHECK_EQUAL( count, 8 );
//XX  BOOST_CHECK( utility::feq( -2.0, var.minimum() ) );
//XX  BOOST_CHECK( utility::feq( 1.8, var.maximum() ) );
//XX   
//XX}
//XX
!!!1615408.cpp!!!	d3_distribution_lifetime_test() : void
{
  // Static Lifetime method tests: virtual pattern

  BOOST_CHECK( not std::is_default_constructible< observable::d3_distribution >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::d3_distribution >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::d3_distribution >::type{} );
  BOOST_CHECK( ( not std::is_assignable< observable::d3_distribution, observable::d3_distribution >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::d3_distribution >::type{} );
}
{
  // factory ctor
  std::map< std::string, std::string > params;
  boost::shared_ptr< observable::base_observable > var( observable::d3_distribution::make_sampler( params ) );

  observable_test_suite::base_observable_method_test( var, "3d-distribution" );
}
!!!1615280.cpp!!!	d3_distribution_method_test() : void
const std::vector< std::string > filenames { { "d3df-CA.dat", "d3df-CO.dat", "d3df-OX.dat", "d3df-Na.dat", "d3df-Cl.dat" } };
{
  boost::shared_ptr< particle::particle_manager > pman = observable_test_suite::mockup_particle_manager();
  boost::shared_ptr< evaluator::evaluator_manager > eman = observable_test_suite::mockup_evaluator_manager();
  boost::shared_ptr< geometry::geometry_manager > gman = observable_test_suite::mockup_geometry_manager();
  boost::shared_ptr< observable::report_manager > rman( new observable::report_manager );
  utility::memory_sink sink;
  // factory ctor
  std::map< std::string, std::string > params;
  params.insert( std::make_pair( "stepsize", "2.0" ) );
  boost::shared_ptr< observable::base_observable > var( observable::d3_distribution::make_sampler( params ) );

  observable::d3_distribution *pvar = dynamic_cast< observable::d3_distribution* >( var.get() );

  BOOST_REQUIRE( pvar != nullptr );

  var->prepare( *pman, *gman, *eman, *rman );
  BOOST_REQUIRE_EQUAL( pvar->size(), pman->specie_count() );

  // first sample and report
  var->on_sample( *pman, *gman, *eman );
  {
    for( auto filename : filenames )
    {
      BOOST_REQUIRE( not sink.exists( filename ) );
    }
    std::stringstream out;
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    for( auto filename : filenames )
    {
      BOOST_REQUIRE( sink.exists( filename ) );
    }
    //std::string buf;
    //sink.read( "specie-count.dat", buf );
    //std::cout << buf << "\n";
  }
  // second sample and report
  var->on_sample( *pman, *gman, *eman );
  {
    std::stringstream out;
    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    //std::string buf;
    //sink.read( "specie-count.dat", buf );
    //std::cout << buf << "\n";
  }
  // need to add/convert a particle
  {
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 2 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 1 );
    // convert a 3 to a 4
    const std::size_t idx = pman->get_ensemble().nth_specie_index( 3, 0 );
    particle::change_set exc;
    particle::change_atom a1, a2;
    a1.key = 3;
    a2.key = 4;
    a1.index = idx;
    a2.index = pman->get_ensemble().size();
    a1.old_position = pman->get_ensemble().position( idx );
    a1.do_old = true;
    a1.do_new = false;
    a2.new_position = pman->get_ensemble().position( idx );
    a2.do_new = true;
    a2.do_old = false;
    exc.add_atom( a1 );
    exc.add_atom( a2 );
    pman->commit( exc );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 3 ), 1 );
    BOOST_REQUIRE_EQUAL( pman->get_ensemble().specie_count( 4 ), 2 );

    var->on_sample( *pman, *gman, *eman );
  }
  {
    std::stringstream out;
    const std::string uuid_head { "# UUID:" };
    const std::string label_head { "# FIELDS: X_MID Y_MID Z_MID PMEAN PVAR" };
    const std::string unit_head { "# UNITS: ANGSTROM ANGSTROM ANGSTROM COUNT COUNT**2" };

    std::vector< std::string > canon_titles {
      "# TITLE: \"3D density distribution histogram for specie CA\"",
      "# TITLE: \"3D density distribution histogram for specie CO\"",
      "# TITLE: \"3D density distribution histogram for specie OX\"",
      "# TITLE: \"3D density distribution histogram for specie Na\"",
      "# TITLE: \"3D density distribution histogram for specie Cl\""
    };
    std::vector< std::string > interesting_rows { {
        "3.000000 3.000000 1.000000   1.000000   0.000000",
        "1.000000 1.000000 3.000000   1.000000   0.000000",
        "3.000000 1.000000 3.000000   1.000000   0.000000",
        "1.000000 1.000000 1.000000   0.666667   0.333333",
        "1.000000 1.000000 1.000000   0.333333   0.333333"
      }
    };

    var->on_report( out, sink );
    //std::cout << out.str() << "\n";
    // should be no output on "out"
    BOOST_CHECK_EQUAL( out.str().size(), 0 );
    std::string buf;
    for( std::size_t idx = 0; idx != filenames.size(); ++idx )
    {
      sink.read( filenames[ idx ], buf );
      BOOST_CHECK_LT( buf.find( uuid_head ), buf.size() );
      BOOST_CHECK_LT( buf.find( label_head ), buf.size() );
      BOOST_CHECK_LT( buf.find( unit_head ), buf.size() );
      BOOST_CHECK_LT( buf.find( canon_titles[ idx ] ), buf.size() );
      BOOST_CHECK_LT( buf.find( interesting_rows[ idx ] ), buf.size() );
      //std::cout << buf << "\n";
    }
  }
}
