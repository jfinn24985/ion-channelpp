class localizer
!!!276016.cpp!!!	make_evaluator(in param_set : std::map< std::string, std::string >, inout sim : simulator) : void
// Check no parameters have been set
UTILITY_INPUT(param_set.size() <= 1,"Localisation evaluator requires only one input parameter.",core::strngs::evaluator_label());
std::unique_ptr< localizer > cc(new localizer);
if (param_set.count( core::strngs::fskmob() ) == 1)
{
   try
   {
      cc->set_spring_factor( boost::lexical_cast< double >( param_set.at( core::strngs::fskmob() ) ) );
   }
   catch(boost::bad_lexical_cast const& err)
   {
      const bool read_input_value = false;
      UTILITY_INPUT(read_input_value == true,"Value for parameter "+core::strngs::fskmob()+" could not be read as a number: \""+param_set.at( core::strngs::fskmob() )+"\".", core::strngs::evaluator_label());

   }
}
else
{
   UTILITY_INPUT(param_set.size() == 0,"Unknown parameter name "+param_set.begin()->first+", Localization evaluator knows only parameter "+core::strngs::fskmob()+".", core::strngs::evaluator_label());

}
sim.add_evaluator( cc.release() );
!!!276272.cpp!!!	type_label_() : string
  return core::strngs::localizer_label();
!!!275376.cpp!!!	compute_potential(in spcs : specie, in ens : ensemble, inout changes : change_set, in start_index : size_t = 0) : void
for (auto &atom: changes)
{
   if ( atom.key == ens.nkey )
   {
      continue;
   }
   // ASSUMPTION: localized atoms can only be moved, not
   // added or removed.
   if ( spcs[ atom.key ].is_localized() )
   { 
      // Get localization data after converting global index into a per-specie index
      const particle::centroid rs( spcs[ atom.key ].get_localization_data( ens.specie_index( atom.index ) ) );
      // new penalty
      const double r_sq{ std::pow( atom.new_position.x - rs.x, 2 )
            + std::pow( atom.new_position.y - rs.y, 2 )
            + std::pow( atom.new_position.z - rs.z, 2 ) };
      if (rs.r * rs.r < r_sq)
      {
         // New position outside of cutoff, fail move.
         changes.set_fail();
         return; 
      }
      atom.energy_new += this->spring_factor_ * r_sq / (rs.r * rs.r);

      // old penalty
      atom.energy_old += this->spring_factor_ *
            ( std::pow( atom.old_position.x - rs.x, 2 )
            + std::pow( atom.old_position.y - rs.y, 2 )
            + std::pow( atom.old_position.z - rs.z, 2 ) ) / (rs.r * rs.r);

   }
}
!!!538928.cpp!!!	compute_total_potential(in sim : simulator) : double
double energy = 0.0;
auto const& ens = sim.get_ensemble();
for (std::size_t idx = 0; idx != ens.size(); ++idx)
{
   std::size_t ispec = ens.key( idx );
   if (particle::ensemble::nkey == ispec)
   {
      continue;
   }
   // ASSUMPTION: localized atoms can only be moved, not
   // added or removed.
   if ( sim.get_specie( ispec ).is_localized() )
   { 
      // Get localization data after converting global index into a per-specie index
      const particle::centroid rs( sim.get_specie( ispec ).get_localization_data( ens.specie_index( idx ) ) );
      const particle::coordinate pos = ens.position( idx );
      // penalty
      const double r_sq{ std::pow( pos.x - rs.x, 2 ) + std::pow( pos.y - rs.y, 2 ) + std::pow( pos.z - rs.z, 2 ) };
      energy += this->spring_factor_ * r_sq / (rs.r * rs.r);
   }
}
return energy;
!!!275504.cpp!!!	do_description(inout os : ostream) : void
os << " Compute the harmonic potential to localize specific particles\n\n";
os << "  For a harmonic oscillator the potential stored in a particle is\n\n";
os << "     U = 1/2 k r^2\n\n";
os << "  Where k is the spring constant and r is the distance from the mean position\n";
os << "  of the oscillation. The potential to approximate a Uniform distribution is:\n\n";
os << "     U  = k_bT/2 ( r^2 )/( sigma^2 )  -- eqn 1\n\n";
os << "  We reformulate this as (now in units of \"k_bT\"):\n\n";
os << "     U = C_mob ( r^2 )/( R_i^2 ) -- eqn 2\n\n";
os << "  Where \"C_mob\" is a simulation wide constant (the spring factor) and R_i\n";
os << "  is a per-particle is the cut-off distance.\n\n";
os << "  To get eqn 2 to model a Uniform distribution our values of the spring factor\n";
os << "  (C_mob, parameter \"mobk\") and R_i must satisfy the relations.\n\n";
os << "     C_mob = 1/2 n^2 and R_i = n * sigma -- eqn 3\n\n";
os << "  where n is any factor. Conversely, given kmob and R_i the distribution\n";
os << "  models a Uniform distribution with \n\n";
os << "     sigma^2 = R_i^2 / (2 * C_mob)\n\n";
os << "  DEFAULT SETTINGS:\n\n";
os << "  In a Uniform distribution, greater that 99.5\% of the distribution\n";
os << "  is within 3 standard deviations of the mean position. We take this as\n";
os << "  the default by defining (n) in eqn 3 as 3 giving:\n\n";
os << "     C_mob = 4.5\n";
os << "     R_i  = 3 * sigma\n\n";
os << "  If we have B factors from an X-ray we can determine R_i from\n\n";
os << "     R_i = 3 * sigma = 3 { 1/(2 pi) sqrt( B_i/2 ) }\n\n";
os << " Spring factor: " << this->spring_factor_ << " (kT)\n";

!!!276144.cpp!!!	do_write_document(inout wr : input_document, in ix : size_t) : void
wr[ ix ].add_entry( core::strngs::fskmob(), this->spring_factor_ );

!!!1406511.python!!!	__call__(in self : , in change_set : , in item_list : ) : double
for change in changes:
    if change.specie().is_mobile():
        loc = item_list.localisation (change.index())
        np = change.new_position
        cp = loc.centrepoint
        r_sq = math.pow(lcp[0] - np[0],2) + math.pow(cp[1] - np[1],2) + math.pow(cp[2] - np[2],2)
        r_cut = loc.r_cutoff_sq
        if r_sq > r_cut:
            raise overlap_exception
        return loc.k_factor * r_sq / r_cut
