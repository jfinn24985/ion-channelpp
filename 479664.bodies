class region_meta
!!!1062448.cpp!!!	add_definition(inout defn : region_definition) : void
UTILITY_REQUIRE( not this->has_definition( defn->label() ), "Can not add two region definitions with the same name." );
this->type_to_object_.push_back( defn.release() );
!!!2330800.cpp!!!	definition_key_list() : string
std::vector< std::string > result;
for( auto const& entry : this->type_to_object_ )
{
  result.push_back( entry.label() );
}
return result;
!!!1061552.cpp!!!	publish_help(inout helper : input_help) : void
const std::string rgnlabel( this->section_label() );
// ----------------------------------------
// add section
// ----------------------------------------

//   Specie input section definition
helper.add_section( { rgnlabel,
    "Region input section definition.  In addition to the listed options, each individual "
    "region subtype may have its own specific options." } );

// ----------------------------------------
// add parameters
// ----------------------------------------

//  name : [required] region label
{
  const std::string description( "Label for a region. Must be unique in a simulation as it can be referred to from other parts of the simulation." );
  helper.get_section( rgnlabel ).add_entry( { core::strngs::fsname(), "text label", "unique for all regions", "required", description } );
}

// Subtype parameter documentation.
for( auto iter = this->type_to_object_.begin(); iter != this->type_to_object_.end(); ++iter )
{
  iter->publish_help( helper, rgnlabel );
}
!!!1062576.cpp!!!	has_definition(in type_name : string) : bool
for (auto iter = this->type_to_object_.begin(); iter != this->type_to_object_.end(); ++iter )
{
  if (iter->label() == type_name )
  {
    return true;
  }
}
return false;
!!!1062064.cpp!!!	do_read_entry(inout reader : input_base_reader) : bool
if( reader.name() == core::strngs::fstype() )
{
  // --------------------
  // Region type
  reader.duplicate_test( this->type_name_.empty(), this->section_label() );
  std::vector< std::string > keylist{ this->definition_key_list() };
  const std::size_t idx = reader.get_key( "Specie subtype", core::strngs::fstype(), keylist );
  this->type_name_ = keylist.at( idx );
}
else if( reader.name() == core::strngs::fsname() )
{
  // --------------------
  // Region label
  reader.duplicate_test( this->label_.empty(), this->section_label() );
  this->label_ = reader.get_text( "Region label", core::strngs::fsname() );
}
else
{
  // --------------------
  // Region subtype specific parameters
  reader.duplicate_test( 0 == this->parameter_set_.count( reader.name() ), this->section_label() );
  this->parameter_set_.insert( std::make_pair( reader.name(), reader.value() ) );
}
return true;

!!!1061936.cpp!!!	do_read_end(in reader : input_base_reader) : void
//UTILITY_INPUT( not this->type_name_.empty(), str( core::input_error_messages::missing_parameter() % core::strngs::fstype() % this->section_label() ), this->section_label(), &reader );
//UTILITY_INPUT( not this->label_.empty(), str( core::input_error_messages::missing_parameter() % core::strngs::fsname() % this->section_label() ), this->section_label(), &reader );
// We know from having a type name and do_read_entry that a
// type object must exist.
for( auto const& defn : this->type_to_object_ )
{
  if( defn.label() == this->type_name_ )
  {
    // check parameters.
    for( auto const& entry : this->parameter_set_ )
    {
      //UTILITY_INPUT( defn.has_definition( entry.first ), str( core::input_error_messages::invalid_parameter_subtype() % entry.first % this->section_label() % this->type_name_ ), this->section_label(), &reader );
    }
    // build object and add to manager.
    this->manager_->add_region( defn( this->label_, this->parameter_set_, reader ) );
    return;
  }
}
UTILITY_CHECK( false, "Earlier checks for region type should mean we never get here." );
!!!1061808.cpp!!!	do_reset() : void
this->label_.clear();
this->type_name_.clear();
this->parameter_set_.clear();
