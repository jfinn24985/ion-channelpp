class imc_simulation
!!!2098992.cpp!!!	add_definition(inout meta : simulator_meta) : void
std::string desc( "Iterative Monte Carlo simulation. This runs a single equilibration phase then multiple production phases." );
std::unique_ptr< simulation_definition > result( new simulation_definition( type_label_(), desc, &imc_simulation::make_simulation_manager ) );
// extra parameters
std::stringstream labels;
labels << "(";
labels <<  malasics_igcmc::add_to_definition( *result );
labels << "|";
labels << lamperski_igcmc::add_to_definition( *result );
labels << ")";
result->add_definition( { "update", "label", labels.str(), "None", "The type of iterative simulation to perform." } );
result->add_definition( { "niter", "number", ">1", "100", "The number of iterations to perform in a iterative simulation." } );

meta.add_type( result );
!!!488881.cpp!!!	do_description(inout os : ostream) : void
os << " Iterative Monte Carlo Simulation.\n"; 
os << " ---------------------------------\n"; 
this->updater_->description( os );
os << "    number of iterations : " << this->super_loop_size_ << "\n"; 
os << "     current iterations* : " << this->super_loop_count_ + 1; 
os << " (*will be 1 except after restart.)\n";
!!!488881.python!!!	do_description(inout os : ostream) : void
print >>os, " - Number of repeats : ", self.super_loop_size_ 
print >>os, " - Current loop*     : ", self.super_loop_count_ + 1 
print >>os, " (*Will be one except after restart.)"
!!!2098864.cpp!!!	make_simulation_manager(in params : string) : simulation_manager
const std::string number_of_iterations_label{ "niter" };
const std::string updater_label{ "update" };
if( params.find( updater_label ) == params.end() )
{
  throw core::input_error::missing_parameters_error( "Simulation configuration", core::strngs::simulator_label(), updater_label, nullptr );
}
std::unique_ptr< imc_simulation > result{ new imc_simulation };
// make copy of params so we can remove used parameters
std::map< std::string, std::string > subparams( params );

if( subparams.find( number_of_iterations_label ) != subparams.end() )
{
  // -------------------
  std::size_t niter{};
  core::input_base_reader::ordinal_input( number_of_iterations_label, subparams.at( number_of_iterations_label ), "Iterative Monte Carlo", core::strngs::simulator_label(), niter, nullptr );
  if( niter <= 1 )
  {
    throw core::input_error::parameter_value_error( "Iterative Monte Carlo", core::strngs::simulator_label(),  number_of_iterations_label, subparams.at( number_of_iterations_label ), nullptr, "Iterative procedure requires more than one iteration." );
  }
  result->set_loop_size( niter );
  subparams.erase( subparams.find( number_of_iterations_label ) );
}
// subparams.find( "update" ) tested above
{
  // -------------------
  const std::vector< std::string > keys{ malasics_igcmc::type_label_(), lamperski_igcmc::type_label_() };
  std::size_t idx;
  core::input_base_reader::key_input( updater_label, subparams.at( updater_label ), "Iterative Monte Carlo", core::strngs::simulator_label(), idx, keys, nullptr );
  subparams.erase( subparams.find( updater_label ) );
  switch( idx )
  {
  case 0:
    result->updater_ = malasics_igcmc::make_updater( subparams );
    break;
  case 1:
    result->updater_ = lamperski_igcmc::make_updater( subparams );
    break;
  }
}
return boost::shared_ptr< simulation_manager >( result.release() );
!!!458033.cpp!!!	run(inout sim : simulation, inout oslog : ostream) : bool
// do thermalization
oslog << "\n -----------------------";
oslog << "\n Start of Thermalisation";
oslog << "\n -----------------------\n\n";
sim.prepare();
sim.run_loop( this->equilibration_interval() );
oslog << "\n ---------------------";
oslog << "\n End of Thermalisation";
oslog << "\n ---------------------\n\n";

this->updater_->prepare( sim );
// Perform iterations on thermalised simulation.
for( ; this->super_loop_count_ < this->super_loop_size_; ++this->super_loop_count_)
{
  // do main simulation
  oslog << "\n ---------------------------";
  oslog << "\n Start of Iteration [" << (this->super_loop_count_ + 1) << "]\n";
  oslog << "\n ---------------------------\n\n";
  sim.prepare();
  sim.run_loop( this->production_interval() );
  oslog << "\n -------------------------";
  oslog << "\n Update [" << (this->super_loop_count_ + 1) << "]\n";
  oslog << "\n -------------------------\n\n";

  // Perform iteration update
  this->updater_->update( sim, oslog );
  oslog << "\n -------------------------";
  oslog << "\n End of Iteration [" << (this->super_loop_count_ + 1) << "]\n";
  oslog << "\n -------------------------\n\n";

}

return true;
!!!458033.python!!!	run(inout sim : simulation, inout oslog : ostream) : bool
self.super_loop_count_ += 1
old_cpx_list = [ v.excess_potential() for v in sys.get_species() ]

self.do_on_super_loop(sys)

fmt_head = " %3s %8s %8s %8s"
print >>out, "CHEMICAL POTENTIAL ESTIMATE [", self.super_loop_count_, "]"
header = ("SPC","CHEM EX","DLTA_CPX","<CPX>")
print >>out, fmt_head % header
fmt_row  = " %3s %8.4f %8.4f %8.4f"
with open("chex.dat","a") as f:
  for old_cpx, mean, spc in zip( old_cpx_list,self.chem_potential_,sys.get_species() ):
    print >>out, fmt_row % (spc.label(),spc.excess_potential(),(spc.excess_potential()-old_cpx),mean.mean())
    print >>f, fmt_row % (spc.label(),spc.excess_potential(),(spc.excess_potential()-old_cpx),mean.mean()),
    mean.append(spc.excess_potential())
  print >>f,""
!!!2105776.cpp!!!	do_write_part_document(inout wr : input_document, in ix : size_t) : void
wr[ ix ].add_entry( core::strngs::fstype(), this->type_label() );
wr[ ix ].add_entry( core::strngs::fsnstp(), this->super_loop_size_);
this->updater_->do_write_part_document( wr, ix );
