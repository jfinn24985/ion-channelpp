class imc_simulation
!!!488881.cpp!!!	do_description(inout os : ostream) : void
os << " Iterative Monte Carlo Simulation.\n"; 
os << " - Number of repeats : " << this->super_loop_size_ << "\n"; 
os << " - Current loop*     : " << this->super_loop_count_ + 1 << "\n"; 
os << " (*Will be one except after restart.)\n";
this->updater_->description( os );
!!!488881.python!!!	do_description(inout os : ostream) : void
print >>os, " - Number of repeats : ", self.super_loop_size_ 
print >>os, " - Current loop*     : ", self.super_loop_count_ + 1 
print >>os, " (*Will be one except after restart.)"
!!!457265.cpp!!!	prepare(inout sim : simulator) : void
this->updater_->prepare( sim );
!!!457265.python!!!	prepare(inout sim : simulator) : void
# Set up chemex estimator
from estimater import estimater
self.chem_potential_ = []
for i in range( sim.specie_count() ):
  self.chem_potential_.append( estimater() )
!!!2105776.cpp!!!	do_write_part_document(inout wr : input_document, in ix : size_t) : void
wr[ ix ].add_entry( core::strngs::fstype(), this->type_label() );
wr[ ix ].add_entry( core::strngs::fsnstp(), this->super_loop_size_);
this->updater_->do_write_part_document( wr, ix );
!!!458033.cpp!!!	run(inout sim : simulation, inout oslog : ostream) : bool
// do thermalization
oslog << "\n -----------------------";
oslog << "\n Start of Thermalisation";
oslog << "\n -----------------------\n\n";
// This should recursively call out prepare method.
sim.prepare();
sim.run_loop( this->equilibration_interval() );
oslog << "\n ---------------------";
oslog << "\n End of Thermalisation";
oslog << "\n ---------------------\n\n";

// Perform iterations on thermalised simulation.
for( ; this->super_loop_count_ < this->super_loop_size_; ++this->super_loop_count_)
{
  // do main simulation
  oslog << "\n ---------------------------";
  oslog << "\n Start of Iteration [" << (this->super_loop_count_ + 1) << "]\n";
  oslog << "\n ---------------------------\n\n";
  // This should recursively call out prepare method.
  sim.prepare();
  sim.run_loop( this->production_interval() );
  oslog << "\n -------------------------";
  oslog << "\n Update [" << (this->super_loop_count_ + 1) << "]\n";
  oslog << "\n -------------------------\n\n";

  // Perform iteration update
  this->updater_->update( sim, oslog );
  oslog << "\n -------------------------";
  oslog << "\n End of Iteration [" << (this->super_loop_count_ + 1) << "]\n";
  oslog << "\n -------------------------\n\n";

}

return true;
!!!458033.python!!!	run(inout sim : simulation, inout oslog : ostream) : bool
self.super_loop_count_ += 1
old_cpx_list = [ v.excess_potential() for v in sys.get_species() ]

self.do_on_super_loop(sys)

fmt_head = " %3s %8s %8s %8s"
print >>out, "CHEMICAL POTENTIAL ESTIMATE [", self.super_loop_count_, "]"
header = ("SPC","CHEM EX","DLTA_CPX","<CPX>")
print >>out, fmt_head % header
fmt_row  = " %3s %8.4f %8.4f %8.4f"
with open("chex.dat","a") as f:
  for old_cpx, mean, spc in zip( old_cpx_list,self.chem_potential_,sys.get_species() ):
    print >>out, fmt_row % (spc.label(),spc.excess_potential(),(spc.excess_potential()-old_cpx),mean.mean())
    print >>f, fmt_row % (spc.label(),spc.excess_potential(),(spc.excess_potential()-old_cpx),mean.mean()),
    mean.append(spc.excess_potential())
  print >>f,""
!!!2098992.cpp!!!	add_definition(inout meta : simulator_meta) : void
std::string desc( "Iterative Monte Carlo simulation. This runs a single equilibration phase then multiple production phases." );
std::unique_ptr< simulation_definition > result( new simulation_definition( type_label_(), desc, &imc_simulation::make_simulation_manager ) );
// extra parameters
std::stringstream labels;
labels << "(";
labels <<  malasics_igcmc::add_to_definition( *result );
labels << "|";
labels << lamperski_igcmc::add_to_definition( *result );
labels << ")";
result->add_definition( { "update", "label", labels.str(), "None", "The type of iterative simulation to perform." } );

meta.add_type( result );
!!!2098864.cpp!!!	make_simulation_manager(in params : string) : simulation_manager
UTILITY_CHECK( not params.empty(), "IMC simulation manager requires parameters." );
UTILITY_INPUT( params.find( "update" ) != params.end(), "Iterative Monte Carlo simulation requires parameter \"update\".", "simulation_manager", nullptr );
std::unique_ptr< imc_simulation > result{ new imc_simulation };
// if( params.find( "update" ) != params.end() )
{
  // -------------------
  const std::string label{ params.at( "update" ) };
  UTILITY_INPUT( not label.empty(), "Iterative Monte Carlo parameter \"update\" requires a value.", "simulation_manager", nullptr );
  if( 0 == malasics_igcmc::type_label_().find( label ) )
  {
    result->updater_ = malasics_igcmc::make_updater( params );
  }
  else if ( 0 == lamperski_igcmc::type_label_().find( label ) )
  {
    result->updater_ = lamperski_igcmc::make_updater( params );
  }
  else
  {
    const bool known_label{ false };
    UTILITY_INPUT( known_label, "Iterative Monte Carlo parameter \"update\" value \""+label+"\" is not a known updater type.", "simulation_manager", nullptr );
  }
}
return boost::shared_ptr< simulation_manager >( result.release() );
