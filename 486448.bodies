class membrane_cylinder_region
!!!1106224.cpp!!!	do_change_volume(in vol : double, in rad : double) : void
// **This region ignores rad argument**
// Maintain halflength/radius ratio
//
//  vol = 2 * HL * pi * R * R
//
//  if C = HL/R then HL = C.R
//
//  vol = 2 * pi * C * R**3
//
const double ratio { this->half_length() / this->radius() };

this->set_radius( std::cbrt( vol / (2 * ratio * core::constants::pi() ) ) );

this->set_half_length( vol / ( 2 * core::constants::pi() * std::pow( this->radius(), 2 ) ) );
!!!1144496.cpp!!!	do_extent(out small_corner : coordinate, out big_corner : coordinate, in radius : double) : void
big_corner.x = this->radius() - radius;
big_corner.y = big_corner.x;
big_corner.z = this->channel_half_length() + this->half_length() - radius;
small_corner.x = -big_corner.x;
small_corner.y = -big_corner.y;
small_corner.z = -big_corner.z;
!!!1106480.cpp!!!	do_is_inside(in pos : coordinate, in radius : double) : bool
// Absolute Z position
const double abs_z_pos { std::abs( pos.z ) };
// Radial position
const double radial_sq_pos { pos.x * pos.x + pos.y * pos.y };
// Radius of channel mouth at at the membrane surface (tube radius + arc
// radius)
const double mouth_radius { this->channel_radius_ + this->arc_radius_ };

// Outside of membrane
if( abs_z_pos >= ( this->channel_half_length_ + radius ) )
{
  // check if outside extreme of compartment in r and z?
  return not( radial_sq_pos > std::pow( this->radius()  - radius, 2 )
              or abs_z_pos > ( this->half_length() + this->channel_half_length_ - radius ) );
}

// (else inside membrane and) Within channel cylinder inner-radius?
if( radial_sq_pos <= std::pow( this->channel_radius_ - radius, 2 ) )
{
  return true;
}

// Not in vestibule OR Outside maximum vestibule radius means overlap
if( abs_z_pos <= ( this->channel_half_length_ - this->arc_radius_ )
   or radial_sq_pos > std::pow( mouth_radius, 2 ) )
{
  return false;
}

// Outside channel radius but may be in the arc zone. We can
// calculate the maximum radius allowed for the sphere based
// on the z-offset (dz) and adjusted arc radius (r) and ddr:
//    ddr * ddr + dz * dz = r * r
// where ddr is the radial distance from the arc centrepoint 
// towards the axis of rotation. The maximum allowed radius
// is then the radius of the arc centrepoint less ddr.
const double ddr
{
   std::sqrt( std::pow( this->arc_radius_ + radius, 2 ) - std::pow( abs_z_pos - ( this->channel_half_length_ - this->arc_radius_ ), 2 ) )
};
const double r2maximum 
{
   std::pow( this->channel_radius_ + this->arc_radius_ - ddr, 2 )
};
return ( radial_sq_pos <= r2maximum );

!!!2042800.cpp!!!	do_make_gridder(inout rgenr : random_distribution, in count : size_t) : grid_generator
boost::shared_ptr< grid_generator > result;
result.reset( new split_tube_grid( this->channel_half_length_, 2*this->half_length(), this->radius(), count, rgenr ) );
return result;
!!!2042672.cpp!!!	do_make_gridder(in spacing : double, inout rgenr : random_distribution) : grid_generator
boost::shared_ptr< grid_generator > result;
result.reset( new split_tube_grid( this->channel_half_length_, 2*this->half_length(), this->radius(), spacing, rgenr ) );
return result;
!!!1106608.cpp!!!	do_new_position(inout rgnr : random_distribution, in radius : double) : coordinate
// A random position anywhere in cell
geometry::coordinate pos( 0.0, 0.0, 0.0 );
constexpr double pi = core::constants::pi();
// Generate z coordinate:
const double reduced_cell_radius { this->radius() - radius };
const double compartment_factor { std::pow( reduced_cell_radius, 2 ) * pi * (this->half_length() - 2 * radius) };

const double reduced_channel_radius { this->channel_radius() - radius };
const double inner_channel_factor { std::pow( reduced_channel_radius, 2 ) * pi * (this->channel_half_length_ - this->arc_radius_) };

const double vestibule_factor { volume_of_rotation( this->channel_radius_ + this->arc_radius_, this->arc_radius_ + radius ) };

// full factor is volume in one half of cell
const double full_factor { compartment_factor + inner_channel_factor + vestibule_factor };
const double zfactor = rgnr.uniform( -full_factor, full_factor );
const double abs_zfactor{ std::abs( zfactor ) };

double max_radius {};
// calculate z pos and radius
if ( abs_zfactor >= inner_channel_factor + vestibule_factor )
{
  // in compartment volume
  pos.z = abs_zfactor - (inner_channel_factor + vestibule_factor);
  // Now linear in compartment volume, reduce to length
  pos.z /= (std::pow( reduced_cell_radius, 2 ) * pi);
  // in cell compartment
  pos.z += this->channel_half_length_ + radius;
  if (zfactor < 0)
  {
    pos.z = -pos.z;
  }
  max_radius = reduced_cell_radius;
}
else if ( abs_zfactor <= inner_channel_factor )
{
  pos.z = (abs_zfactor / (std::pow( reduced_channel_radius, 2 ) * pi));
  if (zfactor < 0)
  {
    pos.z = -pos.z;
  }
  // fully in channel
  max_radius = this->channel_radius_ - radius;
}
else
{
  // in channel vestibule: z is non-linear in volume
  //
  // NOTE abs_zfactor = volume_of_rotation(0, R, r, 0, z)
  //  where R = channel_radius + arc_radius
  //        r = arc_radius + radius
  //        z = unknown z coordinate
  //
  // derivative of volume_of_rotation is:
  //  pi{R^2 + r^2 - z^2 - R(sqrt(r^2 - z^2) - 2*z/sqrt(r^2 - z^2) + rcos(z/r)}
  const double RR = this->channel_radius_ + this->arc_radius_;
  const double rr = this->arc_radius_ + radius;
  auto deriv= [RR,rr,pi](double zz)->double
  {
    double sqt = std::sqrt(rr*rr - zz*zz);
    return pi * ( RR*RR + rr*rr - zz*zz - RR * ( sqt - (2*zz/sqt) + rr *std::cos(zz/rr)));
  };
  double vol { abs_zfactor - inner_channel_factor };
  UTILITY_CHECK( vol < vestibule_factor, "Error in logic, not in expected volume" );
  // first guess is linear approx
  double zguess = rr * vol / vestibule_factor;
  // do four Newton/Raphson steps
  //  f(z) = volume_of_rotation(0, RR, rr, 0, z) - vol = 0
  //  f'(z) = deriv(z)
  for (std::size_t ii = 0; ii < 4; ++ii)
  {
    zguess -= (volume_of_rotation(0.0, RR, rr, 0.0, zguess) - vol)/deriv(zguess);
  }
  UTILITY_CHECK( zguess >= 0.0, "Error in calculating z in vestibule" );
  UTILITY_CHECK( zguess <= rr, "Error in calculating z in vestibule" );
  // bound zguess to 0 <-> this->arc_radius_ + radius
  zguess = zguess < 0.0 ? 0.0 : ( zguess > rr ? rr : zguess );
  pos.z = this->channel_half_length_ - this->arc_radius_ + zguess;
  if (zfactor < 0)
  {
    pos.z = -pos.z;
  }
  //
  // closest approach at pos.z is when 
  //
  //  ddr * ddr + z * z = r * r 
  // 
  //  where ddr is distance from arc centrepoint. This
  //  gives final radius as
  //
  //  max_radius = channel_radius + arc_radius - ddr
  const double ddr_sq { std::pow(rr, 2) - std::pow(zguess,2) };
  max_radius = RR - std::sqrt( ddr_sq );
  
}
// volume distribution is linear in square of radius and phi
const double r( std::sqrt(rgnr.uniform( std::pow(max_radius, 2 ) ) ) );
const double phi( rgnr.uniform( 0.0, core::constants::pi() * 2 ) );
pos.x = r * std::cos( phi );
pos.y = r * std::sin( phi );
//UTILITY_ENSURE( this->is_inside( pos, radius ), "Error in calculating new position." );
return pos;


!!!1310128.cpp!!!	do_write_document(inout wr : input_document, in ix : size_t) : void
const std::string half_length_label { "half-length" };
const std::string radius_label { "radius" };
const std::string offset_label { "channel-half-length" };
const std::string tube_radius_label { "channel-radius" };
const std::string arc_label { "arc" };
wr[ix].add_entry( core::strngs::fstype(), type_label() );
wr[ix].add_entry( half_length_label, this->half_length() );
wr[ix].add_entry( radius_label, this->radius() );
wr[ix].add_entry( arc_label, this->arc_radius() );
wr[ix].add_entry( offset_label, this->channel_half_length() );
wr[ix].add_entry( tube_radius_label, this->channel_radius() );

!!!1107120.cpp!!!	region_factory(in label : string, in params : string, in reader : input_base_reader) : base_region
// needed information
// label : from label arg
// radius : from param arg
// half_length : from param arg
// offset : from param arg
// arc_radius : from param arg
// tube_radius : from param arg
double half_length {};
double radius {};
double offset {};
double tube_radius {};
double arc_radius {};

const std::string half_length_label { "half-length" };
const std::string radius_label { "radius" };
const std::string offset_label { "channel-half-length" };
const std::string tube_radius_label { "channel-radius" };
const std::string arc_label { "arc" };
{
  std::string bad_params;
  // check for required parameters.
  if( params.count( half_length_label ) == 0 ) bad_params = half_length_label;
  if( params.count( radius_label ) == 0 ) bad_params += (bad_params.empty() ? "": " ") + radius_label;
  if( params.count( offset_label ) == 0 ) bad_params += (bad_params.empty() ? "": " ") + offset_label;
  if( params.count( arc_label ) == 0 ) bad_params += (bad_params.empty() ? "": " ") + arc_label;
  if( not bad_params.empty() ) reader.missing_parameters_error( "Membrane cell", core::strngs::fsregn(), bad_params );
}

core::input_base_reader::float_input( half_length_label, params.at( half_length_label ), "Cell membrane region", core::strngs::fsregn(), half_length, true, false, &reader );

core::input_base_reader::float_input( radius_label, params.at( radius_label ), "Cell membrane region", core::strngs::fsregn(), radius, true, false, &reader );

core::input_base_reader::float_input( offset_label, params.at( offset_label ), "Cell membrane region", core::strngs::fsregn(), offset, true, false, &reader );

core::input_base_reader::float_input( tube_radius_label, params.at( tube_radius_label ), "Cell membrane region", core::strngs::fsregn(), tube_radius, true, false, &reader );

core::input_base_reader::float_input( arc_label, params.at( arc_label ), "Cell membrane region", core::strngs::fsregn(), arc_radius, true, false, &reader );

// build region object.
boost::shared_ptr< geometry::base_region > current;
current.reset( new membrane_cylinder_region( label, radius, half_length, offset, tube_radius, arc_radius ) );
return current;



!!!1107248.cpp!!!	add_definition(inout meta : region_meta) : void
std::string desc( "A Cylindrical region centred on the origin with the linear axis in z direction. All walls are considered hard. The cylinder has a membrane splitting the cell in the centre providing two compartments. A tube with rounded ends links these two compartments. This region may be used as a system region." );
std::unique_ptr< region_definition > cylinder_defn( new region_definition( type_label(), desc, &membrane_cylinder_region::region_factory ) );
cylinder_defn->add_definition( { "radius", "distance in Angstrom", ">0", "required", "The radius of the cylinder in the XY plane." } );
cylinder_defn->add_definition( { "half-length", "distance in Angstrom", ">0", "required", "Half the length of the cylinder. The cylinder is centred on the origin so: offset <= |z| <= half-length + offset." } );
cylinder_defn->add_definition( { "channel-length", "distance in Angstrom", ">0", "required", "Half the length of the channel between the two cell compartments." } );
cylinder_defn->add_definition( { "channel-radius", "distance in Angstrom", ">0", "required", "The radius of the channel between the two cell compartments." } );
cylinder_defn->add_definition( { "arc-radius", "distance in Angstrom", ">0", "required", "The radius of the arc that rounds the channel ends into the membrane." } );
meta.add_definition( cylinder_defn );
!!!1114416.cpp!!!	volume_of_rotation(in axial_disp : double, in radial_disp : double, in arc_radius : double, in z_0 : double, in z_1 : double) : double
UTILITY_REQUIRE(arc_radius < radial_disp, "The arc radius must be smaller than the radial offset.");
UTILITY_REQUIRE(not utility::feq(z_0,z_1), "Z0 can not equal Z1.");
UTILITY_REQUIRE(z_0 < z_1, "Z0 must be less than Z1.");
const double z1bar_ (z_1 - axial_disp);
const double z0bar_ (z_0 - axial_disp);
UTILITY_REQUIRE(z0bar_ >= axial_disp - arc_radius, "Z0 must be within one arc_radius of axial_disp.");
UTILITY_REQUIRE(z1bar_ <= axial_disp + arc_radius, "Z0 must be within one arc_radius of axial_disp.");

const double arc_r2 (std::pow(arc_radius,2));
if (utility::feq(z0bar_, 0.0))
{
   // Handle case where x0 = xc --> z0bar_ = 0
   return core::constants::pi()
          * (
             (std::pow(radial_disp,2) + arc_r2) * (z_1 - z_0)
             - std::pow(z1bar_,3)/3.0
             - radial_disp * (z1bar_ * std::sqrt(arc_r2 - std::pow(z1bar_,2))
                              + arc_r2 * asin(z1bar_/arc_radius))
          );
}
else if (utility::feq(z1bar_, arc_radius))
{
   // handle case where x1 = xc + r --> z1bar_ = r)
   return core::constants::pi()
          * (
             (std::pow(radial_disp,2) + arc_r2) * (z_1 - z_0)
             + (std::pow(z0bar_,3) - std::pow(z1bar_,3))/3.0
             - radial_disp * (arc_r2 * core::constants::pi() / 4.0)
             + radial_disp * (z0bar_ * std::sqrt(arc_r2 - std::pow(z0bar_,2))
                              + arc_r2 * std::asin(z0bar_/arc_radius))
          );
}
else
{
   return core::constants::pi()
          * (
             (std::pow(radial_disp,2) + arc_r2) * (z_1 - z_0)
             + (std::pow(z0bar_,3) - std::pow(z1bar_,3))/3.0
             - radial_disp * (z1bar_ * std::sqrt(arc_r2 - std::pow(z1bar_,2))
                              + arc_r2 * std::asin(z1bar_/arc_radius))
             + radial_disp * (z0bar_ * sqrt(arc_r2 - std::pow(z0bar_,2))
                              + arc_r2 * std::asin(z0bar_/arc_radius))
          );
}

