class storage_manager
!!!1835440.cpp!!!	serialize(inout ar : Archive, in version : unsigned int) : void
ar & checkpoint_name_;
ar & filename_base_;
ar & output_dir_fmt_;
ar & output_name_;
ar & run_number_;
!!!1848496.cpp!!!	open_sink_by_extension(in fpath : path, in def_ext : string) : base_sink
std::string ext = fpath.extension().native();
boost::shared_ptr< utility::base_sink > result; 
if ( ext.empty() )
{
  ext = def_ext;
}
if( ext.find( "zip" ) < ext.size() )
{
  // ZIP archive
  result.reset( new utility::archive_file( fpath.native() ) );
}
else if( ext.find( "dbm" ) < ext.size() )
{
  // GDBM/DBM archive
  result.reset( new utility::gdbm_sink( fpath.native() ) );
}
else if( ext.find( "mem" ) < ext.size() )
{
  // in-memory sink
  result.reset( new utility::memory_sink( fpath.native() ) );
}
else
{
  const bool known_extension( false );
  UTILITY_INPUT( known_extension, "Output fileextension["+ext+"] is not one of (zip|dbm|mem)", core::strngs::simulator_label(), nullptr );
}
return result;
!!!1841200.cpp!!!	checkpoint_path() : std::string
UTILITY_INPUT( not this->checkpoint_name().empty()
               , "No name for the checkpoint file."
               , core::strngs::simulator_label(), nullptr );
boost::filesystem::path cpath( this->compute_output_dir() );
cpath /= this->checkpoint_name();
return cpath.native();
!!!1841840.cpp!!!	output_path() : std::string
UTILITY_INPUT( not this->output_name().empty()
               , "No name for the output file."
               , core::strngs::simulator_label(), nullptr );
boost::filesystem::path cpath( this->compute_output_dir() );
cpath /= this->output_name();
return cpath.native();
!!!1759792.cpp!!!	get_log() : ostream
if( not this->log_ )
{
  this->log_ = this->open_log();
}
return *(this->log_);
