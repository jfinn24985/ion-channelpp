class estimater_test_fw
!!!327601.cpp!!!	estimater_test_fw()
: var(31ul)
, data4(100, 4.0)
, data5(100, 5.0)
, data6(100, 6.0)
, data_index(100)
, mean(5.2874135167)
, svar (48.9042830931402)
, variance (47.32672557400666)
{
  for (std::size_t ith = 0; ith != 100; ++ith) data_index[ith] = ith;
  var[ 0] =      5.5516621838;
  var[ 1] =      0.2100560162;
  var[ 2] =      0.592851646;
  var[ 3] =      0.7387133442;
  var[ 4] =      0;
  var[ 5] =      0.0603448137;
  var[ 6] =      0.0399201735;
  var[ 7] =      8.3830492441;
  var[ 8] =     10.6720101019;
  var[ 9] =      8.5243113113;
  var[10] =      0.8336070837;
  var[11] =      0.7854093157;
  var[12] =      0.4436615558;
  var[13] =     14.1975433413;
  var[14] =      25.657982967;
  var[15] =      6.8852868479;
  var[16] =      0.3215328372;
  var[17] =      4.4619749979;
  var[18] =      0.017607702;
  var[19] =     21.0264223786;
  var[20] =     19.0367584515;
  var[21] =      6.7498704974;
  var[22] =      0.5602527081;
  var[23] =     13.1845872369;
  var[24] =      0.4063910795;
  var[25] =      0.3934774747;
  var[26] =      1.0065240381;
  var[27] =      0.0302535373;
  var[28] =      0.0973062654;
  var[29] =      8.2189127477;
  var[30] =      4.8215371193;
}


!!!327857.cpp!!!	estimater_lifetime() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  // TEST: default ctor
  utility::estimater var1;
  //
  // Test that initial values are well-defined
  BOOST_REQUIRE(var1.count() == 0);
  BOOST_REQUIRE(utility::feq(var1.mean(), 0.0));
  BOOST_REQUIRE(utility::feq(var1.variance(), 0.0));
}
{
  utility::estimater var1;

  // TEST: copy constructor on empty object
  utility::estimater var2(var1);

  // var1 should be unchanged
  BOOST_CHECK_EQUAL(var1.count(), 0);
  BOOST_CHECK(utility::feq(var1.mean(), 0.0));
  BOOST_CHECK(utility::feq(var1.variance(), 0.0));
  // var2 should have the same data as var1
  BOOST_CHECK_EQUAL(var1.mean(), var2.mean());
  BOOST_CHECK_EQUAL(var1.variance(), var2.variance());
  BOOST_CHECK_EQUAL(var1.count(), var2.count());
}
{
  utility::estimater var1;
  // Insert some values (using raw pointers)
  var1.insert(&exemplar.var[0], &exemplar.var[31]);

  // TEST: copy constructor on object with data
  utility::estimater var2(var1);

  // var1 should be unchanged
  BOOST_CHECK_EQUAL(var1.count(), 31);
  BOOST_CHECK(utility::feq(var1.mean(), exemplar.mean));
  BOOST_CHECK(utility::feq(var1.variance(), exemplar.svar, 1<<9));
  // var2 should have the same data as var1
  BOOST_CHECK_EQUAL(var1.mean(), var2.mean());
  BOOST_CHECK_EQUAL(var1.variance(), var2.variance());
  BOOST_CHECK_EQUAL(var1.count(), var2.count());
}
{
  utility::estimater var1;
  // Insert some values (using iterators)
  var1.insert(exemplar.var.begin(), exemplar.var.end());

  // TEST: assignment
  utility::estimater var2;
  // insert some values (insert limited set of values using raw pointers)
  var2.insert(&exemplar.var[0], &exemplar.var[11]);
  // assignment should overwrite existing data
  var2 = var1;

  // var1 should be unchanged
  BOOST_CHECK_EQUAL(var1.count(), 31);
  BOOST_CHECK(utility::feq(var1.mean(), exemplar.mean));
  BOOST_CHECK(utility::feq(var1.variance(), exemplar.svar, 1<<9));
  // var2 should have the same data as var1
  BOOST_CHECK_EQUAL(var1.mean(), var2.mean());
  BOOST_CHECK_EQUAL(var1.variance(), var2.variance());
  BOOST_CHECK_EQUAL(var1.count(), var2.count());
}
{
  std::stringstream store;
  {
    utility::estimater var1;
    var1.insert(exemplar.var.begin(), exemplar.var.end());
    boost::archive::text_oarchive oa(store);
    // write class instance to archive
    oa << var1;
    // var1 should be unchanged
    BOOST_CHECK_EQUAL(var1.count(), 31);
    BOOST_CHECK(utility::feq(var1.mean(), exemplar.mean));
    BOOST_CHECK(utility::feq(var1.variance(), exemplar.svar, 1<<9));
  }
  {
    utility::estimater var2;
    boost::archive::text_iarchive ia(store);
    // read class instance to archive
    ia >> var2;
    // var2 should have the same data as var1 had
    BOOST_CHECK_EQUAL(var2.count(), 31);
    BOOST_CHECK(utility::feq(var2.mean(), exemplar.mean));
    BOOST_CHECK(utility::feq(var2.variance(), exemplar.svar, 1<<9));
  }
}



!!!327985.cpp!!!	estimater_data_collection() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  utility::estimater test_var;
  // TEST: default ctor
  //
  // Test that initial values are well-defined
  BOOST_CHECK_EQUAL(test_var.count(), 0);
  BOOST_REQUIRE(utility::feq(test_var.mean(), 0.0));
  BOOST_REQUIRE(utility::feq(test_var.variance(), 0.0));
}
{
  utility::estimater test_var;
  // TEST: append method
  for (auto val : exemplar.var)
  {
    test_var.append(val);
  }
  BOOST_CHECK_EQUAL(test_var.count(), 31);
  BOOST_CHECK(utility::feq(test_var.mean(), exemplar.mean));
  BOOST_CHECK(utility::feq(test_var.variance(), exemplar.svar));
}
{
  // TEST: insert method
  utility::estimater test_var;

  test_var.insert(&exemplar.var[0], &exemplar.var[31]);

  BOOST_CHECK_EQUAL(test_var.count(), 31);
  BOOST_CHECK(utility::feq(test_var.mean(), exemplar.mean));
  BOOST_CHECK(utility::feq(test_var.variance(), exemplar.svar));

  // TEST: reset returns to well-defined values
  test_var.reset ();

  BOOST_CHECK_EQUAL(test_var.count(), 0);
  BOOST_CHECK(utility::feq(test_var.mean(), 0.0));
  BOOST_CHECK(utility::feq(test_var.variance(), 0.0));

  // Check that reinserting value gives the
  // same results after the reset.
  test_var.insert(&exemplar.var[0], &exemplar.var[31]);

  BOOST_CHECK_EQUAL(test_var.count(), 31);
  BOOST_CHECK(utility::feq(test_var.mean(), exemplar.mean));
  BOOST_CHECK(utility::feq(test_var.variance(), exemplar.svar));
}

!!!329009.cpp!!!	basic_mean_lifetime() : void

estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  // TEST: default ctor
  utility::basic_mean var1;
  //
  // Test that initial values are well-defined
  BOOST_REQUIRE(utility::feq(var1.mean(), 0.0));
  BOOST_REQUIRE(utility::feq(var1.variance(0), 0.0));
  // Test that initial values are well-defined for
  // invalid counts
  BOOST_REQUIRE(utility::feq(var1.mean(), 0.0));
  BOOST_REQUIRE(utility::feq(var1.variance(1), 0.0));
  BOOST_REQUIRE(utility::feq(var1.variance(2), 0.0));
}
{
  utility::basic_mean var1;

  // TEST: copy constructor on empty object
  utility::basic_mean var2(var1);

  // var1 should be unchanged
  BOOST_CHECK(utility::feq(var1.mean(), 0.0));
  BOOST_CHECK(utility::feq(var1.variance(0), 0.0));
  // var2 should have the same data as var1
  BOOST_CHECK_EQUAL(var1.mean(), var2.mean());
  BOOST_CHECK_EQUAL(var1.variance(0), var2.variance(0));
}
{
  utility::basic_mean var1;
  // Insert some values
  std::size_t count = 0;
  for (auto val : exemplar.var)
  {
    ++count;
    var1.append(val, count);
  }

  // TEST: copy constructor on object with data
  utility::basic_mean var2(var1);

  // var1 should be unchanged
  BOOST_CHECK(utility::feq(var1.mean(), exemplar.mean));
  BOOST_CHECK(utility::feq(var1.variance(31), exemplar.svar, 1<<9));
  // var2 should have the same data as var1
  BOOST_CHECK_EQUAL(var1.mean(), var2.mean());
  BOOST_CHECK_EQUAL(var1.variance(31), var2.variance(31));
}
{
  utility::basic_mean var1;
  // Insert some values
  for (std::size_t count = 0; count != exemplar.var.size(); ++count)
  {
    var1.append(exemplar.var[count], count + 1);
  }
  // assert match to canonical pattern
  {
    pattern_test::canonical< utility::basic_mean, false, true >( var1, {} );
  }
  // TEST: assignment
  utility::basic_mean var2;
  // insert some values
  const size_t sz (exemplar.var.size()/2);
  for (std::size_t count = 0; count != sz; ++count)
  {
    var2.append(exemplar.var[count], count + 1);
  }
  const double mean2 = var2.mean();
  const double varnc2 = var2.variance(2);
  // assignment should overwrite existing data
  var2 = var1;

  // var1 should be unchanged
  BOOST_CHECK_EQUAL(var1.mean(), exemplar.mean);
  BOOST_CHECK(utility::feq(var1.mean(), exemplar.mean));
  BOOST_CHECK(utility::feq(var1.variance(31), exemplar.svar, 1<<9));
  // var2 should have the same data as var1
  BOOST_CHECK_EQUAL(var1.mean(), var2.mean());
  BOOST_CHECK(var2.mean() != mean2);
  BOOST_CHECK_EQUAL(var1.variance(31), var2.variance(31));
  BOOST_CHECK(var2.variance(31) != varnc2);
}
{
  std::stringstream store;
  {
    utility::basic_mean var1;
    for (std::size_t count = 0; count != exemplar.var.size(); ++count)
    {
      var1.append(exemplar.var[count], count + 1);
    }

    boost::archive::text_oarchive oa(store);
    // write class instance to archive
    oa << var1;
    // var1 should be unchanged
    BOOST_CHECK(utility::feq(var1.mean(), exemplar.mean));
    BOOST_CHECK(utility::feq(var1.variance(31), exemplar.svar, 1<<9));
  }
  {
    utility::basic_mean var2;
    boost::archive::text_iarchive ia(store);
    // read class instance to archive
    ia >> var2;
    // var2 should have the same data as var1 had
    BOOST_CHECK(utility::feq(var2.mean(), exemplar.mean));
    BOOST_CHECK(utility::feq(var2.variance(31), exemplar.svar, 1<<9));
  }

}




!!!335793.cpp!!!	basic_mean_data_collection() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  utility::basic_mean test_var;
  // TEST: default ctor
  //
  // Test that initial values are well-defined
  BOOST_REQUIRE(utility::feq(test_var.mean(), 0.0));
  BOOST_REQUIRE(utility::feq(test_var.variance(0), 0.0));
}
{
  utility::basic_mean test_var;
  std::size_t count = 0;
  // TEST: append method
  for (auto val : exemplar.var)
  {
    ++count;
    test_var.append(val, count);
  }
  BOOST_CHECK_EQUAL(count, 31);
  BOOST_CHECK(utility::feq(test_var.mean(), exemplar.mean));
  BOOST_CHECK(utility::feq(test_var.variance(count), exemplar.svar));

  // TEST: reset returns to well-defined values
  test_var.reset ();

  BOOST_CHECK(utility::feq(test_var.mean(), 0.0));
  BOOST_CHECK(utility::feq(test_var.variance(0), 0.0));

  // Check that reinserting value gives the
  // same results after the reset.
  count = 0;
  for (auto val : exemplar.var)
  {
    ++count;
    test_var.append(val, count);
  }
  BOOST_CHECK_EQUAL(count, 31);
  BOOST_CHECK(utility::feq(test_var.mean(), exemplar.mean));
  BOOST_CHECK(utility::feq(test_var.variance(count), exemplar.svar));

}

!!!356657.cpp!!!	estimate_array_lifetime() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  // Default ctor
  utility::estimate_array var;

  BOOST_CHECK_EQUAL(var.count(), 0ul);
  BOOST_CHECK_EQUAL(var.size(), 0ul);

  // Resize array
  var.resize (25);

  BOOST_CHECK_EQUAL(var.count(), 0ul);
  BOOST_CHECK_EQUAL(var.size(), 25ul);
}
{
  // Ctor with size
  utility::estimate_array var (100);

  BOOST_CHECK_EQUAL(var.count(), 0ul);
  BOOST_CHECK_EQUAL(var.size(), 100ul);
}
{
  // Test of copy and serialization
  std::stringstream store;
  {
    utility::estimate_array var (100);

    var.append (exemplar.data4.begin(), exemplar.data4.end());
    var.append (exemplar.data5.begin(), exemplar.data5.end());
    var.append (exemplar.data6.begin(), exemplar.data6.end());

    BOOST_CHECK_EQUAL(var.count(), 3ul);
    BOOST_CHECK_EQUAL(var.size(), 100ul);
    for (std::size_t ith = 0; ith != var.size(); ++ith)
    {
      BOOST_CHECK_EQUAL(var.mean(ith), 5.0);
      BOOST_CHECK_EQUAL(var.variance(ith), 1.0);
    }

    utility::estimate_array var_copy (var);
    BOOST_CHECK_EQUAL(var_copy.count(), 3ul);
    BOOST_CHECK_EQUAL(var_copy.size(), 100ul);
    for (std::size_t ith = 0; ith != var_copy.size(); ++ith)
    {
      BOOST_CHECK_EQUAL(var_copy.mean(ith), 5.0);
      BOOST_CHECK_EQUAL(var_copy.variance(ith), 1.0);
    }

    boost::archive::text_oarchive oa(store);

    // write class instance to archive
    oa << var;
    // var should be unchanged
    BOOST_CHECK_EQUAL(var.count(), 3ul);
    BOOST_CHECK_EQUAL(var.size(), 100ul);
    for (std::size_t ith = 0; ith != var.size(); ++ith)
    {
      BOOST_CHECK_EQUAL(var.mean(ith), 5.0);
      BOOST_CHECK_EQUAL(var.variance(ith), 1.0);
    }

  }
  {
    utility::estimate_array var;
    BOOST_CHECK_EQUAL(var.count(), 0ul);
    BOOST_CHECK_EQUAL(var.size(), 0ul);
    boost::archive::text_iarchive ia(store);
    // read class instance from archive
    ia >> var;
    // var should have the same data as var1 had
    BOOST_CHECK_EQUAL(var.size(), 100ul);
    BOOST_CHECK_EQUAL(var.count(), 3ul);
    for (std::size_t ith = 0; ith != var.size(); ++ith)
    {
      BOOST_CHECK_EQUAL(var.mean(ith), 5.0);
      BOOST_CHECK_EQUAL(var.variance(ith), 1.0);
    }
  }
}

!!!356785.cpp!!!	estimate_array_data_collection() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  // TESTS FOR CORRECTNESS
  utility::estimate_array var (100);

  // Insure start from zero
  BOOST_CHECK_EQUAL(var.count(), 0ul);
  BOOST_CHECK_EQUAL(var.size(), 100ul);
  for (std::size_t ith = 0; ith != var.size(); ++ith)
  {
    BOOST_CHECK_EQUAL(var.mean(ith), 0.0);
    BOOST_CHECK_EQUAL(var.variance(ith), 0.0);
  }

  // Add first data points (all 4.0)
  var.append (exemplar.data4.begin(), exemplar.data4.end());
  BOOST_CHECK_EQUAL(var.count(), 1ul);
  for (std::size_t ith = 0; ith != var.size(); ++ith)
  {
    BOOST_CHECK_EQUAL(var.mean(ith), 4.0);
    BOOST_CHECK_EQUAL(var.variance(ith), 0.0);
  }

  // Add second data points (all 5.0)
  var.append (exemplar.data5.begin(), exemplar.data5.end());

  BOOST_CHECK_EQUAL(var.count(), 2ul);
  for (std::size_t ith = 0; ith != var.size(); ++ith)
  {
    BOOST_CHECK_EQUAL(var.mean(ith), 4.5);
    BOOST_CHECK_EQUAL(var.variance(ith), 0.5);
  }

  // Add third data points (all 6.0)
  var.append (exemplar.data6.begin(), exemplar.data6.end());

  BOOST_CHECK_EQUAL(var.count(), 3ul);
  for (std::size_t ith = 0; ith != var.size(); ++ith)
  {
    BOOST_CHECK_EQUAL(var.mean(ith), 5.0);
    BOOST_CHECK_EQUAL(var.variance(ith), 1.0);
  }

  // Add fourth data points (from 1.0, 2.0, ... 100.0)
  var.append (exemplar.data_index.begin(), exemplar.data_index.end());

  BOOST_CHECK_EQUAL(var.count(), 4ul);
  double val = 0.0;
  for (std::size_t ith = 0; ith != var.size(); ++ith)
  {
    auto sqr = [](double a)
    {
      return a*a;
    };
    const double mean(3.75+val/4.0);
    const double variance((sqr(4-mean) + sqr(5-mean) + sqr(6-mean) + sqr(val - mean))/3.0);
    BOOST_CHECK(utility::feq(var.mean(ith),mean));
    BOOST_CHECK(utility::feq(var.variance(ith),variance));
    val += 1.0;
  }
}
{
  // BAD DATA
  {
    // DATA TOO SHORT for ARRAY
    utility::estimate_array var (110);

    // Insure start from zero
    BOOST_CHECK_EQUAL(var.count(), 0ul);
    BOOST_CHECK_EQUAL(var.size(), 110ul);

    // Add first data points (all 4.0)
    auto last = var.append (exemplar.data4.begin(), exemplar.data4.end());
    BOOST_CHECK(last == exemplar.data4.end());
    BOOST_CHECK_EQUAL(var.count(), 1ul);
    for (std::size_t ith = 0; ith != var.size(); ++ith)
    {
      if (ith < exemplar.data4.size())
      {
        BOOST_CHECK_EQUAL(var.mean(ith), 4.0);
        BOOST_CHECK_EQUAL(var.variance(ith), 0.0);
      }
      else
      {
        BOOST_CHECK_EQUAL(var.mean(ith), 0.0);
        BOOST_CHECK_EQUAL(var.variance(ith), 0.0);
      }
    }
  }
  {
    // DATA TOO LONG for ARRAY
    utility::estimate_array var (90);

    // Insure start from zero
    BOOST_CHECK_EQUAL(var.count(), 0ul);
    BOOST_CHECK_EQUAL(var.size(), 90ul);

    // Add first data points (all 4.0)
    auto last = var.append (exemplar.data4.begin(), exemplar.data4.end());
    BOOST_CHECK(last == exemplar.data4.end()-10);
    BOOST_CHECK_EQUAL(var.count(), 1ul);
    for (std::size_t ith = 0; ith != var.size(); ++ith)
    {
      BOOST_CHECK_EQUAL(var.mean(ith), 4.0);
      BOOST_CHECK_EQUAL(var.variance(ith), 0.0);
    }
  }

}




!!!355889.cpp!!!	estimate_2d_lifetime() : void
estimater_test_fw const& exemplar( estimater_test_fw::exmplr );
{
  // Default ctor
  utility::estimate_2d var;

  BOOST_CHECK_EQUAL( var.count(), 0ul );
  BOOST_CHECK_EQUAL( var.shape()[0], 0ul );
  BOOST_CHECK_EQUAL( var.shape()[1], 0ul );

  // Resize array
  var.resize( {{4,25}} );

  BOOST_CHECK_EQUAL( var.count(), 0ul );
  BOOST_CHECK_EQUAL( var.shape()[0], 4ul );
  BOOST_CHECK_EQUAL( var.shape()[1], 25ul );
}
{
  // Ctor with size array
  utility::estimate_2d var( utility::estimate_2d::index_type( {4,25} ) );

  BOOST_CHECK_EQUAL( var.count(), 0ul );
  BOOST_CHECK_EQUAL( var.shape()[0], 4ul);
  BOOST_CHECK_EQUAL( var.shape()[1], 25ul );
}
{
  // Test of copy and serialization
  std::stringstream store;
  {
    utility::estimate_2d var( utility::estimate_2d::index_type( {4,25} ) );

    var.append( exemplar.data4.begin(), exemplar.data4.end() );
    var.append( exemplar.data5.begin(), exemplar.data5.end() );
    var.append( exemplar.data6.begin(), exemplar.data6.end() );

    BOOST_CHECK_EQUAL(var.count(), 3ul);
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        BOOST_CHECK_EQUAL( var.mean( {{ith,jth}} ), 5.0 );
        BOOST_CHECK_EQUAL( var.variance( {{ith,jth}} ), 1.0 );
      }
    }

    utility::estimate_2d var_copy (var);
    BOOST_CHECK_EQUAL(var_copy.count(), 3ul);
    for (std::size_t ith = 0; ith != var_copy.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var_copy.shape()[1]; ++jth)
      {
        BOOST_CHECK_EQUAL( var_copy.mean(  {{ith,jth}}  ), 5.0 );
        BOOST_CHECK_EQUAL( var_copy.variance(  {{ith,jth}}  ), 1.0 );
      }
    }

    boost::archive::text_oarchive oa(store);

    // write class instance to archive
    oa << var;
    // var should be unchanged
    BOOST_CHECK_EQUAL(var.count(), 3ul);
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 5.0);
        BOOST_CHECK_EQUAL(var.variance( {{ith,jth}} ), 1.0);
      }
    }

  }
  {
    utility::estimate_2d var;
    BOOST_CHECK_EQUAL(var.count(), 0ul);
    BOOST_CHECK_EQUAL(var.shape()[0], 0ul);
    BOOST_CHECK_EQUAL(var.shape()[1], 0ul);
    boost::archive::text_iarchive ia(store);
    // read class instance to archive
    ia >> var;
    // var should have the same data as var1 had
    BOOST_CHECK_EQUAL(var.shape()[0], 4ul);
    BOOST_CHECK_EQUAL(var.shape()[1], 25ul);
    BOOST_CHECK_EQUAL(var.count(), 3ul);
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 5.0);
        BOOST_CHECK_EQUAL(var.variance( {{ith,jth}} ), 1.0);
      }
    }
  }
}

!!!349105.cpp!!!	estimate_2d_data_collection() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  utility::estimate_2d var( utility::estimate_2d::index_type( {10,10} ) );
  BOOST_CHECK_EQUAL(var.size(), 100ul);

  // Insure start from zero
  BOOST_CHECK_EQUAL(var.count(), 0ul);
  for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
  {
    for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
    {
      BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 0.0);
      BOOST_CHECK_EQUAL(var.variance( {{ith,jth}} ), 0.0);
    }
  }

  // Add first data points (all 4.0)
  var.append (exemplar.data4.begin(), exemplar.data4.end());
  BOOST_CHECK_EQUAL(var.count(), 1ul);
  for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
  {
    for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
    {
      BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 4.0);
      BOOST_CHECK_EQUAL(var.variance( {{ith,jth}} ), 0.0);
    }
  }

  // Add second data points (all 5.0)
  var.append (exemplar.data5.begin(), exemplar.data5.end());

  BOOST_CHECK_EQUAL(var.count(), 2ul);
  for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
  {
    for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
    {
      BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 4.5);
      BOOST_CHECK_EQUAL(var.variance( {{ith,jth}} ), 0.5);
    }
  }

  // Add third data points (all 6.0)
  var.append (exemplar.data6.begin(), exemplar.data6.end());

  BOOST_CHECK_EQUAL(var.count(), 3ul);
  for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
  {
    for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
    {
      BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 5.0);
      BOOST_CHECK_EQUAL(var.variance( {{ith,jth}} ), 1.0);
    }
  }

  // Add fourth data points (from 1.0, 2.0, ... 100.0)
  var.append (exemplar.data_index.begin(), exemplar.data_index.end());

  BOOST_CHECK_EQUAL(var.count(), 4ul);
  double val = 0.0;
  for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
  {
    for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
    {
      auto sqr = [](double a)
      {
        return a*a;
      };
      const double mean(3.75+val/4.0);
      const double variance((sqr(4-mean) + sqr(5-mean) + sqr(6-mean) + sqr(val - mean))/3.0);
      BOOST_CHECK(utility::feq(var.mean( {{ith,jth}} ),mean));
      BOOST_CHECK(utility::feq(var.variance( {{ith,jth}} ),variance));
      val += 1.0;
    }
  }
}
{
  // DATA / ARRAY SIZE MISMATCH
  {
    // DATA SET TOO LONG
    utility::estimate_2d var( utility::estimate_2d::index_type( {10,9} ) );
    BOOST_CHECK_EQUAL(var.size(), 90ul);
    {
      auto last = var.append (exemplar.data4.begin(), exemplar.data4.end());
      BOOST_CHECK(last != exemplar.data4.end());
      BOOST_CHECK(last == exemplar.data4.begin() + var.size());
    }
    {
      auto last = var.append (exemplar.data5.begin(), exemplar.data5.end());
      BOOST_CHECK(last != exemplar.data5.end());
      BOOST_CHECK(last == exemplar.data5.begin() + var.size());
    }
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 4.5);
        BOOST_CHECK_EQUAL(var.variance( {{ith,jth}} ), 0.5);
      }
    }
  }
  {
    // DATA SET TOO SHORT
    utility::estimate_2d var( utility::estimate_2d::index_type( {10,11} ) );
    BOOST_CHECK_EQUAL(var.size(), 110ul);
    {
      auto last = var.append (exemplar.data4.begin(), exemplar.data4.end());
      BOOST_CHECK(last == exemplar.data4.end());
      BOOST_CHECK(last != exemplar.data4.begin() + var.size());
    }
    {
      auto last = var.append (exemplar.data5.begin(), exemplar.data5.end());
      BOOST_CHECK(last == exemplar.data5.end());
      BOOST_CHECK(last != exemplar.data5.begin() + var.size());
    }
    std::size_t counter = 0;
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth, ++counter)
      {
        if (counter < exemplar.data4.size())
        {
          BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 4.5);
          BOOST_CHECK_EQUAL(var.variance( {{ith,jth}} ), 0.5);
        }
        else
        {
          BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 0.0);
          BOOST_CHECK_EQUAL(var.variance( {{ith,jth}} ), 0.0);
        }
      }
    }
  }

}

!!!356529.cpp!!!	estimate_3d_lifetime() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  // Default ctor
  utility::estimate_3d var;

  BOOST_CHECK_EQUAL(var.count(), 0ul);
  BOOST_CHECK_EQUAL(var.shape()[0], 0ul);
  BOOST_CHECK_EQUAL(var.shape()[1], 0ul);
  BOOST_CHECK_EQUAL(var.shape()[2], 0ul);

  // Resize array
  var.resize( {{4,5,5}} );

  BOOST_CHECK_EQUAL(var.count(), 0ul);
  BOOST_CHECK_EQUAL(var.shape()[0], 4ul);
  BOOST_CHECK_EQUAL(var.shape()[1], 5ul);
  BOOST_CHECK_EQUAL(var.shape()[2], 5ul);
}
{
  // Ctor with size array
  utility::estimate_3d var( utility::estimate_3d::index_type( {4,5,5} ) );

  BOOST_CHECK_EQUAL(var.count(), 0ul);
  BOOST_CHECK_EQUAL(var.shape()[0], 4ul);
  BOOST_CHECK_EQUAL(var.shape()[1], 5ul);
  BOOST_CHECK_EQUAL(var.shape()[2], 5ul);
}
{
  // Test of copy and serialization
  std::stringstream store;
  {
    utility::estimate_3d var( utility::estimate_3d::index_type( {4,5,5} ) );

    var.append (exemplar.data4.begin(), exemplar.data4.end());
    var.append (exemplar.data5.begin(), exemplar.data5.end());
    var.append (exemplar.data6.begin(), exemplar.data6.end());

    BOOST_CHECK_EQUAL(var.count(), 3ul);
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
        {
          BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 5.0);
          BOOST_CHECK_EQUAL(var.variance( {{ith,jth,kth}} ), 1.0);
        }
      }
    }

    utility::estimate_3d var_copy(var);
    BOOST_CHECK_EQUAL(var_copy.count(), 3ul);
    for (std::size_t ith = 0; ith != var_copy.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var_copy.shape()[1]; ++jth)
      {
        for (std::size_t kth = 0; kth != var_copy.shape()[2]; ++kth)
        {
          BOOST_CHECK_EQUAL(var_copy.mean( {{ith,jth,kth}} ), 5.0);
          BOOST_CHECK_EQUAL(var_copy.variance( {{ith,jth,kth}} ), 1.0);
        }
      }
    }

    boost::archive::text_oarchive oa(store);

    // write class instance to archive
    oa << var;
    // var should be unchanged
    BOOST_CHECK_EQUAL(var.count(), 3ul);
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        for (std::size_t kth = 0; kth != var.shape()[1]; ++kth)
        {
          BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 5.0);
          BOOST_CHECK_EQUAL(var.variance( {{ith,jth,kth}} ), 1.0);
        }
      }
    }

  }
  {
    utility::estimate_3d var;
    BOOST_CHECK_EQUAL(var.count(), 0ul);
    BOOST_CHECK_EQUAL(var.shape()[0], 0ul);
    BOOST_CHECK_EQUAL(var.shape()[1], 0ul);
    BOOST_CHECK_EQUAL(var.shape()[2], 0ul);
    boost::archive::text_iarchive ia(store);
    // read class instance to archive
    ia >> var;
    // var should have the same data as var1 had
    BOOST_CHECK_EQUAL(var.shape()[0], 4ul);
    BOOST_CHECK_EQUAL(var.shape()[1], 5ul);
    BOOST_CHECK_EQUAL(var.shape()[2], 5ul);
    BOOST_CHECK_EQUAL(var.count(), 3ul);
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        for (std::size_t kth = 0; kth != var.shape()[1]; ++kth)
        {
          BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 5.0);
          BOOST_CHECK_EQUAL(var.variance( {{ith,jth,kth}} ), 1.0);
        }
      }
    }
  }
}

!!!356401.cpp!!!	estimate_3d_data_collection() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
utility::estimate_3d var( utility::estimate_3d::index_type( {5,5,4} ) );

// Insure start from zero
BOOST_CHECK_EQUAL(var.count(), 0ul);
for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
{
  for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
  {
    for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
    {
      BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 0.0);
      BOOST_CHECK_EQUAL(var.variance( {{ith,jth,kth}} ), 0.0);
    }
  }
}

// Add first data points (all 4.0)
var.append (exemplar.data4.begin(), exemplar.data4.end());
BOOST_CHECK_EQUAL(var.count(), 1ul);
for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
{
  for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
  {
    for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
    {
      BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 4.0);
      BOOST_CHECK_EQUAL(var.variance( {{ith,jth,kth}} ), 0.0);
    }
  }
}

// Add second data points (all 5.0)
var.append (exemplar.data5.begin(), exemplar.data5.end());

BOOST_CHECK_EQUAL(var.count(), 2ul);
for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
{
  for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
  {
    for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
    {
      BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 4.5);
      BOOST_CHECK_EQUAL(var.variance( {{ith,jth,kth}} ), 0.5);
    }
  }
}

// Add third data points (all 6.0)
var.append (exemplar.data6.begin(), exemplar.data6.end());

BOOST_CHECK_EQUAL(var.count(), 3ul);
for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
{
  for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
  {
    for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
    {
      BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 5.0);
      BOOST_CHECK_EQUAL(var.variance( {{ith,jth,kth}} ), 1.0);
    }
  }
}

// Add fourth data points (from 1.0, 2.0, ... 100.0)
var.append (exemplar.data_index.begin(), exemplar.data_index.end());

BOOST_CHECK_EQUAL(var.count(), 4ul);
double val = 0.0;
for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
{
  for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
  {
    for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
    {
      auto sqr = [](double a)
      {
        return a*a;
      };
      const double mean(3.75+val/4.0);
      const double variance((sqr(4-mean) + sqr(5-mean) + sqr(6-mean) + sqr(val - mean))/3.0);
      BOOST_CHECK(utility::feq(var.mean( {{ith,jth,kth}} ),mean));
      BOOST_CHECK(utility::feq(var.variance( {{ith,jth,kth}} ),variance));
      val += 1.0;
    }
  }
}
{
  // DATA / ARRAY SIZE MISMATCH
  {
    // DATA SET TOO LONG
    utility::estimate_3d var( utility::estimate_3d::index_type( {2,5,9} ) );
    BOOST_CHECK_EQUAL(var.size(), 90ul);
    {
      auto last = var.append (exemplar.data4.begin(), exemplar.data4.end());
      BOOST_CHECK(last != exemplar.data4.end());
      BOOST_CHECK(last == exemplar.data4.begin() + var.size());
    }
    {
      auto last = var.append (exemplar.data5.begin(), exemplar.data5.end());
      BOOST_CHECK(last != exemplar.data5.end());
      BOOST_CHECK(last == exemplar.data5.begin() + var.size());
    }
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
        {
          BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 4.5);
          BOOST_CHECK_EQUAL(var.variance( {{ith,jth,kth}} ), 0.5);
        }
      }
    }
  }
  {
    // DATA SET TOO SHORT
    utility::estimate_3d var( utility::estimate_3d::index_type( {4,5,6} ) );
    BOOST_CHECK_EQUAL(var.size(), 120ul);
    {
      auto last = var.append (exemplar.data4.begin(), exemplar.data4.end());
      BOOST_CHECK(last == exemplar.data4.end());
      BOOST_CHECK(last != exemplar.data4.begin() + var.size());
    }
    {
      auto last = var.append (exemplar.data5.begin(), exemplar.data5.end());
      BOOST_CHECK(last == exemplar.data5.end());
      BOOST_CHECK(last != exemplar.data5.begin() + var.size());
    }
    std::size_t counter = 0;
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    {
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        for (std::size_t kth = 0; kth != var.shape()[2]; ++kth, ++counter)
        {
          if (counter < exemplar.data4.size())
          {
            BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 4.5);
            BOOST_CHECK_EQUAL(var.variance( {{ith,jth,kth}} ), 0.5);
          }
          else
          {
            BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 0.0);
            BOOST_CHECK_EQUAL(var.variance( {{ith,jth,kth}} ), 0.0);
          }
        }
      }
    }
  }
}
!!!356273.cpp!!!	digitizer_lifetime() : void
{
  // Default ctor
  utility::digitizer var;
  BOOST_CHECK_EQUAL(var.minimum(), 0.0);
  BOOST_CHECK_EQUAL(var.maximum(), 0.0);
  BOOST_CHECK_EQUAL(var.size(), 0ul);
  for(int x = -10; x != 11; ++x)
  {
    BOOST_REQUIRE(not var.in_range(double(x)/5.0));
  }
}
{
  // Min/Max/Count ctor
  utility::digitizer var(-1.0,1.0,21ul);
  BOOST_CHECK_EQUAL(var.minimum(), -1.0);
  BOOST_CHECK_EQUAL(var.maximum(), 1.0);
  BOOST_CHECK_EQUAL(var.size(), 21ul);
  BOOST_CHECK(utility::feq(var.bin_width(), 0.095238095238095233));
  for(int x = -10; x != 11; ++x)
  {
    if (not var.in_range(double(x)/5.0))
    {
      if (-5 <= x and x < 5)
      {
        std::stringstream ss;
        ss << double(x)/5.0 << " should be in range!";
        BOOST_ERROR(ss.str());
      }
    }
    else
    {
      if (-5 > x or x >= 5)
      {
        std::stringstream ss;
        ss << double(x)/5.0 << " should NOT be in range!";
        BOOST_ERROR(ss.str());
      }
    }
  }
  // Min/Max/Count with literal
  utility::digitizer var2(-1.0,1.0,21);
  BOOST_CHECK( var2.equivalent( var ) );
}
{
  // Min/Max/Step
  utility::digitizer var (-1.0,1.0,0.1);
  BOOST_CHECK_EQUAL(var.minimum(), -1.0);
  BOOST_CHECK_EQUAL(var.maximum(), 1.0);
  BOOST_CHECK_EQUAL(var.bin_width(), 0.1);
  BOOST_CHECK_EQUAL(var.size(), 20ul);
  for(int x = -10; x != 11; ++x)
  {
    if (not var.in_range(double(x)/5.0))
    {
      if (-5 <= x and x < 5)
      {
        std::stringstream ss;
        ss << double(x)/5.0 << " should be in range!";
        BOOST_ERROR(ss.str());
      }
    }
    else
    {
      if (-5 > x or x >= 5)
      {
        std::stringstream ss;
        ss << double(x)/5.0 << " should NOT be in range!";
        BOOST_ERROR(ss.str());
      }
    }
  }
}
// INVALID DIGITISER CTORS
{
  // Min/Max/Step Min>Max
  try
  {
    utility::digitizer var(2.0,1.0,0.1);
    BOOST_ERROR("Able to construct digitizer with min > max");
  }
  catch(...) {}
  // Min/Max/Step Min=Max
  try
  {
    utility::digitizer var(1.0,1.0,0.1);
    BOOST_ERROR("Able to construct digitizer with min == max");
  }
  catch(...) {}
  // Min/Max/Step Step=0
  try
  {
    utility::digitizer var(2.0,1.0,0.0);
    BOOST_ERROR("Able to construct digitizer with step = 0");
  }
  catch(...) {}
  // Min/Max/Step Step<0.0
  try
  {
    utility::digitizer var(0.0,1.0,-0.1);
    BOOST_ERROR("Able to construct digitizer with step < 0");
  }
  catch(...) {}
  // Min/Max/Count Min>Max
  try
  {
    utility::digitizer var(2.0,1.0,1ul);
    BOOST_ERROR("Able to construct digitizer with min > max");
  }
  catch(...) {}
  // Min/Max/Count Min=Max
  try
  {
    utility::digitizer var(1.0,1.0,1ul);
    BOOST_ERROR("Able to construct digitizer with min == max");
  }
  catch(...) {}
  // Min/Max/Count Count=0
  try
  {
    utility::digitizer var(-1.0,1.0,0ul);
    BOOST_ERROR("Able to construct digitizer with bin count = 0");
  }
  catch(...) {}
}
!!!357169.cpp!!!	digital_sampler() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  // Default ctor
  utility::digital_sampler var;

  BOOST_CHECK_EQUAL(var.size(), 0ul);
  BOOST_CHECK_EQUAL(var.get_digitizer().size(), 0ul);
}
{
  std::stringstream store;
  utility::digitizer axis (4.0,100.0,1.0);
  {
    // Ctor with digitizer
    utility::digital_sampler var (axis);

    BOOST_CHECK_EQUAL(var.size(), axis.size());
    BOOST_CHECK_EQUAL(var.get_digitizer().size(), axis.size());
    for (std::size_t ith = 0; ith != var.size(); ++ith)
    {
      BOOST_CHECK_EQUAL(var[ith], 0ul);
    }

    // Test of data insertion
    // ----------------------

    // MANY POINTS WITH THE SAME VALUE
    var.insert (exemplar.data4.begin(), exemplar.data4.end());
    var.insert (exemplar.data5.begin(), exemplar.data5.end());
    var.insert (exemplar.data6.begin(), exemplar.data6.end());
    // SOME POINTS OUTSIDE RANGE
    var.insert (exemplar.data_index.begin(), exemplar.data_index.end());

    {
      std::size_t ith = 0;
      for (auto smpl: var)
      {
        switch(ith)
        {
        case 0:
        case 1:
        case 2:
          BOOST_CHECK_EQUAL(smpl, 101ul);
          break;
        default:
          BOOST_CHECK_EQUAL(smpl, 1ul);
          break;
        }
        ++ith;
      }
    }
    {
      // Test of copy
      utility::digital_sampler var_copy (var);
      BOOST_CHECK_EQUAL(var_copy.size(), axis.size());
      BOOST_CHECK_EQUAL(var_copy.get_digitizer().size(), axis.size());
      {
        std::size_t ith = 0;
        for (auto smpl: var_copy)
        {
          switch(ith)
          {
          case 0:
          case 1:
          case 2:
            BOOST_CHECK_EQUAL(smpl, 101ul);
            break;
          default:
            BOOST_CHECK_EQUAL(smpl, 1ul);
            break;
          }
          ++ith;
        }
      }
    }
    // Test of serialization
    boost::archive::text_oarchive oa(store);
    // write class instance to archive
    oa << var;
    // var should be unchanged
    BOOST_CHECK_EQUAL(var.size(), axis.size());
    BOOST_CHECK_EQUAL(var.get_digitizer().size(), axis.size());
    {
      std::size_t ith = 0;
      for (auto smpl: var)
      {
        switch(ith)
        {
        case 0:
        case 1:
        case 2:
          BOOST_CHECK_EQUAL(smpl, 101ul);
          break;
        default:
          BOOST_CHECK_EQUAL(smpl, 1ul);
          break;
        }
        ++ith;
      }
    }
  }
  {
    // Test of deserialization
    utility::digital_sampler var;
    boost::archive::text_iarchive ia(store);
    // read class instance from archive
    ia >> var;
    BOOST_CHECK_EQUAL(var.size(), axis.size());
    BOOST_CHECK_EQUAL(var.get_digitizer().size(), axis.size());
    for (std::size_t ith = 0; ith != var.size(); ++ith)
    {
      switch(ith)
      {
      case 0:
      case 1:
      case 2:
        BOOST_CHECK_EQUAL(var[ith], 101ul);
        break;
      default:
        BOOST_CHECK_EQUAL(var[ith], 1ul);
        break;
      }
    }

    // Test of RESET
    var.reset ();
    BOOST_CHECK_EQUAL(var.size(), axis.size());
    BOOST_CHECK_EQUAL(var.get_digitizer().size(), axis.size());
    for (std::size_t ith = 0; ith != var.size(); ++ith)
    {
      BOOST_CHECK_EQUAL(var[ith], 0ul);
    }
  }
}

!!!357553.cpp!!!	digital_2d_sampler() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  // Default ctor
  utility::digital_2d_sampler var;

  BOOST_CHECK_EQUAL(var.size(), 0ul);
  BOOST_CHECK_EQUAL(var.shape()[0], 0ul);
  BOOST_CHECK_EQUAL(var.shape()[1], 0ul);
  BOOST_CHECK_EQUAL(var.get_digitizer(0).size(), 0ul);
  BOOST_CHECK_EQUAL(var.get_digitizer(1).size(), 0ul);
}
{
  std::stringstream store;
  utility::digitizer axis0 (4.0,10.0,1.0);
  utility::digitizer axis1 (4.0,11.0,1.0);
  {
    // Ctor with digitizer
    utility::digital_2d_sampler var( std::array< utility::digitizer, 2ul >( {axis0,axis1} ) );

    BOOST_CHECK_EQUAL(var.size(), axis0.size()*axis1.size());
    BOOST_CHECK_EQUAL(var.shape()[0], axis0.size());
    BOOST_CHECK_EQUAL(var.shape()[1], axis1.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(0).size(), axis0.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(1).size(), axis1.size());
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        BOOST_CHECK_EQUAL((var[ {{ith,jth}} ]), 0ul);
      }
    // Test of data insertion
    // ----------------------
    // MANY POINTS WITH THE SAME VALUE
    typedef std::array< double, 2 > pt;
    std::vector< pt > dataset(100);
    for (std::size_t i = 0; i != dataset.size(); ++i)
    {
      dataset[i][0] = exemplar.data4[i];
      dataset[i][1] = exemplar.data5[i];
    }
    var.insert (dataset.begin(), dataset.end());

    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        if (ith == 0 and jth == 1)
          BOOST_CHECK_EQUAL((var[ {{ith,jth}} ]), 100ul);
        else
          BOOST_CHECK_EQUAL((var[ {{ith,jth}} ]), 0ul);
      }

    for (std::size_t i = 0; i != dataset.size(); ++i)
    {
      dataset[i][0] = exemplar.data6[i];
      dataset[i][1] = exemplar.data_index[i];
    }
    var.insert (dataset.begin(), dataset.end());

    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        if (ith == 0 and jth == 1)
          BOOST_CHECK_EQUAL((var[ {{ith,jth}} ]), 100ul);
        else if (ith == 2)
          BOOST_CHECK_EQUAL((var[ {{ith,jth}} ]), 1ul);
        else
          BOOST_CHECK_EQUAL((var[ {{ith,jth}} ]), 0ul);
      }

    {
      // Test of copy
      utility::digital_2d_sampler var_copy (var);
      BOOST_CHECK_EQUAL(var_copy.size(), axis0.size()*axis1.size());
      BOOST_CHECK_EQUAL(var_copy.shape()[0], axis0.size());
      BOOST_CHECK_EQUAL(var_copy.shape()[1], axis1.size());
      BOOST_CHECK_EQUAL(var_copy.get_digitizer(0).size(), axis0.size());
      BOOST_CHECK_EQUAL(var_copy.get_digitizer(1).size(), axis1.size());
      for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
        for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
        {
          if (ith == 0 and jth == 1)
            BOOST_CHECK_EQUAL((var_copy[ {{ith,jth}} ]), 100ul);
          else if (ith == 2)
            BOOST_CHECK_EQUAL((var_copy[ {{ith,jth}} ]), 1ul);
          else
            BOOST_CHECK_EQUAL((var_copy[ {{ith,jth}} ]), 0ul);
        }
    }
    // Test of serialization
    boost::archive::text_oarchive oa(store);
    // write class instance to archive
    oa << var;
  }
  {
    // Test of deserialization
    utility::digital_2d_sampler var;
    boost::archive::text_iarchive ia(store);
    // read class instance from archive
    ia >> var;
    BOOST_CHECK_EQUAL(var.size(), axis0.size()*axis1.size());
    BOOST_CHECK_EQUAL(var.shape()[0], axis0.size());
    BOOST_CHECK_EQUAL(var.shape()[1], axis1.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(0).size(), axis0.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(1).size(), axis1.size());

    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        if (ith == 0 and jth == 1)
          BOOST_CHECK_EQUAL((var[ {{ith,jth}} ]), 100ul);
        else if (ith == 2)
          BOOST_CHECK_EQUAL((var[ {{ith,jth}} ]), 1ul);
        else
          BOOST_CHECK_EQUAL((var[ {{ith,jth}} ]), 0ul);
      }

    // Test of RESET
    var.reset ();
    BOOST_CHECK_EQUAL(var.size(), axis0.size()*axis1.size());
    BOOST_CHECK_EQUAL(var.shape()[0], axis0.size());
    BOOST_CHECK_EQUAL(var.shape()[1], axis1.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(0).size(), axis0.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(1).size(), axis1.size());

    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      {
        BOOST_CHECK_EQUAL((var[ {{ith,jth}} ]), 0ul);
      }
  }
}

!!!357937.cpp!!!	digital_3d_sampler() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  // Default ctor
  utility::digital_3d_sampler var;

  BOOST_CHECK_EQUAL(var.size(), 0ul);
  BOOST_CHECK_EQUAL(var.shape()[0], 0ul);
  BOOST_CHECK_EQUAL(var.shape()[1], 0ul);
  BOOST_CHECK_EQUAL(var.shape()[2], 0ul);
  BOOST_CHECK_EQUAL(var.get_digitizer(0).size(), 0ul);
  BOOST_CHECK_EQUAL(var.get_digitizer(1).size(), 0ul);
  BOOST_CHECK_EQUAL(var.get_digitizer(2).size(), 0ul);
}
{
  std::stringstream store;
  utility::digitizer axis0 (4.0,10.0,1.0);
  utility::digitizer axis1 (4.0,11.0,1.0);
  utility::digitizer axis2 (4.0,12.0,1.0);
  {
    // Ctor with digitizer
    utility::digital_3d_sampler var( std::array< utility::digitizer, 3ul >( {axis0,axis1,axis2} ) );

    BOOST_CHECK_EQUAL(var.size(), axis0.size()*axis1.size()*axis2.size());
    BOOST_CHECK_EQUAL(var.shape()[0], axis0.size());
    BOOST_CHECK_EQUAL(var.shape()[1], axis1.size());
    BOOST_CHECK_EQUAL(var.shape()[2], axis2.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(0).size(), axis0.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(1).size(), axis1.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(2).size(), axis2.size());
    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
        for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
        {
          BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 0ul);
        }
    // Test of data insertion
    // ----------------------
    // MANY POINTS WITH THE SAME VALUE
    typedef std::array< double, 3 > pt;
    std::vector< pt > dataset(100);
    for (std::size_t i = 0; i != dataset.size(); ++i)
    {
      dataset[i][0] = exemplar.data4[i];
      dataset[i][1] = exemplar.data5[i];
      dataset[i][2] = exemplar.data6[i];
    }
    var.insert (dataset.begin(), dataset.end());

    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
        for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
        {
          if (ith == 0 and jth == 1 and kth == 2)
            BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 100ul);
          else
            BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 0ul);
        }

    for (std::size_t i = 0; i != dataset.size(); ++i)
    {
      dataset[i][0] = exemplar.data5[i];
      dataset[i][1] = exemplar.data6[i];
      dataset[i][2] = exemplar.data_index[i];
    }
    var.insert (dataset.begin(), dataset.end());

    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
        for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
        {
          if (ith == 0 and jth == 1 and kth == 2)
            BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 100ul);
          else if (ith == 1 and jth == 2)
            BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 1ul);
          else
            BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 0ul);
        }

    {
      // Test of copy
      utility::digital_3d_sampler var_copy (var);
      BOOST_CHECK_EQUAL(var_copy.size(), axis0.size()*axis1.size()*axis2.size());
      BOOST_CHECK_EQUAL(var_copy.shape()[0], axis0.size());
      BOOST_CHECK_EQUAL(var_copy.shape()[1], axis1.size());
      BOOST_CHECK_EQUAL(var_copy.shape()[2], axis2.size());
      BOOST_CHECK_EQUAL(var_copy.get_digitizer(0).size(), axis0.size());
      BOOST_CHECK_EQUAL(var_copy.get_digitizer(1).size(), axis1.size());
      BOOST_CHECK_EQUAL(var_copy.get_digitizer(2).size(), axis2.size());
      for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
        for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
          for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
          {
            if (ith == 0 and jth == 1 and kth == 2)
              BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 100ul);
            else if (ith == 1 and jth == 2)
              BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 1ul);
            else
              BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 0ul);
          }
    }
    // Test of serialization
    boost::archive::text_oarchive oa(store);
    // write class instance to archive
    oa << var;
  }
  {
    // Test of deserialization
    utility::digital_3d_sampler var;
    boost::archive::text_iarchive ia(store);
    // read class instance from archive
    ia >> var;
    BOOST_CHECK_EQUAL(var.size(), axis0.size()*axis1.size()*axis2.size());
    BOOST_CHECK_EQUAL(var.shape()[0], axis0.size());
    BOOST_CHECK_EQUAL(var.shape()[1], axis1.size());
    BOOST_CHECK_EQUAL(var.shape()[2], axis2.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(0).size(), axis0.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(1).size(), axis1.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(2).size(), axis2.size());

    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
        for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
        {
          if (ith == 0 and jth == 1 and kth == 2)
            BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 100ul);
          else if (ith == 1 and jth == 2)
            BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 1ul);
          else
            BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 0ul);
        }

    // Test of RESET
    var.reset ();
    BOOST_CHECK_EQUAL(var.size(), axis0.size()*axis1.size()*axis2.size());
    BOOST_CHECK_EQUAL(var.shape()[0], axis0.size());
    BOOST_CHECK_EQUAL(var.shape()[1], axis1.size());
    BOOST_CHECK_EQUAL(var.shape()[2], axis2.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(0).size(), axis0.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(1).size(), axis1.size());
    BOOST_CHECK_EQUAL(var.get_digitizer(2).size(), axis2.size());

    for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
      for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
        for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
        {
          BOOST_CHECK_EQUAL((var[ {{ith,jth,kth}} ]), 0ul);
        }
  }
}


!!!358577.cpp!!!	sample_2d_collection() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  std::stringstream store;
  utility::digitizer axis0 (0.0,10.0,1.0);
  utility::digitizer axis1 (1.0,11.0,1.0);
  utility::estimate_2d var( utility::estimate_2d::index_type( {axis0.size(), axis1.size()} ) );

  // Insure start from zero
  BOOST_CHECK_EQUAL(var.size(), axis0.size()*axis1.size());
  BOOST_CHECK_EQUAL(var.count(), 0ul);
  for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
  {
    for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
    {
      BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 0.0);
      BOOST_CHECK_EQUAL(var.variance( {{ith,jth}} ), 0.0);
    }
  }
  utility::digital_2d_sampler smpl( std::array< utility::digitizer, 2ul >( {axis0,axis1} ) );

  // ----------------------
  // MANY POINTS WITH THE SAME VALUE
  typedef std::array< double, 2 > pt;
  std::vector< pt > dataset(100);
  for (std::size_t i = 0; i != dataset.size(); ++i)
  {
    dataset[i][0] = exemplar.data4[i];
    dataset[i][1] = exemplar.data5[i];
  }
  smpl.insert (dataset.begin(), dataset.end());

  var.append (smpl.begin(), smpl.end());

  smpl.reset ();
  for (std::size_t i = 0; i != dataset.size(); ++i)
  {
    dataset[i][0] = exemplar.data6[i];
    dataset[i][1] = exemplar.data_index[i];
  }
  smpl.insert (dataset.begin(), dataset.end());

  var.append (smpl.begin(), smpl.end());
  for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
    {
      if (ith == 4 and jth == 4)
        BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 50.0);
      else if (ith == 6)
        BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 0.5);
      else
        BOOST_CHECK_EQUAL(var.mean( {{ith,jth}} ), 0.0);
    }
}

!!!358705.cpp!!!	sample_3d_collection() : void
estimater_test_fw const& exemplar(estimater_test_fw::exmplr);
{
  utility::digitizer axis0 (4.0,10.0,1.0);
  utility::digitizer axis1 (4.0,11.0,1.0);
  utility::digitizer axis2 (4.0,12.0,1.0);
  // Ctor with digitizer
  utility::digital_3d_sampler smpl( std::array< utility::digitizer, 3ul >( {axis0,axis1,axis2} ) );
  utility::estimate_3d var( utility::estimate_3d::index_type( {axis0.size(),axis1.size(),axis2.size()} ) );


  // Test of data insertion
  // ----------------------
  // MANY POINTS WITH THE SAME VALUE
  typedef std::array< double, 3 > pt;
  std::vector< pt > dataset(100);
  for (std::size_t i = 0; i != dataset.size(); ++i)
  {
    dataset[i][0] = exemplar.data4[i];
    dataset[i][1] = exemplar.data5[i];
    dataset[i][2] = exemplar.data6[i];
  }
  smpl.insert (dataset.begin(), dataset.end());

  var.append (smpl.begin(), smpl.end ());

  smpl.reset ();
  for (std::size_t i = 0; i != dataset.size(); ++i)
  {
    dataset[i][0] = exemplar.data5[i];
    dataset[i][1] = exemplar.data6[i];
    dataset[i][2] = exemplar.data_index[i];
  }
  smpl.insert (dataset.begin(), dataset.end());
  var.append (smpl.begin(), smpl.end ());

  for (std::size_t ith = 0; ith != var.shape()[0]; ++ith)
    for (std::size_t jth = 0; jth != var.shape()[1]; ++jth)
      for (std::size_t kth = 0; kth != var.shape()[2]; ++kth)
      {
        if (ith == 0 and jth == 1 and kth == 2)
          BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 50.0);
        else if (ith == 1 and jth == 2)
          BOOST_CHECK_EQUAL(var.mean( {{ith,jth,kth}} ), 0.5);
        else
          BOOST_CHECK_EQUAL(var.mean ( {{ith,jth,kth}} ), 0.0);
      }
}


