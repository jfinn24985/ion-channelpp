class cube_region
!!!1037616.cpp!!!	do_change_volume(in vol : double, in rad : double) : void
if( this->is_open() ) 
{
 // we can ignore radius
 this->length_ = std::cbrt( vol );
}
else
{
  // (len - 2r)**3 = volume
  this->length_ = std::cbrt( vol ) + 2 * rad;
}
!!!1038384.cpp!!!	do_is_inside(in pos : coordinate, in radius : double) : bool
double len( this->length_ );
particle::coordinate orig( this->origin_ );
auto inrange = [](double min, double width, double val)->bool
{
  return !(val < min) and !((min + width) < val);
};
if( not this->is_open_ )
{
  UTILITY_CHECK( (2 * radius) < len, "Test if particle could fit in cube should have been performed." );
  len -= (2 * radius);
  orig.x += radius;
  orig.y += radius;
  orig.z += radius;
}
return inrange( orig.x, len, pos.x )
   and inrange( orig.y, len, pos.y )
   and inrange( orig.z, len, pos.z );
!!!1038256.cpp!!!	do_new_position(inout rgnr : random_distribution, in radius : double) : coordinate
double len( this->length_ );
particle::coordinate orig( this->origin_ );
if( not this->is_open_ )
{
  len -= (2 * radius);
  orig.x += radius;
  orig.y += radius;
  orig.z += radius;
}
return particle::coordinate( orig.x + rgnr.uniform( len ), orig.y + rgnr.uniform( len ), orig.z + rgnr.uniform( len ) );
!!!1037744.cpp!!!	do_volume(in radius : double) : double
double len( this->is_open_ ? this->length_ : this->length_ - 2 * radius );
return std::pow( len, 3 );
!!!1069360.cpp!!!	region_factory(in label : string, in params : string) : base_region
// needed information
// label : from label arg
// origin : from param arg
// width : from param arg
// open : from param arg or default:true
double width {};
particle::coordinate origin {};
bool isopen { true }; // default is true

const std::string width_label { "width" };
const std::string origin_label { "origin" };
const std::string isopen_label { "open" };

// check for required parameters.
UTILITY_INPUT( params.count( width_label ) == 1, "Cube region \""+width_label+"\" parameter missing in input.", core::strngs::fsregn() );
UTILITY_INPUT( params.count( origin_label ) == 1, "Cube region \""+origin_label+"\" parameter missing in input.", core::strngs::fsregn() );

core::input_base_reader::float_input( width_label, params.at( width_label ), "Cube region", core::strngs::fsregn(), width, true, false );

particle::coordinate::coordinate_input( origin_label, params.at( origin_label ), "Cube region", core::strngs::fsregn(), origin );

if ( params.count( isopen_label ) == 1 )
{
  core::input_base_reader::bool_input( isopen_label, params.at( isopen_label ), "Cube region", core::strngs::fsregn(), isopen, true, true );
}

// build region object.
boost::shared_ptr< geometry::base_region > current;
current.reset( new cube_region( label, width, origin, isopen ) );
return current;



!!!1069488.cpp!!!	add_region_definition(inout meta : region_meta) : void
region_definition cube_defn;
cube_defn.type_name_ = "cube";
cube_defn.documentation_.insert( std::make_pair< std::string, std::string >( "origin", "[required, values in Angstrom] The coordinate of the lowest (most negative) corner of the cubic region" ) );
cube_defn.documentation_.insert( std::make_pair< std::string, std::string >( "width", "[required, value in Angstrom] The width in each dimension of the cubic region" ) );
cube_defn.documentation_.insert( std::make_pair< std::string, std::string >( "open", "[true/false: default=true] Whether the cube walls are open or closed." ) );
cube_defn.factory_ = &cube_region::region_factory;
meta.add_definition( cube_defn );
