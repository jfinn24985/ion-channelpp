class cube_region
!!!1037616.cpp!!!	do_change_volume(in vol : double, in rad : double) : void
if( this->is_open() ) 
{
 // we can ignore radius
 this->length_ = std::cbrt( vol );
}
else
{
  // (len - 2r)**3 = volume
  this->length_ = std::cbrt( vol ) + 2 * rad;
}
!!!1038384.cpp!!!	do_is_inside(in pos : coordinate, in radius : double) : bool
double len( this->length_ );
particle::coordinate orig( this->origin_ );
auto inrange = [](double min, double width, double val)->bool
{
  return !(val < min) and !((min + width) < val);
};
if( not this->is_open_ )
{
  UTILITY_CHECK( (2 * radius) < len, "Test if particle could fit in cube should have been performed." );
  len -= (2 * radius);
  orig.x += radius;
  orig.y += radius;
  orig.z += radius;
}
return inrange( orig.x, len, pos.x )
   and inrange( orig.y, len, pos.y )
   and inrange( orig.z, len, pos.z );
!!!1038256.cpp!!!	do_new_position(inout rgnr : random_distribution, in radius : double) : coordinate
double len( this->length_ );
particle::coordinate orig( this->origin_ );
if( not this->is_open_ )
{
  len -= (2 * radius);
  orig.x += radius;
  orig.y += radius;
  orig.z += radius;
}
return particle::coordinate( orig.x + rgnr.uniform( len ), orig.y + rgnr.uniform( len ), orig.z + rgnr.uniform( len ) );
!!!1037744.cpp!!!	do_volume(in radius : double) : double
double len( this->is_open_ ? this->length_ : this->length_ - 2 * radius );
return std::pow( len, 3 );
!!!1069360.cpp!!!	region_factory(in label : string, in params : string) : base_region
// needed information
// label : from label arg
// origin : from param arg
// width : from param arg
// open : from param arg or default:true
double width {};
particle::coordinate origin {};
bool isopen { true }; // default is true

const std::string width_label { "width" };
const std::string origin_label { "origin" };
const std::string isopen_label { "open" };

// check for required parameters.
UTILITY_INPUT( params.count( width_label ) == 1, "Missing \""+width_label+"\" parameter for cube region.", core::strngs::fsregn() );
UTILITY_INPUT( params.count( origin_label ) == 1, "Missing \""+origin_label+"\" parameter for cube region.", core::strngs::fsregn() );

{
  // --------------------
  // Cube width
  try
  {
    width = boost::lexical_cast< double >( params.at( width_label ) );
  }
  catch( std::bad_cast const& err )
  {
    const bool value_is_a_number = false;
    UTILITY_INPUT( value_is_a_number, std::string( "Cube region \""+width_label+"\" parameter not a number: " ) + err.what(), core::strngs::fsregn() );
  }
  UTILITY_INPUT( width >= 0.0, "Cube region \""+width_label+"\" must be greater than zero.", core::strngs::fsregn() );
}

{
  // --------------------
  // Cube origin
  std::vector< double > values;
  UTILITY_INPUT( core::input_base_reader::read_as_floats( params.at( origin_label ), values ), "Cube region \""+origin_label+"\" position has invalid data", core::strngs::fsregn() );
  UTILITY_INPUT( values.size() == 3, "Cube region \""+origin_label+"\" coordinate data should have 3 values", core::strngs::fsregn() );
  origin = particle::coordinate( values[0], values[1], values[2] );
}

if( params.count( isopen_label ) == 1 )
{
  // --------------------
  // Cube open/closed state
  try
  {
    isopen = core::input_base_reader::read_as_bool( params.at( isopen_label ) );
  }
  catch( std::bad_cast const& err )
  {
    const bool value_is_a_boolean = false;
    UTILITY_INPUT( value_is_a_boolean, std::string( "Cube region \""+isopen_label+"\" parameter not a boolean: " ) + err.what(), core::strngs::fsregn() );
  }
}

// build region object.
boost::shared_ptr< geometry::base_region > current;
current.reset( new cube_region( label, width, origin, isopen ) );
return current;


!!!1069488.cpp!!!	add_region_definition(inout meta : region_meta) : void
region_definition cube_defn;
cube_defn.type_name_ = "cube";
cube_defn.documentation_.insert( std::make_pair< std::string, std::string >( "origin", "[required, values in Angstrom] The coordinate of the lowest (most negative) corner of the cubic region" ) );
cube_defn.documentation_.insert( std::make_pair< std::string, std::string >( "width", "[required, value in Angstrom] The width in each dimension of the cubic region" ) );
cube_defn.documentation_.insert( std::make_pair< std::string, std::string >( "open", "[true/false: default=true] Whether the cube walls are open or closed." ) );
cube_defn.factory_ = &cube_region::region_factory;
meta.add_definition( cube_defn );
