class widom
!!!1628976.cpp!!!	add_definition(inout meta : sampler_meta) : void
std::string desc( "Calculate the particle free energy using the Widom method. This calculates the excess chemical potential from insertion trials. This class calculates an average global value." );
std::unique_ptr< tracked_definition > result( new tracked_definition( type_label_(), desc, &widom::make_sampler ) );
// two extra parameters
result->add_definition( { core::strngs::fsiwid(), "number", ">=0", "0", "Minimum number of insertion attempts per sampling period." } );
result->add_definition( { core::strngs::fsspec(), "list", "specie labels", "all \""+ core::strngs::fsfree()+"\" species", "List of labels of the species to sample. Each species must be of solute type ("+ core::strngs::fsfree()+"). Default is to use all solute species." } );
meta.add_tracked_type( result );
!!!488113.cpp!!!	description(inout out : ostream) : void
out << " " << this->get_label() << "\n";
out << " " << std::string( this->type_label_().size(), '-' ) << "\n";
out << "    Sample the free energy distribution of the ensemble\n";
out << "    - Trials per sampling loop : " << this->trials_ << "\n";

!!!695984.cpp!!!	get_value() : boost::any
boost::any result = this->data_;
return result;
!!!2175279.cpp!!!	make_sampler(in params : string) : tracked_observable
std::unique_ptr< widom > smplr( new widom );
// Check parameters for usable values
for( auto const& item : params )
{
  if( item.first == core::strngs::fsiwid() )
  {
    core::input_base_reader::ordinal_input( item.first, item.second, type_label_(), core::strngs::sampler_label(), smplr->trials_ );
  }
  else if( item.first == core::strngs::fsspec() )
  {
    UTILITY_INPUT( not item.second.empty(),
                   "widom \""+item.first+"\" parameter requires a value",
                   core::strngs::sampler_label(), nullptr );
    smplr->key_labels_ = item.second;
  }
  else
  {
    const std::string known_key;
    UTILITY_INPUT( item.first==known_key,
                   "Parameter ["+item.first+"] unknown for sampler type ["+widom::type_label_()+"]",
                   core::strngs::sampler_label(), nullptr );
  }
}
boost::shared_ptr< tracked_observable > result;
result.reset( smplr.release() );
return result;

!!!1747631.cpp!!!	on_report(inout out : ostream, inout sink : base_sink) : void
// write report to log
{
  out << " Results widom test particle method : \n";
  out << " " << std::string( 56+5,'-' ) << "\n";
  out << " " << std::setw( 6 ) << "SPECIE";
  out << " " << std::setw( 10 ) << "SAMPLES";
  out << " " << std::setw( 10 ) << "<U> (E)";
  out << " " << std::setw( 10 ) << "<U>VAR";
  out << " " << std::setw( 10 ) << "EXCESS";
  out << "\n";
  for( widom_datum const& datum : this->data_ )
  {
    if( datum.exp_potential_.count() > 0 )
    {
      out << " CP " << std::setw( 3 ) << datum.label_;
      out << " " << std::setw( 10 ) << datum.exp_potential_.count();
      const double mu = -std::log( datum.exp_potential_.mean() );
      out << " " << std::setw( 10 ) << mu;
      out << " " << std::setw( 10 ) << datum.exp_potential_.variance();
      const double mu_ex = mu - std::log( core::constants::to_SI() * datum.specie_count_.mean() / datum.volume_ );
      out << " " << std::setw( 10 ) << mu_ex;
      out << "\n";
    }
    else
    {
      out << "CP " << std::setw( 8 ) << datum.label_;
      out << " No results as no samples taken.\n";
    }
  }
  out << core::strngs::horizontal_bar() << "\n";
}
// write data to output
{
  const std::string filename { "widom.dat" };

  core::output_series dset { sink.uuid() };
  dset.set_title( "Series of Widom method chemical potential estimates" );
  const std::size_t loopindex = this->loop_count_;

  dset.push_back_entry( core::output_field( "INDEX", "ORDINAL", [loopindex]( std::ostream& os, std::size_t )
  {
    os << loopindex;
  } ) );

  for( widom_datum const& datum : this->data_ )
  {
    dset.push_back_entry( core::output_field( datum.label_ + "_EXCESS0" , "ENERGY", [&datum]( std::ostream& os, std::size_t )
    {
      os << datum.excess_potential_;
    } ) );
    dset.push_back_entry( core::output_field( datum.label_ + "_POTENTIAL" , "ENERGY", [&datum]( std::ostream& os, std::size_t )
    {
      if( datum.exp_potential_.mean() == 0.0 )
        os << 0.0;
      else
        os << -std::log( datum.exp_potential_.mean() );
    } ) );
    dset.push_back_entry( core::output_field( datum.label_ + "_EXCESS" , "ENERGY", [&datum]( std::ostream& os, std::size_t )
    {
      if( datum.exp_potential_.mean() == 0.0 or datum.volume_ == 0.0 )
        os << 0.0;
      else
        os << -std::log( datum.exp_potential_.mean() ) - std::log( core::constants::to_SI() * datum.specie_count_.mean() / datum.volume_ );
    } ) );
    dset.push_back_entry( core::output_field( datum.label_ + "_COUNT" , "COUNT", [&datum]( std::ostream& os, std::size_t )
    {
      os << datum.exp_potential_.count();
    } ) );
  }

  dset.write( filename, sink, not sink.exists( filename ) );

}
// reset accumulators
for( widom_datum & datum : this->data_ )
{
  if( datum.specie_count_.count() > 0 )
  {
    datum.specie_count_.reset();
    datum.exp_potential_.reset();
  }
  // reset the per-cycle iteration
  // counter to zero.
  datum.count_ = 0ul;
}
!!!688048.cpp!!!	on_sample(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager) : void
++this->loop_count_;
utility::fp_env &env( utility::fp_env::env_ );
// Perform insertion trials until minimum number of trials
// has been reached.
auto const& ens = pman.get_ensemble();
const std::size_t nspec = pman.specie_count();
for( widom_datum & datum : this->data_ )
{
  datum.specie_count_.append( double( ens.specie_count( datum.key_ ) ) );
  if( datum.count_ < this->trials() )
  {
    trial::add_specie adder( datum.key_ );
    for( std::size_t imove = datum.count_; imove != this->trials(); ++imove )
    {
      std::unique_ptr< particle::change_set > move_( adder.generate( pman, gman, this->ranf_ ) );
      // Calculate distance vectors.
      for( auto & atom : *move_ )
      {
        gman.calculate_distances( atom.new_position, ens.get_coordinates(), atom.new_rij, 0, ens.size() );
        // check for overlap to existing particles.
        const double iradius = pman.get_specie( atom.key ).radius();
        for( std::size_t idx = 0; idx != atom.new_rij.size() and not move_->fail(); ++idx )
        {
          if( idx != atom.index )
          {
            const std::size_t jspec = ens.key( idx );
            if( jspec < nspec )
            {
              const double min_distance = iradius + pman.get_specie( jspec ).radius();
              if( min_distance > atom.new_rij[ idx ] )
              {
                move_->set_fail();
              }
            }
          }
        }
      }
      // Calculate energy
      eman.compute_potential( pman, gman, *move_ );
      if( not env.no_except() )
      {
        UTILITY_ALWAYS( 0 == ( ( ~env.Inexact ) & env.except() )
                        , " Floating point exception : "+ env.error_message() );
        env.reset();
      }
      // Update data
      this->update_data( ( *move_ )[0], move_->fail() );
    }
    // reset counter.
    datum.count_ = 0ul;
  }
  else
  {
    // reset counter.
    // ** if test assures this->count_[key] >= this->trials() **
    datum.count_ = 0ul;
  }
}



!!!1622064.cpp!!!	on_trial_end(in trial : change_set) : void
// We cannot use "failed" trials but we
// can use all other trials.
for( auto const& atom : trial )
{
  if( atom.do_new and not atom.do_old )
  {
    this->update_data( atom, trial.fail() );
  }
}
!!!2167599.cpp!!!	prepare(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager, in sman : report_manager) : void
this->loop_count_ = 0ul;
this->data_.clear();
if( this->key_labels_.empty() )
{
  // Use all solute species if none specified in the input file.
  for( std::size_t key = 0; key != pman.specie_count(); ++key )
  {
    auto const& spc = pman.get_specie( key );
    if( spc.is_solute() )
    {
      widom_datum datum( key );
      datum.label_ = spc.label();
      datum.excess_potential_ = spc.excess_potential();
      datum.conc_ = spc.concentration();
      datum.volume_ = gman.system_region().volume( spc.radius() );
      this->data_.push_back( datum );
    }
  }
}
else
{
  // Use species specified in the input file.
  boost::tokenizer<> tok { this->key_labels_ };
  // construct a new label list with no duplicate labels
  std::string used_labels;
  for( std::string lbl : tok )
  {
    UTILITY_INPUT( pman.has_specie( lbl ),
                   "widom \"specie\" parameter value ("+ this->key_labels_ +") has unknown specie label ["+ lbl +"]",
                   core::strngs::sampler_label(), nullptr );
    std::size_t key = pman.get_specie_key( lbl );
    UTILITY_INPUT( pman.get_specie( key ).is_solute(),
                   "widom \"specie\" parameter value ("+ this->key_labels_ +") has specie ["+ lbl +"] that is not a solute",
                   core::strngs::sampler_label(), nullptr );
    auto const& spc = pman.get_specie( key );
    // Ignore duplicate indices
    if( this->data_.end() == std::find_if( this->data_.begin(), this->data_.end(), [key]( const widom_datum& dat )
  {
    return dat.key_ == key;
  } ) )
    {
      widom_datum datum( key );
      datum.label_ = spc.label();
      datum.excess_potential_ = spc.excess_potential();
      datum.conc_ = spc.concentration();
      datum.volume_ = gman.system_region().volume( spc.radius() );
      this->data_.push_back( datum );
      used_labels += lbl + " ";
    }
  }
  if( not used_labels.empty() )
  {
    used_labels.pop_back();
  }
  std::swap( this->key_labels_, used_labels );
}
!!!222128.cpp!!!	do_write_document(inout wr : input_document, in ix : size_t) : void
wr[ix].add_entry(core::strngs::fstype(), this->get_label());
wr[ix].add_entry(core::strngs::fsiwid(), this->trials());
if (not this->key_labels_.empty())
{
  wr[ix].add_entry(core::strngs::fsspec(), this->key_labels_);
}
!!!686512.cpp!!!	specie_of_interest(in idx : size_t) : bool
return this->data_.end() != std::find_if(this->data_.begin(), this->data_.end(), [idx](widom_datum const& dat){ return dat.key_ == idx; });

!!!434481.cpp!!!	update_data(in atom : change_atom, in is_fail : bool) : void
for( widom_datum &datum : this->data_ )
{
  if( datum.key_ == atom.key )
  {
    ++datum.count_;
    if( not is_fail )
    {
      datum.exp_potential_.append( std::exp( -atom.energy_new ) );
    }
    else
    {
      // failed test has failure probability of 1
      datum.exp_potential_.append( 1.0 );
    }
    break;
  }
}

