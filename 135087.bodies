class widom
!!!1628976.cpp!!!	add_definition(inout meta : sampler_meta) : void
std::unique_ptr< tracked_definition > result( new tracked_definition( type_label_(), &widom::make_sampler ) );
// two extra parameters
result->add_definition( "width", "[optional, number, default(0)] Minimum number of insertion attempts per sampling period." );
result->add_definition( core::strngs::fsspec(), "[optional, list] List of specie labels to use. Species must be solute type. Default is to use all solute species." );
meta.add_tracked_type( result );
!!!488113.cpp!!!	description(inout out : ostream) : void
out << "[sampler] " << this->get_label() << "\n";
out << " Sample the free energy distribution of the ensemble\n";
out << " - Trials per sampling loop : " << this->trials_ << "\n";

!!!695984.cpp!!!	get_value() : boost::any
boost::any result = this->data_;
return result;
!!!2175279.cpp!!!	make_sampler(in params : string) : tracked_observable
std::unique_ptr< widom > smplr( new widom );
// Check parameters for usable values
for( auto const& item : params )
{
  if( item.first == core::strngs::fsiwid() )
  {
    core::input_base_reader::ordinal_input( item.first, item.second, type_label_(), core::strngs::sampler_label(), smplr->trials_ );
  }
  else if( item.first == core::strngs::fsspec() )
  {
    smplr->key_labels_ = item.second;
  }
  else
  {
    const std::string known_key;
    UTILITY_INPUT( item.first==known_key,
                   "Parameter ["+item.first+"] unknown for sampler type ["+widom::type_label_()+"]",
                   core::strngs::sampler_label() );
  }
}
boost::shared_ptr< tracked_observable > result;
result.reset( smplr.release() );
return result;

!!!1747631.cpp!!!	on_report(inout out : ostream, inout sink : base_sink) : void
// write report to log
{
  out << " Results widom test particle method : \n";
  out << " " << std::string( 56+5,'-' ) << "\n";
  out << " " << std::setw( 6 ) << "SPECIE";
  out << " " << std::setw( 10 ) << "SAMPLES";
  out << " " << std::setw( 10 ) << "-ln<e-E>";
  out << " " << std::setw( 10 ) << "V(e-E)";
  out << " " << std::setw( 10 ) << "<E>";
  out << " " << std::setw( 10 ) << "V(E)";
  out << "\n";
  for( widom_datum const& datum : this->data_ )
  {
    if( datum.chem_potential_.count() > 0 )
    {
      out << " CP " << std::setw( 3 ) << datum.specie_label_;
      out << " " << std::setw( 10 ) << datum.chem_potential_.count();
      out << " " << std::setw( 10 ) << -std::log( datum.exp_chem_potential_.mean() );
      out << " " << std::setw( 10 ) << datum.exp_chem_potential_.variance();
      out << " " << std::setw( 10 ) << datum.chem_potential_.mean();
      out << " " << std::setw( 10 ) << datum.chem_potential_.variance();
      out << "\n";
    }
    else
    {
      out << "CP " << std::setw( 8 ) << datum.specie_label_;
      out << " No results as no samples taken.\n";
    }
  }
  out << core::strngs::horizontal_bar() << "\n";
}
// write data to output
{
  const std::string filename { "widom.dat" };

  core::output_series dset { sink.uuid() };
  dset.set_title( "Series of Widom method chemical potential estimates" );
  const std::size_t loopindex = this->loop_count_;

  dset.push_back_entry( core::output_field( "INDEX", "ORDINAL", [loopindex]( std::ostream& os, std::size_t )
  {
    os << loopindex;
  } ) );

  for( widom_datum const& datum : this->data_ )
  {
    dset.push_back_entry( core::output_field( datum.specie_label_ + "_CURRENT" , "ENERGY", [&datum]( std::ostream& os, std::size_t )
    {
      os << datum.specie_ecp_;
    } ) );
    dset.push_back_entry( core::output_field( datum.specie_label_ + "_E_MEAN" , "LN(-ENERGY)", [&datum]( std::ostream& os, std::size_t )
    {
      os << -std::log( datum.exp_chem_potential_.mean() );
    } ) );
    dset.push_back_entry( core::output_field( datum.specie_label_ + "_MEAN" , "ENERGY", [&datum]( std::ostream& os, std::size_t )
    {
      os << datum.chem_potential_.mean();
    } ) );
    dset.push_back_entry( core::output_field( datum.specie_label_ + "_COUNT" , "COUNT", [&datum]( std::ostream& os, std::size_t )
    {
      os << datum.exp_chem_potential_.count();
    } ) );
  }

  dset.write( filename, sink, not sink.exists( filename ) );

}
// reset accumulators
for( widom_datum & datum : this->data_ )
{
  if( datum.chem_potential_.count() > 0 )
  {
    datum.chem_potential_.reset();
    datum.exp_chem_potential_.reset();
  }
  // reset the per-cycle iteration
  // counter to zero.
  datum.count_ = 0ul;
}
!!!688048.cpp!!!	on_sample(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager) : void
++this->loop_count_;
utility::fp_env &env( utility::fp_env::env_ );
// Perform insertion trials until minimum number of trials
// has been reached.
auto const& ens = pman.get_ensemble();
for( widom_datum & datum : this->data_ )
{
  if( datum.count_ < this->trials() )
  {
    trial::add_specie adder( datum.specie_key_ );
    std::size_t imove = datum.count_;
    std::size_t fail_safe = 0;
    while( imove != this->trials() )
    {
      ++fail_safe;
      if( fail_safe > ( this->trials() * 100 ) )
      {
        std::cerr << "WARNING: Widom sampler's add attempts are below 1\% for specie " << pman.get_specie( datum.specie_key_ ).label() << ".\n";
        break;
      }
      std::unique_ptr< particle::change_set > move_( adder.generate( pman, gman, this->ranf_ ) );
      // Calculate distance vectors.
      for( auto & atom : *move_ )
      {
        gman.calculate_distances( atom.new_position, ens.get_coordinates(), atom.new_rij, 0, ens.size() );
      }
      // Calculate energy
      for( auto const& evaluator : eman.get_evaluators() )
      {
        evaluator.compute_potential( pman, gman, *move_ );
        if( move_->fail() ) break;
      }
      if( not env.no_except() )
      {
        UTILITY_ALWAYS( 0 == ( ( ~env.Inexact ) & env.except() )
                        , " Floating point exception : "+ env.error_message() );
        env.reset();
      }
      if( not move_->fail() ) // **
      {
        // ** We skip failed attempts as we assume
        // these are particle-particle overlaps which
        // have infinite/undefined energy.

        // Update data
        ++imove;
        this->update_data( ( *move_ )[0] );
      }
    }
    // reset counter.
    datum.count_ = 0ul;
  }
  else
  {
    // reset counter.
    // ** if test assures this->count_[key] >= this->trials() **
    datum.count_ = 0ul;
  }
}

!!!1622064.cpp!!!	on_trial_end(in trial : change_set) : void
// We cannot use "failed" trials but we
// can use all other trials.
if( not trial.fail() )
{
  for( auto const& atom : trial )
  {
    if( atom.do_new and not atom.do_old )
    {
      this->update_data( atom );
    }
  }
}
!!!2167599.cpp!!!	prepare(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager, in sman : report_manager) : void
this->loop_count_ = 0ul;
this->data_.clear();
if( this->key_labels_.empty() )
{
  // Use all solute species if none specified in the input file.
  for( std::size_t key = 0; key != pman.specie_count(); ++key )
  {
    if( pman.get_specie( key ).is_solute() )
    {
      this->data_.push_back( widom_datum( key ) );
      this->data_.back().specie_label_ = pman.get_specie( key ).label();
      this->data_.back().specie_ecp_ = pman.get_specie( key ).excess_potential();
    }
  }
}
else
{
  // Use species specified in the input file.
  boost::tokenizer<> tok { this->key_labels_ };
  // construct a new label list with no duplicate labels
  std::string used_labels;
  for( std::string lbl : tok )
  {
    UTILITY_INPUT( pman.has_specie( lbl ),
                   "Specie label ["+lbl+"] not found",
                   core::strngs::sampler_label() );
    std::size_t key = pman.get_specie_key( lbl );
    UTILITY_INPUT( pman.get_specie( key ).is_solute(),
                   "Specie labelled ["+lbl+"] is not a solute",
                   core::strngs::sampler_label() );
    // Ignore duplicate indices
    if( this->data_.end() == std::find_if( this->data_.begin(), this->data_.end(), [key]( const widom_datum& dat )
  {
    return dat.specie_key_ == key;
  } ) )
    {
      this->data_.push_back( widom_datum( key ) );
      this->data_.back().specie_label_ = pman.get_specie( key ).label();
      this->data_.back().specie_ecp_ = pman.get_specie( key ).excess_potential();
      used_labels += lbl + " ";
    }
  }
  if( not used_labels.empty() )
  {
    used_labels.pop_back();
  }
  std::swap( this->key_labels_, used_labels );
}
!!!222128.cpp!!!	do_write_document(inout wr : input_document, in ix : size_t) : void
wr[ix].add_entry(core::strngs::fstype(), this->get_label());
wr[ix].add_entry(core::strngs::fsiwid(), this->trials());
if (not this->key_labels_.empty())
{
  wr[ix].add_entry(core::strngs::fsspec(), this->key_labels_);
}
!!!686512.cpp!!!	specie_of_interest(in idx : size_t) : bool
return this->data_.end() != std::find_if(this->data_.begin(), this->data_.end(), [idx](widom_datum const& dat){ return dat.specie_key_ == idx; });

!!!434481.cpp!!!	update_data(in atom : change_atom) : void
for( widom_datum &datum : this->data_ )
{
  if( datum.specie_key_ == atom.key )
  {
    ++datum.count_;
    datum.chem_potential_.append( atom.energy_new );
    datum.exp_chem_potential_.append( std::exp( -atom.energy_new ) );
    break;
  }
}

