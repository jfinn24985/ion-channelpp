class widom
!!!488113.cpp!!!	description(inout out : ostream) : void
out << "[sampler] " << this->get_label() << "\n";
out << " Sample the free energy distribution of the ensemble\n";
out << " - Trials per sampling loop : " << this->trials_ << "\n";

!!!222128.cpp!!!	do_write_document(inout wr : input_document, in ix : size_t) : void
wr[ix].add_entry(core::strngs::fstype(), this->get_label());
wr[ix].add_entry(core::strngs::fsiwid(), this->trials());
const bool use_main = (this->monitor_.lock() ? true : false);
wr[ix].add_entry(core::strngs::fswidm(), use_main);
if (not this->key_labels_.empty())
{
  wr[ix].add_entry(core::strngs::fsspec(), this->key_labels_);
}
!!!695984.cpp!!!	get_value() : boost::any
boost::any result = this->data_;
return result;
!!!1747631.cpp!!!	on_report(in sim : simulator, inout out : ostream, inout reporter : report_manager) : void
// write report to log
{
   out << " Results widom test particle method : \n";
   out << " " << std::string(56+5,'-') << "\n";
   out << " " << std::setw(6) << "SPECIE";
   out << " " << std::setw(10) << "SAMPLES";
   out << " " << std::setw(10) << "-ln<e-E>";
   out << " " << std::setw(10) << "V(e-E)";
   out << " " << std::setw(10) << "<E>";
   out << " " << std::setw(10) << "V(E)";
   out << "\n";
   for (widom_datum const& datum : this->data_)
   {
      if (datum.chem_potential_.count() > 0)
      {
         out << " CP " << std::setw(3) << sim.get_specie(datum.specie_key_).label();
         out << " " << std::setw(10) << datum.chem_potential_.count();
         out << " " << std::setw(10) << -std::log(datum.exp_chem_potential_.mean());
         out << " " << std::setw(10) << datum.exp_chem_potential_.variance();
         out << " " << std::setw(10) << datum.chem_potential_.mean();
         out << " " << std::setw(10) << datum.chem_potential_.variance();
         out << "\n";
      }
      else
      {
         out << "CP " << std::setw(8) << sim.get_specie(datum.specie_key_).label();
         out << " No results as no samples taken.\n";
      }
   }
  out << core::strngs::horizontal_bar() << "\n";
}
// write data to output
{
   const std::string filename { "widom.dat" };

   const std::size_t loopindex { sim.get_outer_loop_index() };

   core::output_series dset { sim.run_uuid() };
   dset.set_title( "Series of Widom method chemical potential estimates" );

   dset.push_back_entry( core::output_field( "INDEX", "ORDINAL", [loopindex](std::ostream& os, std::size_t)
   {
      os << loopindex;
   } ) );

   for (widom_datum const& datum : this->data_)
   {
      auto const& spc = sim.get_specie(datum.specie_key_);
      dset.push_back_entry( core::output_field( spc.label() + "_CURRENT" , "COUNT", [&spc](std::ostream& os, std::size_t)
      {
         os << spc.excess_potential();
      } ) );
      dset.push_back_entry( core::output_field( spc.label() + "_E_MEAN" , "COUNT", [&datum](std::ostream& os, std::size_t)
      {
         os << -std::log(datum.exp_chem_potential_.mean());
      } ) );
      dset.push_back_entry( core::output_field( spc.label() + "_MEAN" , "COUNT", [&datum](std::ostream& os, std::size_t)
      {
         os << datum.chem_potential_.mean();
      } ) );
      dset.push_back_entry( core::output_field( spc.label() + "_COUNT" , "COUNT", [&datum](std::ostream& os, std::size_t)
      {
         os << datum.exp_chem_potential_.count();
      } ) );
   }

   dset.write( filename, reporter.get_sink(), 1 == loopindex );

}
// reset accumulators
for (widom_datum & datum : this->data_)
{
   if (datum.chem_potential_.count() > 0)
   {
      datum.chem_potential_.reset();
      datum.exp_chem_potential_.reset();
   }
   // reset the per-cycle iteration
   // counter to zero.
   datum.count_ = 0ul;
}
!!!688048.cpp!!!	on_sample(in sim : simulator) : void
utility::fp_env &env(utility::fp_env::env_);
// Perform insertion trials until minimum number of trials
// has been reached.
for (widom_datum & datum : this->data_)
{
  if (datum.count_ < this->trials())
  {
    periodic_cube::add_specie_pbc adder(datum.specie_key_, nullptr);
    std::size_t imove = datum.count_;
    std::size_t fail_safe = 0;
    while(imove != this->trials())
    {
      ++fail_safe;
      if (fail_safe > (this->trials() * 100))
      {
        std::cerr << "WARNING: Widom sampler's add attempts are below 1\% for specie " << sim.get_specie(datum.specie_key_).label() << ".\n";
        break;
      } 
      std::unique_ptr< trial::change_set > move_(adder.generate(sim, this->ranf_));
      // Calculate distance vectors.
      for (auto & atom : *move_)
      {
        sim.compute_distances( atom.new_position, sim.get_ensemble().get_coordinates(), atom.new_rij, sim.get_ensemble().size(), 0 );
      }
      // Calculate energy
      for (auto const& evaluator : sim.get_evaluators())
      {
        evaluator.compute_potential( sim.get_species(), sim.get_ensemble(), *move_, 0 );
        if (move_->fail()) break;
      }
      if ( not env.no_except() )
      {
        UTILITY_ALWAYS (0 == ((~env.Inexact) & env.except())
          , " Floating point exception : "+ env.error_message ());
        env.reset();
      }
      if (not move_->fail()) // **
      { 
        // ** We skip failed attempts as we assume
        // these are particle-particle overlaps which
        // have infinite/undefined energy. 

        // Update data
        ++imove;
        this->update_data((*move_)[0]);
      }
    }
    // reset counter.
    datum.count_ = 0ul;
  }
  else
  {
    // reset counter.
    // ** if test assures this->count_[key] >= this->trials() **
    datum.count_ -= this->trials();
  }
}
!!!2167599.cpp!!!	prepare(inout sim : simulator) : void
this->data_.clear();
if (this->key_labels_.empty())
{
  // Use all solute species if none specified in the input file.
  for (std::size_t key = 0; key != sim.specie_count(); ++key)
  {
    if (sim.get_specie(key).is_solute())
    {
      this->data_.push_back(widom_datum(key));
      this->key_labels_ += sim.get_specie(key).label() + " ";
    }
  }
  if (not this->key_labels_.empty())
  {
     this->key_labels_.pop_back();
  }
}
else
{
  // Use species specified in the input file.
  boost::tokenizer<> tok{ this->key_labels_ };
  // construct a new label list with no duplicate labels
  std::string used_labels{};
  for (auto beg = tok.begin(); beg != tok.end(); ++beg)
  {
    std::string lbl{ *beg };
    UTILITY_INPUT(sim.has_specie(lbl),
                  "Specie label ["+lbl+"] not found",
                  core::strngs::sampler_label());
    std::size_t key = sim.get_specie_key(lbl);
    UTILITY_INPUT(sim.get_specie(key).is_solute(),
                  "Specie labelled ["+lbl+"] is not a solute",
                  core::strngs::sampler_label());
    // Ignore duplicate indices
    if (this->data_.end() == std::find_if(this->data_.begin(), this->data_.end(), [key](const widom_datum& dat){ return dat.specie_key_ == key; }))
    {
      this->data_.push_back(widom_datum(key));
      used_labels += lbl + " ";
    }
  }
  if (not used_labels.empty())
  {
     used_labels.pop_back();
  }
  std::swap(this->key_labels_, used_labels);
}
!!!686512.cpp!!!	specie_of_interest(in idx : size_t) : bool
return this->data_.end() != std::find_if(this->data_.begin(), this->data_.end(), [idx](widom_datum const& dat){ return dat.specie_key_ == idx; });

!!!434481.cpp!!!	update_data(in atom : change_atom) : void
for (widom_datum &datum : this->data_)
{
  if (datum.specie_key_ == atom.key)
  {
    ++datum.count_;
    datum.chem_potential_.append(atom.energy_new);
    datum.exp_chem_potential_.append(std::exp(-atom.energy_new));
    break;
  }
}
!!!2175279.cpp!!!	make_sampler(in params : string, inout sim : simulator) : void
boost::shared_ptr< widom > smplr(new widom);
// Check parameters for usable values
bool use_main = true;
for (auto const& item : params)
{
  if (item.first == core::strngs::fsiwid())
  {
    smplr->trials_ = boost::lexical_cast< std::size_t >(item.second);
  }
  else if (item.first == core::strngs::fswidm())
  {
    use_main = core::input_reader::read_as_bool(item.second);
  }
  else if (item.first == core::strngs::fsspec())
  {
    smplr->key_labels_ = item.second;
  }
  else
  {
    const std::string known_key;
    UTILITY_INPUT(item.first==known_key,
      "Parameter ["+item.first+"] unknown for sampler type ["+widom::type_label_()+"]",
      core::strngs::sampler_label ());
  }
}
if (use_main)
{
  boost::shared_ptr< widom_monitor > monitor(new widom_monitor(smplr));
  smplr->monitor_ = monitor;
  sim.get_reporter().add_tracked(monitor);
}
// boost::shared_ptr< observable::base_observable > result(smplr.release());
sim.get_reporter().add_sample(smplr);
