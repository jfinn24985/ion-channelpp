class simulator_meta
!!!2162607.cpp!!!	do_read_entry(inout reader : input_base_reader) : bool
// Example input section
//
// simulator
// name Some title
// outputdir somewhere/here
// inputname some regular expression
// nstep 100000
// naver 1000
// inner 1000 # Number or "auto"
// isave 1000
// ntarg 300
// kelvin 300
// type standard
// end
//
// process entry
if (reader.name().find(core::strngs::fsname()) == 0)
{
   // --------------------
   //run title "name ##"
   UTILITY_INPUT(not reader.value().empty(), "Simulation title \""+core::strngs::fsname()+"\" parameter requires a value.", this->section_label(), &reader);
   const std::string title { reader.dequote( reader.value() ) };
   UTILITY_INPUT(not title.empty(), "Simulation title \""+core::strngs::fsname()+"\" parameter requires a non-empty value.", this->section_label(), &reader);
   this->sim_->set_run_title( title );
}
else if (reader.name().find(core::strngs::fsnstp()) == 0)
{
   // --------------------
   // Number of production step "nstep ##"
   this->nstep_ = reader.get_ordinal( "Simulation production step", this->section_label() );
   this->required_tags_.set( SIMULATOR_PROD );
}
else if (reader.name().find(core::strngs::fsnavr()) == 0)
{
   // --------------------
   // Number of equilibrium step "naver ##"
   this->naver_ = reader.get_ordinal( "Simulation equilibration step", this->section_label() );
   this->required_tags_.set( SIMULATOR_THERM );
}
else if (reader.name().find(core::strngs::inner_label()) == 0)
{
   // --------------------
   // Number of inner loop trials per step "inner ##"
   this->sim_->set_inner_loop_size( reader.get_ordinal( "Simulation inner loop", this->section_label() ) );
   this->required_tags_.set( SIMULATOR_INNER );
}
else if (reader.name().find(core::strngs::fsisav()) == 0)
{
   // --------------------
   // Checkpoint interval "isave ##"
   this->sim_->set_report_interval( reader.get_ordinal( "Simulation checkpoint/report interval", this->section_label() ) );
   this->required_tags_.set( SIMULATOR_CHECK );
}
else if (reader.name().find(core::strngs::fsntrg()) == 0)
{
   // --------------------
   // Target particle number "ntarg ##"
   this->sim_->set_target_count( reader.get_ordinal( "Simulation target particle number", this->section_label() ) );
}
else if (reader.name().find(core::strngs::fsepsw()) == 0)
{
   // --------------------
   // Relative permittivity of media "epsw ##.#"
   this->sim_->set_solvent_permittivity( reader.get_float( "Simulation media permittivity", this->section_label(), true, false ) );
}
else if (reader.name().find(core::strngs::fstsi()) == 0)
{
   // --------------------
   // Temperature "kelvin ##.#"
   const double temperature = reader.get_float( "Simulation temperature (in kelvin)", this->section_label(), true, false );
   this->sim_->set_temperature( temperature );
   if (temperature < 273.0)
   {
    this->sim_->get_log() << core::strngs::horizontal_bar() << "\n";
    {
      namespace io = boost::iostreams;
      core::fixed_width_output_filter filt( 2, 1, 68 );
      io::filtering_ostream os;
      os.push( filt );
      os.push( this->sim_->get_log() );
      os << "WARNING: Requested simulation temperature ("
         << temperature << ") is below the freezing point of water.";
    }
    this->sim_->get_log() << "\n" << core::strngs::horizontal_bar() << "\n";
   }
}
else if( reader.name().find( core::strngs::fstype() ) == 0 )
{
  // --------------------
  // Storage manager subtype
  UTILITY_INPUT( this->type_.empty(), ( "Simulation manager \"type\" parameter appears more than once." ), this->section_label(), &reader );
  UTILITY_INPUT( not reader.value().empty(), (core::input_error_messages::missing_value() % core::strngs::fstype() % this->section_label() ).str(), this->section_label(), &reader );
  std::string val( reader.dequote( reader.value() ) );
  UTILITY_INPUT( this->has_type( val ), "Simulation manager \"type\" parameter value (" + val + ") does not name a valid simulation manager subtype for this application (see documentation).", this->section_label(), &reader );
  this->type_ = val;
  this->required_tags_.set( SIMULATOR_TYPE );
}
else
{
  // --------------------
  // Choice specific parameters?
  UTILITY_INPUT( 0 == this->params_.count( reader.name() ), ( "Sampler \""+reader.name()+"\" parameter appears more than once in a single in section" ), this->section_label(), &reader );
  this->params_.insert( std::make_pair( reader.name(), reader.value() ) );
}
return true;
!!!186416.cpp!!!	do_read_end() : void
UTILITY_INPUT( this->required_tags_[SIMULATOR_PROD], "Simulation production step \""+core::strngs::fsnstp()+"\" missing in input file.", this->section_label(), nullptr);
UTILITY_INPUT( this->required_tags_[SIMULATOR_THERM], "Simulation equilibration step \""+core::strngs::fsnavr()+"\" missing in input file.", this->section_label(), nullptr);
UTILITY_INPUT( this->required_tags_[SIMULATOR_CHECK], "Simulation checkpoint/report interval \""+core::strngs::fsisav()+"\" missing in input file.", this->section_label(), nullptr);
UTILITY_INPUT( this->required_tags_[SIMULATOR_INNER], "Simulation inner loop \""+core::strngs::inner_label()+"\" missing in input file.", this->section_label(), nullptr);
UTILITY_INPUT( this->required_tags_[SIMULATOR_TYPE], "Simulation manager \""+core::strngs::fstype()+"\" missing in input file.", this->section_label(), nullptr);
UTILITY_INPUT( this->required_tags_.all(), "Not all required tags were present.", this->section_label(), nullptr);
// create sim manager
for( auto const& defn : this->types_ )
{
  if( defn.label() == this->type_ )
  {
    // check parameters.
    for( auto const& entry : this->params_ )
    {
      UTILITY_INPUT( defn.has_definition( entry.first ), str( core::input_error_messages::invalid_parameter_subtype() % entry.first % this->section_label() % this->type_ ), this->section_label(), nullptr );
    }
    boost::shared_ptr< simulation_manager > sman;
    sman = defn( this->params_ );
    sman->set_equilibration_interval( this->naver_ );
    sman->set_production_interval( this->nstep_ );
    this->sim_->set_manager( sman );
    return;
  }
}
UTILITY_ALWAYS( false, "Programming error, should never get here." );  
!!!1938224.cpp!!!	add_type(inout ctor : simulation_definition) : void
UTILITY_REQUIRE( not this->has_type( ctor->label() ), ("Attempt to add more than one chooser factory for type \"" + ctor->label() + "\".") );
this->types_.push_back( ctor.release() );
!!!1938096.cpp!!!	has_type(in label : string) : bool
for( auto const& defn : this->types_ )
{
  if( defn.label() == label )
  {
    return true;
  }
}
return false;

!!!268720.cpp!!!	do_reset() : void
this->required_tags_.reset();
!!!1886768.cpp!!!	publish_help(inout helper : input_help) : void
const std::string seclabel( core::strngs::simulator_label() );
// ----------------------------------------
// add section
// ----------------------------------------
//   Specie input section definition
helper.add_section( { seclabel, "Define global simulation parameters." } );
auto &sect = helper.get_section( seclabel );


// ----------------------------------------
// add parameters { name, type, range, default, description } 
// ----------------------------------------

//XX // nstep : [required, number] production steps
//XX {
//XX   const std::string description( "Number of steps in production phase of simulation." );
//XX   sect.add_entry( { core::strngs::fsnstp(), "integer", "> 0", "required", description } );
//XX }
//XX // naver : [required, number] equilibrium steps
//XX {
//XX   const std::string description( "Number of steps in equilibration/thermalization phase of simulation." );
//XX   sect.add_entry( { core::strngs::fsnavr(), "integer", "> 0", "required", description } );
//XX }
// isave : [required, number] steps between system checkpoints
{
  const std::string description( "Number of steps between checkpoints and reports of the system." );
  sect.add_entry( { core::strngs::fsisav(), "integer", "> 0", "required", description } );
}
// inner : [optional, number] steps between system checkpoints
{
  const std::string description( "Number of trials within a step. TODO: Default is 'auto' which gives a loop size that scales with the problem size." );
  sect.add_entry( { core::strngs::inner_label(), "integer", "> 0", "required", description } );
}

// kelvin : [optional, number] simulation temperature (in Kelvin)
{
  const std::string description( "Simulation temperature in Kelvin. The default is room temperature. For the simulation to be meaningful the temperature should be above the freezing point of the media." );
  sect.add_entry( { core::strngs::fstsi(), "number", "> 0.0", std::to_string( evaluator::evaluator_manager::standard_room_temperature() ), description } );
}
// name : [optional, string] User provided descriptive title
{
  const std::string description( "Title or descriptive text for the simulation." );
  sect.add_entry( { core::strngs::fsname(), "text", "", "optional", description } );
}
// ntarg : [required, integer] target average particle count.
{
  const std::string description( "Target average number of solute particles. If no value (or zero) is given then the simulation will attempt to calculate the particle number from the target concentration and initial volume.  (If no concentrations are given and no ntarg then the particle defined in the input file specie sections are used as-is.)" );
  sect.add_entry( { core::strngs::fsntrg(), "integer", ">0", "optional", description } );
}
// epsw : [optional, number > 0.0] The relative permittivity of the media 
{
  const std::string description( "The relative permittivity of the media. The default is the standard relative permittivity of water." );
  sect.add_entry( { core::strngs::fsepsw(), "number", "> 0.0", std::to_string( evaluator::evaluator_manager::standard_aqueous_permittivity() ), description } );
}

