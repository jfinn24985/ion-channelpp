class simulator_meta
!!!2162607.cpp!!!	do_read_entry(inout reader : input_base_reader) : bool
// Example input section
//
// simulator
// name Some title
// outputdir somewhere/here
// inputname some regular expression
// nstep 100000
// naver 1000
// inner 1000 # Number or "auto"
// isave 1000
// ntarg 300
// kelvin 300
// end
//
// process entry
if (reader.name().find(core::strngs::fsname()) == 0)
{
   // --------------------
   //run title "name ##"
   UTILITY_INPUT(not reader.value().empty(), "Run title '"+core::strngs::fsname()+"' must have a value.", this->section_label(), &reader);
   const std::string title { reader.dequote( reader.value() ) };
   UTILITY_INPUT(not title.empty(), "Run title '"+core::strngs::fsname()+"' must have a value.", this->section_label(), &reader);
   this->sim_->set_run_title( title );
}
else if (reader.name().find(core::strngs::outputdir_label()) == 0)
{
   // --------------------
   // Output/data directory name "outputdir 'abc/def'"
   UTILITY_INPUT(not reader.value().empty(), "Output directory '"+core::strngs::outputdir_label()+"' must have a value.", this->section_label(), &reader);
   // Need to test for directory existance elsewhere
   this->sim_->set_output_dir_fmt( reader.dequote( reader.value() ) );
}
else if (reader.name().find(core::strngs::inputpattern_label()) == 0)
{
   // --------------------
   // Input file recognition pattern "inputpattern 'abc.%03d.def'"
   UTILITY_INPUT(not reader.value().empty(), "Input file recognition pattern '"+core::strngs::inputpattern_label()+"' must have a value.", this->section_label(), &reader);
   this->sim_->set_filename_base( reader.dequote( reader.value() ) );
}
else if (reader.name().find(core::strngs::fsnstp()) == 0)
{
   // --------------------
   // Number of production step "nstep ##"
   UTILITY_INPUT(not reader.value().empty(), "Number of production steps '"+core::strngs::fsnstp()+"' must have a value.", this->section_label(), &reader);
   try
   {
      this->sim_->set_production_interval( boost::lexical_cast< std::size_t  >(reader.value()) );
      UTILITY_INPUT(this->sim_->production_interval() > 0ul, "Number of production steps must be greater than zero.", this->section_label(), &reader);
      this->missing_required_tags_.reset(SIMULATOR_PROD);
   }
   catch (boost::bad_lexical_cast const& err)
   {
      const bool convert_succeed(false);
      UTILITY_INPUT(convert_succeed, "Invalid value for " + core::strngs::fsnstp() + " : " + err.what(), this->section_label(), &reader);
   }
}
else if (reader.name().find(core::strngs::fsnavr()) == 0)
{
   // --------------------
   // Number of equilibrium step "naver ##"
   UTILITY_INPUT(not reader.value().empty(), "Number of equilibration steps '"+core::strngs::fsnavr()+"' must have a value.", this->section_label(), &reader);
   try
   {
      this->sim_->set_equilibration_interval( boost::lexical_cast< std::size_t  >(reader.value()) );
      UTILITY_INPUT(this->sim_->equilibration_interval() > 0ul, "Number of equilibration steps must be greater than zero.", this->section_label(), &reader);
      this->missing_required_tags_.reset(SIMULATOR_THERM);
   }
   catch (boost::bad_lexical_cast const& err)
   {
      const bool convert_succeed(false);
      UTILITY_INPUT(convert_succeed, "Invalid value for " + core::strngs::fsnavr() + " : " + err.what(), this->section_label(), &reader);
   }
}
else if (reader.name().find(core::strngs::inner_label()) == 0)
{
   // --------------------
   // Number of inner loop trials per step "inner ##"
   UTILITY_INPUT(not reader.value().empty(), "Number of production steps '"+core::strngs::inner_label()+"' must have a value.", this->section_label(), &reader);
   try
   {
      this->sim_->set_inner_loop_size( boost::lexical_cast< std::size_t  >(reader.value()) );
      UTILITY_INPUT(this->sim_->inner_loop_size() > 0ul, "Number of production steps must be greater than zero.", this->section_label(), &reader);
   }
   catch (boost::bad_lexical_cast const& err)
   {
      const bool convert_succeed(false);
      UTILITY_INPUT(convert_succeed, "Invalid value for " + core::strngs::inner_label() + " : " + err.what(), this->section_label(), &reader);
   }
}
else if (reader.name().find(core::strngs::fsisav()) == 0)
{
   // --------------------
   // Checkpoint interval "isave ##"
   UTILITY_INPUT(not reader.value().empty(), "Checkpoint interval '"+core::strngs::fsisav()+"' must have a value.", this->section_label(), &reader);
   try
   {
      this->sim_->set_report_interval( boost::lexical_cast< std::size_t  >(reader.value()) );
      UTILITY_INPUT(this->sim_->report_interval() > 0ul, "Reporting interval must be greater than zero", this->section_label(), &reader);
      this->missing_required_tags_.reset(SIMULATOR_CHECK);
   }
   catch (boost::bad_lexical_cast const& err)
   {
      const bool convert_succeed(false);
      UTILITY_INPUT(convert_succeed, "Invalid value for " + core::strngs::fsisav() + " : " + err.what(), this->section_label(), &reader);
   }
}
else if (reader.name().find(core::strngs::fsntrg()) == 0)
{
   // --------------------
   // Target particle number "ntarg ##"
   UTILITY_INPUT(not reader.value().empty(), "Target particle number '"+core::strngs::fsntrg()+"' must have a value.", this->section_label(), &reader);
   try
   {
      this->sim_->set_target_count( boost::lexical_cast< std::size_t  >(reader.value()) );
      UTILITY_INPUT(this->sim_->target_count() > 0ul, "Target particle number must be greater than zero", this->section_label(), &reader);
      this->missing_required_tags_.reset(SIMULATOR_NTARG);
   }
   catch (boost::bad_lexical_cast const& err)
   {
      const bool convert_succeed(false);
      UTILITY_INPUT(convert_succeed, "Invalid value for " + core::strngs::fsntrg() + " : " + err.what(), this->section_label(), &reader);
   }
}
else if (reader.name().find(core::strngs::fstsi()) == 0)
{
   // --------------------
   // Temperature "kelvin ##.#"
   UTILITY_INPUT(not reader.value().empty(), "Temperature '"+core::strngs::fstsi()+"' must have a value.", this->section_label(), &reader);
   try
   {
      this->sim_->set_temperature( boost::lexical_cast< double >(reader.value()) );
      if (this->sim_->get_temperature() < 273.0)
      {
         std::cerr << "WARNING: Requested simulation temperature is below the freezing point of water.";
      }
   }
   catch (boost::bad_lexical_cast const& err)
   {
      const bool convert_succeed(false);
      UTILITY_INPUT(convert_succeed, "Invalid value for " + core::strngs::fstsi() + " : " + err.what(), this->section_label(), &reader);
   }
}
else
{
   // Option not understood
   return false;
}
return true;
!!!186416.cpp!!!	do_read_end(inout sim : simulator) : void
UTILITY_INPUT(not this->missing_required_tags_.any(), "Not all required tags were present.", this->section_label(), nullptr);
!!!268720.cpp!!!	do_reset() : void
this->missing_required_tags_.reset();
!!!1886768.cpp!!!	publish_help(inout helper : input_help) : void
const std::string seclabel( core::strngs::simulator_label() );
// ----------------------------------------
// add section
// ----------------------------------------
//   Specie input section definition
helper.add_section( { seclabel, "Define global simulation parameters." } );
auto &sect = helper.get_section( seclabel );


// ----------------------------------------
// add parameters { name, type, range, default, description } 
// ----------------------------------------

//XX // nstep : [required, number] production steps
//XX {
//XX   const std::string description( "Number of steps in production phase of simulation." );
//XX   sect.add_entry( { core::strngs::fsnstp(), "integer", "> 0", "required", description } );
//XX }
//XX // naver : [required, number] equilibrium steps
//XX {
//XX   const std::string description( "Number of steps in equilibration/thermalization phase of simulation." );
//XX   sect.add_entry( { core::strngs::fsnavr(), "integer", "> 0", "required", description } );
//XX }
// isave : [required, number] steps between system checkpoints
{
  const std::string description( "Number of steps between checkpoints and reports of the system." );
  sect.add_entry( { core::strngs::fsisav(), "integer", "> 0", "required", description } );
}
// inner : [optional, number] steps between system checkpoints
{
  const std::string description( "Number of trials within a step. TODO: Default is 'auto' which gives a loop size that scales with the problem size." );
  sect.add_entry( { core::strngs::inner_label(), "integer", "> 0", "required", description } );
}

// kelvin : [optional, number] simulation temperature (in Kelvin)
{
  const std::string description( "Simulation temperature in Kelvin. The default is room temperature. For the simulation to be meaningful the temperature should be above the freezing point of the media." );
  sect.add_entry( { core::strngs::fstsi(), "number", "> 0.0", std::to_string( evaluator::evaluator_manager::standard_room_temperature() ), description } );
}
// name : [optional, string] User provided descriptive title
{
  const std::string description( "Title or descriptive text for the simulation." );
  sect.add_entry( { core::strngs::fsname(), "text", "", "optional", description } );
}
// ntarg : [required, integer] target average particle count.
{
  const std::string description( "Target average number of solute particles. If no value (or zero) is given then the simulation will attempt to calculate the particle number from the target concentration and initial volume.  (If no concentrations are given and no ntarg then the particle defined in the input file specie sections are used as-is.)" );
  sect.add_entry( { core::strngs::fsntrg(), "integer", ">0", "optional", description );
}
// epsw : [optional, number > 0.0] The relative permittivity of the media 
{
  const std::string description( "The relative permittivity of the media. The default is the standard relative permittivity of water." );
  sect.add_entry( { core::strngs::fsepsw(), "number", "> 0.0", std::to_string( evaluator::evaluator_manager::standard_relative_permittivity() ), description } );
}

