class lamperski_igcmc
!!!128057.cpp!!!	description(inout os : ostream) : void
os << "[sampler] " << this->type_label_() << "\n";
os << " Super-observable: used to perform iterative GCMC simulations.\n";
os << " Use IGCMC to estimate the excess chemical potentials required\n";
os << " to maintain the target concentrations of solute species.\n";
os << " Reference: S. Lamperski, Mol. Simul. 33, 1193, 2007\n";
!!!128185.cpp!!!	do_update(inout sys : simulation, inout oslog : ostream) : void
// Lamperski: 
//  Add or subtract "delta" depending on whether average 
// density is greater or less than desired
// 
// Use mean concentration from specie_count sampler.
//
// NOTE: we could use specie_count::type_label_()
boost::any means_any = sys.report().get_sample("specie-count")->get_value();
std::vector< utility::estimater > const& means = *(boost::any_cast< std::vector< utility::estimater > const* >(means_any));
auto & pman = sys.particles();
auto const& sysreg = sys.regions().system_region();

for (size_t ispec = 0; ispec != pman.specie_count(); ++ispec)
{
   particle::specie & spcobj = pman.get_specie(ispec);
   // only solute species exist when using IGCMC
   double actual_concentration = means[ispec].mean()*core::constants::to_SI()/sysreg.volume( spcobj.radius() );
   if (not utility::feq(actual_concentration,0.0))
   {
      double chempi = spcobj.excess_potential() + (spcobj.concentration() > actual_concentration? this->delta : -this->delta);
      spcobj.set_excess_potential( chempi );
   }
}
!!!218160.cpp!!!	do_write_part_document(inout wr : input_document, in ix : size_t) : void
wr[ ix ].add_entry( "delta", this->delta );
!!!2113072.cpp!!!	add_to_definition(inout defn : simulation_definition) : string
defn.add_definition( { "delta", "number", ">0", "0.1", "(lamperski update) The magnitude of the change in chemical potential to use in updates." } );
return type_label_();
!!!2113200.cpp!!!	make_updater(in params : string) : imc_update
std::unique_ptr< lamperski_igcmc > smplr(new lamperski_igcmc);
// Check parameters for usable values
for (auto const& item : params)
{
  if (item.first == "delta")
  {
    smplr->delta=(boost::lexical_cast< double >(item.second));
  }
  else
  {
    const std::string known_key;
    UTILITY_INPUT( item.first == known_key,
                  "Parameter ["+item.first+"] unknown for sampler type ["+lamperski_igcmc::type_label_()+"]",
                  "simulation-manager", nullptr);
  }
}
return boost::shared_ptr< imc_update >( smplr.release() );
