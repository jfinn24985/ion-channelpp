class lamperski_igcmc
!!!128057.cpp!!!	description(inout os : ostream) : void
os << " Update Method [" << this->type_label_() << "]\n";
os << " Estimate the excess chemical potential parameters required\n";
os << " to maintain the target concentrations of solute species.\n\n";
os << "   S. Lamperski, Mol. Simul. 33, 1193, 2007\n\n";
!!!128185.cpp!!!	do_update(inout sys : simulation, inout oslog : ostream) : void
// Lamperski: 
//  Add or subtract "delta" depending on whether average 
// density is greater or less than desired
//
// Use mean concentration from specie_count sampler.
//
// NOTE: we could use specie_count::type_label_()
boost::any means_any = sys.report().get_sample("specie-count")->get_value();
utility::estimate_array const& means = *(boost::any_cast< utility::estimate_array const* >(means_any));
auto & pman = sys.particles();
auto const& sysreg = sys.regions().system_region();

for (size_t ispec = 0; ispec != pman.specie_count(); ++ispec)
{
  particle::specie & spcobj = pman.get_specie(ispec);
  // only solute species exist when using IGCMC
  double actual_concentration = means.mean(ispec)*core::constants::to_SI()/sysreg.volume( spcobj.radius() );
  if (not utility::feq(actual_concentration,0.0))
  {
    const double change = (this->use_random_ ? this->delta_ * sys.get_random().uniform(): this->delta_ );
    const double chempi = spcobj.excess_potential() + (spcobj.concentration() > actual_concentration? change : -change);
    spcobj.set_excess_potential( chempi );
  }
}
!!!218160.cpp!!!	do_write_part_document(inout wr : input_document, in ix : size_t) : void
wr[ ix ].add_entry( "delta", this->delta_ );
wr[ ix ].add_entry( "use-random", this->use_random_ );
!!!2113072.cpp!!!	add_to_definition(inout defn : simulation_definition) : string
defn.add_definition( { "delta", "number", ">0", "0.1", "(lamperski update) The magnitude of the change in chemical potential to use in updates." } );
defn.add_definition( { "use-random", "boolean", "", "false", "(lamperski update) Scale the magnitude of the change in chemical potential by a random factor during updates.." } );
return type_label_();
!!!2113200.cpp!!!	make_updater(in params : string) : imc_update
std::unique_ptr< lamperski_igcmc > smplr(new lamperski_igcmc);
// Check parameters for usable values
for (auto const& item : params)
{
  if (item.first == "delta")
  {
    double delta{ 0.0 };
    core::input_base_reader::float_input( item.first, item.second, "Lamperski IMC", core::strngs::simulator_label(), delta, true, false, nullptr );
    smplr->delta_ = delta;
  }
  else if (item.first == "use-random")
  {
    bool do_random{ false };
    core::input_base_reader::bool_input( item.first, item.second, "Lamperski IMC", core::strngs::simulator_label(), do_random, true, false, nullptr );
    smplr->use_random_ = do_random;
  }
  else
  {
    const std::string known_key;
    //UTILITY_INPUT( item.first == known_key,
    //              (core::input_error_messages::invalid_parameter() % item.first % ("Iterative Monte Carlo [lamperski]" + core::strngs::simulator_label())).str(), core::strngs::simulator_label(), nullptr);
  }
}
return boost::shared_ptr< imc_update >( smplr.release() );
