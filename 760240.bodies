class output_test_suite
!!!2645936.cpp!!!	base_output_field_test(in fld : output_field) : void
std::stringstream store;
const std::string lbl = fld->label();
const std::string unt = fld->unit();
{
  const std::string lbl2{ "label2" };
  BOOST_CHECK_NO_THROW( fld->set_label( lbl2 ) );
  BOOST_CHECK_EQUAL( fld->label(), lbl2 );
  fld->set_label( lbl );
}
{
  const std::string unt2{ "unit2" };
  BOOST_CHECK_NO_THROW( fld->set_unit( unt2 ) );
  BOOST_CHECK_EQUAL( fld->unit(), unt2 );
  fld->set_unit( unt );
}
std::string output;
utility::estimate_array arr( 2 );
arr.append( { 0.1, 0.2 } );
arr.append( { 0.11, 0.22 } );
arr.append( { 0.12, 0.21 } );
{
  std::stringstream os;
  fld->write( os, arr, 0, 0 );
  output = os.str();
 
  boost::archive::text_oarchive oa( store );
  oa << fld; 
}
{
  std::unique_ptr< observable::output_field > fld2;
  boost::archive::text_iarchive ia( store );
  ia >> fld2; 
  BOOST_CHECK_EQUAL( fld2->label(), lbl );
  BOOST_CHECK_EQUAL( fld2->unit(), unt );
  std::stringstream os;
  fld2->write( os, arr, 0, 0 );
  BOOST_CHECK_EQUAL( output, os.str() );
}
!!!477616.cpp!!!	output_field_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< observable::output_field >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::output_field >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::output_field >::type{} );
  BOOST_CHECK( not ( std::is_assignable< observable::output_field, observable::output_field >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::output_field >::type{} );
}
!!!2645808.cpp!!!	element_output_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< observable::element_output >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::element_output >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::element_output >::type{} );
  BOOST_CHECK( not ( std::is_assignable< observable::element_output, observable::output_field >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::element_output >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
utility::estimate_array arr( 2 );
arr.append( { 0.0, 0.1 } );
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  observable::element_output aset( label1, unit1, true );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );
  aset.push_back( 0.1 );
  aset.push_back( 0.2 );

  // "unset" label
  aset.set_label( emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  // set unit
  aset.set_unit( unit2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_label( label2 );
  BOOST_CHECK_EQUAL( aset.label(), label2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" unit
  aset.set_unit( emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  {
    // Output error if not valid
    try
    {
      std::stringstream os;
      aset.write( os, arr, 0, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  aset.set_unit( unit2 );

  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 3 );
    BOOST_CHECK_EQUAL( output2, "0.1" );
  }
  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 1 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 3 );
    BOOST_CHECK_EQUAL( output2, "0.2" );
  }
}
{
  observable::element_output aset( label1, unit1, false );
  aset.push_back( 0.1 );
  aset.push_back( 0.2 );
  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 3 );
    BOOST_CHECK_EQUAL( output2, "0.1" );
  }
  {
    aset.set_unit( unit2 );
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 1, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 3 );
    BOOST_CHECK_EQUAL( output2, "0.2" );
  }
}

// base class tests
{
  std::unique_ptr< observable::element_output > fld( new observable::element_output( label1, unit1, true ) );
  fld->push_back( 0.1 );
  fld->push_back( 0.2 );
  output_test_suite::base_output_field_test( std::move( fld ) );
}
!!!2646064.cpp!!!	index_output_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< observable::index_output >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::index_output >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::index_output >::type{} );
  BOOST_CHECK( not ( std::is_assignable< observable::index_output, observable::output_field >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::index_output >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
utility::estimate_array arr( 2 );
arr.append( { 0.0, 0.1 } );
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  observable::index_output aset( label1, unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" label
  aset.set_label( emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  // set unit
  aset.set_unit( unit2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_label( label2 );
  BOOST_CHECK_EQUAL( aset.label(), label2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" unit
  aset.set_unit( emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  {
    // Output error if not valid
    try
    {
      std::stringstream os;
      aset.write( os, arr, 0, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  aset.set_unit( unit2 );
  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 1 );
    BOOST_CHECK_EQUAL( output2, "0" );
  }
  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 1 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 1 );
    BOOST_CHECK_EQUAL( output2, "0" );
  }
  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 1, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 1 );
    BOOST_CHECK_EQUAL( output2, "1" );
  }
  {
    aset.set_unit( unit2 );
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 1, 1 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 1 );
    BOOST_CHECK_EQUAL( output2, "1" );
  }
}

// base class tests
{
  std::unique_ptr< observable::index_output > fld( new observable::index_output( label1, unit1 ) );
  output_test_suite::base_output_field_test( std::move( fld ) );
}
!!!2646320.cpp!!!	key_output_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< observable::key_output >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::key_output >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::key_output >::type{} );
  BOOST_CHECK( not ( std::is_assignable< observable::key_output, observable::output_field >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::key_output >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
utility::estimate_array arr( 2 );
arr.append( { 0.0, 0.1 } );
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  observable::key_output aset( label1, unit1, true );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );
  aset.push_back( "L1" );
  aset.push_back( "L2" );

  // "unset" label
  aset.set_label( emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  // set unit
  aset.set_unit( unit2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_label( label2 );
  BOOST_CHECK_EQUAL( aset.label(), label2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" unit
  aset.set_unit( emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  {
    // Output error if not valid
    try
    {
      std::stringstream os;
      aset.write( os, arr, 0, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }

  {
    aset.set_unit( unit2 );
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 2 );
    BOOST_CHECK_EQUAL( output2, "L1" );
  }
  {
    aset.set_unit( unit2 );
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 1 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 2 );
    BOOST_CHECK_EQUAL( output2, "L2" );
  }
}
{
  observable::key_output aset( label1, unit1, false );
  aset.push_back( "L1" );
  aset.push_back( "L2" );
  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 2 );
    BOOST_CHECK_EQUAL( output2, "L1" );
  }
  {
    aset.set_unit( unit2 );
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 1, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 2 );
    BOOST_CHECK_EQUAL( output2, "L2" );
  }
}

// base class tests
{
  std::unique_ptr< observable::key_output > fld( new observable::key_output( label1, unit1, true ) );
  fld->push_back( "L1" );
  fld->push_back( "L2" );
  output_test_suite::base_output_field_test( std::move( fld ) );
}
!!!2646192.cpp!!!	mean_output_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< observable::mean_output >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::mean_output >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::mean_output >::type{} );
  BOOST_CHECK( not ( std::is_assignable< observable::mean_output, observable::output_field >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::mean_output >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
utility::estimate_array arr( 2 );
arr.append( { 0.0, 0.1 } );
arr.append( { 0.1, 0.2 } );
arr.append( { 0.2, 0.3 } );
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  observable::mean_output aset( label1, unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" label
  aset.set_label( emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  // set unit
  aset.set_unit( unit2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_label( label2 );
  BOOST_CHECK_EQUAL( aset.label(), label2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" unit
  aset.set_unit( emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  {
    // Output error if not valid
    try
    {
      std::stringstream os;
      aset.write( os, arr, 0, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  aset.set_unit( unit2 );

  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 3 );
    BOOST_CHECK_EQUAL( output2, "0.1" );
  }
  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 1, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2.size(), 3 );
    BOOST_CHECK_EQUAL( output2, "0.2" );
  }
}

// base class tests
{
  std::unique_ptr< observable::mean_output > fld( new observable::mean_output( label1, unit1 ) );
  output_test_suite::base_output_field_test( std::move( fld ) );
}
!!!2647088.cpp!!!	mean_variance_output_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< observable::mean_variance_output >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::mean_variance_output >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::mean_variance_output >::type{} );
  BOOST_CHECK( not ( std::is_assignable< observable::mean_variance_output, observable::output_field >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::mean_variance_output >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
utility::estimate_array arr( 2 );
arr.append( { 0.0, 0.1 } );
arr.append( { 0.1, 0.2 } );
arr.append( { 0.2, 0.3 } );
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  observable::mean_variance_output aset( label1, unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" label
  aset.set_label( emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  // set unit
  aset.set_unit( unit2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_label( label2 );
  BOOST_CHECK_EQUAL( aset.label(), label2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" unit
  aset.set_unit( emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  {
    // Output error if not valid
    try
    {
      std::stringstream os;
      aset.write( os, arr, 0, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  aset.set_unit( unit2 );

  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "0.1 0.01" );
  }
  {
    aset.set_unit( unit2 );
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 1, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "0.2 0.01" );
  }
}

// base class tests
{
  std::unique_ptr< observable::mean_variance_output > fld( new observable::mean_variance_output( label1, unit1 ) );
  output_test_suite::base_output_field_test( std::move( fld ) );
}
!!!2646960.cpp!!!	rank_output_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< observable::rank_output >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::rank_output >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::rank_output >::type{} );
  BOOST_CHECK( not ( std::is_assignable< observable::rank_output, observable::output_field >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::rank_output >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
utility::estimate_array arr( 2 );
arr.append( { 0.0, 0.1 } );
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  observable::rank_output aset( label1, unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" label
  aset.set_label( emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  // set unit
  aset.set_unit( unit2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_label( label2 );
  BOOST_CHECK_EQUAL( aset.label(), label2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" unit
  aset.set_unit( emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  {
    // Output error if not valid
    try
    {
      std::stringstream os;
      aset.write( os, arr, 0, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  aset.set_unit( unit2 );

  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "0" );
  }
  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 1, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "0" );
  }
  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 1 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "1" );
  }
}

// base class tests
{
  std::unique_ptr< observable::rank_output > fld( new observable::rank_output( label1, unit1 ) );
  output_test_suite::base_output_field_test( std::move( fld ) );
}
!!!2646832.cpp!!!	sample_count_output_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< observable::sample_count_output >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::sample_count_output >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::sample_count_output >::type{} );
  BOOST_CHECK( not ( std::is_assignable< observable::sample_count_output, observable::output_field >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::sample_count_output >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
utility::estimate_array arr( 2 );
arr.append( { 0.0, 0.1 } );
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  observable::sample_count_output aset( label1, unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" label
  aset.set_label( emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  // set unit
  aset.set_unit( unit2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_label( label2 );
  BOOST_CHECK_EQUAL( aset.label(), label2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" unit
  aset.set_unit( emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  {
    // Output error if not valid
    try
    {
      std::stringstream os;
      aset.write( os, arr, 0, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  aset.set_unit( unit2 );

  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "1" );
  }
  {
    // Output should work
    std::stringstream os;
    arr.append( { 0.1, 0.2 } );
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 1 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "2" );
  }
  {
    // Output should work
    std::stringstream os;
    arr.append( { 0.2, 0.3 } );
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 1, 1 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "3" );
  }
}

// base class tests
{
  std::unique_ptr< observable::sample_count_output > fld( new observable::sample_count_output( label1, unit1 ) );
  output_test_suite::base_output_field_test( std::move( fld ) );
}
!!!2646704.cpp!!!	variance_output_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< observable::variance_output >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::variance_output >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::variance_output >::type{} );
  BOOST_CHECK( not ( std::is_assignable< observable::variance_output, observable::output_field >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::variance_output >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
utility::estimate_array arr( 2 );
arr.append( { 0.0, 0.1 } );
arr.append( { 0.1, 0.2 } );
arr.append( { 0.2, 0.3 } );
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  observable::variance_output aset( label1, unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" label
  aset.set_label( emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  // set unit
  aset.set_unit( unit2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_label( label2 );
  BOOST_CHECK_EQUAL( aset.label(), label2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" unit
  aset.set_unit( emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  {
    // Output error if not valid
    try
    {
      std::stringstream os;
      aset.write( os, arr, 0, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  aset.set_unit( unit2 );

  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "0.01" );
  }
  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 1, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "0.01" );
  }
}

// base class tests
{
  std::unique_ptr< observable::variance_output > fld( new observable::variance_output( label1, unit1 ) );
  output_test_suite::base_output_field_test( std::move( fld ) );
}
!!!2646576.cpp!!!	digitizer_output_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< observable::digitizer_output >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::digitizer_output >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::digitizer_output >::type{} );
  BOOST_CHECK( not ( std::is_assignable< observable::digitizer_output, observable::output_field >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::digitizer_output >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
utility::estimate_array arr( 2 );
utility::digitizer axis( 0.1, 0.2, 2 );
arr.append( { 0.0, 0.1 } );
arr.append( { 0.1, 0.2 } );
arr.append( { 0.2, 0.3 } );
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  observable::digitizer_output aset( label1, unit1, axis, observable::digitizer_output::USE_ALL );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" label
  aset.set_label( emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  // set unit
  aset.set_unit( unit2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_label( label2 );
  BOOST_CHECK_EQUAL( aset.label(), label2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" unit
  aset.set_unit( emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  {
    // Output error if not valid
    try
    {
      std::stringstream os;
      aset.write( os, arr, 0, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  aset.set_unit( unit2 );

  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "0.1 0.125 0.15" );
  }
  {
    // Output should work
    std::stringstream os;
    BOOST_CHECK_NO_THROW( aset.write( os, arr, 1, 0 ) );
    const std::string output2( os.str() );
    BOOST_CHECK( not output2.empty() );
    BOOST_CHECK_EQUAL( output2, "0.15 0.175 0.2" );
  }
}

// base class tests
{
  std::unique_ptr< observable::digitizer_output > fld( new observable::digitizer_output( label1, unit1, axis, observable::digitizer_output::USE_ALL ) );
  output_test_suite::base_output_field_test( std::move( fld ) );
}
!!!2646448.cpp!!!	digitizer_3d_output_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< observable::digitizer_3d_output >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< observable::digitizer_3d_output >::type{} );
  BOOST_CHECK( not std::is_move_constructible< observable::digitizer_3d_output >::type{} );
  BOOST_CHECK( not ( std::is_assignable< observable::digitizer_3d_output, observable::output_field >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< observable::digitizer_3d_output >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
geometry::digitizer_3d axis( { 0.0, 0.0, 0.0 }, { 1.0, 1.0, 1.0 }, 0.5 );
utility::estimate_array arr( axis.size() );
std::vector< double > vec( axis.size() );
for( double & var : vec ) var = 0.1;
arr.append( vec );
for( double & var : vec ) var = 0.2;
arr.append( vec );
for( double & var : vec ) var = 0.3;
arr.append( vec );
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  observable::digitizer_3d_output aset( label1, unit1, axis, observable::digitizer_3d_output::USE_ALL );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" label
  aset.set_label( emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  // set unit
  aset.set_unit( unit2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_label( label2 );
  BOOST_CHECK_EQUAL( aset.label(), label2 );
  BOOST_CHECK_EQUAL( aset.unit(), unit2 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  // "unset" unit
  aset.set_unit( emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  {
    // Output error if not valid
    try
    {
      std::stringstream os;
      aset.write( os, arr, 0, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  aset.set_unit( unit2 );
  {
    // Output should work
    std::vector< std::string > output2
    {
      "0 0 0 0.25 0.25 0.25 0.5 0.5 0.5",
      "0.5 0 0 0.75 0.25 0.25 1 0.5 0.5",
      "0 0.5 0 0.25 0.75 0.25 0.5 1 0.5",
      "0.5 0.5 0 0.75 0.75 0.25 1 1 0.5",
      "0 0 0.5 0.25 0.25 0.75 0.5 0.5 1",
      "0.5 0 0.5 0.75 0.25 0.75 1 0.5 1",
      "0 0.5 0.5 0.25 0.75 0.75 0.5 1 1",
      "0.5 0.5 0.5 0.75 0.75 0.75 1 1 1" };
    for( std::size_t idx = 0; idx != axis.size(); ++idx )
    {
      std::stringstream os;
      BOOST_CHECK_NO_THROW( aset.write( os, arr, idx, 0 ) );
      const std::string out( os.str() );
      //std::cout << "(" << idx << ")" << out << "\n"; 
      BOOST_CHECK( not out.empty() );
      BOOST_CHECK_EQUAL( out, output2[ idx ] );
    }
    {
      // Output should work
      std::stringstream os;
      BOOST_CHECK_NO_THROW( aset.write( os, arr, 0, 1 ) );
      const std::string out2( os.str() );
      BOOST_CHECK( not out2.empty() );
      BOOST_CHECK_EQUAL( out2, output2[ 0 ] );
    }
  }
}

// base class tests
{
  std::unique_ptr< observable::digitizer_3d_output > fld( new observable::digitizer_3d_output( label1, unit1, axis, observable::digitizer_3d_output::USE_ALL ) );
  output_test_suite::base_output_field_test( std::move( fld ) );
}
!!!484912.cpp!!!	output_series_test() : void
//XX {
//XX   // Static Lifetime method tests
//XX   BOOST_CHECK( std::is_default_constructible< observable::output_series >::type{} );
//XX   BOOST_CHECK( std::is_copy_constructible< observable::output_series >::type{} );
//XX   BOOST_CHECK( std::is_move_constructible< observable::output_series >::type{} );
//XX   BOOST_CHECK( ( std::is_assignable< observable::output_series, observable::output_series >::type{} ) );
//XX   BOOST_CHECK( not std::has_virtual_destructor< observable::output_series >::type{} );
//XX }
//XX // CTOR TESTS
//XX // ----------
//XX std::string emptr_str;
//XX const std::string test_fname
//XX { "result.dat"
//XX };
//XX const std::string test_title
//XX { "Something or other."
//XX };
//XX {
//XX   observable::output_series aset;
//XX   BOOST_CHECK_EQUAL( aset.title(), emptr_str );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   aset.set_title( test_title );
//XX   BOOST_CHECK_EQUAL( aset.title(), test_title );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   observable::output_series bset;
//XX   BOOST_CHECK_EQUAL( bset.title(), emptr_str );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   bset = aset;
//XX   BOOST_CHECK_EQUAL( bset.title(), test_title );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   observable::output_series cset( aset );
//XX   BOOST_CHECK_EQUAL( cset.title(), test_title );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   aset = aset;
//XX   BOOST_CHECK_EQUAL( aset.title(), test_title );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   observable::output_series dset( std::move( aset ) );
//XX   BOOST_CHECK_EQUAL( dset.title(), test_title );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   // Output error if no entries
//XX   {
//XX     observable::output_series dsetcp( dset );
//XX     try
//XX     {
//XX       dsetcp.do_header( std::cout );
//XX       BOOST_ERROR( "expected \"dsetcp.do_header( std::cout )\" exception not thrown" );
//XX     }
//XX     catch( std::runtime_error const& err )
//XX     {
//XX       const std::string msg( err.what() );
//XX       //std::cout << msg << "\n";
//XX       BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
//XX     }
//XX     catch( std::exception const& err )
//XX     {
//XX       BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX     }
//XX   }
//XX   {
//XX     observable::output_series dsetcp( dset );
//XX     try
//XX     {
//XX       dsetcp.do_body( std::cout );
//XX       BOOST_ERROR( "expected \"dsetcp.do_body( std::cout )\" exception not thrown" );
//XX     }
//XX     catch( std::runtime_error const& err )
//XX     {
//XX       const std::string msg( err.what() );
//XX       //std::cout << msg << "\n";
//XX       BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
//XX     }
//XX     catch( std::exception const& err )
//XX     {
//XX       BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX     }
//XX   }
//XX   {
//XX     observable::memory_sink sink;
//XX     observable::output_series dsetcp( dset );
//XX     try
//XX     {
//XX       dsetcp.write( test_fname, sink, true );
//XX       BOOST_ERROR( "expected \"dsetcp.write( test_fname, sink, true )\" exception not thrown" );
//XX     }
//XX     catch( std::runtime_error const& err )
//XX     {
//XX       const std::string msg( err.what() );
//XX       //std::cout << msg << "\n";
//XX       BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
//XX     }
//XX     catch( std::exception const& err )
//XX     {
//XX       BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX     }
//XX   }
//XX   {
//XX     observable::memory_sink sink;
//XX     observable::output_series dsetcp( dset );
//XX     try
//XX     {
//XX       dsetcp.write( test_fname, sink, false );
//XX       BOOST_ERROR( "expected \"dsetcp.write( test_fname, sink, false )\" exception not thrown" );
//XX     }
//XX     catch( std::runtime_error const& err )
//XX     {
//XX       const std::string msg( err.what() );
//XX       //std::cout << msg << "\n";
//XX       BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
//XX     }
//XX     catch( std::exception const& err )
//XX     {
//XX       BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX     }
//XX   }
//XX }
//XX struct person
//XX {
//XX   std::string name;
//XX   std::size_t day_of_birth;
//XX   std::size_t month_of_birth;
//XX   std::size_t year_of_birth;
//XX };
//XX 
//XX struct family
//XX {
//XX   std::vector< person > ppl;
//XX   std::size_t day( std::size_t i ) const
//XX   {
//XX     return ppl[ i ].day_of_birth;
//XX   }
//XX   std::size_t month( std::size_t i ) const
//XX   {
//XX     return ppl[ i ].month_of_birth;
//XX   }
//XX   std::size_t year( std::size_t i ) const
//XX   {
//XX     return ppl[ i ].year_of_birth;
//XX   }
//XX   std::string name( std::size_t i ) const
//XX   {
//XX     return ppl[ i ].name;
//XX   }
//XX   std::size_t size() const
//XX   {
//XX     return ppl.size();
//XX   }
//XX };
//XX 
//XX const std::string label1( "name" );
//XX const std::string label2( "day" );
//XX const std::string label3( "month" );
//XX const std::string label4( "year" );
//XX const std::string unit1( "label" );
//XX const std::string unit2( "ordinal1" );
//XX const std::string unit3( "ordinal2" );
//XX const std::string unit4( "ordinal3" );
//XX {
//XX   person me { "justin", 17, 4, 1965 };
//XX 
//XX   observable::output_series dset{};
//XX   dset.set_title( test_title );
//XX   dset.push_back_entry( observable::output_field( label1, unit1, [&me]( std::ostream& os, std::size_t )
//XX   {
//XX     os << me.name;
//XX   } ) );
//XX   dset.push_back_entry( observable::output_field( label2, unit2, [&me]( std::ostream& os, std::size_t )
//XX   {
//XX     os << me.day_of_birth;
//XX   } ) );
//XX   dset.push_back_entry( observable::output_field( label3, unit3, [&me]( std::ostream& os, std::size_t )
//XX   {
//XX     os << me.month_of_birth;
//XX   } ) );
//XX   dset.push_back_entry( observable::output_field( label4, unit4, [&me]( std::ostream& os, std::size_t )
//XX   {
//XX     os << me.year_of_birth;
//XX   } ) );
//XX 
//XX   {
//XX     std::stringstream store;
//XX     dset.do_header( store );
//XX     const std::string output
//XX     {
//XX       store.str()
//XX     };
//XX     BOOST_CHECK_NE( output.find( test_title ), std::string::npos );
//XX     BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
//XX     BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
//XX   }
//XX   {
//XX     std::stringstream store;
//XX     dset.do_body( store );
//XX     const std::string output
//XX     {
//XX       store.str()
//XX     };
//XX     BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
//XX     BOOST_CHECK_NE( output.find( "justin" ), std::string::npos );
//XX     BOOST_CHECK_NE( output.find( "1965" ), std::string::npos );
//XX   }
//XX }
!!!471728.cpp!!!	output_dataset_test() : void
//XX // CTOR TESTS
//XX // ----------
//XX std::string emptr_str;
//XX const std::string test_fname { "result.dat" };
//XX const std::string test_title { "Something or other." };
//XX {
//XX   observable::output_dataset aset;
//XX   BOOST_CHECK_EQUAL( aset.title(), emptr_str );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   aset.set_title( test_title );
//XX   BOOST_CHECK_EQUAL( aset.title(), test_title );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   observable::output_dataset bset;
//XX   BOOST_CHECK_EQUAL( bset.title(), emptr_str );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   bset = aset;
//XX   BOOST_CHECK_EQUAL( bset.title(), test_title );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   observable::output_dataset cset( aset );
//XX   BOOST_CHECK_EQUAL( cset.title(), test_title );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   aset = aset;
//XX   BOOST_CHECK_EQUAL( aset.title(), test_title );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   observable::output_dataset dset( std::move( aset ) );
//XX   BOOST_CHECK_EQUAL( dset.title(), test_title );
//XX   BOOST_CHECK_EQUAL( aset.size(), 0 );
//XX   BOOST_CHECK_EQUAL( aset.empty(), true );
//XX   BOOST_CHECK( aset.begin() == aset.end() );
//XX 
//XX   // Output error if no entries
//XX   {
//XX     observable::output_dataset dsetcp( dset );
//XX     try
//XX     {
//XX       dsetcp.do_header( std::cout );
//XX       BOOST_ERROR( "expected \"dsetcp.do_header( std::cout )\" exception not thrown" );
//XX     }
//XX     catch( std::runtime_error const& err )
//XX     {
//XX       const std::string msg( err.what() );
//XX       //std::cout << msg << "\n";
//XX       BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
//XX     }
//XX     catch( std::exception const& err )
//XX     {
//XX       BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX     }
//XX   }
//XX   {
//XX     observable::output_dataset dsetcp( dset );
//XX     try
//XX     {
//XX       dsetcp.do_body( std::cout );
//XX       BOOST_ERROR( "expected \"dsetcp.do_body( std::cout )\" exception not thrown" );
//XX     }
//XX     catch( std::runtime_error const& err )
//XX     {
//XX       const std::string msg( err.what() );
//XX       //std::cout << msg << "\n";
//XX       BOOST_CHECK( msg.find( "Can not write data set without any fields" ) < msg.size() );
//XX     }
//XX     catch( std::exception const& err )
//XX     {
//XX       BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX     }
//XX   }
//XX   {
//XX     observable::memory_sink sink;
//XX     observable::output_dataset dsetcp( dset );
//XX     try
//XX     {
//XX       dsetcp.write( test_fname, sink );
//XX       BOOST_ERROR( "expected \"dsetcp.write( test_fname, sink )\" exception not thrown" );
//XX     }
//XX     catch( std::runtime_error const& err )
//XX     {
//XX       const std::string msg( err.what() );
//XX       //std::cout << msg << "\n";
//XX       BOOST_CHECK( msg.find( "Can not write data set without any fields" ) < msg.size() );
//XX     }
//XX     catch( std::exception const& err )
//XX     {
//XX       BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX     }
//XX   }
//XX }
//XX struct person
//XX {
//XX   std::string name;
//XX   std::size_t day_of_birth;
//XX   std::size_t month_of_birth;
//XX   std::size_t year_of_birth;
//XX };
//XX 
//XX struct family
//XX {
//XX   std::vector< person > ppl;
//XX   std::size_t day( std::size_t i ) const
//XX   {
//XX     return ppl[ i ].day_of_birth;
//XX   }
//XX   std::size_t month( std::size_t i ) const
//XX   {
//XX     return ppl[ i ].month_of_birth;
//XX   }
//XX   std::size_t year( std::size_t i ) const
//XX   {
//XX     return ppl[ i ].year_of_birth;
//XX   }
//XX   std::string name( std::size_t i ) const
//XX   {
//XX     return ppl[ i ].name;
//XX   }
//XX   std::size_t size() const
//XX   {
//XX     return ppl.size();
//XX   }
//XX };
//XX 
//XX const std::string label1( "name" );
//XX const std::string label2( "day" );
//XX const std::string label3( "month" );
//XX const std::string label4( "year" );
//XX const std::string unit1( "label" );
//XX const std::string unit2( "ordinal1" );
//XX const std::string unit3( "ordinal2" );
//XX const std::string unit4( "ordinal3" );
//XX {
//XX   person me { "justin", 17, 4, 1965 };
//XX 
//XX   observable::output_dataset dset( []()
//XX   {
//XX     return 1;
//XX   } );
//XX   dset.set_title( test_title );
//XX   dset.push_back_entry( observable::output_field( label1, unit1, [&me]( std::ostream& os, std::size_t )
//XX   {
//XX     os << me.name;
//XX   } ) );
//XX   dset.push_back_entry( observable::output_field( label2, unit2, [&me]( std::ostream& os, std::size_t )
//XX   {
//XX     os << me.day_of_birth;
//XX   } ) );
//XX   dset.push_back_entry( observable::output_field( label3, unit3, [&me]( std::ostream& os, std::size_t )
//XX   {
//XX     os << me.month_of_birth;
//XX   } ) );
//XX   dset.push_back_entry( observable::output_field( label4, unit4, [&me]( std::ostream& os, std::size_t )
//XX   {
//XX     os << me.year_of_birth;
//XX   } ) );
//XX 
//XX   {
//XX     std::stringstream store;
//XX     dset.do_header( store );
//XX     const std::string output
//XX     {
//XX       store.str()
//XX     };
//XX     BOOST_CHECK_NE( output.find( test_title ), std::string::npos );
//XX     BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
//XX     BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
//XX   }
//XX   {
//XX     std::stringstream store;
//XX     dset.do_body( store );
//XX     const std::string output
//XX     {
//XX       store.str()
//XX     };
//XX     BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
//XX     BOOST_CHECK_NE( output.find( "justin" ), std::string::npos );
//XX     BOOST_CHECK_NE( output.find( "1965" ), std::string::npos );
//XX   }
//XX }
//XX 
//XX {
//XX   family myfamily;
//XX   myfamily.ppl.push_back( { "justin", 17, 4, 1965 } );
//XX   myfamily.ppl.push_back( { "sean", 15, 4, 1969 } );
//XX   myfamily.ppl.push_back( { "debi", 8, 2, 1963 } );
//XX   myfamily.ppl.push_back( { "susan", 19, 6, 1953 } );
//XX   myfamily.ppl.push_back( { "peabody", 1, 1, 2012 } );
//XX   observable::output_dataset dset( [&myfamily]()
//XX   {
//XX     return myfamily.size();
//XX   } );
//XX   dset.push_back_entry( observable::output_field( label1, unit1, [&myfamily]( std::ostream& os, std::size_t i )
//XX   {
//XX     os << myfamily.name( i );
//XX   } ) );
//XX   dset.push_back_entry( observable::output_field( label2, unit2, [&myfamily]( std::ostream& os, std::size_t i )
//XX   {
//XX     os << myfamily.ppl[ i ].day_of_birth;
//XX   } ) );
//XX   dset.push_back_entry( observable::output_field( label3, unit3, [&myfamily]( std::ostream& os, std::size_t i )
//XX   {
//XX     os << myfamily.month( i );
//XX   } ) );
//XX   dset.push_back_entry( observable::output_field( label4, unit4, [&myfamily]( std::ostream& os, std::size_t i )
//XX   {
//XX     os << myfamily.year( i );
//XX   } ) );
//XX 
//XX   {
//XX     std::stringstream store;
//XX     dset.do_header( store );
//XX     const std::string output
//XX     {
//XX       store.str()
//XX     };
//XX     BOOST_CHECK_EQUAL( output.find( "TITLE" ), std::string::npos );
//XX     BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
//XX     BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
//XX     BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
//XX   }
//XX   dset.set_title( test_title );
//XX   {
//XX     std::stringstream store;
//XX     dset.do_header( store );
//XX     const std::string output
//XX     {
//XX       store.str()
//XX     };
//XX     BOOST_CHECK_NE( output.find( "TITLE" ), std::string::npos );
//XX     BOOST_CHECK_NE( output.find( test_title ), std::string::npos );
//XX     BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
//XX     BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
//XX   }
//XX   {
//XX     std::stringstream store;
//XX     dset.do_body( store );
//XX     const std::string output
//XX     {
//XX       store.str()
//XX     };
//XX     BOOST_CHECK_EQUAL( output.find( "TITLE" ), std::string::npos );
//XX     BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
//XX     BOOST_CHECK_NE( output.find( "justin" ), std::string::npos );
//XX     BOOST_CHECK_NE( output.find( "1965" ), std::string::npos );
//XX     BOOST_CHECK_NE( output.find( "peabody" ), std::string::npos );
//XX     BOOST_CHECK_EQUAL( std::count( output.begin(), output.end(), '\n' ), 5 );
//XX   }
//XX }
//XX 
!!!512304.cpp!!!	test_archive_file() : void
const std::string paxpath( "myar.pax" );
const std::string zippath( "myar.zip" );
{
   // main constructor with name that needs to
   // be changed.
   BOOST_CHECK_NO_THROW( observable::archive_file ar( paxpath ) );
   observable::archive_file ar( paxpath );
   BOOST_CHECK_EQUAL( ar.filename(), paxpath + ".zip" );
}
{
   // check filename conversion
   observable::archive_file ar( zippath );
   BOOST_CHECK_EQUAL( ar.filename(), zippath );
}
{
   // Standard tests
   observable::archive_file ar( zippath );
   output_test_suite::test_base_sink_method( ar );
}
!!!558896.cpp!!!	test_memory_sink() : void
const std::string root_path( "dummy_path" );
{
   // main constructor.
   BOOST_CHECK_NO_THROW( observable::memory_sink ar( root_path ) );
}
{
   // Standard tests
   observable::memory_sink ar( root_path );
   BOOST_CHECK_EQUAL( ar.filename(), root_path );
   output_test_suite::test_base_sink_method( ar );
}
!!!570032.cpp!!!	test_gdbm_sink() : void
const std::string paxpath( "myar.pax" );
const std::string gdbmpath( "myar.dbm" );
{
   // main constructor with name that needs to
   // be changed.
   BOOST_CHECK_NO_THROW( observable::gdbm_sink ar( paxpath ) );
   observable::gdbm_sink ar( paxpath );
   BOOST_CHECK_EQUAL( ar.filename(), paxpath + ".dbm" );
}
{
   // check filename no conversion
   observable::gdbm_sink ar( gdbmpath );
   BOOST_CHECK_EQUAL( ar.filename(), gdbmpath );
}
{
   // Standard tests
   observable::gdbm_sink ar( gdbmpath );
   output_test_suite::test_base_sink_method( ar );
}
!!!568880.cpp!!!	test_base_sink_method(inout sink : base_sink) : void
const std::string path( "dat/amx.dat" );
const std::string content( "a1b2c3d4e5" );
const std::string content2( "a5b4c3d2e1" );
// BASIC OPERATION
{
  // UUID is non-empty string with 32 characters.
  BOOST_CHECK( not sink.uuid().empty() );
  BOOST_CHECK_EQUAL( sink.uuid().size(), 32ul );
  // write to file
  BOOST_CHECK_NO_THROW( sink.write( path, content ) );
  // check path now exists
  BOOST_CHECK_EQUAL( sink.exists( path ), true );
  // read from file
  std::string buffer;
  bool success;
  BOOST_CHECK_NO_THROW( success = sink.read( path, buffer ) );
  BOOST_CHECK_MESSAGE( success, "read after write failed" );
  BOOST_CHECK_EQUAL( content, buffer );

  // test of write twice to same path in file then read
  BOOST_CHECK_NO_THROW( sink.write( path, content ) );
  BOOST_CHECK_NO_THROW( sink.write( path, content2 ) );
  BOOST_CHECK_NO_THROW( success = sink.read( path, buffer ) );
  BOOST_CHECK_MESSAGE( success, "read after write failed" );
  BOOST_CHECK_EQUAL( content2, buffer );

  // test of append then read
  BOOST_CHECK_NO_THROW( sink.write( path, content ) );
  BOOST_CHECK_NO_THROW( sink.append( path, content2 ) );
  BOOST_CHECK_NO_THROW( success = sink.read( path, buffer ) );
  BOOST_CHECK_MESSAGE( success, "read failed" );
  BOOST_CHECK_EQUAL( content + content2, buffer );
}
// ERROR CONDITIONS that should have strong exception guarrantee
{
  // OPERATIONS WITH EMPTY PATH
  const std::string emptypath;
  std::string buffer;
  {
    // Specification is for strong exception guarantee
    const std::string fncall { "sink.write( emptypath, content )" };
    try
    {
      sink.write( emptypath, content );
      BOOST_ERROR( "expected \"" + fncall + "\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write to an empty location/path" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( "exception thrown by \"" + fncall + "\" was not expected type: " + err.what() );
    }
  }
  {
    // Specification is for strong exception guarantee
    const std::string fncall { "sink.append( emptypath, content )" };
    try
    {
      sink.append( emptypath, content );
      BOOST_ERROR( "expected \"" + fncall + "\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not append to an empty location/path" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( "exception thrown by \"" + fncall + "\" was not expected type: " + err.what() );
    }
  }
  {
    // Specification is for strong exception guarantee
    const std::string fncall { "sink.exists( emptypath )" };
    try
    {
      sink.exists( emptypath );
      BOOST_ERROR( "expected \"" + fncall + "\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not check for an empty location/path" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( "exception thrown by \"" + fncall + "\" was not expected type: " + err.what() );
    }
  }
  {
    // Specification is for strong exception guarantee
    const std::string fncall { "sink.read( emptypath, buffer )" };
    try
    {
      sink.read( emptypath, buffer );
      BOOST_ERROR( "expected \"" + fncall + "\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not read from an empty location/path" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( "exception thrown by \"" + fncall + "\" was not expected type: " + err.what() );
    }
  }

  // OPERATIONS WITH EMPTY WRITE BUFFER
  {
    // Specification is for strong exception guarantee
    const std::string fncall { "sink.write( path, emptypath )" };
    try
    {
      sink.write( path, emptypath );
      BOOST_ERROR( "expected \"" + fncall + "\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write without content" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( "exception thrown by \"" + fncall + "\" was not expected type: " + err.what() );
    }
  }
}
// TEST OF SERIALIZATION
std::stringstream store;
{
  // serialize
  boost::archive::text_oarchive oa( store );
  oa << sink;
  BOOST_CHECK_EQUAL( sink.exists( path ), true );
  std::string buffer;
  bool success;
  BOOST_CHECK_NO_THROW( success = sink.read( path, buffer ) );
  BOOST_CHECK_MESSAGE( success, "read failed" );
  BOOST_CHECK_EQUAL( content + content2, buffer );
  // Changes to sink made after serialization may or may not
  // be available after deserialization.
  BOOST_CHECK_NO_THROW( sink.write( path, content2 ) );
  BOOST_CHECK_NO_THROW( success = sink.read( path, buffer ) );
  BOOST_CHECK_MESSAGE( success, "read after write failed" );
  BOOST_CHECK_EQUAL( content2, buffer );
}
{
  boost::archive::text_iarchive ia( store );
  ia >> sink;
  BOOST_CHECK_EQUAL( sink.exists( path ), true );
  std::string buffer;
  bool success;
  BOOST_CHECK_NO_THROW( success = sink.read( path, buffer ) );
  BOOST_CHECK_MESSAGE( success, "read failed" );
  // Change made after serialization may or may not be
  // available. However, content should be one of two
  // well-defined values
  BOOST_CHECK( content + content2 == buffer or content2 == buffer );
}



