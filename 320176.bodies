class gdbm_sink
!!!569648.cpp!!!	gdbm_sink(in path : string)
const std::string ext( ".dbm" );
if ( ext != this->path_.substr( this->path_.size() - ext.size() ) )
{
   this->path_.append( ext );
}
!!!567600.cpp!!!	append_priv(in path : string, in buffer : string) : void
// Empty buffer is allowed, but ignored.
UTILITY_CHECK( not buffer.empty(), "append method should ensure buffer is not empty before calling append_priv." );

this->ensure_open();
datum_type key;
key.buffer( path );
datum_type content( std::move( ::gdbm_fetch( static_cast< GDBM_FILE >(this->dbf_), key ) ) );
content.append( buffer );
::gdbm_store( static_cast< GDBM_FILE >(this->dbf_), key, content, GDBM_REPLACE );

!!!567728.cpp!!!	ensure_open() : void
UTILITY_REQUIRE( not this->path_.empty(), "Attempt to use sink before setting path" );
if (nullptr == this->dbf_)
{
   this->dbf_ = ::gdbm_open( const_cast< char* >( this->path_.c_str() ), 4096, GDBM_WRCREAT, 0644, nullptr );
   if ( nullptr == this->dbf_ )
   {
      // error occurred
      std::string mesg = ::gdbm_strerror( ::gdbm_errno );
      throw std::runtime_error( mesg );
   }
}
!!!567856.cpp!!!	ensure_close() : void
if ( nullptr != this->dbf_ )
{
   ::gdbm_close( static_cast< GDBM_FILE >(this->dbf_) );
   this->dbf_ = nullptr;
}

!!!567472.cpp!!!	exists_priv(in path : string) : bool
this->ensure_open();
datum_type key;
key.buffer( path );
return 0 != ::gdbm_exists( static_cast< GDBM_FILE >(this->dbf_), key );
!!!567344.cpp!!!	read_priv(in path : string, out outbuffer : string) : bool
UTILITY_REQUIRE( not path.empty(), "Can not read from empty path." );
this->ensure_open();
datum_type key;
key.buffer( path );
if ( 0 != ::gdbm_exists( static_cast< GDBM_FILE >(this->dbf_), key ) )
{
   datum_type content( std::move( ::gdbm_fetch( static_cast< GDBM_FILE >(this->dbf_), key ) ) );
   outbuffer = content.buffer();
   return true;
}
else
{
   return false;
}
!!!567216.cpp!!!	write_priv(in path : string, in buffer : string) : void
this->ensure_open();
datum_type key, content;
key.buffer( path );
content.buffer( buffer );
::gdbm_store( static_cast< GDBM_FILE >(this->dbf_), key, content, GDBM_REPLACE );
