class evaluator_meta
!!!842416.cpp!!!	add_evaluator_type(inout defn : evaluator_definition) : void
UTILITY_REQUIRE( 0 == this->has_type( defn->label() ), ( "Attempt to add more than one evaluator factory for type \"" + defn->label() + "\"." ) );
this->type_to_object_.push_back( defn.release() );
!!!1362736.cpp!!!	has_type(in label : string) : bool
for( auto const& defn : this->type_to_object_ )
{
  if( defn.label() == label )
  {
    return true;
  }
}
return false;
!!!842160.cpp!!!	publish_help(inout helper : input_help) : void
const std::string seclabel( core::strngs::evaluator_label() );
// ----------------------------------------
// add section
// ----------------------------------------

//   Specie input section definition
core::input_help::exemplar().add_section( seclabel,
    "Evaluator input section definition.  In addition to the listed options, each individual"
    "evaluator subtype may have its own specific options.");

// ----------------------------------------
// add parameters
// ----------------------------------------

//  type : [required] trial subtype
{
  const std::string description( "[required, string] trial subtype (see documentation for valid subtypes)." );
  core::input_help::exemplar().add_option( seclabel, core::strngs::fstype(), description );
}
// Subtype parameter documentation.
for( auto const& iter : this->type_to_object_ )
{
  iter.publish_help( helper, seclabel );
}
!!!203824.cpp!!!	do_read_entry(inout reader : input_base_reader) : bool
if( reader.name().find( core::strngs::fstype() ) == 0 )
{
  // --------------------
  // Evaluator type
  UTILITY_INPUT( this->missing_required_tags_[ EVALUATOR_TYPE ], ( "Evaluator \"type\" parameter appears more than once in a single in section" ), this->section_label() );
  UTILITY_INPUT( not reader.value().empty(), "Evaluator \"type\" parameter must have a value.", this->section_label() );
  std::string val( reader.dequote( reader.value() ) );
  UTILITY_INPUT( this->has_type( val ), "Evaluator \"type\" parameter value (" + val + ") does not name a valid evaluator for this application (see documentation).", this->section_label() );
  this->type_ = val;
  missing_required_tags_.reset( EVALUATOR_TYPE );
}
else
{
  // --------------------
  // Choice specific parameters
  UTILITY_INPUT( 0 == this->parameter_set_.count( reader.name() ), ( "keyword \""+reader.name()+"\" appears more than once in a single in specie section" ), this->section_label() );
  this->parameter_set_.insert( std::make_pair( reader.name(), reader.value() ) );
}
return true;

!!!203952.cpp!!!	do_read_end() : void
UTILITY_INPUT( not this->missing_required_tags_[ EVALUATOR_TYPE ], ( "Evaluator \"type\" parameter missing in input." ), this->section_label() );
UTILITY_INPUT (not this->missing_required_tags_.any(), "Not all required tags were present.", this->section_label());

// Call functor method to create evaluator
for( const auto& defn : this->type_to_object_ )
{
  if( defn.label() == this->type_ )
  { 
    // check parameters are in definition
    for( const auto& entry : this->parameter_set_ )
    {
      UTILITY_INPUT( defn.has_definition( entry.first ), "Parameter with name \""+entry.first+"\" is not valid for evaluator type \"" + this->type_ + "\".", this->section_label() );
    } 

    this->manager_->add_evaluator( defn( this->parameter_set_ ) );
    return;
  }
}
// error to get here
UTILITY_CHECK( false, "should never reach this point in the code." );
!!!1362352.cpp!!!	do_reset() : void
// Reset meta data
this->missing_required_tags_.set();
this->parameter_set_.clear();
this->type_.clear();
