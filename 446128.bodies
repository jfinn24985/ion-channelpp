class particle_manager
!!!908336.cpp!!!	serialize(inout ar : Archive, in version : unsigned int) : void
ar & species_;
ar & ensemble_;
ar & target_particles_;
!!!937520.cpp!!!	charge() : double
double result = 0.0;
for( std::size_t ii = 0; ii != this->ensemble_->known_keys(); ++ii )
{
  result += ( this->species_[ii].valency() * this->ensemble_->specie_count( ii ) );
}
return result;

!!!907952.cpp!!!	description(inout os : ostream) : void
os << core::strngs::horizontal_bar() << "\n";
os << "Particle system details.\n";
os << "------------------------\n";
os << "          specie count : " << this->specie_count() << "\n";
os << " target particle count : " << this->target_count() << "\n"; 
if( 0 != this->specie_count() )
{
  os << core::strngs::horizontal_bar() << "\n";
  for( auto const& spc : this->species_ )
  {
    spc.description( os );
  }
}
if( this->ensemble_ )
{
  os << core::strngs::horizontal_bar() << "\n";
  this->ensemble_->description( os );
}
!!!907952.python!!!	description(inout os : ostream) : void
from constants import constants
constants.description( os )
print >>os, "[simulation]"
print >>os, "        volume :", self.cell_region_.volume(-1), "Anstrom{3}"
print >>os, "  permittivity :", self.cell_region_.permittivity()
print >>os, " beta (1/k_BT) :", (1.0/(constants.boltzmann_constant()*self.temperature_kelvin_)), " J{-1}"
print >>os, "  temperature :", self.temperature_kelvin_, " K"
print >>os, " specie count :", self.specie_count()
print >>os, " - loop sizes"
print >>os, "       thermal :", self.equilibration_interval_
print >>os, "    production :", self.production_interval_
print >>os, "         inner :", self.inner_loop_size_
print >>os, " current index :", self.outer_loop_index_
print >>os, " - other parameters"
print >>os, " starting particle count :", self.target_number_of_particles()
print >>os, "          ionic strength :", self.ionic_strength()
print >>os, "             trial rates :", self.rates_
print >>os, "              move delta :", self.delta
for spc in self.species_:
  spc.description( os )
print >>os, "[choices] trial types and rates"
print >>os, " %6s %4s %7s" % ( "type", "spc.", "rate(%)" )
for choice in self.choices_:
  print >>os, " %6s %4s %7.2f" % ( choice.label(), self.species_[choice.specie_key()].label(), choice.probability()*100.0 )
for observable in self.observables_:
  observable.description( os )
for potl in self.evaluators_:
  potl.description( os )
self.ensemble_.description( os )

!!!907440.cpp!!!	get_specie_key(in label : string) : size_t
for (std::size_t ix = 0; ix != this->species_.size(); ++ix)
{
  if (label == species_[ix].label ()) return ix;
}
throw std::out_of_range(label+" is not a specie label");
return this->species_.size();
!!!907440.python!!!	get_specie_key(in label : string) : size_t
for ispec, spc in enumerate(self.species_):
  if spc.label() == label:
    return ispec
raise KeyError, label+" is not a specie label"
!!!907184.cpp!!!	has_specie(in name : string) : bool
for (auto const& spc: this->species_)
{
  if (name == spc.label ()) return true;
}
return false;
!!!1760816.cpp!!!	ionic_strength(in volume : double) : double
std::size_t ionic_particles = 0ul;
for( std::size_t ispec = 0ul; ispec != this->specie_count(); ++ispec )
{
  if( this->get_specie( ispec ).is_solute() )
  {
    ionic_particles += this->ensemble_->specie_count( ispec );
  }
}
return ( ionic_particles == 0ul ? 0.0 : ( ionic_particles * core::constants::to_SI() )/volume );
!!!1760816.python!!!	ionic_strength(in volume : double) : double
result = 0.0 # ionic strength
for spc in self.species_:
   result += spc.concentration()
return result
!!!1800112.cpp!!!	target_ionic_strength() : double
double result = 0.0; // ionic strength
for( auto const& spc: this->species_ )
{
  if( spc.is_solute() )
  {
    result += spc.concentration();
  }
}
return result;
!!!1800112.python!!!	target_ionic_strength() : double
result = 0.0 # ionic strength
for spc in self.species_:
   result += spc.concentration()
return result
!!!1806640.cpp!!!	target_volume() : double
const double conc = this->target_ionic_strength();
UTILITY_REQUIRE( conc != 0.0, "Cannot calculate target volume without a target concentration" );
return ( ( this->target_count() == 0ul ) ? 0.0 : ( this->target_count() * core::constants::to_SI() )/conc );
!!!951216.cpp!!!	write_document(inout wr : input_document) : void
// Add specie definitions.
if( this->specie_count() != 0ul )
{
  // Update specie position information.
  //////////////////////////////////////
  if( this->ensemble_->count() != 0ul )
  {
    // local index of each specie
    std::vector< std::size_t > cursors( this->specie_count(), 0ul );

    for( std::size_t idx = 0ul; idx != this->ensemble_->size(); ++ idx )
    {
      const std::size_t ispec { this->ensemble_->key( idx ) };
      if( ispec != particle::specie_key::nkey )
      {
        this->species_[ ispec ].update_position( cursors[ ispec ], this->ensemble_->position( idx ) );
        ++cursors[ ispec ];
      }
    }
  }
  // Write updated specie definitions.
  ////////////////////////////////////
  for( auto const& spc : this->species_ )
  {
    spc.write_document( wr );
  }
}


!!!951344.cpp!!!	add_predefined_particles() : void
// Local reference to the ensemble.
particle::ensemble &ens( *this->ensemble_ );

// Add any predifined particles to the ensemble
for (std::size_t ispec { 0 }; ispec != this->species_.size(); ++ispec)
{
   auto const& spc = this->species_[ ispec ];
   if ( spc.get_position_size() != 0 )
   {
      for (std::size_t idx { 0 }; idx != spc.get_position_size(); ++idx)
      {
         ens.append_position( ispec, spc.get_position( idx ) );
      }
   }
}
!!!951344.python!!!	add_predefined_particles() : void
from constants import constants
## Generate a list of trial types
self.update_choices()
sumconc = self.ionic_strength()
# Use a PBC system.
from periodic_system import periodic_system
self.cell_region_ = periodic_system(self.target_particles_ * constants.to_SI() / sumconc)
# Generate initial ensemble on a grid
gridder = self.cell_region_.make_grid_generator( self.target_particles_, self.get_random() ) 
self.ensemble_.generate_ensemble( gridder, self.target_particles_, self.get_random() )
pass
!!!1877680.cpp!!!	set_target_count_by_volume(in vol : double) : void
UTILITY_REQUIRE( vol > 0.0, "Cannot calculate target count without a positive volume" );
const double conc = this->target_ionic_strength();
UTILITY_REQUIRE( conc > 0.0, "Cannot calculate target count without a positive target concentration" );
this->set_target_count( std::nearbyint( conc * vol / core::constants::to_SI() ) );
!!!1779632.cpp!!!	build_input_delegater(inout pman : particle_manager, inout delegate : input_delegater) : void
//////////
// Species
boost::shared_ptr< core::input_base_meta > smeta{ new particle::specie_meta( pman ) };
delegate.add_input_delegate( smeta );
