class specie_meta
!!!2078895.cpp!!!	add_keyword(in name : string) : void
UTILITY_REQUIRE( not specie_meta::is_standard_keyword( name ), "Attempt to register keyword \""+name+"\" that is the same as a standard keyword" );

specie_meta::known_keywords_.insert( name );
!!!267952.cpp!!!	is_standard_keyword(in name : string) : bool
// Check keyword is not a 'standard' word
std::size_t match_standard_keyword(0);
for ( std::string kw : { core::strngs::fsname(), core::strngs::fstype(), core::strngs::fsrtsp(), core::strngs::fsd(), core::strngs::fsz(), core::strngs::fsctrg(), core::strngs::fschex(), core::strngs::fsn() } )
{
   if (kw == name) ++match_standard_keyword;
}
return match_standard_keyword != 0;
!!!2086575.cpp!!!	has_keyword(in name : string) : bool
return 0 != specie_meta::known_keywords_.count( name );
!!!915248.cpp!!!	publish_help(inout helper : input_help) : void
const std::string seclabel( core::strngs::fsspec() );
const std::string freeonly( "required: only valid for \"" + core::strngs::fsfree() + "\"" );
// ----------------------------------------
// add section
// ----------------------------------------

//   Specie input section definition
helper.add_section( { seclabel, "Specie input section definition" } );

core::help_section &sect = helper.get_section( seclabel );
// ----------------------------------------
// add parameters
// ----------------------------------------

//   z : [required, number] specie valency
{
  const std::string description( "specie valency (atomic)." );
  sect.add_entry( { core::strngs::fsz(), "number", "", "required", description } );
}
//  d : [required, number] specie diameter
{
  const std::string description( "Specie diameter." );
  sect.add_entry( { core::strngs::fsd(), "number in Angstrom", "> 0", "required", description } );
}
// name : [required, two letters] specie code name (quotes optional)
{
  const std::string description( "Specie code name (quotes optional)." );
  sect.add_entry( { core::strngs::fsname(), "two letters", "unique", "required", description } );
}
//  type : [optional, default type is \"free\"] specie model
//         type. value should be one of: fsmobl, fsflxd, fschon
//         or fsfree (only first 3 letters required)
{
  std::stringstream subtypes;
  subtypes << core::strngs::fsmobl() << "|" << core::strngs::fsflxd() << "|"
           << core::strngs::fschon() << "|" << core::strngs::fsfree();
  std::string description( "Specie model type (only first 3 letters required)." );
  sect.add_entry( { core::strngs::fstype(), "keyword", subtypes.str(), core::strngs::fsfree(), description } );
}
// chex : [required and valid for ",fsfree," type only, number] initial chemical excess
{
  const std::string description( "Initial chemical excess." );
  sect.add_entry( { core::strngs::fschex(), "number", "", freeonly, description } );
}
// ratspec  : [optional for ",fsmobl,", ",fsflxd," and ",fschon,", required for ",fsfree,", number]
//            Probability this specie is used in a move trial
{
  std::stringstream description;
  description << "Probability this specie is used in a move trial. "
              << "Optional for \"" << core::strngs::fsmobl()
              << "\", \"" << core::strngs::fsflxd() << "\" and \""
              << core::strngs::fschon() << "\", required for \""
              << core::strngs::fsfree()
              << " type species.";
  sect.add_entry( { core::strngs::fsrtsp(), "number", ">0", "none", description.str() } );
}
// ratexchg : [",fsfree," type only, required, number] Once selected for a move, "
//   write(unit=fid,fmt='(9X,A)')"probability of channel insertion (vs step) move"
{
  std::string description( "Probability of channel insertion." );
  sect.add_entry( { core::strngs::fsrtex(), "number", ">0", freeonly, description } );
}
//  ratmov : [",fsfree," type only, required, number] Once selected for a step move,
//           probability of a gas phase or liquid phase move.
{
  std::string description( "Probability of a gas phase or liquid phase move." );
  sect.add_entry( { core::strngs::fsrtmv(), "number", ">0", freeonly, description } );
}
// ratgr  : [",fsfree," type only, optional, number] Probability this specie is
//         used in a individual ion grand-canonical trial.
{
  std::string description( "Probability this specie is used in a individual ion grand-canonical trial." );
  sect.add_entry( { core::strngs::fsrtgr(), "number", ">0", freeonly, description } );
}
//  ratreg : ["fsfree" type only, required*, four numbers] Per-region probability
//          this specie is inserted into the particular region in a grand-
//          canonical trial. *Required if this specie is part of a salt or
//          if "fsrtgr" is set
{
  std::stringstream description;
  description << "Per-region probabilities "
              << "this specie is inserted into the particular region in a grand-"
              << "canonical trial. \n(*)Required if this specie is part of a salt or "
              << "if " << core::strngs::fsrtgr() << " is set.";
  sect.add_entry( { core::strngs::fsrtrg(), "list(number for each region)", ">0", freeonly, description.str() } );
}
//   n : [required for "fsmobl" and "fsflxd", optional for other types, integer > 0]
//       Initial position definition flag. The lines following "fsn" contain
//       X number of lines of x,y,z etc information, where X is the argument
//       to "fsn". This tag must appear after the "fstype" tag for "fsmobl" and "fsflxd"
//       species. "fschon" or "fsfree" require three numbers defining the initial
//       x,y,z position of the particle. "fsmobl" and "fsflxd" additionally require
//       a fourth number with the localisation radius, and an optional three
//       numbers defining the x,y,z position of the localisation centre-point.
//       If the optional last three numbers are not included then the initial x,y,z
//       position is used as the localisation centre-point.
{
  std::stringstream description;
  description << "Number of initial particle position definitions.\n"
              << "The lines following \"" << core::strngs::fsn() << "\" contain "
              << "X number of lines of x,y,z etc information, where X is the argument "
              << "to \"" << core::strngs::fsn() << "\". This tag must appear after the \""
              << core::strngs::fstype() << "\" tag for \"" << core::strngs::fsmobl()
              << "\" and \"" << core::strngs::fsflxd() << "\" species. \""
              << core::strngs::fschon() << "\" or \"" << core::strngs::fsfree()
              << "\" require three numbers defining the initial "
              << "x,y,z position of the particle. \"" << core::strngs::fsmobl()
              << "\" and \"" << core::strngs::fsflxd() << "\" additionally require "
              << "a fourth number with the localisation radius, and an optional three "
              << "numbers defining the x,y,z position of the localisation centre-point. "
              << "If these last three numbers are not included then the initial x,y,z "
              << "position is used as the localisation centre-point. This "
              << "option is required for \"" << core::strngs::fsmobl()
              << "\", \"" << core::strngs::fsflxd() << "\" and \""
              << core::strngs::fschon() << "\", optional for \""
              << core::strngs::fsfree() << "\".";
  sect.add_entry( { core::strngs::fsn(), "number", ">0", "required", description.str() } );
}
!!!203312.cpp!!!	do_read_entry(inout reader : input_base_reader) : bool
// process entries
if( reader.name() == core::strngs::fsname() )
{
  // --------------------
  // Specie label (required)
  reader.duplicate_test( this->missing_required_tags_[ SPECIE_LABEL ], this->section_label() );
  std::string label = reader.get_text( "Specie label", this->section_label() );
  boost::algorithm::trim( label );
  UTILITY_INPUT( label.size() == 2, "Specie label must have exactly two letters.", this->section_label(), &reader );
  this->specie_obj_.set_label( label );
  this->missing_required_tags_.reset( SPECIE_LABEL );
}
else if( reader.name() == core::strngs::fstype() )
{
  // --------------------
  // Specie type
  reader.duplicate_test( this->missing_required_tags_[ SPECIE_TYPE ], this->section_label() );
  const std::size_t subtype = reader.get_key( "Specie subtype", this->section_label(), this->specie_obj_.specie_type_list() );
  this->specie_obj_.set_type( subtype );
  this->missing_required_tags_.reset( SPECIE_TYPE );
}
else if( reader.name() == core::strngs::rate_label() )
{
  // --------------------
  // Specie (relative) rate
  // (can not test for duplicate entry [note rate_label and fsrtsp both call set_rate].)
  const double rate = reader.get_float( "Specie relative trial rate", this->section_label(), true, true );
  this->specie_obj_.set_rate( rate );
}
else if( reader.name() == core::strngs::fsrtsp() )
{
  // --------------------
  // Specie relative rate (optional)
  // (can not test for duplicate entry [note rate_label and fsrtsp both call set_rate].)
  const double rate = reader.get_float( "Specie relative trial rate", this->section_label(), true, true );
  this->specie_obj_.set_rate( rate );
}
else if( reader.name() == core::strngs::fsd() )
{
  // --------------------
  // Specie diameter
  reader.duplicate_test( this->missing_required_tags_[ SPECIE_DIAMETER ], this->section_label() );
  const double diameter = reader.get_float( "Specie diameter", this->section_label(), true, true );
  this->specie_obj_.set_radius( diameter / 2 );
  this->missing_required_tags_.reset( SPECIE_DIAMETER );
}
else if( reader.name() == core::strngs::fsz() )
{
  // --------------------
  // Specie valency
  reader.duplicate_test( this->missing_required_tags_[ SPECIE_VALENCY ], this->section_label() );
  const double valency = reader.get_float( "Specie valency", this->section_label(), false, false );
  this->specie_obj_.set_valency( valency );
  this->missing_required_tags_.reset( SPECIE_VALENCY );
}
else if( reader.name() == core::strngs::fsctrg() )
{
  // --------------------
  // Specie concentration
  // (can not test for duplicate entry.)
  const double conc = reader.get_float( "Specie target concentration", this->section_label(), true, false );
  this->specie_obj_.set_concentration( conc );
}
else if( reader.name() == core::strngs::fschex() )
{
  // --------------------
  // Specie chemical excess
  // (can not test for duplicate entry.)
  const double chex = reader.get_float( "Specie excess chemical potential", this->section_label(), false, false );
  this->specie_obj_.set_excess_potential( chex );
}
else if( reader.name() == core::strngs::fsn() )
{
  // --------------------
  // Initial particle positions of this specie
  reader.duplicate_test( this->specie_obj_.get_position_size() == 0, this->section_label() );
  

  std::size_t initial_count{ reader.get_ordinal( "Defined positions", this->section_label() ) };
  std::vector< double > values;
  for( std::size_t cursor_ = 0; cursor_ != initial_count; ++cursor_ )
  {
    reader.next();
    reader.get_line_as_floats( core::strngs::fsn(), "Position definition", this->section_label(), values );
    // Non-position line data should begin with a keyword so should give no values
    UTILITY_INPUT( not values.empty(), "Fewer position data lines than expected", this->section_label(), &reader );
    UTILITY_INPUT( values.size() == 3 or values.size() == 4 or values.size() == 7, "Position data should have 3, 4 or 7 values", this->section_label(), &reader );
    geometry::coordinate pos { values[0], values[1], values[2] };
    if( values.size() > 3 )
    {
      UTILITY_INPUT( values[3] > 0.0, "Localization radius must be greater than zero", this->section_label(), &reader );
      geometry::centroid cntr;
      cntr.r = values[3]; // = update radius
      if( values.size() == 7 )
      {
        cntr.x = values[4];
        cntr.y = values[5];
        cntr.z = values[6];
      }
      else
      {
        cntr.x = pos.x;
        cntr.y = pos.y;
        cntr.z = pos.z;
      }
      // append location and centroid information
      this->specie_obj_.append_position( pos, cntr );
    }
    else
    {
      // append only location.
      this->specie_obj_.append_position( pos );
    }
  }
}
else
{
  // --------------------
  // Other (usually) evaluator specific specie parameters
  UTILITY_INPUT( 0 != this->known_keywords_.count( reader.name() ), ( "keyword \""+reader.name()+"\" is not valid in specie section" ), this->section_label(), &reader );
  reader.duplicate_test( not this->specie_obj_.has_parameter( reader.name() ), this->section_label() );
  this->specie_obj_.set_parameter( reader.name(), reader.value() );
  // We leave the user's of these parameters to check whether all the
  // required parameters are present
}
return true;



!!!203440.cpp!!!	do_read_end(in reader : input_base_reader) : void
if ( this->missing_required_tags_[ SPECIE_TYPE ] )
{
  UTILITY_CHECK( not this->specie_obj_.is_valid(), "Type flag not set but type assigned." );
  // Type not set, attempt to deduce type.
  if ( this->specie_obj_.concentration() > 0.0 )
  {
    // Assume FREE
    this->specie_obj_.set_type( particle::specie::SOLUTE );
    this->missing_required_tags_.reset( SPECIE_TYPE );
  }
  // We allow only free/SOLUTE subtype to be deduced
}

UTILITY_INPUT( this->missing_required_tags_.none(), "Not all required tags were present.", this->section_label(), &reader);

this->manager_->add_specie( this->specie_obj_ );
!!!944688.cpp!!!	do_reset() : void
// Reset state
this->specie_obj_ = particle::specie();
this->missing_required_tags_.set();

