class specie_meta
!!!2078895.cpp!!!	add_keyword(in name : string) : void
UTILITY_REQUIRE( not specie_meta::is_standard_keyword( name ), "Attempt to register keyword \""+name+"\" that is the same as a standard keyword" );

specie_meta::known_keywords_.insert( name );
!!!267952.cpp!!!	is_standard_keyword(in name : string) : bool
// Check keyword is not a 'standard' word
std::size_t match_standard_keyword(0);
for ( std::string kw : { core::strngs::fsname(), core::strngs::fstype(), core::strngs::fsrtsp(), core::strngs::fsd(), core::strngs::fsz(), core::strngs::fsctrg(), core::strngs::fschex(), core::strngs::fsn() } )
{
   if (kw == name) ++match_standard_keyword;
}
return match_standard_keyword != 0;
!!!2086575.cpp!!!	has_keyword(in name : string) : bool
return 0 != specie_meta::known_keywords_.count( name );
!!!915248.cpp!!!	add_documentation(inout helper : input_help) : void
const std::string seclabel( core::strngs::fsspec() );
// ----------------------------------------
// add section
// ----------------------------------------

//   Specie input section definition
helper.add_section( seclabel, "Specie input section definition" );

// ----------------------------------------
// add parameters
// ----------------------------------------

//   z : [required, number] specie valency
{
  const std::string description( "[required, number] specie valency (atomic)." );
  helper.add_option( seclabel, core::strngs::fsz(), description );
}
//  d : [required, number] specie diameter
{
  const std::string description( "[required, number > 0] specie diameter (Angstrom)." );
  helper.add_option( seclabel, core::strngs::fsd(), description );
}
// name : [required, two letters] specie code name (quotes optional)
{
  const std::string description( "[required, two letters] specie code name (quotes optional)." );
  helper.add_option( seclabel, core::strngs::fsname(), description );
}
//  type : [optional, default type is \"free\"] specie model
//         type. value should be one of: fsmobl, fsflxd, fschon
//         or fsfree (only first 3 letters required)
{
  std::stringstream description;
  description << "[optional, default type is \"" << core::strngs::fsfree()
              << "\"] specie model type. value should be one of: \""
              << core::strngs::fsmobl() << "\", \"" << core::strngs::fsflxd() << "\", \""
              << core::strngs::fschon() << "\" or \"" << core::strngs::fsfree()
              << "\" (only first 3 letters required).";
  helper.add_option( seclabel, core::strngs::fstype(), description.str() );
}
// chex : [required and valid for ",fsfree," type only, number] initial chemical excess
{
  const std::string description( "[required and valid for \"" + core::strngs::fsfree()
                                 + "\" type only, number] initial chemical excess." );
  helper.add_option( seclabel, core::strngs::fschex(), description );
}
// ratspec  : [optional for ",fsmobl,", ",fsflxd," and ",fschon,", required for ",fsfree,", number]
//            Probability this specie is used in a move trial
{
  std::stringstream description;
  description << "[optional for  \"" << core::strngs::fsmobl()
              << "\", \"" << core::strngs::fsflxd() << "\" and \""
              << core::strngs::fschon() << "\", required for \"" << core::strngs::fsfree()
              << ", number > 0] Probability this specie is used in a move trial.";
  helper.add_option( seclabel, core::strngs::fsrtsp(), description.str() );
}
// ratexchg : [",fsfree," type only, required, number] Once selected for a move, "
//   write(unit=fid,fmt='(9X,A)')"probability of channel insertion (vs step) move"
{
  std::stringstream description;
  description << "[\"" << core::strngs::fsfree()
              << " type only, required, number > 0] Once selected for a move, probability of channel insertion (vs step) move.";
  helper.add_option( seclabel, core::strngs::fsrtex(), description.str() );
}
//  ratmov : [",fsfree," type only, required, number] Once selected for a step move,
//           probability of a gas phase or liquid phase move.
{
  std::stringstream description;
  description << "[\"" << core::strngs::fsfree()
              << " type only, required, number > 0] Once selected for a step move, probability  of a gas phase or liquid phase move.";
  helper.add_option( seclabel, core::strngs::fsrtmv(), description.str() );
}
// ratgr  : [",fsfree," type only, optional, number] Probability this specie is
//         used in a individual ion grand-canonical trial.
{
  std::stringstream description;
  description << "[\"" << core::strngs::fsfree()
              << " type only, required, number > 0] Probability this specie is used in a individual ion grand-canonical trial.";
  helper.add_option( seclabel, core::strngs::fsrtgr(), description.str() );
}
//  ratreg : ["fsfree" type only, required*, four numbers] Per-region probability
//          this specie is inserted into the particular region in a grand-
//          canonical trial. *Required if this specie is part of a salt or
//          if "fsrtgr" is set
{
  std::stringstream description;
  description << "[\"" << core::strngs::fsfree()
              << " type only, required*, number > 0 for each region] Per-region probabilities "
              << "this specie is inserted into the particular region in a grand-"
              << "canonical trial. \n(*)Required if this specie is part of a salt or "
              << "if " << core::strngs::fsrtgr() << " is set.";
  helper.add_option( seclabel, core::strngs::fsrtrg(), description.str() );
}
//   n : [required for "fsmobl" and "fsflxd", optional for other types, integer > 0]
//       Initial position definition flag. The lines following "fsn" contain
//       X number of lines of x,y,z etc information, where X is the argument
//       to "fsn". This tag must appear after the "fstype" tag for "fsmobl" and "fsflxd"
//       species. "fschon" or "fsfree" require three numbers defining the initial
//       x,y,z position of the particle. "fsmobl" and "fsflxd" additionally require
//       a fourth number with the localisation radius, and an optional three
//       numbers defining the x,y,z position of the localisation centre-point.
//       If the optional last three numbers are not included then the initial x,y,z
//       position is used as the localisation centre-point.
{
  std::stringstream description;
  description << "[required for \"" << core::strngs::fsmobl()
              << "\", \"" << core::strngs::fsflxd() << "\" and \""
              << core::strngs::fschon() << "\", optional for \"" << core::strngs::fsfree()
              << "\", integer number > 0] Number of initial position definitions.\n"
              << "The lines following \"" << core::strngs::fsn() << "\" contain "
              << "X number of lines of x,y,z etc information, where X is the argument "
              << "to \"" << core::strngs::fsn() << "\". This tag must appear after the \""
              << core::strngs::fstype() << "\" tag for \"" << core::strngs::fsmobl()
              << "\" and \"" << core::strngs::fsflxd() << "\" species.  \""
              << core::strngs::fschon() << "\" or \"" << core::strngs::fsfree()
              << "\" require three numbers defining the initial "
              << "x,y,z position of the particle. \"" << core::strngs::fsmobl()
              << "\" and \"" << core::strngs::fsflxd() << "\" additionally require "
              << "a fourth number with the localisation radius, and an optional three "
              << "numbers defining the x,y,z position of the localisation centre-point. "
              << "If these last three numbers are not included then the initial x,y,z "
              << "position is used as the localisation centre-point.";
  helper.add_option( seclabel, core::strngs::fsn(), description.str() );
}

!!!203312.cpp!!!	do_read_entry(inout reader : input_base_reader) : bool
// process entries

if( reader.name() == core::strngs::fsname() )
{
  // --------------------
  // Specie label (required)
  UTILITY_INPUT( not reader.value().empty(), "Specie label must have a value.", this->section_label() );
  std::string label( reader.dequote( reader.value() ) );
  boost::algorithm::trim( label );
  UTILITY_INPUT( label.size() == 2, "Specie label must have exactly two letters.", this->section_label() );
  this->specie_obj_.set_label( label );
  missing_required_tags_.reset( SPECIE_LABEL );
}
else if( reader.name() == core::strngs::fstype() )
{
  // --------------------
  // Specie type
  UTILITY_INPUT( not reader.value().empty(), "Specie type must have a value.", this->section_label() );
  bool valid_type;
  std::string value( reader.dequote( reader.value() ) );
  boost::algorithm::trim( value );
  const std::size_t subtype = this->specie_obj_.string_to_specie_type( value, valid_type );
  UTILITY_INPUT( valid_type, "Specie type must be one of allowed values.", this->section_label() );
  if( valid_type )
  {
    this->specie_obj_.set_type( subtype );
    missing_required_tags_.reset( SPECIE_TYPE );
  }
}
else if( reader.name() == core::strngs::fsrtsp() )
{
  // --------------------
  // Specie relative rate (optional)
  UTILITY_INPUT( not reader.value().empty(), "Relative rate parameter for a specie must have a value.", this->section_label() );
  double rate = 0.0;
  try
  {
    rate = boost::lexical_cast< double >( reader.value() );
  }
  catch( std::bad_cast const& err )
  {
    const bool value_is_a_number = false;
    UTILITY_INPUT( value_is_a_number, std::string( "Specie rate parameter not a number: " ) + err.what(), this->section_label() );
  }
  UTILITY_INPUT( rate >= 0.0, "Specie rate parameter must be greater or equal to zero.", this->section_label() );
  this->specie_obj_.set_rate( rate );
}
else if( reader.name() == core::strngs::fsd() )
{
  // --------------------
  // Specie diameter
  UTILITY_INPUT( not reader.value().empty(), "Specie diameter must have a value.", this->section_label() );
  double diameter = 0.0;
  try
  {
    diameter = boost::lexical_cast< double >( reader.value() );
  }
  catch( std::bad_cast const& err )
  {
    const bool value_is_a_number = false;
    UTILITY_INPUT( value_is_a_number, std::string( "Specie diameter parameter not a number: " ) + err.what(), this->section_label() );
  }
  UTILITY_INPUT( diameter >= 0.0, "Specie diameter must be greater than (or in special cases equal to) zero.", this->section_label() );
  this->specie_obj_.set_radius( diameter / 2 );
  missing_required_tags_.reset( SPECIE_DIAMETER );
}
else if( reader.name() == core::strngs::fsz() )
{
  // --------------------
  // Specie valency
  UTILITY_INPUT( not reader.value().empty(), "Specie valency must have a value.", this->section_label() );
  double valency = 0.0;
  try
  {
    valency = boost::lexical_cast< double >( reader.value() );
  }
  catch( std::bad_cast const& err )
  {
    const bool value_is_a_number = false;
    UTILITY_INPUT( value_is_a_number, std::string( "Specie valency parameter not a number: " ) + err.what(), this->section_label() );
  }
  this->specie_obj_.set_valency( valency );
  missing_required_tags_.reset( SPECIE_VALENCY );
}
else if( reader.name() == core::strngs::fsctrg() )
{
  // --------------------
  // Specie concentration
  UTILITY_INPUT( not reader.value().empty(), "Specie concentration must have a value.", this->section_label() );
  double conc = 0.0;
  try
  {
    conc = boost::lexical_cast< double >( reader.value() );
  }
  catch( std::bad_cast const& err )
  {
    const bool value_is_a_number = false;
    UTILITY_INPUT( value_is_a_number, std::string( "Specie concentration parameter not a number: " ) + err.what(), this->section_label() );
  }
  UTILITY_INPUT( conc > 0.0, "Target concentration must be greater than zero.", this->section_label() );
  this->specie_obj_.set_concentration( conc );
}
else if( reader.name() == core::strngs::fschex() )
{
  // --------------------
  // Specie chemical excess
  UTILITY_INPUT( not reader.value().empty(), "Specie excess chemical potential must have a value.", this->section_label() );
  double chex = 0.0;
  try
  {
    chex = boost::lexical_cast< double >( reader.value() );
  }
  catch( std::bad_cast const& err )
  {
    const bool value_is_a_number = false;
    UTILITY_INPUT( value_is_a_number, std::string( "Specie excess chemical potential parameter not a number: " ) + err.what(), this->section_label() );
  }
  this->specie_obj_.set_excess_potential( chex );
}
else if( reader.name() == core::strngs::fsn() )

{
  // --------------------
  // Initial particle positions of this specie
  std::size_t initial_count( 0 );
  try
  {
    initial_count = boost::lexical_cast < std::size_t >( reader.value() );
  }
  catch( std::bad_cast const& err )
  {
    const bool value_is_a_number = false;
    UTILITY_INPUT( value_is_a_number, std::string( "Predefined particle \"n\" value not a number: " ) + err.what(), this->section_label() );
  }
  for( std::size_t cursor_ = 0; cursor_ != initial_count; ++cursor_ )
  {
    reader.next();
    std::string line_( reader.line() );
    std::vector< double > values;
    UTILITY_INPUT( reader.read_as_floats( line_, values ), "Bad values in position data line", this->section_label() );
    // Non-position line data should begin with a keyword so should give no values
    UTILITY_INPUT( not values.empty(), "Fewer position data lines than expected", this->section_label() );
    UTILITY_INPUT( values.size() == 3 or values.size() == 4 or values.size() == 7, "Position data should have 3, 4 or 7 values", this->section_label() );
    particle::coordinate pos { values[0], values[1], values[2] };
    if( values.size() > 3 )
    {
      UTILITY_INPUT( values[3] >= 0.0, "Localization radius must be greater than zero", this->section_label() );
      particle::centroid cntr;
      cntr.r = values[3]; // = update radius
      if( values.size() == 7 )
      {
        cntr.x = values[4];
        cntr.y = values[5];
        cntr.z = values[6];
      }
      else
      {
        cntr.x = pos.x;
        cntr.y = pos.y;
        cntr.z = pos.z;
      }
      // append location and centroid information
      this->specie_obj_.append_position( pos, cntr );
    }
    else
    {
      // append only location.
      this->specie_obj_.append_position( pos );
    }
  }
}
else
{
  // --------------------
  // Other (usually) evaluator specific specie parameters
  UTILITY_INPUT( 0 != this->known_keywords_.count( reader.name() ), ( "keyword \""+reader.name()+"\" is not valid in specie section" ), this->section_label() );
  UTILITY_INPUT( not this->specie_obj_.has_parameter( reader.name() ), ( "keyword \""+reader.name()+"\" appears more than once in the same specie section" ), this->section_label() );
  this->specie_obj_.set_parameter( reader.name(), reader.value() );
  // We leave the user's of these parameters to check whether all the
  // required parameters are present
}
return true;



!!!203440.cpp!!!	do_read_end() : void
if ( this->missing_required_tags_[ SPECIE_TYPE ] )
{
  UTILITY_CHECK( not this->specie_obj_.is_valid(), "Type flag not set but type assigned." );
  // Type not set, attempt to deduce type.
  if ( this->specie_obj_.concentration() > 0.0 )
  {
    // Assume FREE
    this->specie_obj_.set_type( particle::specie::SOLUTE );
    this->missing_required_tags_.reset( SPECIE_TYPE );
  }
  // We allow only free/SOLUTE subtype to be deduced
}

UTILITY_INPUT( this->missing_required_tags_.none(), "Not all required tags were present.", this->section_label());

this->manager_->add_specie( this->specie_obj_ );
!!!944688.cpp!!!	do_reset() : void
// Reset state
this->specie_obj_ = particle::specie();
this->missing_required_tags_.set();

