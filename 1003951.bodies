class accum
!!!1826863.cpp!!!	accumulate() : void
this->acharge_ << parent_.get_conf().charge ();
const int ifree (parent_.get_spec().spec_size () - parent_.get_spec().nstr); // number of free ions

for (int ireg = constants::izlim; ireg <= constants::ichan; ++ireg)
{
    // histogram indices
    int i3 = 0;
    int i4 = 0;

    switch (ifree)
    {
    default:
    case 3:
        i4 = std::min< int > (parent_.get_conf().nin (parent_.get_spec().chloride_index () + 3, ireg), noccmx);
    case 2:
        i3 = std::min< int > (parent_.get_conf().nin (parent_.get_spec().chloride_index () + 2, ireg), noccmx);
    case 1:
        const int i2 = std::min< int > (parent_.get_conf().nin (parent_.get_spec().chloride_index () + 1, ireg), noccmx);
        const int i1 = std::min< int > (parent_.get_conf().nin (parent_.get_spec().chloride_index (), ireg), noccmx);
        ++this->aocc_ [ireg][i1][i2][i3][i4];
    }
}

for (int ispec = 0; ispec != ifree; ++ispec)
{
    const int ispec_adj (ispec + parent_.get_spec().chloride_index ());
    this->anin_[ispec][constants::izlim] << static_cast< double > (parent_.get_conf().nin (ispec_adj, constants::izlim));
    this->anin_[ispec][constants::ifilt] << static_cast< double > (parent_.get_conf().nin (ispec_adj, constants::ifilt));
    this->anin_[ispec][constants::ichan] << static_cast< double > (parent_.get_conf().nin (ispec_adj, constants::ichan));
    this->anin_[ispec][constants::ibulk] << static_cast< double > (parent_.get_conf().ni (ispec_adj));
}

if (not patch::homog ())
{
    IONCH_CHECK (this->ah_.bin_count () >= patch::get_h ().size ()
                 , "Observable for patch::h is too small");
    this->ah_.insert (patch::get_h ().begin (), patch::get_h ().end ());
}

!!!1826991.cpp!!!	acceql() : void
this->acharge_ << parent_.get_conf().charge ();

const int ifree (parent_.get_spec().spec_size () - parent_.get_spec().nstr); // number of free ions
// int nbulk_[ifree];
ionch::count_scope cscope_;

for (int isx = 0; isx != ifree; ++isx)
{
    cscope_ << this->abulk_[isx];
}

for (int ii = 0; ii != parent_.get_conf().active_size (); ++ii)
{
    const int ispec = parent_.get_conf().ispcbk (ii);

    if (ispec != constants::invspc and parent_.get_spec().isfree (ispec))
    {
        if (parent_.get_geom().is_bulk_sample (parent_.get_conf().rz (ii), parent_.get_conf().r2 (ii)))
        {
            ++this->abulk_[ispec - parent_.get_spec().chloride_index ()];
        }
    }
}

!!!1827119.cpp!!!	accblk() : void
this->acharge_ << parent_.get_conf().charge ();

for (int ispec = parent_.get_spec().chloride_index (); ispec != parent_.get_spec().spec_size (); ++ispec)
{
    this->anin_[ispec - parent_.get_spec().chloride_index ()][constants::ibulk] << static_cast< double > (parent_.get_conf().ni (ispec));
}

!!!1827247.cpp!!!	hist() : void
const int ifree (parent_.get_spec().spec_size () - parent_.get_spec().nstr); // number of free ions

// -----------------------------------------------------------------
// Create a scope object for counting observables and add
// observables to the object
ionch::count_scope cscope_;

for (int ispec = 0; ispec != ifree; ++ispec)
{
    cscope_ << this->abulk_[ispec]; //bulk sub-zone sampling
}

for (int ispec = 0; ispec != parent_.get_spec().spec_size (); ++ispec)
{
    cscope_ << this->gz_[ispec];
}

if (calrdf)
{
    for (int ispec = 0; ispec != parent_.get_spec().spec_size (); ++ispec)
    {
        for (int jspec = 0; jspec != parent_.get_spec().spec_size (); ++jspec)
        {
            cscope_ << this->rdf_chan_[ispec][jspec];
            cscope_ << this->rdf_zlim_[ispec][jspec];
        }
    }
}

if (calgin)
{
    cscope_ << this->chgdist_;

    for (int ispec = 0; ispec != parent_.get_spec().spec_size (); ++ispec)
    {
        cscope_ << this->gin_[ispec];
    }
}

// -----------------------------------------------------------------
// START OF SAMPLING
//
// Rather than loop over each specie then particle, here we loop over
// the particles and select the specie
for (int ii = 0; ii != parent_.get_conf().active_size (); ++ii)
{
    const int ispec = parent_.get_conf().ispcbk (ii);

    if (ispec == constants::invspc) { continue; }

    const double rzi = parent_.get_conf().rz (ii);

    const double r2i = parent_.get_conf().r2 (ii);

    // collect bulk sampling region occupancy information
    if (parent_.get_spec().isfree (ispec) and parent_.get_geom().is_bulk_sample (rzi, r2i))
    {
        ++this->abulk_ [ispec - parent_.get_spec().chloride_index ()];
    }

    // Collect z-axial distribution
    this->gz_ [ispec].increment (parent_.get_geom().gz_bin (rzi));

    // Collect statistics about the mobile ions
    if (this->calmob and parent_.get_spec().mobile (ispec))
    {
        // Mobile ion statistics
        const double dx = parent_.get_conf().rx (ii) - parent_.get_conf().rsx (ii);
        const double dy = parent_.get_conf().ry (ii) - parent_.get_conf().rsy (ii);
        const double dz = rzi - parent_.get_conf().rsz (ii);
        const double rsq = constants::sqr (dx) + constants::sqr (dy) + constants::sqr (dz);
        this->amobdl_ [ispec] << std::sqrt (rsq);
        this->amobdx_ [ispec] << dx;
        this->amobdy_ [ispec] << dy;
        this->amobdz_ [ispec] << dz;
    }

    // Collect z-azial & r-radial distrbution
    if (this->calgin)
    {
        if (this->zinlft_ <= rzi and rzi <= -this->zinlft_ and r2i <= this->rinup_)
        {
            // matrix indices (z,r)
            std::size_t _tmp_[] = { int (std::floor ((rzi - this->zinlft_) / this->drg_)), int (std::floor (r2i / this->drg_)) };
            const std::vector< size_t > idx_(&_tmp_[0], &_tmp_[0] + 2);
            this->chgdist_.increment (idx_, int64_t (std::tr1::nearbyint (2 * parent_.get_spec().xz (ispec))));
            this->gin_[ispec].increment (idx_);
        }
    }

    // inter-particle radial distribution in region ifilt and izlim
    if (this->calrdf)
    {
        int ireg;
        parent_.get_geom().inregn (rzi, ispec, ireg);

        if (ireg <= constants::ichan)
        {
            boost::multi_array< ionch::count_histogram< double >, 2 > &rdf_ (ireg == constants::izlim ? this->rdf_zlim_ : this->rdf_chan_);
            const double rxi (parent_.get_conf().rx (ii));
            const double ryi (parent_.get_conf().ry (ii));

            for (int jj = 0; jj != parent_.get_conf().active_size (); ++jj)
            {
                if (jj != ii)
                {
                    const int jspec = parent_.get_conf().ispcbk (jj);

                    if (jspec == constants::invspc) { continue; }

                    const double rijsq (constants::sqr (rxi - parent_.get_conf().rx (jj))
                                        + constants::sqr (ryi - parent_.get_conf().ry (jj))
                                        + constants::sqr (rzi - parent_.get_conf().rz (jj)));

                    // RDF only consider particles with closest surface-surface distance
                    // of 10A.  We translate this here to minimum centre-centre sq test
                    // of (10 + 4)^2 rounded up to 200 before we do the sqrt.
                    if (rijsq <= 200.0)
                    {
                        // need sqrt now
                        const int r_bin_ (std::floor ( (std::sqrt (rijsq) - parent_.get_spec().dd_get (ispec, jspec)) / drdf_));
                        IONCH_CHECK (0 <= r_bin_, "'RDF' index is negative: particles are too close");

                        if (r_bin_ < nrdf_)
                        {
                            rdf_ [ispec][jspec].increment (r_bin_);
                        }
                    }
                }
            }
        }
    }
}

!!!1827375.cpp!!!	input_help(inout a_os : ostream, in msg : string) : void
  a_os << "Bad statistic (" << constants::fsaccu << ") section in input:\n";
  a_os << msg << "\n";
  a_os << "Required tags are:\n";
  a_os << constants::fsdrg << " " << constants::fsdzg << " " << constants::fsisav << "\n";
  a_os << "These optional tags control what results are obtained (default to false):\n";
  a_os << constants::fscgin << " " << constants::fscrdf << " " << constants::fsclac << " " << constants::fsclmb << " " << constants::fswidm << "\n";
  a_os << "If " << constants::fswidm << " is true then " << constants::fsiwid << " indicates the minimum number of\n";
  a_os << "test particle insertions to be used.\n";
  

!!!1827503.cpp!!!	iterat(in isbulk : bool, in cpmeth : int) : void
if (0 != cpmeth) { return; }

// Constant for non-zero charge.
const static double csloth (2 * (6 * std::log (2 + std::sqrt (3.0)) - constants::pi));
const static double chcons = csloth * constants::sqr (this->run_.qstar() / patch::epsw()) / (8 * parent_.get_geom().lenblk());

// current particle count in "bulk" sampling subregion of channel sim
// or all particles in 'bulk' simulation
std::vector< int > ncurr (parent_.get_spec().spec_size ());

// The changed chemical potentials
std::vector< double > new_chemical_potentials (parent_.get_spec().spec_size ());
std::fill (new_chemical_potentials.begin(), new_chemical_potentials.end (), 0.0);

// Volume to use in calculations
const double volume (isbulk ? parent_.get_geom().volblk() : parent_.get_geom().bulk_sample_volume());

// Current per-specie concentration in bulk
std::vector< double > cbulk (parent_.get_spec().spec_size ());

// malas2: Result vector and Success/failure of dgesv routine
std::vector< double > rhs (parent_.get_spec().spec_size ());

constants::os_log << constants::horizontal_bar << "\n";
constants::os_log << " Chem. Pot. estimation iteration [over " << acharge_.size() << " trials]\n";
constants::os_log << constants::horizontal_bar << "\n";

const double avchg = this->acharge_.mean ();
constants::os_log << "Average system charge: " << avchg << "\n";

if (isbulk)
{
    for (int ispec = parent_.get_spec().chloride_index (); ispec != parent_.get_spec().spec_size (); ++ispec)
    {
        // In periodic boundary bulk simulation the number of particles
        // is the total number for a specie (saved in anin[ibulk])
        cbulk [ispec] = (this->anin_ [ispec - parent_.get_spec().chloride_index ()][constants::ibulk].mean () * constants::to_SI ()) / volume;
        ncurr [ispec] = parent_.get_conf().ni (ispec);
    }
}
else
{
    for (int ispec = parent_.get_spec().chloride_index (); ispec != parent_.get_spec().spec_size (); ++ispec)
    {
        // In cylindrical cell simulation the bulk concentration comes from
        // the 'bulk' sampling region.
        cbulk [ispec] = (this->abulk_ [ispec - parent_.get_spec().chloride_index ()].mean () * constants::to_SI ()) / volume;
    }

    // Current count ing the bulk sampling region must be calculated
    // on the fly.
    std::fill (ncurr.begin(), ncurr.end (), 0);


    for (int ii = 0; ii != parent_.get_conf().active_size (); ++ii)
    {
        const int ispec = parent_.get_conf().ispcbk (ii);

        if (ispec == constants::invspc or not parent_.get_spec().isfree (ispec)) { continue; }

        if (parent_.get_geom().is_bulk_sample (parent_.get_conf().rz (ii), parent_.get_conf().r2 (ii)))
        {
            ++ncurr [ispec];
        }
    }
}

// For malas2 solve the fluctuation equations.
if (cpmeth == malas2)
{
    const int dimA (parent_.get_spec().spec_size () - parent_.get_spec().chloride_index ());
    double fluctn [dimA][dimA];
    double navrg [dimA];

    for (int ispec = parent_.get_spec().chloride_index (); ispec != parent_.get_spec().spec_size (); ++ispec)
    {
        rhs [ispec - parent_.get_spec().chloride_index ()] = parent_.get_spec().ctargi (ispec) - cbulk [ispec];
        navrg [ispec - parent_.get_spec().chloride_index ()] = this->anin_ [ispec - parent_.get_spec().chloride_index ()][constants::ibulk].mean ();
    }

    for (int ispec = parent_.get_spec().chloride_index (); ispec != parent_.get_spec().spec_size (); ++ispec)
    {
        for (int jspec = parent_.get_spec().chloride_index (); jspec != parent_.get_spec().spec_size (); ++jspec)
        {
            fluctn [jspec - parent_.get_spec().chloride_index ()][ispec - parent_.get_spec().chloride_index ()] = (navrg [ispec - parent_.get_spec().chloride_index ()] + navrg [jspec - parent_.get_spec().chloride_index ()] - (navrg[ispec - parent_.get_spec().chloride_index ()] * navrg[jspec - parent_.get_spec().chloride_index ()]))
                    / (this->run_.beta() * volume);
        }
    }

    int info = 0;
    int nrhs = 1;
    int lda  = dimA;
    int ldb  = 1;
    int ipiv [dimA]; // solver data
    ionch::dgesv (dimA, nrhs, &fluctn[0][0], lda, &ipiv[0], &rhs[0], ldb, &info);
    IONCH_ALWAYS (0 == info, "Matrix inversion in malasic's method 2 chemical potential iteration failed");
}

// ------------------------------------------------------------
// INDIVIDUAL CHEMICAL POTENTIALS
for (int ispec = parent_.get_spec().chloride_index (); ispec != parent_.get_spec().spec_size (); ++ispec)
{
    // mu_i(n) = kT.log(rho^targ_i)+mu_ex(n)
    //
    // mu^ex_i(n) = mubar^ex_i(n-1)
    // mubar^ex_i(n-1)=mu_i(n) - kT log(rhobar_i(n))
    //
    // chempi(n)*beta()={dlog(ctargi(ispec)) - dlog(tosi) + chexi(ispec)*beta() - dlog(cbulk(ispec)) + dlog(tosi)}
    // chempi(n)       ={dlog(ctargi(ispec)/cbulk(ispec))/beta() + chempi(ispec)}

    switch (cpmeth)
    {
    case malas1:
        // change in chemical potential is ratio of target and current densities
        // use average density when close to convergence
        // concentration in current system
        new_chemical_potentials[ispec] = parent_.get_spec().chempi (ispec) + std::log (parent_.get_spec().ctargi (ispec) / cbulk [ispec]);
        break;
    case malas2:
        // Only update if info was zero
        new_chemical_potentials[ispec] = parent_.get_spec().chempi (ispec) - (rhs [ispec] + parent_.get_spec().xz (ispec) * avchg * chcons);
        break;
    case acept1:
        // Approximate density ratio with energy difference
        // Approximating with bfdr-bfcr/(bfdr+bfcr)
        new_chemical_potentials[ispec] = parent_.get_spec().chempi (ispec) + trial::avgget (ispec);
        break;
    case acept2:
        // Approximate density ratio with trial
        // ratios log(try(+)/try(-))
        new_chemical_potentials[ispec] = parent_.get_spec().chempi (ispec) + trial::accget (ispec);
        break;
    default:
        IONCH_CHECK (0 <= cpmeth and cpmeth <= acept2, "Unknown chemical potential update method");
        break;
    }

    {
        // non-zero charge correction
        new_chemical_potentials[ispec] -= (parent_.get_spec().xz (ispec) * avchg * chcons);
    }

    trial::avergi (ispec);
}

// parent_.get_spec().setchp (&new_chemical_potentials[0]);

// -----------------------------------------------------------------
// Print simulation statistics
trial::accrat (constants::os_log);

// Reset statistic counters in trial and acharge
this->acharge_.reset ();
trial::zeroav();

!!!1827631.cpp!!!	read_input_section(inout fid : istream, in sname : string, in svalue : string) : void
IONCH_REQUIRE (constants::fsaccu == sname, "Error: incorrect section name");
IONCH_INPUT (svalue.empty (), "Error: section does not any parameters");

std::bitset< 2 > missing_options;
missing_options.set ();

//
// INPUT SECTION
//
// accum
// dzgtrg REAL
// drg REAL
// calgin (true|false)
// calacc (true|false)
// calrdf (true|false)
// calmob (true|false)
// calwid (true|false)
// iwidom INT
// isave INT
// end

// 'accum' section has calwid and iwidom entries
// that set values in 'trial' module.
bool widom_on_ (false); // -> trial::calwid
int  widom_try_;        // -> trial::nwdtry

do
{
    std::string name_;
    std::string val_ = " ";
    constants::readnv (fid, name_, val_);

    // exit loop on section 'end'
    if (name_ == constants::fsend) { break; }

    // looking for calgin, calrdf, etc
    if (name_ == constants::fscgin)
    {
        constants::read_bool (val_, this->calgin);
    }
    else if (name_ == constants::fscrdf)
    {
        constants::read_bool (val_, this->calrdf);
    }
    else if (name_ == constants::fsclac)
    {
        constants::read_bool (val_, this->calacc);
    }
    else if (name_ == constants::fsclmb)
    {
        constants::read_bool (val_, this->calmob);
    }
    else if (name_ == constants::fswidm)
    {
        constants::read_bool (val_, widom_on_);
    }
    else if (name_ == constants::fsiwid)
    {
        widom_try_ = boost::lexical_cast< int > (val_);
    }
    else if (name_ == constants::fsgzoc)
    {
        this->zocc_ = boost::lexical_cast< double > (val_);
    }
    else if (name_ == constants::fsdrg)
    {
        this->drg_ = boost::lexical_cast< double > (val_);
        missing_options.flip (0);
    }
    else if (name_ == constants::fsisav)
    {
        this->isave_ = boost::lexical_cast< int > (val_);
        missing_options.flip (1);
    }
    else
    {
        static const std::string known_input_options;
        IONCH_INPUT (known_input_options == name_, "Name " + name_ + " is not valid in statistic (accum) section");
    }
}
while (fid);

IONCH_INPUT (not missing_options.any(), "Not all required tags were present.");

IONCH_INPUT (not this->calgin or not constants::feq (this->drg_, 0.0)
             , "When collecting 2D statistics " + constants::fsdrg + " option may not be zero.");

trial::set_widom (widom_on_, std::max (0, widom_try_));

!!!1827759.cpp!!!	read_finalise() : void
constants::os_log << constants::horizontal_bar << "\n";
constants::os_log << "Statistical data accumulation parameters\n";
constants::os_log << constants::horizontal_bar << "\n";

// --------------------------------------------------
// Allocate arrays to fit number of species
anaca_.resize (boost::extents[parent_.get_spec().spec_size ()][constants::nrgnmx]);
amobdl_.resize (parent_.get_spec().spec_size ());
amobdx_.resize (parent_.get_spec().spec_size ());
amobdy_.resize (parent_.get_spec().spec_size ());
amobdz_.resize (parent_.get_spec().spec_size ());
anin_.resize (boost::extents[parent_.get_spec().spec_size ()][constants::nrgnmx]);
abulk_.resize (parent_.get_spec().spec_size ());


// --------------------------------------------------
// initialise gin 2D distribution
if (calgin)
{
    // Set radial parameters
    this->nrgr_   = int (std::floor ((parent_.get_geom().rl (4) + 10.0) / this->drg_));
    this->rinup_  = this->nrgr_ * this->drg_;

    // Set z-axial parameters
    this->nrgz_   = int (std::floor ((parent_.get_geom().zl (2) + 10.0) / this->drg_));
    this->zinlft_ = -this->nrgz_ * this->drg_;
    this->nrgz_   *= 2;

    // Set volume factor (vol = factor * (2*r_indx + 1))
    this->vjin_factor_ = this->drg_ * this->drg_ * this->drg_ * constants::pi;

    constants::os_log << "Parameters for 2D histogram of Z-axis and Radius\n";
    constants::os_log << " Histogram bins in radial dimension = " << std::setw (8) << this->nrgr_ << " width = " << this->drg_ << "\n";
    constants::os_log << " Histogram bins in z-axial dimension= " << std::setw (8) << this->nrgz_ << " width = " << this->drg_  << "\n";

    if (this->nrgr_ > nrgmx or this->nrgz_ > nrgmx)
    {
        constants::os_log << "\n\nWARNING\n\nThe number of requested bins exceeds suggested limit\n request = "
                          << this->nrgz_ <<  " and " << this->nrgr_ <<  "; suggested limit = "
                          << nrgmx <<  "\nSUGGESTION: increase '"
                          << constants::fsdrg <<  "' option in input file\n\n";
    }
    constants::os_log << constants::horizontal_bar << "\n";

    this->gin_.resize (parent_.get_spec().spec_size (), ionch::count_matrix< double, 2 > (boost::extents[this->nrgz_][constants::next64 (this->nrgr_)]));
    this->chgdist_.resize (boost::extents[this->nrgz_][constants::next64 (this->nrgr_)]);
}

// ------------------------------------------------------------
// Initialise geometry and variables for the radial distribution
if (calrdf)
{
    this->drdf_ = this->drg_;
    this->nrdf_ = int (std::floor (10.0 / this->drdf_));
    this->rdf_zlim_.resize (boost::extents[parent_.get_spec().spec_size ()][parent_.get_spec().spec_size ()]);
    this->rdf_chan_.resize (boost::extents[parent_.get_spec().spec_size ()][parent_.get_spec().spec_size ()]);

    for (std::size_t idx = 0; idx != rdf_zlim_.size(); ++idx)
    {
        this->rdf_zlim_.data() [idx].resize (nrdf_);
        this->rdf_chan_.data() [idx].resize (nrdf_);
    }
}

// --------------------------------------------------
// Initialise array parameters now we know sizes
this->gz_.resize (parent_.get_spec().spec_size (), ionch::count_histogram< double > (constants::next64 (parent_.get_geom().gz_max ())));

this->ah_.resize (patch::npatch ());

// Set zocc if not already set
if (constants::feq (0.0, zocc_))
{
    this->zocc_ = parent_.get_geom().zlimit ();
}
else
{
    IONCH_INPUT (this->zocc_ <= parent_.get_geom().zl (1)
                 , "Limit of occupancy region 1 is outside central cylinder (zocc > zl1)");
}

constants::os_log << constants::horizontal_bar << "\n";
constants::os_log << "Interpreted statistic/accumulation parameters from input (includes defaults)\n";
constants::os_log << constants::horizontal_bar << "\n";
this->write_input_section (constants::os_log);
constants::os_log << constants::horizontal_bar << "\n";

!!!1827887.cpp!!!	reset() : void
for (int ispec = 0; ispec != parent_.get_spec().spec_size (); ++ispec)
{
    this->amobdl_[ispec].reset ();
    this->amobdx_[ispec].reset ();
    this->amobdy_[ispec].reset ();
    this->amobdz_[ispec].reset ();

    this->abulk_[ispec].reset ();
    this->gin_[ispec].reset ();
    this->chgdist_.reset ();
    this->gz_[ispec].reset ();

    for (int ireg = constants::izlim; ireg <= constants::ibulk; ++ireg)
    {
        size_t tmp[] = { ispec, ireg };
        const std::vector< size_t > idx_ (&tmp[0], &tmp[0] + 2);
        this->anin_ (idx_).reset ();
    }

    for (int jspec = constants::izlim; jspec <= constants::ibulk; ++jspec)
    {
        size_t tmp[] = { ispec, jspec };
        const std::vector< size_t > idx_ (&tmp[0], &tmp[0] + 2);
        this->rdf_zlim_ (idx_).reset ();
        this->rdf_chan_ (idx_).reset ();
    }
}
IONCH_CHECK(std::distance(&this->aocc_[0][0][0][0][0],&this->aocc_[4][0][0][0][0])*sizeof(uint8_t)
	 == 3*std::pow(double(noccmx+1),4)
	, "Fill exceeds array size");
std::fill (&this->aocc_[0][0][0][0][0], &this->aocc_[4][0][0][0][0], 0);

this->acharge_.reset ();
this->ah_.reset ();

!!!1828143.cpp!!!	saves(in istep : int) : void
// LOCALS
double conductances[constants::nspcmx][constants::nrgnmx];

IONCH_CHECK (0 != this->acharge_.size (), "Attempt to save results before accumulating any");

constants::os_log << "\n\n\nBEGIN SAVES FOR STEP " << istep << "\n";
++this->ksub_;

std::ofstream os_ooo;
{
    const std::string file_name ("res/o." + this->run_.firun ());
    os_ooo.open (file_name.c_str ());
}

os_ooo << " STEP    = " << istep << "\n";
os_ooo << " RUN     = " << this->run_.firun () << "\n";
os_ooo << " zl4 [A] = " << parent_.get_geom().zl (4) << "\n";
os_ooo << " rl5 [A] = " << parent_.get_geom().rl (5) << "\n";
os_ooo << " rl1 [A] = " << parent_.get_geom().rl (1) << "\n";
os_ooo << " epspr   = " << patch::epspr() << "\n";
os_ooo << " epsw    = " << patch::epsw() << "\n";
os_ooo << "\n";

for (int igc = 0; igc != parent_.get_spec().nsalt; ++igc)
{
    const boost::format fmt_ (" %1$4s: ctarg = %2$11.8g, chemp = %3$10.5g, excess = %4$10.6g");
    os_ooo << boost::format (fmt_) % parent_.get_spec().fsalt (igc) % parent_.get_spec().ctargs (igc) % parent_.get_spec().chemps (igc) % parent_.get_spec().chexs (igc) << "\n";
}

os_ooo << "\n";
{
    const boost::format fmt_ ("%1$4s  %2$7d  %3$6.2g  %4$8.4g");

    os_ooo << boost::format (fmt_) % "ION" % "N" % "q [e]" % "d [A]" << "\n";

    for (int ispec = 0; ispec != parent_.get_spec().spec_size (); ++ispec)
    {
        os_ooo << boost::format (fmt_) % parent_.get_spec().fspc (ispec) % parent_.get_conf().ni (ispec) % parent_.get_spec().xz (ispec) % (parent_.get_spec().xri (ispec) * 2) << "\n";
    }
}

// ----- Calculate and write out concentration profiles -------
if (calgin)
  {
    for (int ispec = 0; ispec != parent_.get_spec().spec_size (); ++ispec)
      {
        if (DEBUG) { constants::os_log << "#DEBUG gin profile for " << parent_.get_spec().fspc (ispec) << "\n"; }

        const std::string file_name ("res/gin-" + parent_.get_spec().fspc (ispec) + "." + this->run_.firun ());

        std::ofstream os (file_name.c_str());

        const std::size_t k_end (this->nrgz_);

        const std::size_t idx_end (this->nrgr_);

        for (std::size_t k_ = 0; k_ != k_end; ++k_)
          {
            // histogram z coord
            const double zri = this->zinlft_ + (k_ * this->drg_) + (this->drg_ / 2);

            size_t tmp[] = { k_, 0 };
            for (std::vector< size_t > idx(&tmp[0], &tmp[0] + 2); idx[1] != idx_end; ++idx[1])
              {
                const double cin = constants::to_SI () * this->gin_[ispec].mean (idx) / (this->vjin (idx[1]));
                // histogram r coord
                const double rrj = (idx[1] * this->drg_) + (this->drg_ / 2);
                os << zri << "\t" << rrj << "\t" <<  cin << "\t" << this->vjin (idx[1]) << "\n";
              }

            os << "\n";
          }

        os.close();
      }

    // Output charge distribution
    {
      if (DEBUG) { constants::os_log << "#DEBUG gin profile for charges\n"; }

      const std::string file_name ("res/gin-charge." + this->run_.firun ());

      std::ofstream os (file_name.c_str());

      const std::size_t k_end (this->nrgz_);

      const std::size_t idx_end (this->nrgr_);

      for (size_t k_ = 0; k_ != k_end; ++k_)
        {
          // histogram z coord
          const double zri = this->zinlft_ + (k_ * this->drg_) + (this->drg_ / 2);

          size_t tmp[] = { k_, 0 };
          for (std::vector< size_t > idx(&tmp[0], &tmp[0] + 2); idx[1] != idx_end; ++idx[1])
            {
              const double cin = constants::to_SI () * this->chgdist_.mean (idx) / (this->vjin (idx[1]));
              // histogram r coord
              const double rrj = (idx[1] * this->drg_) + (this->drg_ / 2);
              os << zri << "\t" << rrj << "\t" <<  cin << "\t" << this->vjin (idx[1]) << "\n";
            }

          os << "\n";
        }

      os.close();
    }
  }

if (DEBUG) { constants::os_log << "#DEBUG gin profiles complete\n"; }

for (int ispec = 0; ispec != parent_.get_spec().spec_size (); ++ispec) // k8a2o9
{
    const double zocspc = zocc_ - parent_.get_spec().xri (ispec);
    const int strgn3 = parent_.get_geom().gz_bin (-parent_.get_geom().zreg (constants::ichan, ispec));
    const int strgn2 = parent_.get_geom().gz_bin (-parent_.get_geom().zreg (constants::ifilt, ispec));
    const int strgn1 = parent_.get_geom().gz_bin (-zocspc);
    const int enrgn1 = parent_.get_geom().gz_bin (zocspc);;
    const int enrgn2 = parent_.get_geom().gz_bin (parent_.get_geom().zreg (constants::ifilt, ispec));
    const int enrgn3 = parent_.get_geom().gz_bin (parent_.get_geom().zreg (constants::ichan, ispec));
    std::bitset< 3 > usecd;
    usecd.set ();
    conductances[ispec][constants::izlim] = 0.0; // Actually this is for zocc not zlim
    conductances[ispec][constants::ifilt] = 0.0;
    conductances[ispec][constants::ichan] = 0.0;

    {
        std::ofstream os;
        const std::string file_name ("res/gz-" + parent_.get_spec().fspc (ispec) + "." + this->run_.firun ());
        os.open (file_name.c_str ());

        for (int i_ = 0; i_ != parent_.get_geom().gz_max(); ++i_)
        {
            double concentration (0.0); // concentration
            const double average_particle_number (this->gz_[ispec].mean (i_));

            if (constants::feq (average_particle_number, 0.0))
            {
                if (i_ >= strgn3 and i_ < enrgn3)
                {
                    usecd.set (constants::ichan, false);

                    if (i_ >= strgn2 and i_ < enrgn2)
                    {
                        usecd.set (constants::ifilt, false);

                        if (i_ >= strgn1 and i_ < enrgn1)
                        {
                            usecd.set (constants::izlim, false);
                        }
                    }
                }
            }
            else
            {
                concentration = (constants::to_SI () * average_particle_number) / parent_.get_geom().gz_vol (ispec, i_);

                if (i_ >= strgn3 and i_ < enrgn3)
                {
                    conductances[ispec][constants::ichan] += 1.0 / average_particle_number;

                    if (i_ >= strgn2 and i_ < enrgn2)
                    {
                        conductances[ispec][constants::ifilt] += 1.0 / average_particle_number;

                        if (i_ >= strgn1 and i_ < enrgn1)
                        {
                            conductances[ispec][constants::izlim] += 1.0 / average_particle_number;
                        }
                    }
                }
            }

            os << parent_.get_geom().gz_mid (i_) << "  " << concentration << "  " << (average_particle_number * constants::to_SI ())
               << "  " << parent_.get_geom().gz_vol (ispec, i_) << "  " << parent_.get_geom().gzwdth() << "\n";
        } // t2q4q1
    }

    // finalise conductances for specie
    for (int ireg = constants::izlim; ireg <= constants::ichan; ++ireg)
    {
        conductances[ispec][ireg] = (usecd[ireg] ? 1.0 / conductances[ispec][ireg] : 0.0);
    }

}  // end ispec loop k8a2o9

if (DEBUG) { constants::os_log << "#DEBUG gz profiles complete\n"; }

// Calculate radial distribution of ions near channel
if (calrdf)
{
    const boost::format rdf_row ("%1$8.4g %2$8.4g %3$8.4g %4$16.10g %5$16.10g");
    const std::size_t spec_end (parent_.get_spec().spec_size ());
    for (size_t ispec = 0; ispec != spec_end; ++ispec)
    {
        for (size_t jspec = 0; jspec != spec_end; ++jspec)
        {
            size_t tmp[] = { ispec, jspec };
            const std::vector< size_t > idx (&tmp[0], &tmp[0] + 2);
            // inter-particle distances
            const double ddi = parent_.get_spec().dd_get (ispec, jspec);

            const std::string file_name ("res/rdf-" + parent_.get_spec().fspc (ispec) + "-" + parent_.get_spec().fspc (jspec) + "." + this->run_.firun ());
            std::ofstream os (file_name.c_str ());
            const int j_end (this->nrdf_);

            for (int j_ = 0; j_ != j_end; ++j_)
            {
                // histogram bin data
                const double rlow = ddi + j_ * this->drdf_;
                const double rhigh = rlow + this->drdf_;
                const double ri   = rlow + this->drdf_ / 2;
                const double vshell = 4 * constants::pi * (rhigh * rhigh * rhigh - rlow * rlow * rlow) / 3.0;

                // radial dist. counts
                const double rdfi1 = this->rdf_zlim_ (idx).mean (j_);
                const double rdfi2 = this->rdf_chan_ (idx).mean (j_);

                // dist. density
                const double rdf1vs = rdfi1 / vshell;
                const double rdf2vs = rdfi2 / vshell;

                os << boost::format (rdf_row) % ri % rdfi1 % rdfi2 % rdf1vs % rdf2vs << "\n";
            }
        }
    }
}

if (DEBUG) { constants::os_log << "#DEBUG rdf profiles complete\n"; }

// ----- Output conductances -------------------------------

for (int ispec = parent_.get_spec().chloride_index (); ispec != parent_.get_spec().spec_size (); ++ispec)
{
    for (int ireg = constants::izlim; ireg <= constants::ifilt; ++ireg)
    {
        const std::string file_name ("res/g" + parent_.get_geom().freg (ireg) + "-" + parent_.get_spec().fspc (ispec) + "." + this->run_.firun ());
        std::ofstream os (file_name.c_str (), (this->ksub_ == 1 ? std::ifstream::trunc : std::ifstream::ate));
        os << this->ksub_ << " " << conductances[ispec][ireg] << "\n";
    }
}

// ----- Write out particle counts and chem. pot. comparison
this->particle_count_distribution ();
{
    std::stringstream os;
    this->particle_counts (os);
    this->chemical_potentials (os);
    const std::string report (os.str ());
    constants::os_log << report;
    constants::os_log << constants::horizontal_bar << "\n";
    os_ooo << report;
}

// Calculate chem. pot. if calwid
if (trial::calwid ())
{
    trial::trywd (this->ksub_);
    trial::savewd ();
}

// ----- Acceptance ratios --------------------------------
for (int ispec = parent_.get_spec().chloride_index (); ispec != parent_.get_spec().spec_size (); ++ ispec)
{
    trial::avergi (ispec);
}

trial::zeroav ();

if (calacc)
{
    trial::accrat (constants::os_log);
    trial::accrat (os_ooo);
}

// ----- Co-occupancies
{
    const std::string file_name ("res/occ." + this->run_.firun ());
    std::ofstream os (file_name.c_str());

    for (int ireg = constants::izlim; ireg <= constants::ichan; ++ireg)
    {
        int k_end = 1;
        int l_end = 1;

        switch (parent_.get_spec().spec_size () - parent_.get_spec().nstr)
        {
        default:
        case 4:
            l_end = noccmx + 1;
        case 3:
            k_end = noccmx + 1;
        case 2:
        case 1:

            for (int g_ = 0; g_ != noccmx + 1; ++g_)
                for (int h_ = 0; h_ != noccmx + 1; ++h_)
                    for (int k_ = 0; k_ != k_end; ++k_)
                        for (int l_ = 0; l_ != l_end; ++l_)
                        {
                            os << g_ << " " << h_ << " " << k_ << " " << l_ << " " << this->aocc_[ireg][g_][h_][k_][l_] / acharge_.size () << "\n";
                        }

            break;
        }

        os << "\n";
    }

    os << constants::horizontal_bar << "\n";

    for (int ireg = constants::izlim; ireg <= constants::ichan; ++ireg)
    {
        // chloride co-occupancy sum
        int k_end = 1;
        int l_end = 1;

        switch (parent_.get_spec().spec_size () - parent_.get_spec().nstr)
        {
        default:
        case 4:
            l_end = noccmx + 1;
        case 3:
            k_end = noccmx + 1;
        case 2:
        case 1:
        {
            double azcl = 0;

            for (int h_ = 0; h_ != noccmx + 1; ++h_)
                for (int k_ = 0; k_ != k_end; ++k_)
                    for (int l_ = 0; l_ != l_end; ++l_)
                    {
                        for (int g_ = 0; g_ != noccmx + 1; ++g_)
                        {
                            azcl += this->aocc_[ireg][g_][h_][k_][l_];
                        }

                        os << h_ << " " << k_ << " " << l_ << " " << azcl / this->acharge_.size () << "\n";
                    }
        }
        break;
        }

        os << "\n";
    }
}

// 'h' vector
{
    const std::string file_name ("res/h." + this->run_.firun ());
    std::ofstream os (file_name.c_str());

    for (int ipch = 0; ipch != patch::npatch (); ++ipch)
    {
        os << ipch << " " << this->ah_.mean (ipch) << "\n";
    }
}

// write out statistics about the movement of 'mobile' structural ions
if (parent_.get_spec().nmob != 0) { amobsv (); }

// write out details of volumes occupied by the ions
if (parent_.get_spec().nstr != 0 and parent_.get_spec().nfix != parent_.get_spec().nstr) { parent_.get_conf().volslb (constants::os_log, 10, istep); }

!!!1828399.cpp!!!	write_input_section(inout a_os : ostream) : void
a_os << constants::fsaccu << "\n";
a_os << constants::fscgin << " " << constants::str (this->calgin) << "\n";
a_os << constants::fscrdf << " " << constants::str (this->calrdf) << "\n";
a_os << constants::fsclac << " " << constants::str (this->calacc) << "\n";
a_os << constants::fsclmb << " " << constants::str (this->calmob) << "\n";
a_os << constants::fswidm << " " << constants::str (trial::calwid ()) << "\n";
a_os << constants::fsiwid << " " << trial::widom_trials() << "\n";
a_os << constants::fsdrg  << " " << this->drg_ << "\n";
a_os << constants::fsgzoc << " " << this->zocc_ << "\n";
a_os << constants::fsisav << " " << this->isave_ << "\n";
a_os << constants::fsend << "\n\n";

!!!1828527.cpp!!!	amobsv() : void
const boost::format fmt_ (" %1$5s %2$8.2g %2$8.2g %2$8.2g %2$8.2g %2$8.2g");
constants::os_log << "Statistics for mobile ions\n";
constants::os_log << boost::format (fmt_) % "SPC" % "AVRG" % "VAR" % "DX" % "DY" % "DZ" << "\n";

for (int ispec = 0; ispec != parent_.get_spec().spec_size (); ++ispec)
{
    if (parent_.get_spec().mobile (ispec))
    {
        constants::os_log << boost::format (fmt_) % parent_.get_spec().fspc (ispec)
                          % this->amobdl_[ispec].mean () % this->amobdl_[ispec].variance ()
                          % this->amobdx_[ispec].mean () % this->amobdy_[ispec].mean ()
                          % this->amobdz_[ispec].mean () << "\n";
    }
}

!!!1828655.cpp!!!	chemical_potentials(inout strbuf : ostream) : void
// Current per-specie concentration in bulk ?
std::vector< double > cbulk (parent_.get_spec().spec_size () - parent_.get_spec().chloride_index ());
strbuf << "Chemical potential comparison\n";
const boost::format fmt_ ("  %1$6s:  %2$10.6g %3$10.6g %4$10.6g %5$10.6g");
strbuf << boost::format (fmt_) % "SPECIE" % "mu TARGET" % "mu CURRNT" % "excess TRG" % "excess CUR" << "\n";

for (int ispec = parent_.get_spec().chloride_index (); ispec != parent_.get_spec().spec_size (); ++ispec)
{
    // bulk here is from the 'bulk' sampling sub-zone
    const int ispec_adj (ispec - parent_.get_spec().chloride_index ());
    cbulk[ispec_adj] = (this->abulk_[ispec_adj].mean () * constants::to_SI () / parent_.get_geom().bulk_sample_volume ());

    if (constants::feq (0.0, cbulk[ispec_adj]))
    {
        // Skip on zero concentration
        strbuf << boost::format (fmt_) % parent_.get_spec().fspc (ispec) % parent_.get_spec().chempi (ispec) % "-----" % parent_.get_spec().chexi (ispec) % "-----" << "\n";
    }
    else
    {
        const double chexnw = parent_.get_spec().chempi (ispec) - std::log (cbulk[ispec_adj] / constants::to_SI ());
        const double chmpnw = std::log (parent_.get_spec().ctargi (ispec) / constants::to_SI ()) - chexnw;
        strbuf << boost::format (fmt_) % parent_.get_spec().fspc (ispec) % parent_.get_spec().chempi (ispec) % chmpnw % parent_.get_spec().chexi (ispec) % chexnw << "\n";
    }
}

for (int igc = 0; igc != parent_.get_spec().nsalt; ++igc)
{
    const int ispec = parent_.get_spec().isalt (igc);
    const int ispec_adj (ispec - parent_.get_spec().chloride_index ());
 
    if (constants::feq (cbulk[ispec_adj], 0.0))
    {
        // Skip on zero concentration
        strbuf << boost::format (fmt_) % parent_.get_spec().fsalt (igc) % parent_.get_spec().chemps (igc) % "-----" % parent_.get_spec().chexs (igc) % "-----" << "\n";
    }
    else
    {
        const double rtargi = (parent_.get_spec().ctargs (igc) / constants::to_SI ()) * std::pow (parent_.get_spec().ctargi (parent_.get_spec().chloride_index ()) / constants::to_SI (), std::tr1::nearbyint (parent_.get_spec().xz (ispec)));
        const double rbulki = cbulk[ispec_adj] / constants::to_SI ();
        const double rblkcl = cbulk[0] / constants::to_SI ();
        const double chexnw = parent_.get_spec().chemps (igc) - std::log (rbulki * std::pow (rblkcl, std::tr1::nearbyint (parent_.get_spec().xz (ispec))));
        const double chempn = std::log (rtargi) + chexnw;
        strbuf << boost::format (fmt_) % parent_.get_spec().fsalt (igc) % parent_.get_spec().chemps (igc) % chempn % parent_.get_spec().chexs (igc) % chexnw << "\n";
    }
}

!!!1828783.cpp!!!	particle_counts(inout strbuf : ostream) : void
std::vector< double > region_charge_ (constants::nrgnmx);

const boost::format fmt_ (" %1$8s | %2$10.5g | %3$10.5g | %4$10.5g | %5$10.5g | %6$8.3g (%7$4d)");
strbuf << "Particle region_count_ by region\n";
strbuf << boost::format (fmt_) % "SPECIE" % "BULK SMPL" % "CHANNEL" % "FILTER" % "CENTER" % "TOTAL" % "CURR" << "\n";

// ----- number of ions -------------------------
for (int ispec = 0; ispec != parent_.get_spec().chloride_index (); ++ispec)
{
    if (parent_.get_spec().fixed (ispec)) { continue; }

    boost::format region_count_ (fmt_);
    region_count_ % parent_.get_spec().fspc (ispec) % "";

    // non free ions always have constant ni
    for (int ireg = constants::izlim; ireg <= constants::ibulk; ++ireg)
    {
        region_count_ % parent_.get_conf().ni (ispec);
        region_charge_[ireg] += parent_.get_conf().ni (ispec) * parent_.get_spec().xz (ispec);
    }

    // Output concentration profiles
    strbuf << region_count_ % parent_.get_conf().ni (ispec) << "\n";
}

for (int ispec = parent_.get_spec().chloride_index (); ispec != parent_.get_spec().spec_size (); ++ispec)
{
    const int ispec_adj (ispec - parent_.get_spec().chloride_index ());
    boost::format region_count_ (fmt_);
    region_count_ % parent_.get_spec().fspc (ispec);
    region_count_ % this->abulk_[ispec_adj].mean ();
    region_count_ % this->anin_[ispec_adj][constants::ichan].mean ();
    region_count_ % this->anin_[ispec_adj][constants::ifilt].mean ();
    region_count_ % this->anin_[ispec_adj][constants::izlim].mean ();
    region_count_ % this->anin_[ispec_adj][constants::ibulk].mean ();
    strbuf << region_count_ % parent_.get_conf().ni (ispec) << "\n";

    for (int ireg = constants::izlim; ireg <= constants::ibulk; ++ireg)
    {
        region_charge_[ireg] += this->anin_[ispec_adj][ireg].mean () * parent_.get_spec().xz (ispec);
    }
}

strbuf << constants::horizontal_bar << "\n";
strbuf << boost::format ("  Charge: |  %1$10.5g | %2$10.5g | %3$10.5g | %4$10.5 |")
       % region_charge_[constants::ibulk] % region_charge_[constants::ichan] % region_charge_[constants::ifilt] % region_charge_[constants::izlim] << "\n";
strbuf << constants::horizontal_bar << "\n";

!!!1828911.cpp!!!	particle_count_distribution() : void
for (int ispec = parent_.get_spec().chloride_index (); ispec != parent_.get_spec().spec_size (); ++ispec)
{
    const int ispec_adj (ispec - parent_.get_spec().chloride_index ());
    const double count[] =
    {
        this->anin_[ispec_adj][constants::izlim].mean ()
        , this->anin_[ispec_adj][constants::ifilt].mean ()
        , this->anin_[ispec_adj][constants::ichan].mean ()
        , this->abulk_[ispec_adj].mean()
    };

    for (int ireg = 0; ireg != constants::nrgnmx; ++ireg)
    {
        const std::string filename_ ("res/a" + parent_.get_geom().freg (ireg) + "-" + parent_.get_spec().fspc (ispec) + "." + constants::firun ());
        std::ofstream os_arg;
        double asuba;

        if (ksub_ == 0)
        {
            os_arg.open (filename_.c_str (), std::ifstream::trunc);
            asuba = this->anaca_[ispec_adj][ireg] = count[ireg];
        }
        else
        {
            os_arg.open (filename_.c_str (), std::ifstream::ate);
	    // a = (K+1) b - K c = K (b - c) + b;
            asuba = this->ksub_ * (count[ireg] - this->anaca_[ispec_adj][ireg]) + count[ireg];
            this->anaca_[ispec_adj][ireg] = count[ireg];
        }

        // Output particle count profiles for solute ions
        os_arg << this->ksub_ << " " << this->anaca_[ispec][ireg] << " " << asuba << "\n";
        os_arg.close ();
    }
}

