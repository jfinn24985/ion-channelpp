class sampler_meta
!!!833584.cpp!!!	add_sampler_type(inout defn : sampler_definition) : void
UTILITY_REQUIRE( this->has_type( defn->label() ), ("Attempt to add more than one chooser factory for type \""+defn->label()+"\".") );
this->type_to_sample_.push_back( defn.release() );
!!!1326000.cpp!!!	add_tracked_type(inout defn : tracked_definition) : void
UTILITY_REQUIRE( this->has_type( defn->label() ), ("Attempt to add more than one chooser factory for type \""+defn->label()+"\".") );
this->type_to_tracked_.push_back( defn.release() );
!!!833456.cpp!!!	has_type(in label : string) : bool
for( auto const& defn : this->type_to_sample_ )
{
  if( defn.label() == label )
  {
    return true;
  }
}
for( auto const& defn : this->type_to_tracked_ )
{
  if( defn.label() == label )
  {
    return true;
  }
}
return false;
!!!833328.cpp!!!	publish_help(inout helper : input_help) : void
const std::string seclabel( core::strngs::sampler_label() );
// ----------------------------------------
// add section
// ----------------------------------------

//   Specie input section definition
core::input_help::exemplar().add_section( seclabel,
    "Sampler input section definition.  In addition to the listed options, each individual "
    "sampler subtype may have its own specific options." );

// ----------------------------------------
// add parameters
// ----------------------------------------

//  type : [required] trial subtype
{
  const std::string description("[required, string] sampler subtype (see documentation for valid subtypes).");
  core::input_help::exemplar().add_option( seclabel, core::strngs::fstype(), description);
}

// Subtype parameter documentation.
for( auto const& iter : this->type_to_sample_ )
{
  iter.publish_help( helper, seclabel );
}
for( auto const& iter : this->type_to_tracked_ )
{
  iter.publish_help( helper, seclabel );
}


!!!204208.cpp!!!	do_read_entry(inout reader : input_base_reader) : bool
if( reader.name().find( core::strngs::fstype() ) == 0 )
{
  // --------------------
  // Evaluator type
  UTILITY_INPUT( this->missing_required_tags_[ SAMPLER_TYPE ], ( "Sampler \"type\" parameter appears more than once in a single in section" ), this->section_label() );
  UTILITY_INPUT( not reader.value().empty(), "Sampler \"type\" parameter must have a value.", this->section_label() );
  std::string val( reader.dequote( reader.value() ) );
  UTILITY_INPUT( this->has_type( val ), "Sampler \"type\" parameter value (" + val + ") does not name a valid sampler for this application (see documentation).", this->section_label() );
  this->type_ = val;
  this->missing_required_tags_.reset( SAMPLER_TYPE );
}
else
{
  // --------------------
  // Choice specific parameters
  UTILITY_INPUT( 0 == this->parameter_set_.count( reader.name() ), ( "Sampler \""+reader.name()+"\" parameter appears more than once in a single in section" ), this->section_label() );
  this->parameter_set_.insert( std::make_pair( reader.name(), reader.value() ) );
}
return true;

!!!204336.cpp!!!	do_read_end() : void
UTILITY_INPUT( not this->missing_required_tags_[ SAMPLER_TYPE ], ( "Sampler \"type\" parameter missing in input." ), this->section_label() );
UTILITY_INPUT (not this->missing_required_tags_.any(), "Not all required tags were present.", this->section_label());

// Call functor method to create sampler and add to simulator
for( const auto& defn : this->type_to_sample_ )
{
  if( defn.label() == this->type_ )
  { 
    this->manager_->add_sample( defn( this->parameter_set_ ) );
    return;
  }
}
for( const auto& defn : this->type_to_tracked_ )
{
  if( defn.label() == this->type_ )
  { 
    this->manager_->add_tracked( defn( this->parameter_set_ ) );
    return;
  }
}
// error to get here
UTILITY_CHECK( false, "should never reach this point in the code." );
!!!1308976.cpp!!!	do_reset() : void
// Reset meta data
this->missing_required_tags_.set();
this->parameter_set_.clear();
this->type_.clear();
