class move_choice
!!!1965103.cpp!!!	generate(inout sys : simulator) : change_set
std::unique_ptr< change_set > result (new change_set(*this));
auto const& ens = sys.get_ensemble();
if (sys.get_specie( this->specie_key() ).count() == 0)
{
  result->set_fail(); // No particles of this specie
  return result;
}
// Select a particle at random
change_atom atom;
atom.key = this->specie_key();
switch (sys.get_specie(atom.key).count())
{
case 0:
  {
    result->set_fail(); // No particles of this specie
    return result;
  }
  break;
case 1:
  {
    atom.index = ens.nth_specie_index(atom.key, 0);
  }
  break;
default:
  {
    atom.index = ens.nth_specie_index(atom.key, sys.get_random().randint(0, sys.get_specie(atom.key).count() - 1));
  }
  break;
}
// Get old position
atom.old_position = ens.position(atom.index);
atom.eps_old = ens.eps(atom.index);
// give particle a random displacement
atom.new_position.x = atom.old_position.x + sys.get_random().uniform(-this->delta_, this->delta_);
atom.new_position.y = atom.old_position.y + sys.get_random().uniform(-this->delta_, this->delta_);
atom.new_position.z = atom.old_position.z + sys.get_random().uniform(-this->delta_, this->delta_);
if (not sys.is_valid_position(atom.new_position, atom.key))
{
  result->set_fail ();
}
atom.eps_new = sys.permittivity_at(atom.new_position);
result->add_atom (atom);
return result;
!!!1965103.python!!!	generate(inout sys : simulator) : change_set
self.begin_trial()
ens = sys.get_ensemble()
genr = sys.get_random()
import change_set
result = change_set.change_set( self )
if sys.get_specie( self.key_ ).count() == 0:
  result.fail = True # No particles of this specie
  return result
atom = change_set.change_atom()
atom.key = self.specie_key()
atom.index = ens.nth_specie_index( atom.key, genr.randint( 0, sys.get_specie( atom.key ).count() - 1) )
atom.old_position = ens.position( atom.index )
atom.new_position.x = atom.old_position.x + genr.uniform( -self.delta_, self.delta_ )
atom.new_position.y = atom.old_position.y + genr.uniform( -self.delta_, self.delta_ )
atom.new_position.z = atom.old_position.z + genr.uniform( -self.delta_, self.delta_ )
if not sys.get_cell_region().is_valid_position( atom.new_position, atom.key ):
  result.fail = True # Particle not in valid position
  return result
result.add_atom( atom )
return result
!!!1964719.cpp!!!	move_choice(in ispec : size_t, in params : string)
if (params.find("delta") != params.end())
{
   try
   {
      this->delta_ = boost::lexical_cast< double >(params.at( "delta" ) );
      UTILITY_INPUT( this->delta_ > 0, "Input value for \"delta\" must be greater than zero", core::strngs::fstry() );
   }
   catch( boost::bad_lexical_cast const& err )
   {
      const bool invalid_conversion( false );
      UTILITY_INPUT( invalid_conversion, "Input value for \"delta\" is not a number", core::strngs::fstry() );
   }
}
