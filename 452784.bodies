class geometry_test
!!!988336.cpp!!!	calculate_volume_test(in reg : base_region, in full_volume : double, in radius : double, in reduced_volume : double) : void
double full;
double access;

BOOST_REQUIRE_NO_THROW( full = reg.volume( 0.0 ) );
BOOST_REQUIRE_NO_THROW( access = reg.volume( radius ) );
BOOST_CHECK_EQUAL( full, full_volume );
BOOST_CHECK_EQUAL( access, reduced_volume );
!!!1022512.cpp!!!	region_new_position_test(in regn : base_region, in inside : coordinate, in outside : coordinate, in okradius : double, in bigradius : double) : void
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rand( generator );
const double offset( 1.0 );
// region = regn
BOOST_REQUIRE( regn.fits( okradius ) );
BOOST_REQUIRE( ((bigradius < 0.0) or (not regn.fits( bigradius ))) );
BOOST_REQUIRE( regn.is_inside( inside, okradius  ) );
BOOST_REQUIRE( not regn.is_inside( outside, okradius ) );

// Test methods that should throw first
if( bigradius > 0.0 )
{
  BOOST_CHECK( not regn.is_inside( outside, bigradius ) );
  BOOST_CHECK( not regn.is_inside( inside, bigradius ) );
  particle::coordinate pos;
  BOOST_CHECK_THROW( pos = regn.new_position( rand, bigradius ), std::runtime_error );
  pos = inside;
  BOOST_CHECK_THROW( regn.new_position_offset( rand, pos, offset, bigradius ), std::runtime_error );
  pos = outside;
  BOOST_CHECK_THROW( regn.new_position_offset( rand, pos, offset, bigradius ), std::runtime_error );
}
{
  particle::coordinate pos( outside );
  BOOST_CHECK_THROW( regn.new_position_offset( rand, pos, offset, okradius ), std::runtime_error );
}
for( std::size_t count = 0; count != 1000; ++count )
{
  {
    particle::coordinate pos;
    BOOST_REQUIRE_NO_THROW( pos = regn.new_position( rand, okradius ) );
    BOOST_CHECK( regn.is_inside( pos, okradius ) );
  }
  {
    particle::coordinate pos( inside );
    bool result;
    BOOST_REQUIRE_NO_THROW( result = regn.new_position_offset( rand, pos, offset, okradius ) );
    BOOST_CHECK( result = regn.is_inside( pos, okradius ) );
  }
}

!!!262320.cpp!!!	test_grid_generator(inout gridder : grid_generator) : void
// Store generated coordinates
std::vector< particle::coordinate > postns;
// Initial grid point count
const std::size_t count { gridder->size() };
// Test serialization
std::stringstream store;
{
   boost::archive::text_oarchive oa(store);
   // write class instance to archive
   BOOST_REQUIRE_NO_THROW( oa << gridder );
}

// Test grid next
for ( std::size_t idx = 0; idx != count; ++idx )
{
   // Not empty before first 'count' calls to gridder->next
   BOOST_CHECK( not gridder->empty() );
   // Non zero size before first 'count' calls to gridder->next
   BOOST_CHECK_LT( 0, gridder->size() );

   const std::size_t remain { gridder->size() };
   particle::coordinate pnt;

   // Next return is not false for first 'count' - 1 calls to gridder->next
   // and false for the 'count'th call.
   BOOST_REQUIRE_MESSAGE( gridder->next( pnt ), "gridder.next() is false before expected end point" );

   // Size decreases by one during call to gridder->next
   BOOST_CHECK_EQUAL( remain - 1, gridder->size() );

   // Generated position is not the same as any previously generated position
   for (auto const& p2 : postns )
   {
      BOOST_REQUIRE_NE( p2, pnt );
   }

   // store generated position.
   postns.push_back( pnt );
}
{
   particle::coordinate pnt;
   BOOST_REQUIRE_MESSAGE( not gridder->next( pnt), "gridder.next() is true after expected end point" );
}
// Gridder is empty after 'count' calls
BOOST_CHECK( gridder->empty() );
// Gridder has zero size after 'count' calls
BOOST_CHECK_EQUAL(0, gridder->size());

// Test deserialization
{
   boost::shared_ptr< geometry::grid_generator > g;
   boost::archive::text_iarchive oa(store);
   // read class instance from archive
   BOOST_REQUIRE_NO_THROW( oa >> g );

   BOOST_REQUIRE_EQUAL( count, g->size() );
   for ( std::size_t idx = 0; idx != count; ++idx )
   {
      // Not empty before first 'count' calls to gridder->next
      BOOST_CHECK( not g->empty() );
      // Non zero size before first 'count' calls to gridder->next
      BOOST_CHECK_LT( 0, g->size() );

      const std::size_t remain { g->size() };
      particle::coordinate pnt;

      // Next return is not false for first 'count' - 1 calls to gridder->next
      // and false for the 'count'th call.
      BOOST_REQUIRE_MESSAGE( g->next( pnt), "gridder->next() is false before count calls" );
      // Expect copy to return points in same order as original
      BOOST_CHECK_EQUAL( pnt, postns[idx] );

      // Size decreases by one during call to gridder->next
      BOOST_CHECK_EQUAL( remain - 1, g->size() );
   }

}

!!!262448.cpp!!!	circle_grid_lifetime_test() : void
{
  // Test is canonical pattern
  BOOST_CHECK( std::is_default_constructible< geometry::circle_grid >::type {} );
  BOOST_CHECK( std::is_copy_constructible< geometry::circle_grid >::type {} );
  BOOST_CHECK( std::is_move_constructible< geometry::circle_grid >::type {} );
  BOOST_CHECK( ( std::is_assignable< geometry::circle_grid, geometry::circle_grid >::type {} ) );
  BOOST_CHECK( not std::has_virtual_destructor< geometry::circle_grid >::type {} );
}
std::stringstream log;
{
   // Circle grid default ctor
   geometry::circle_grid var1;
   // Default should have no size
   BOOST_REQUIRE_EQUAL( var1.size(), 0 );
   // Should throw error
   particle::coordinate pnt;
   BOOST_REQUIRE_THROW( var1.set_xy( pnt, 0 ), std::runtime_error );
}
{
   // Circle grid copy and serialization test
   const double radius{ 3.0 };
   const double space{ 1.0 };
   std::stringstream ss;
   {
      geometry::circle_grid var1( radius, space );
      BOOST_CHECK_EQUAL( var1.size(), 21 );
      {
      geometry::circle_grid var2( var1 );
      BOOST_CHECK_EQUAL( var2.size(), 21 );
      BOOST_CHECK_EQUAL( var1.size(), 21 );
      }
      {
      geometry::circle_grid var3;
      BOOST_CHECK_EQUAL( var3.size(), 0 );
      var3 = var1;
      BOOST_CHECK_EQUAL( var3.size(), 21 );
      BOOST_CHECK_EQUAL( var1.size(), 21 );
      }
      {
        geometry::circle_grid var4( var1 );
        geometry::circle_grid var5( std::move( var4 ) );
        BOOST_CHECK_EQUAL( var5.size(), 21 );
      }

      boost::archive::text_oarchive oa(ss);
      // write class instance to archive
      oa << var1;
      BOOST_CHECK_EQUAL( var1.size(), 21 );
   }
   {
      geometry::circle_grid var1;
      BOOST_CHECK_EQUAL( var1.size(), 0 );
      boost::archive::text_iarchive ia(ss);
      // read class instance from archive
      ia >> var1;
      BOOST_CHECK_EQUAL( var1.size(), 21 );
   }
}
!!!1014960.cpp!!!	circle_grid_methods_test() : void
{
   // Circle grid real ctor
   const double radius{ 3.0 };
   const double space{ 1.0 };
   geometry::circle_grid var1( radius, space );
   BOOST_CHECK_EQUAL( var1.size(), 21 );

   const double r_edge( std::pow( radius - space, 2 ) );
   const double r_max( std::pow( radius - ( space/2 ), 2 ) );
   const std::size_t size( var1.size() );
   std::size_t countr1 = 0; // count of elements near r
   for (std::size_t idx = 0; idx != size; ++idx)
   {
      BOOST_CHECK_LT(0, var1.size());
      particle::coordinate pnt;
      var1.set_xy( pnt, idx );
      const double r(pnt.x*pnt.x + pnt.y*pnt.y);
      BOOST_CHECK_LE( r, r_max );
      if (r >= r_edge) ++countr1;
   }
   BOOST_CHECK_EQUAL( size, var1.size() );
   // Should throw error
   particle::coordinate pnt;
   BOOST_REQUIRE_THROW( var1.set_xy( pnt, size ), std::runtime_error );
   BOOST_CHECK_LT( 0, countr1 );
   const std::size_t mod4{ countr1 % 4 };
   const std::size_t mod8{ countr1 % 8 };
   BOOST_CHECK_MESSAGE( mod4 == 0, "4 fold symmetry error: 0 != countr1 % 4" );
   BOOST_WARN_MESSAGE( mod8 == 0, "8 fold symmetry error: 0 != countr1 % 8" );
}
{
   std::vector< particle::coordinate > canon;
   // Circle grid copy and serialization test
   const double radius{ 3.0 };
   const double space{ 1.0 };
   std::stringstream ss;
   {
      geometry::circle_grid var1 = geometry::circle_grid( radius, space );
      BOOST_CHECK_EQUAL( var1.size(), 21 );

      boost::archive::text_oarchive oa(ss);
      // write class instance to archive
      oa << var1;

      const std::size_t size( var1.size() );
      canon.resize( size );
      for (std::size_t idx = 0; idx != size; ++idx)
      {
         var1.set_xy( canon[ idx ], idx );
         BOOST_CHECK_LT(0, var1.size());
      }
   }
   {
      geometry::circle_grid var3;
      BOOST_CHECK_EQUAL( var3.size(), 0 );
      boost::archive::text_iarchive ia(ss);
      // read class instance from archive
      ia >> var3;
      BOOST_CHECK_EQUAL( var3.size(), 21 );
      BOOST_REQUIRE_EQUAL( var3.size(), canon.size() );
      for (std::size_t idx = 0; idx != var3.size(); ++idx)
      {
         particle::coordinate pnt;
         var3.set_xy( pnt, idx );
         BOOST_CHECK_EQUAL( pnt, canon[idx] );
      }

   }
   {
      // circle grid that should be used in tubular grid
      geometry::circle_grid var1( 8.5, 0.5 );
      BOOST_CHECK_EQUAL( var1.size(), 861 );
   }
}
!!!1015088.cpp!!!	cubic_grid_lifetime_test() : void
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< geometry::cubic_grid >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< geometry::cubic_grid >::type {} );
  BOOST_CHECK( not std::is_move_constructible< geometry::cubic_grid >::type {} );
  BOOST_CHECK( not( std::is_assignable< geometry::cubic_grid, geometry::cubic_grid >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< geometry::cubic_grid >::type {} );
}
std::stringstream ss;
{
  boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
  utility::random_distribution rgen( generator );
  // Cubic grid main ctor
  boost::shared_ptr< geometry::cubic_grid > var1( new geometry::cubic_grid( 30.0, 216, rgen ) );
  BOOST_CHECK_EQUAL( var1->size(), 216 );

  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  BOOST_REQUIRE_NO_THROW( oa << var1 );
  BOOST_CHECK_EQUAL( var1->size(), 216 );
}
{
  boost::shared_ptr< geometry::cubic_grid > var1;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  BOOST_REQUIRE_NO_THROW( ia >> var1 );
  BOOST_CHECK_EQUAL( var1->size(), 216 );
}

!!!427185.cpp!!!	cubic_grid_test() : void
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgen( generator );
std::vector< particle::coordinate > canon;
// Cubic grid 30.0, 216
// 216**1/3 => 6
// 30/6 => 5 (spacing)
// Edge spacing => 2.5
// Min == 2.5; Max == 27.5
{
  // cubic grid ctor(length, numpart, ranf)
  boost::shared_ptr< geometry::grid_generator > var1( new geometry::cubic_grid( 30.0, 216, rgen ) );
  BOOST_CHECK_EQUAL( var1->size(), 216 );
  BOOST_CHECK( not var1->empty() );
  // Test base class behavior
  geometry_test::test_grid_generator( var1 );
}
{
  // Test all coordinates are in the expected
  // range.
  boost::shared_ptr< geometry::cubic_grid > var1( new geometry::cubic_grid( 30.0, 216, rgen ) );

  boost::shared_ptr< geometry::cubic_grid > var2;
  {
    std::stringstream ss;
    boost::archive::text_oarchive oa( ss );
    // write class instance to archive
    oa << var1;
    boost::archive::text_iarchive ia( ss );
    // read class instance from archive
    BOOST_CHECK_NO_THROW( ia >> var2 );
    BOOST_CHECK_EQUAL( var2->size(), 216 );
  }
  const std::size_t size { var1->size() };
  canon.resize( size );
  for( std::size_t idx = 0; idx != size; ++idx )
  {
    particle::coordinate pnt;
    particle::coordinate pnt2;
    var1->next( pnt );
    var2->next( pnt2 );
    BOOST_CHECK_EQUAL( pnt, pnt2 );
    BOOST_CHECK_EQUAL( var1->size(), ( size - idx - 1 ) );
    BOOST_CHECK( not var1->empty() or ( size == idx + 1 ) );
    BOOST_CHECK_LE( pnt.x, 27.5 );
    BOOST_CHECK_LE( pnt.y, 27.5 );
    BOOST_CHECK_LE( pnt.z, 27.5 );
    BOOST_CHECK_LE( 2.5, pnt.x );
    BOOST_CHECK_LE( 2.5, pnt.y );
    BOOST_CHECK_LE( 2.5, pnt.z );
    canon[idx] = pnt;
  }
  // Check every valid point in the grid is generated
  // by converting grid position into an index
  std::vector< bool > check( size, false );
  std::vector< size_t > indices( size );
  for( std::size_t ix = 0; ix != size; ++ix )
  {
    particle::coordinate pnt( canon[ix] );
    std::size_t idx( ( ( ( pnt.x - 2.5 ) * 6 + pnt.y - 2.5 ) * 6 + ( pnt.z - 2.5 ) ) / 5.0 );
    // Check generated index is less than size
    BOOST_CHECK_LT( idx, size );
    indices[ix] = idx;
    // Check generated index has not already seen
    BOOST_CHECK( not check[idx] );
    check[idx] = true;
  }
  {
    std::sort( indices.begin(), indices.end() );
    for( std::size_t ix = 0; ix != size; ++ix )
    {
      // Check generated index runs from 0 to 'size'
      BOOST_CHECK_EQUAL( ix, indices[ix] );
    }
  }
  // Check for missing (false) indices.
  BOOST_CHECK( check.end() == std::find( check.begin(), check.end(), false ) );
}

!!!1015216.cpp!!!	tubular_grid_lifetime_test() : void
boost::shared_ptr< boost::mt19937> generator(new boost::mt19937);
std::stringstream log;
utility::random_distribution rgen(generator);
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< geometry::tubular_grid >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< geometry::tubular_grid >::type {} );
  BOOST_CHECK( not std::is_move_constructible< geometry::tubular_grid >::type {} );
  BOOST_CHECK( not( std::is_assignable< geometry::tubular_grid, geometry::tubular_grid >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< geometry::tubular_grid >::type {} );
}
std::stringstream ss;
{
  boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
  utility::random_distribution rgen( generator );
  // Cubic grid main ctor
  boost::shared_ptr< geometry::tubular_grid > var1( new geometry::tubular_grid( 31.0, 8.5, 2.5, rgen ) );
  BOOST_CHECK_EQUAL( var1->size(), 300 );

  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  BOOST_REQUIRE_NO_THROW( oa << var1 );
  BOOST_CHECK_EQUAL( var1->size(), 300 );
}
{
  boost::shared_ptr< geometry::tubular_grid > var1;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  BOOST_REQUIRE_NO_THROW( ia >> var1 );
  BOOST_CHECK_EQUAL( var1->size(), 300 );
}
!!!427313.cpp!!!	tubular_grid_test() : void
boost::shared_ptr< boost::mt19937> generator(new boost::mt19937);
std::stringstream log;
utility::random_distribution rgen(generator);
// Cylindrical grid 
// HLENGTH 31.0,
// RADIUS  8.5
// SPACING 0.5
// ZGRID = (31 - .5) / .5 = 61
// XYGRID = Y \   X
//             \        2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x
//              \ 0     0.5   1     1.5   2     2.5   3     3.5   4     4.5   5     5.5   6     6.5   7     7.5   8
//               \---------------------------------------------------------------------------------------------------
//    33    0    |0     0.5   1     1.5   2     2.5   3     3.5   4     4.5   5     5.5   6     6.5   7     7.5   8.0
// 2x 33    0.5  |0.5   0.7   1.1   1.6   2.1   2.5   3.0   3.5   4.0   4.5   5.0   5.5   6.0   6.5   7.0   7.5   8.0
// 2x 33    1    |1     1.1   1.4   1.8   2.2   2.7   3.2   3.6   4.1   4.6   5.1   5.6   6.1   6.6   7.1   7.6   8.1
// 2x 33    1.5  |1.5   1.6   1.8   2.1   2.5   2.9   3.4   3.8   4.3   4.7   5.2   5.7   6.2   6.7   7.2   7.6   8.1
// 2x 33    2    |2     2.1   2.2   2.5   2.8   3.2   3.6   4.0   4.5   4.9   5.4   5.9   6.3   6.8   7.3   7.8   8.2
// 2x 31    2.5  |2.5   2.5   2.7   2.9   3.2   3.5   3.9   4.3   4.7   5.1   5.6   6.0   6.5   7.0   7.4   7.9
// 2x 31    3    |3     3.0   3.2   3.4   3.6   3.9   4.2   4.6   5.0   5.4   5.8   6.3   6.7   7.2   7.6   8.1
// 2x 29    3.5  |3.5   3.5   3.6   3.8   4.0   4.3   4.6   4.9   5.3   5.7   6.1   6.5   6.9   7.4   7.8
// 2x 29    4    |4     4.0   4.1   4.3   4.5   4.7   5.0   5.3   5.7   6.0   6.4   6.8   7.2   7.6   8.1
// 2x 27    4.5  |4.5   4.5   4.6   4.7   4.9   5.1   5.4   5.7   6.0   6.4   6.7   7.1   7.5   7.9
// 2x 27    5    |5     5.0   5.1   5.2   5.4   5.6   5.8   6.1   6.4   6.7   7.1   7.4   7.8   8.2
// 2x 25    5.5  |5.5   5.5   5.6   5.7   5.9   6.0   6.3   6.5   6.8   7.1   7.4   7.8   8.1
// 2x 23    6    |6     6.0   6.1   6.2   6.3   6.5   6.7   6.9   7.2   7.5   7.8   8.1
// 2x 21    6.5  |6.5   6.5   6.6   6.7   6.8   7.0   7.2   7.4   7.6   7.9   8.2
// 2x 17    7    |7     7.0   7.1   7.2   7.3   7.4   7.6   7.8   8.1
// 2x 13    7.5  |7.5   7.5   7.6   7.6   7.8   7.9   8.1
// 2x 5     8    |8     8.0   8.1   8.1   8.2 
// ======
//    861
//
{
  // Tubular grid ctor (with spacing)
   boost::shared_ptr< geometry::grid_generator > var1( new geometry::tubular_grid( 31.0, 8.5, 2.5 ) );

  BOOST_CHECK( not var1->empty() );
  // Test base class behavior
  geometry_test::test_grid_generator( var1 );
}
{
  // Tubular grid ctor (with target grid point)
  boost::shared_ptr< geometry::grid_generator > var1( new geometry::tubular_grid( 31.0, 8.5, 500 ) );

  BOOST_CHECK_LE( 500, var1->size() );
  BOOST_CHECK_LE( 0.0, var1->spacing() );
  BOOST_CHECK( not var1->empty() );
}

{
  // Tubular grid test: constructed with defined spacing
   const double length{ 31.0 };
   const double radius{ 8.5 };
   const double spacing{ 0.5 };
  geometry::tubular_grid var1 (length, radius, spacing);
  BOOST_CHECK_EQUAL(var1.size(), 861*62);
  // Should have some grid points within 3/2*'spacing' of edge
  const double r_edge{ std::pow(radius - (3*spacing/2), 2) };
  const double z1_edge{ (length - 3*spacing)/2 };
  const double z2_edge{ -z1_edge };
  // should have no grid points within ('spacing'/2) of edge
  const double r_max{ std::pow(radius - spacing/2.0, 2) };
  const double z1_max{ (length - spacing)/ 2.0 };
  const double z2_max{ -z1_max };
  const double z_min{ spacing / 2.0 };
  // Number of grid points
  const std::size_t size{ var1.size() };
  std::set< double > zvalues;

  std::size_t counter_spacing_r1 = 0; // count of elements near r, when z>0
  std::size_t counter_spacing_r2 = 0; // count of elements near r, when z<0
  std::size_t counter_spacing_z1 = 0; // count of elements near +z
  std::size_t counter_spacing_z2 = 0; // count of elements near -z

  for (std::size_t idx = 0; idx != size; ++idx)
  {
    BOOST_CHECK_LT(0, var1.size());
    particle::coordinate pnt;
    var1.next(pnt);
    const double r(pnt.x*pnt.x + pnt.y*pnt.y);
    BOOST_CHECK_LE( r, r_max );
    BOOST_CHECK_LE( pnt.z, z1_max );
    BOOST_CHECK_LE( z2_max, pnt.z );
    BOOST_CHECK_LE( z_min, std::abs(pnt.z) );

    if (r > r_edge and pnt.z > 0.0) ++counter_spacing_r1;
    if (r > r_edge and pnt.z < 0.0) ++counter_spacing_r2;
    if (pnt.z > z1_edge) ++counter_spacing_z1;
    if (pnt.z < z2_edge) ++counter_spacing_z2;
    zvalues.insert( pnt.z );
  }
  log << "ZMIN " << z_min << " ZMAX " << z1_max << " ZEDGE " << z1_edge << " SPC " << spacing << "\n";
  for (double zz : zvalues )
  {
     log << zz << " ";
  }
  log << "\n";
  BOOST_CHECK_EQUAL( 0, var1.size() );
  BOOST_CHECK_LT( 0, counter_spacing_r1 );
  BOOST_CHECK_EQUAL( counter_spacing_r1, counter_spacing_r2 );
  // r count should be multiple of 4*60
  const std::size_t mod_60{ counter_spacing_r1 % 62 };
  BOOST_CHECK_MESSAGE( 0 == mod_60, "0 == (counter_spacing_r1 % 62)" );
  const std::size_t mod_120{ counter_spacing_r1 % (2*62) };
  BOOST_CHECK_MESSAGE( 0 == mod_120, "2 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (2*62))" );
  const std::size_t mod_240{ counter_spacing_r1 % (4*62) };
  BOOST_CHECK_MESSAGE( 0 == mod_240, "4 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (4*62))" );
  const std::size_t mod_480{ counter_spacing_r1 % (8*62) };
  BOOST_WARN_MESSAGE( 0 == mod_480, "8 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (4*62))" );


  BOOST_CHECK_LT( 0, counter_spacing_z1 );
  BOOST_CHECK_EQUAL( counter_spacing_z1, counter_spacing_z2 );
  // z count should be 861
  BOOST_CHECK_EQUAL( 861, counter_spacing_z1 );
}
{
  // Tubular grid: constructed with target grid point minimum count
   const double length{ 31.0 };
   const double radius{ 8.5 };
   geometry::tubular_grid var1( length, radius, 500);

  std::set< double > zvalues;

  // Should have no points within (spacing/2) of edge
  const double r_max( std::pow(radius - var1.spacing()/2.0, 2) );
  const double z1_max( (length - var1.spacing())/2.0 );
  const double z2_max( -z1_max );
  const double z_min( var1.spacing()/2.0 );
  // Should have some points within 1.5*spacing of edge
  const double r_edge( std::pow(radius - (3*var1.spacing()/2), 2) );
  const double z1_edge( (length - 3*var1.spacing())/2 );
  const double z2_edge( -z1_edge );

  std::size_t counter_ntarget_r1 = 0; // count of elements near r, when z>0
  std::size_t counter_ntarget_r2 = 0; // count of elements near r, when z<0
  std::size_t counter_ntarget_z1 = 0; // count of elements near +z
  std::size_t counter_ntarget_z2 = 0; // count of elements near -z

  particle::coordinate pnt;
  while ( var1.next( pnt ) )
  {
    const double r( pnt.x*pnt.x + pnt.y*pnt.y );
    // Test that no grid points get closer than 'spacing'/2 from edge
    BOOST_CHECK_LE( r, r_max );
    BOOST_CHECK_LE( pnt.z, z1_max );
    BOOST_CHECK_LE( z2_max, pnt.z );
    BOOST_CHECK_LE( z_min, std::abs( pnt.z ) );// no points nearer to z=0.0 than spacing/2

    if ( r > r_edge and pnt.z > 0.0 ) ++counter_ntarget_r1;
    if ( r > r_edge and pnt.z < 0.0 ) ++counter_ntarget_r2;
    if ( pnt.z > z1_edge ) ++counter_ntarget_z1;
    if ( pnt.z < z2_edge ) ++counter_ntarget_z2;
    zvalues.insert( pnt.z );
  }
  log << "ZMIN " << z_min << " ZMAX " << z1_max << " ZEDGE " << z1_edge << " SPC " << var1.spacing() << "\n";
  for (double zz : zvalues )
  {
     log << zz << " ";
  }
  log << "\n";
  BOOST_CHECK_EQUAL( 0, var1.size() );
  // Test that some  grid points get closer than 'spacing' from edge
  // and that there are the same number on each side of z=0
  BOOST_CHECK_LT( 0, counter_ntarget_r1 );
  BOOST_CHECK_EQUAL( counter_ntarget_r1, counter_ntarget_r2 );
  BOOST_CHECK_LT( 0, counter_ntarget_z1 );
  BOOST_CHECK_EQUAL( counter_ntarget_z1, counter_ntarget_z2 );
  const std::size_t mod_2{ counter_ntarget_r2 % 2 };
  BOOST_CHECK_MESSAGE( 0 == mod_2, "2 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 2)" );
  const std::size_t mod_4{ counter_ntarget_r2 % 4 };
  BOOST_CHECK_MESSAGE( 0 == mod_4, "4 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 4)" );
  const std::size_t mod_8{ counter_ntarget_r2 % 8 };
  BOOST_WARN_MESSAGE( 0 == mod_8, "8 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 8)" );
}
!!!1015344.cpp!!!	split_tube_grid_lifetime_test() : void
boost::shared_ptr< boost::mt19937> generator(new boost::mt19937);
std::stringstream log;
utility::random_distribution rgen(generator);
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< geometry::split_tube_grid >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< geometry::split_tube_grid >::type {} );
  BOOST_CHECK( not std::is_move_constructible< geometry::split_tube_grid >::type {} );
  BOOST_CHECK( not( std::is_assignable< geometry::split_tube_grid, geometry::split_tube_grid >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< geometry::split_tube_grid >::type {} );
}
std::stringstream ss;
{
  boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
  utility::random_distribution rgen( generator );
  // Cubic grid main ctor
  boost::shared_ptr< geometry::split_tube_grid > var1( new geometry::split_tube_grid( 10.0, 31.0, 8.5, 2.5, rgen ) );
  BOOST_CHECK_EQUAL( var1->size(), 300 );

  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  BOOST_REQUIRE_NO_THROW( oa << var1 );
  BOOST_CHECK_EQUAL( var1->size(), 300 );
}
{
  boost::shared_ptr< geometry::split_tube_grid > var1;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  BOOST_REQUIRE_NO_THROW( ia >> var1 );
  BOOST_CHECK_EQUAL( var1->size(), 300 );
}
!!!1015472.cpp!!!	split_tube_grid_test() : void
boost::shared_ptr< boost::mt19937> generator(new boost::mt19937);
std::stringstream log;
utility::random_distribution rgen(generator);
const double offset( 10.0 );
// Cylindrical grid 
// HLENGTH 31.0,
// RADIUS  8.5
// SPACING 0.5
// ZGRID = (31 - .5) / .5 = 61
// XYGRID = Y \   X
//             \        2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x
//              \ 0     0.5   1     1.5   2     2.5   3     3.5   4     4.5   5     5.5   6     6.5   7     7.5   8
//               \---------------------------------------------------------------------------------------------------
//    33    0    |0     0.5   1     1.5   2     2.5   3     3.5   4     4.5   5     5.5   6     6.5   7     7.5   8.0
// 2x 33    0.5  |0.5   0.7   1.1   1.6   2.1   2.5   3.0   3.5   4.0   4.5   5.0   5.5   6.0   6.5   7.0   7.5   8.0
// 2x 33    1    |1     1.1   1.4   1.8   2.2   2.7   3.2   3.6   4.1   4.6   5.1   5.6   6.1   6.6   7.1   7.6   8.1
// 2x 33    1.5  |1.5   1.6   1.8   2.1   2.5   2.9   3.4   3.8   4.3   4.7   5.2   5.7   6.2   6.7   7.2   7.6   8.1
// 2x 33    2    |2     2.1   2.2   2.5   2.8   3.2   3.6   4.0   4.5   4.9   5.4   5.9   6.3   6.8   7.3   7.8   8.2
// 2x 31    2.5  |2.5   2.5   2.7   2.9   3.2   3.5   3.9   4.3   4.7   5.1   5.6   6.0   6.5   7.0   7.4   7.9
// 2x 31    3    |3     3.0   3.2   3.4   3.6   3.9   4.2   4.6   5.0   5.4   5.8   6.3   6.7   7.2   7.6   8.1
// 2x 29    3.5  |3.5   3.5   3.6   3.8   4.0   4.3   4.6   4.9   5.3   5.7   6.1   6.5   6.9   7.4   7.8
// 2x 29    4    |4     4.0   4.1   4.3   4.5   4.7   5.0   5.3   5.7   6.0   6.4   6.8   7.2   7.6   8.1
// 2x 27    4.5  |4.5   4.5   4.6   4.7   4.9   5.1   5.4   5.7   6.0   6.4   6.7   7.1   7.5   7.9
// 2x 27    5    |5     5.0   5.1   5.2   5.4   5.6   5.8   6.1   6.4   6.7   7.1   7.4   7.8   8.2
// 2x 25    5.5  |5.5   5.5   5.6   5.7   5.9   6.0   6.3   6.5   6.8   7.1   7.4   7.8   8.1
// 2x 23    6    |6     6.0   6.1   6.2   6.3   6.5   6.7   6.9   7.2   7.5   7.8   8.1
// 2x 21    6.5  |6.5   6.5   6.6   6.7   6.8   7.0   7.2   7.4   7.6   7.9   8.2
// 2x 17    7    |7     7.0   7.1   7.2   7.3   7.4   7.6   7.8   8.1
// 2x 13    7.5  |7.5   7.5   7.6   7.6   7.8   7.9   8.1
// 2x 5     8    |8     8.0   8.1   8.1   8.2 
// ======
//    861
//
{
  // Tubular grid ctor (with spacing)
   boost::shared_ptr< geometry::grid_generator > var1( new geometry::split_tube_grid( offset, 31.0, 8.5, 2.5 ) );

  BOOST_CHECK( not var1->empty() );
  // Test base class behavior
  geometry_test::test_grid_generator( var1 );
}
{
  // Tubular grid ctor (with target grid point)
  boost::shared_ptr< geometry::grid_generator > var1( new geometry::split_tube_grid( offset, 31.0, 8.5, 500 ) );

  BOOST_CHECK_LE( 500, var1->size() );
  BOOST_CHECK_LE( 0.0, var1->spacing() );
  BOOST_CHECK( not var1->empty() );
}

{
  // Tubular grid test: constructed with defined spacing
   const double length{ 31.0 };
   const double radius{ 8.5 };
   const double spacing{ 0.5 };
  geometry::split_tube_grid var1 (offset, length, radius, spacing);
  BOOST_CHECK_EQUAL(var1.size(), 861*62);
  // Should have some grid points within 3/2*'spacing' of edge
  const double r_edge{ std::pow(radius - (3*spacing/2), 2) };
  const double z1_edge{ (length - 3*spacing)/2 + offset };
  const double z2_edge{ -z1_edge };
  // should have no grid points within ('spacing'/2) of edge
  const double r_max{ std::pow(radius - spacing/2.0, 2) };
  const double z1_max{ (length - spacing)/ 2.0 + offset };
  const double z2_max{ -z1_max };
  const double z_min{ spacing / 2.0 + offset };
  // Number of grid points
  const std::size_t size{ var1.size() };
  std::set< double > zvalues;

  std::size_t counter_spacing_r1 = 0; // count of elements near r, when z>0
  std::size_t counter_spacing_r2 = 0; // count of elements near r, when z<0
  std::size_t counter_spacing_z1 = 0; // count of elements near +z
  std::size_t counter_spacing_z2 = 0; // count of elements near -z

  for (std::size_t idx = 0; idx != size; ++idx)
  {
    BOOST_CHECK_LT(0, var1.size());
    particle::coordinate pnt;
    var1.next(pnt);
    const double r(pnt.x*pnt.x + pnt.y*pnt.y);
    BOOST_CHECK_LE( r, r_max );
    BOOST_CHECK_LE( pnt.z, z1_max );
    BOOST_CHECK_LE( z2_max, pnt.z );
    BOOST_CHECK_LE( z_min, std::abs(pnt.z) );

    if (r > r_edge and pnt.z > 0.0) ++counter_spacing_r1;
    if (r > r_edge and pnt.z < 0.0) ++counter_spacing_r2;
    if (pnt.z > z1_edge) ++counter_spacing_z1;
    if (pnt.z < z2_edge) ++counter_spacing_z2;
    zvalues.insert( pnt.z );
  }
  log << "ZMIN " << z_min << " ZMAX " << z1_max << " ZEDGE " << z1_edge << " SPC " << spacing << "\n";
  for (double zz : zvalues )
  {
     log << zz << " ";
  }
  log << "\n";
  BOOST_CHECK_EQUAL( 0, var1.size() );
  BOOST_CHECK_LT( 0, counter_spacing_r1 );
  BOOST_CHECK_EQUAL( counter_spacing_r1, counter_spacing_r2 );
  // r count should be multiple of 4*60
  const std::size_t mod_60{ counter_spacing_r1 % 62 };
  BOOST_CHECK_MESSAGE( 0 == mod_60, "0 == (counter_spacing_r1 % 62)" );
  const std::size_t mod_120{ counter_spacing_r1 % (2*62) };
  BOOST_CHECK_MESSAGE( 0 == mod_120, "2 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (2*62))" );
  const std::size_t mod_240{ counter_spacing_r1 % (4*62) };
  BOOST_CHECK_MESSAGE( 0 == mod_240, "4 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (4*62))" );
  const std::size_t mod_480{ counter_spacing_r1 % (8*62) };
  BOOST_WARN_MESSAGE( 0 == mod_480, "8 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (4*62))" );


  BOOST_CHECK_LT( 0, counter_spacing_z1 );
  BOOST_CHECK_EQUAL( counter_spacing_z1, counter_spacing_z2 );
  // z count should be 861
  BOOST_CHECK_EQUAL( 861, counter_spacing_z1 );
}
{
  // Tubular grid: constructed with target grid point minimum count
   const double length{ 31.0 };
   const double radius{ 8.5 };
   geometry::split_tube_grid var1( offset, length, radius, 500);

  std::set< double > zvalues;

  // Should have no points within (spacing/2) of edge
  const double r_max( std::pow(radius - var1.spacing()/2.0, 2) );
  const double z1_max( (length - var1.spacing())/2.0 + offset );
  const double z2_max( -z1_max );
  const double z_min( var1.spacing()/2.0 + offset );
  // Should have some points within 1.5*spacing of edge
  const double r_edge( std::pow(radius - (3*var1.spacing()/2), 2) );
  const double z1_edge( (length - 3*var1.spacing())/2 + offset );
  const double z2_edge( -z1_edge );

  std::size_t counter_ntarget_r1 = 0; // count of elements near r, when z>0
  std::size_t counter_ntarget_r2 = 0; // count of elements near r, when z<0
  std::size_t counter_ntarget_z1 = 0; // count of elements near +z
  std::size_t counter_ntarget_z2 = 0; // count of elements near -z

  particle::coordinate pnt;
  while ( var1.next( pnt ) )
  {
    const double r( pnt.x*pnt.x + pnt.y*pnt.y );
    // Test that no grid points get closer than 'spacing'/2 from edge
    BOOST_CHECK_LE( r, r_max );
    BOOST_CHECK_LE( pnt.z, z1_max );
    BOOST_CHECK_LE( z2_max, pnt.z );
    BOOST_CHECK_LE( z_min, std::abs( pnt.z ) );// no points nearer to z=0.0 than spacing/2

    if ( r > r_edge and pnt.z > 0.0 ) ++counter_ntarget_r1;
    if ( r > r_edge and pnt.z < 0.0 ) ++counter_ntarget_r2;
    if ( pnt.z > z1_edge ) ++counter_ntarget_z1;
    if ( pnt.z < z2_edge ) ++counter_ntarget_z2;
    zvalues.insert( pnt.z );
  }
  log << "ZMIN " << z_min << " ZMAX " << z1_max << " ZEDGE " << z1_edge << " SPC " << var1.spacing() << "\n";
  for (double zz : zvalues )
  {
     log << zz << " ";
  }
  log << "\n";
  BOOST_CHECK_EQUAL( 0, var1.size() );
  // Test that some  grid points get closer than 'spacing' from edge
  // and that there are the same number on each side of z=0
  BOOST_CHECK_LT( 0, counter_ntarget_r1 );
  BOOST_CHECK_EQUAL( counter_ntarget_r1, counter_ntarget_r2 );
  BOOST_CHECK_LT( 0, counter_ntarget_z1 );
  BOOST_CHECK_EQUAL( counter_ntarget_z1, counter_ntarget_z2 );
  const std::size_t mod_2{ counter_ntarget_r2 % 2 };
  BOOST_CHECK_MESSAGE( 0 == mod_2, "2 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 2)" );
  const std::size_t mod_4{ counter_ntarget_r2 % 4 };
  BOOST_CHECK_MESSAGE( 0 == mod_4, "4 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 4)" );
  const std::size_t mod_8{ counter_ntarget_r2 % 8 };
  BOOST_WARN_MESSAGE( 0 == mod_8, "8 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 8)" );
}
!!!1022640.cpp!!!	periodic_cube_region_lifetime_test() : void
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< geometry::periodic_cube_region >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< geometry::periodic_cube_region >::type {} );
  BOOST_CHECK( not std::is_move_constructible< geometry::periodic_cube_region >::type {} );
  BOOST_CHECK( not( std::is_assignable< geometry::periodic_cube_region, geometry::periodic_cube_region >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< geometry::periodic_cube_region >::type {} );
}
std::stringstream ss;
{
  // Cubic grid main ctor
  boost::shared_ptr< geometry::periodic_cube_region > var1( new geometry::periodic_cube_region( "bulk", 10.0 ) );
  BOOST_CHECK_EQUAL( var1->length(), 10.0 );
  BOOST_CHECK_EQUAL( var1->label(), "bulk" );
  BOOST_CHECK_EQUAL( var1->volume( 1.0 ), 1000.0 );

  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  BOOST_REQUIRE_NO_THROW( oa << var1 );
}
{
  boost::shared_ptr< geometry::periodic_cube_region > var1;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  BOOST_REQUIRE_NO_THROW( ia >> var1 );
  BOOST_CHECK_EQUAL( var1->length(), 10.0 );
  BOOST_CHECK_EQUAL( var1->label(), "bulk" );
  BOOST_CHECK_EQUAL( var1->volume( 1.0 ), 1000.0 );
}
!!!1022768.cpp!!!	periodic_cube_region_method_test() : void
const std::string label( "bulk" );
// Cubic grid main ctor
boost::shared_ptr< geometry::periodic_cube_region > var1( new geometry::periodic_cube_region( label, 10.0 ) );
BOOST_CHECK_EQUAL( var1->length(), 10.0 );

{
  particle::coordinate inside( 0.0, 10.0, 10.0 );
  particle::coordinate outside( 0.0, -0.1, 10.0 );
  double okradius( 1.0 );
  double bigradius( 10.1 );
  // tests fits, is_inside, new_position and new_position_offset
  geometry_test::region_new_position_test( *var1, inside, outside, okradius, bigradius );
}
// Test volume (should be the same regardless of size)
{
  BOOST_CHECK_EQUAL( var1->volume( 1.0 ), 1000.0 );
  BOOST_CHECK_EQUAL( var1->volume( 0.0 ), 1000.0 );
  // should throw on non-fitting radius
  BOOST_CHECK_THROW( var1->volume( 100.0 ), std::runtime_error );
}
// label / set_label
{
  BOOST_CHECK_EQUAL( var1->label(), "bulk" );
  BOOST_CHECK_NO_THROW( var1->set_label( "100" ) );
  BOOST_CHECK_EQUAL( var1->label(), "100" );
  BOOST_CHECK_NO_THROW( var1->set_label( label ) );
  BOOST_CHECK_EQUAL( var1->label(), label );
}
// Calculate distances
{
  // Uses wrapping
  particle::coordinate_set pnts;
  std::vector< double > target, result;
  pnts.resize( 10 );
  // First five points effectively wrap to origin
  pnts.set_x( 0, 0.0 );
  pnts.set_y( 0, 0.0 );
  pnts.set_z( 0 , 0.0 );
  pnts.set_x( 1, 10.0 );
  pnts.set_y( 1, 0.0 );
  pnts.set_z( 1 , 0.0 );
  pnts.set_x( 2, 0.0 );
  pnts.set_y( 2, 10.0 );
  pnts.set_z( 2 , 0.0 );
  pnts.set_x( 3, 0.0 );
  pnts.set_y( 3, 0.0 );
  pnts.set_z( 3 , 10.0 );
  pnts.set_x( 4, 10.0 );
  pnts.set_y( 4, 10.0 );
  pnts.set_z( 4 , 10.0 );
  pnts.set_x( 5, 1.0 );
  pnts.set_y( 5, 0.0 );
  pnts.set_z( 5 , 0.0 );
  pnts.set_x( 6, 0.0 );
  pnts.set_y( 6, 1.0 );
  pnts.set_z( 6 , 1.0 );
  pnts.set_x( 7, 1.0 );
  pnts.set_y( 7, 1.0 );
  pnts.set_z( 7 , 1.0 );
  pnts.set_x( 8, 2.0 );
  pnts.set_y( 8, 2.0 );
  pnts.set_z( 8 , 2.0 );
  pnts.set_x( 9, 5.0 );
  pnts.set_y( 9, 5.0 );
  pnts.set_z( 9 , 5.0 );

  target.resize( 10 );
  particle::coordinate newpos( 0.0, 5.0, 0.0 );
  target[0] = 5.0;
  target[1] = 5.0;
  target[2] = 5.0;
  target[3] = 5.0;
  target[4] = 5.0;
  target[5] = std::sqrt( 26.0 );
  target[6] = std::sqrt( 17.0 );
  target[7] = std::sqrt( 18.0 );
  target[8] = std::sqrt( 17.0 );
  target[9] = std::sqrt( 50.0 );

  geometry::geometry_manager man( var1 );

  man.calculate_distances( newpos, pnts, result, 10, 0 );
  for( std::size_t ii = 0; ii != 10; ++ii )
  {
    BOOST_CHECK( utility::feq( result[ii], target[ii] ) );
    particle::coordinate otherpos( pnts.x( ii ), pnts.y( ii ), pnts.z( ii ) );
    BOOST_CHECK( utility::feq( man.calculate_distance_squared( newpos, otherpos ), std::pow( target[ii], 2 ) ) );
  }

}
// change volume
// make_gridder


