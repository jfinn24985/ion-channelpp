class geometry_test
!!!988336.cpp!!!	calculate_volume_test(in reg : base_region, in full_volume : double, in radius : double, in reduced_volume : double) : void
double full;
double access;

BOOST_REQUIRE_NO_THROW( full = reg.volume( 0.0 ) );
BOOST_REQUIRE_NO_THROW( access = reg.volume( radius ) );
BOOST_CHECK_EQUAL( full, full_volume );
BOOST_CHECK_EQUAL( access, reduced_volume );
!!!1022512.cpp!!!	region_serialization_test(in regn : base_region) : void
std::stringstream ss;
std::string label;
double volume;
double radius = 0.01;
bool use_radius = true;
particle::coordinate big, small;
{
  // Cubic grid main ctor
  BOOST_CHECK_NO_THROW( label = regn->label() );
  BOOST_CHECK_NO_THROW( use_radius = regn->fits( radius ) );
  BOOST_REQUIRE( use_radius or regn->fits( 0.0 ) ); // something must fit!
  BOOST_CHECK_NO_THROW( volume = regn->volume( (use_radius ? radius : 0.0 ) ) );
  BOOST_CHECK_NO_THROW( regn->extent( small, big, (use_radius ? radius : 0.0 ) ) );

  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  BOOST_REQUIRE_NO_THROW( oa << regn );
}
{
  boost::shared_ptr< geometry::base_region > var2;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  BOOST_REQUIRE_NO_THROW( ia >> var2 );
  BOOST_CHECK_EQUAL( var2->label(), label );
  BOOST_CHECK_EQUAL( var2->fits( radius ), use_radius );
  double newvol;
  BOOST_CHECK_NO_THROW( newvol = var2->volume( (use_radius ? radius : 0.0 ) ) );
  BOOST_CHECK_EQUAL( newvol, volume );
  particle::coordinate newbig, newsmall;
  BOOST_CHECK_NO_THROW( var2->extent( newsmall, newbig, (use_radius ? radius : 0.0 ) ) );
  BOOST_CHECK_EQUAL( newsmall, small );
  BOOST_CHECK_EQUAL( newbig, big );
}
!!!1193264.cpp!!!	region_new_position_test(in regn : base_region, in inside : coordinate, in outside : coordinate, in okradius : double, in bigradius : double) : void
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rand( generator );
const double offset( 1.0 );
// region = regn
BOOST_REQUIRE( regn.fits( okradius ) );
BOOST_REQUIRE( ( ( bigradius < 0.0 ) or ( not regn.fits( bigradius ) ) ) );
BOOST_REQUIRE( regn.is_inside( inside, okradius ) );
BOOST_REQUIRE( not regn.is_inside( outside, okradius ) );

// Test methods that should throw first
if( bigradius > 0.0 )
{
  BOOST_CHECK( not regn.is_inside( outside, bigradius ) );
  BOOST_CHECK( not regn.is_inside( inside, bigradius ) );
  particle::coordinate pos;
  BOOST_CHECK_THROW( pos = regn.new_position( rand, bigradius ), std::runtime_error );
  pos = inside;
  BOOST_CHECK_THROW( regn.new_position_offset( rand, pos, offset, bigradius ), std::runtime_error );
  pos = outside;
  BOOST_CHECK_THROW( regn.new_position_offset( rand, pos, offset, bigradius ), std::runtime_error );
}
{
  particle::coordinate pos( outside );
  BOOST_CHECK_THROW( regn.new_position_offset( rand, pos, offset, okradius ), std::runtime_error );
}
for( std::size_t count = 0; count != 1000; ++count )
{
  {
    particle::coordinate pos;
    BOOST_REQUIRE_NO_THROW( pos = regn.new_position( rand, okradius ) );
    BOOST_CHECK( regn.is_inside( pos, okradius ) );
  }
  {
    particle::coordinate pos( inside );
    bool result;
    BOOST_REQUIRE_NO_THROW( result = regn.new_position_offset( rand, pos, offset, okradius ) );
    BOOST_CHECK_EQUAL( result, regn.is_inside( pos, okradius ) );
  }
}

!!!1047472.cpp!!!	region_make_gridder_test(in regn : base_region, in min_count : size_t, in max_count : size_t, in min_space : double, in max_space : double) : void
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rand( generator );
// region = regn

// check count grid generation
{
  if( min_count > max_count )
  {
    std::swap( max_count, min_count );
  }
  const std::size_t increment = ( min_count + 10 > max_count ? 1 : ( max_count - min_count ) / 10 );

  for( std::size_t count = min_count; count <= max_count; count += increment )
  {
    boost::shared_ptr< geometry::grid_generator > grid;
    grid = regn.make_gridder( rand, count );
    BOOST_CHECK_LE( count, grid->size() );
  }
}

// check spacing grid generation
{
  if( min_space > max_space )
  {
    std::swap( min_space, max_space );
  }
  const double increment = ( min_space == max_space ? 1.0 : ( max_space - min_space ) / 10.0 );

  double space = 0.0;
  for( space = min_space; space <= max_space; space += increment )
  {
    if( regn.fits( space/2 ) )
    {
      boost::shared_ptr< geometry::grid_generator > grid;
      BOOST_CHECK_NO_THROW( grid = regn.make_gridder( space, rand ) );
      BOOST_CHECK_LE( space, grid->spacing() );
    }
    else
    {
      BOOST_CHECK_THROW( regn.make_gridder( space, rand ), std::runtime_error );
    }
  }
}


!!!262320.cpp!!!	test_grid_generator(inout gridder : grid_generator) : void
// Store generated coordinates
std::vector< particle::coordinate > postns;
// Initial grid point count
const std::size_t count { gridder->size() };
// Test serialization
std::stringstream store;
{
   boost::archive::text_oarchive oa(store);
   // write class instance to archive
   BOOST_REQUIRE_NO_THROW( oa << gridder );
}

// Test grid next
for ( std::size_t idx = 0; idx != count; ++idx )
{
   // Not empty before first 'count' calls to gridder->next
   BOOST_CHECK( not gridder->empty() );
   // Non zero size before first 'count' calls to gridder->next
   BOOST_CHECK_LT( 0, gridder->size() );

   const std::size_t remain { gridder->size() };
   particle::coordinate pnt;

   // Next return is not false for first 'count' - 1 calls to gridder->next
   // and false for the 'count'th call.
   BOOST_REQUIRE_MESSAGE( gridder->next( pnt ), "gridder.next() is false before expected end point" );

   // Size decreases by one during call to gridder->next
   BOOST_CHECK_EQUAL( remain - 1, gridder->size() );

   // Generated position is not the same as any previously generated position
   for (auto const& p2 : postns )
   {
      BOOST_REQUIRE_NE( p2, pnt );
   }

   // store generated position.
   postns.push_back( pnt );
}
{
   particle::coordinate pnt;
   BOOST_REQUIRE_MESSAGE( not gridder->next( pnt), "gridder.next() is true after expected end point" );
}
// Gridder is empty after 'count' calls
BOOST_CHECK( gridder->empty() );
// Gridder has zero size after 'count' calls
BOOST_CHECK_EQUAL(0, gridder->size());

// Test deserialization
{
   boost::shared_ptr< geometry::grid_generator > g;
   boost::archive::text_iarchive oa(store);
   // read class instance from archive
   BOOST_REQUIRE_NO_THROW( oa >> g );

   BOOST_REQUIRE_EQUAL( count, g->size() );
   for ( std::size_t idx = 0; idx != count; ++idx )
   {
      // Not empty before first 'count' calls to gridder->next
      BOOST_CHECK( not g->empty() );
      // Non zero size before first 'count' calls to gridder->next
      BOOST_CHECK_LT( 0, g->size() );

      const std::size_t remain { g->size() };
      particle::coordinate pnt;

      // Next return is not false for first 'count' - 1 calls to gridder->next
      // and false for the 'count'th call.
      BOOST_REQUIRE_MESSAGE( g->next( pnt), "gridder->next() is false before count calls" );
      // Expect copy to return points in same order as original
      BOOST_CHECK_EQUAL( pnt, postns[idx] );

      // Size decreases by one during call to gridder->next
      BOOST_CHECK_EQUAL( remain - 1, g->size() );
   }

}

!!!262448.cpp!!!	circle_grid_lifetime_test() : void
{
  // Test is canonical pattern
  BOOST_CHECK( std::is_default_constructible< geometry::circle_grid >::type {} );
  BOOST_CHECK( std::is_copy_constructible< geometry::circle_grid >::type {} );
  BOOST_CHECK( std::is_move_constructible< geometry::circle_grid >::type {} );
  BOOST_CHECK( ( std::is_assignable< geometry::circle_grid, geometry::circle_grid >::type {} ) );
  BOOST_CHECK( not std::has_virtual_destructor< geometry::circle_grid >::type {} );
}
std::stringstream log;
{
   // Circle grid default ctor
   geometry::circle_grid var1;
   // Default should have no size
   BOOST_REQUIRE_EQUAL( var1.size(), 0 );
   // Should throw error
   particle::coordinate pnt;
   BOOST_REQUIRE_THROW( var1.set_xy( pnt, 0 ), std::runtime_error );
}
{
   // Circle grid copy and serialization test
   const double radius{ 3.0 };
   const double space{ 1.0 };
   std::stringstream ss;
   {
      geometry::circle_grid var1( radius, space );
      BOOST_CHECK_EQUAL( var1.size(), 21 );
      {
      geometry::circle_grid var2( var1 );
      BOOST_CHECK_EQUAL( var2.size(), 21 );
      BOOST_CHECK_EQUAL( var1.size(), 21 );
      }
      {
      geometry::circle_grid var3;
      BOOST_CHECK_EQUAL( var3.size(), 0 );
      var3 = var1;
      BOOST_CHECK_EQUAL( var3.size(), 21 );
      BOOST_CHECK_EQUAL( var1.size(), 21 );
      }
      {
        geometry::circle_grid var4( var1 );
        geometry::circle_grid var5( std::move( var4 ) );
        BOOST_CHECK_EQUAL( var5.size(), 21 );
      }

      boost::archive::text_oarchive oa(ss);
      // write class instance to archive
      oa << var1;
      BOOST_CHECK_EQUAL( var1.size(), 21 );
   }
   {
      geometry::circle_grid var1;
      BOOST_CHECK_EQUAL( var1.size(), 0 );
      boost::archive::text_iarchive ia(ss);
      // read class instance from archive
      ia >> var1;
      BOOST_CHECK_EQUAL( var1.size(), 21 );
   }
}
!!!1014960.cpp!!!	circle_grid_methods_test() : void
{
   // Circle grid real ctor
   const double radius{ 3.0 };
   const double space{ 1.0 };
   geometry::circle_grid var1( radius, space );
   BOOST_CHECK_EQUAL( var1.size(), 21 );

   const double r_edge( std::pow( radius - space, 2 ) );
   const double r_max( std::pow( radius - ( space/2 ), 2 ) );
   const std::size_t size( var1.size() );
   std::size_t countr1 = 0; // count of elements near r
   for (std::size_t idx = 0; idx != size; ++idx)
   {
      BOOST_CHECK_LT(0, var1.size());
      particle::coordinate pnt;
      var1.set_xy( pnt, idx );
      const double r(pnt.x*pnt.x + pnt.y*pnt.y);
      BOOST_CHECK_LE( r, r_max );
      if (r >= r_edge) ++countr1;
   }
   BOOST_CHECK_EQUAL( size, var1.size() );
   // Should throw error
   particle::coordinate pnt;
   BOOST_REQUIRE_THROW( var1.set_xy( pnt, size ), std::runtime_error );
   BOOST_CHECK_LT( 0, countr1 );
   const std::size_t mod4{ countr1 % 4 };
   const std::size_t mod8{ countr1 % 8 };
   BOOST_CHECK_MESSAGE( mod4 == 0, "4 fold symmetry error: 0 != countr1 % 4" );
   BOOST_WARN_MESSAGE( mod8 == 0, "8 fold symmetry error: 0 != countr1 % 8" );
}
{
   std::vector< particle::coordinate > canon;
   // Circle grid copy and serialization test
   const double radius{ 3.0 };
   const double space{ 1.0 };
   std::stringstream ss;
   {
      geometry::circle_grid var1 = geometry::circle_grid( radius, space );
      BOOST_CHECK_EQUAL( var1.size(), 21 );

      boost::archive::text_oarchive oa(ss);
      // write class instance to archive
      oa << var1;

      const std::size_t size( var1.size() );
      canon.resize( size );
      for (std::size_t idx = 0; idx != size; ++idx)
      {
         var1.set_xy( canon[ idx ], idx );
         BOOST_CHECK_LT(0, var1.size());
      }
   }
   {
      geometry::circle_grid var3;
      BOOST_CHECK_EQUAL( var3.size(), 0 );
      boost::archive::text_iarchive ia(ss);
      // read class instance from archive
      ia >> var3;
      BOOST_CHECK_EQUAL( var3.size(), 21 );
      BOOST_REQUIRE_EQUAL( var3.size(), canon.size() );
      for (std::size_t idx = 0; idx != var3.size(); ++idx)
      {
         particle::coordinate pnt;
         var3.set_xy( pnt, idx );
         BOOST_CHECK_EQUAL( pnt, canon[idx] );
      }

   }
   {
      // circle grid that should be used in tubular grid
      geometry::circle_grid var1( 8.5, 0.5 );
      BOOST_CHECK_EQUAL( var1.size(), 861 );
   }
}
!!!1015088.cpp!!!	cubic_grid_lifetime_test() : void
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< geometry::cubic_grid >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< geometry::cubic_grid >::type {} );
  BOOST_CHECK( not std::is_move_constructible< geometry::cubic_grid >::type {} );
  BOOST_CHECK( not( std::is_assignable< geometry::cubic_grid, geometry::cubic_grid >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< geometry::cubic_grid >::type {} );
}
std::stringstream ss;
{
  boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
  utility::random_distribution rgen( generator );
  // Cubic grid ctor from count
  boost::shared_ptr< geometry::cubic_grid > var1( geometry::cubic_grid::make_grid( 30.0, rgen, 216 ) );
  BOOST_CHECK_EQUAL( var1->size(), 216 );

  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  BOOST_REQUIRE_NO_THROW( oa << var1 );
  BOOST_CHECK_EQUAL( var1->size(), 216 );

  // Cubic grid ctor from spacing
  boost::shared_ptr< geometry::cubic_grid > var2( geometry::cubic_grid::make_grid( 30.0, var1->spacing(), rgen ) );
  BOOST_CHECK_EQUAL( var2->size(), 216 );
  BOOST_CHECK_EQUAL( var2->spacing(), var1->spacing() );
}
{
  boost::shared_ptr< geometry::cubic_grid > var1;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  BOOST_REQUIRE_NO_THROW( ia >> var1 );
  BOOST_CHECK_EQUAL( var1->size(), 216 );
}

!!!427185.cpp!!!	cubic_grid_test() : void
boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
utility::random_distribution rgen( generator );
std::vector< particle::coordinate > canon;
// Cubic grid 30.0, 216
// 216**1/3 => 6
// 30/6 => 5 (spacing)
// Edge spacing => 2.5
// Min == 2.5; Max == 27.5
{
  // cubic grid ctor(length, numpart, ranf)
  boost::shared_ptr< geometry::grid_generator > var1( geometry::cubic_grid::make_grid( 30.0, rgen, 216 ) );
  BOOST_CHECK_EQUAL( var1->size(), 216 );
  BOOST_CHECK( not var1->empty() );
  // Test base class behavior
  geometry_test::test_grid_generator( var1 );
}
{
  // Test all coordinates are in the expected
  // range.
  boost::shared_ptr< geometry::cubic_grid > var1( geometry::cubic_grid::make_grid( 30.0, rgen, 216 ) );

  boost::shared_ptr< geometry::cubic_grid > var2;
  {
    std::stringstream ss;
    boost::archive::text_oarchive oa( ss );
    // write class instance to archive
    oa << var1;
    boost::archive::text_iarchive ia( ss );
    // read class instance from archive
    BOOST_CHECK_NO_THROW( ia >> var2 );
    BOOST_CHECK_EQUAL( var2->size(), 216 );
  }
  const std::size_t size { var1->size() };
  canon.resize( size );
  for( std::size_t idx = 0; idx != size; ++idx )
  {
    particle::coordinate pnt;
    particle::coordinate pnt2;
    var1->next( pnt );
    var2->next( pnt2 );
    BOOST_CHECK_EQUAL( pnt, pnt2 );
    BOOST_CHECK_EQUAL( var1->size(), ( size - idx - 1 ) );
    BOOST_CHECK( not var1->empty() or ( size == idx + 1 ) );
    BOOST_CHECK_LE( pnt.x, 27.5 );
    BOOST_CHECK_LE( pnt.y, 27.5 );
    BOOST_CHECK_LE( pnt.z, 27.5 );
    BOOST_CHECK_LE( 2.5, pnt.x );
    BOOST_CHECK_LE( 2.5, pnt.y );
    BOOST_CHECK_LE( 2.5, pnt.z );
    canon[idx] = pnt;
  }
  // Check every valid point in the grid is generated
  // by converting grid position into an index
  std::vector< bool > check( size, false );
  std::vector< size_t > indices( size );
  for( std::size_t ix = 0; ix != size; ++ix )
  {
    particle::coordinate pnt( canon[ix] );
    std::size_t idx( ( ( ( pnt.x - 2.5 ) * 6 + pnt.y - 2.5 ) * 6 + ( pnt.z - 2.5 ) ) / 5.0 );
    // Check generated index is less than size
    BOOST_CHECK_LT( idx, size );
    indices[ix] = idx;
    // Check generated index has not already seen
    BOOST_CHECK( not check[idx] );
    check[idx] = true;
  }
  {
    std::sort( indices.begin(), indices.end() );
    for( std::size_t ix = 0; ix != size; ++ix )
    {
      // Check generated index runs from 0 to 'size'
      BOOST_CHECK_EQUAL( ix, indices[ix] );
    }
  }
  // Check for missing (false) indices.
  BOOST_CHECK( check.end() == std::find( check.begin(), check.end(), false ) );
}

!!!1015216.cpp!!!	tubular_grid_lifetime_test() : void
boost::shared_ptr< boost::mt19937> generator(new boost::mt19937);
std::stringstream log;
utility::random_distribution rgen(generator);
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< geometry::tubular_grid >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< geometry::tubular_grid >::type {} );
  BOOST_CHECK( not std::is_move_constructible< geometry::tubular_grid >::type {} );
  BOOST_CHECK( not( std::is_assignable< geometry::tubular_grid, geometry::tubular_grid >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< geometry::tubular_grid >::type {} );
}
std::stringstream ss;
{
  boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
  utility::random_distribution rgen( generator );
  // Cubic grid main ctor
  boost::shared_ptr< geometry::tubular_grid > var1( new geometry::tubular_grid( 31.0, 8.5, 2.5, rgen ) );
  BOOST_CHECK_EQUAL( var1->size(), 300 );

  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  BOOST_REQUIRE_NO_THROW( oa << var1 );
  BOOST_CHECK_EQUAL( var1->size(), 300 );
}
{
  boost::shared_ptr< geometry::tubular_grid > var1;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  BOOST_REQUIRE_NO_THROW( ia >> var1 );
  BOOST_CHECK_EQUAL( var1->size(), 300 );
}
!!!427313.cpp!!!	tubular_grid_test() : void
boost::shared_ptr< boost::mt19937> generator(new boost::mt19937);
std::stringstream log;
utility::random_distribution rgen(generator);
// Cylindrical grid 
// HLENGTH 31.0,
// RADIUS  8.5
// SPACING 0.5
// ZGRID = (31 - .5) / .5 = 61
// XYGRID = Y \   X
//             \        2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x
//              \ 0     0.5   1     1.5   2     2.5   3     3.5   4     4.5   5     5.5   6     6.5   7     7.5   8
//               \---------------------------------------------------------------------------------------------------
//    33    0    |0     0.5   1     1.5   2     2.5   3     3.5   4     4.5   5     5.5   6     6.5   7     7.5   8.0
// 2x 33    0.5  |0.5   0.7   1.1   1.6   2.1   2.5   3.0   3.5   4.0   4.5   5.0   5.5   6.0   6.5   7.0   7.5   8.0
// 2x 33    1    |1     1.1   1.4   1.8   2.2   2.7   3.2   3.6   4.1   4.6   5.1   5.6   6.1   6.6   7.1   7.6   8.1
// 2x 33    1.5  |1.5   1.6   1.8   2.1   2.5   2.9   3.4   3.8   4.3   4.7   5.2   5.7   6.2   6.7   7.2   7.6   8.1
// 2x 33    2    |2     2.1   2.2   2.5   2.8   3.2   3.6   4.0   4.5   4.9   5.4   5.9   6.3   6.8   7.3   7.8   8.2
// 2x 31    2.5  |2.5   2.5   2.7   2.9   3.2   3.5   3.9   4.3   4.7   5.1   5.6   6.0   6.5   7.0   7.4   7.9
// 2x 31    3    |3     3.0   3.2   3.4   3.6   3.9   4.2   4.6   5.0   5.4   5.8   6.3   6.7   7.2   7.6   8.1
// 2x 29    3.5  |3.5   3.5   3.6   3.8   4.0   4.3   4.6   4.9   5.3   5.7   6.1   6.5   6.9   7.4   7.8
// 2x 29    4    |4     4.0   4.1   4.3   4.5   4.7   5.0   5.3   5.7   6.0   6.4   6.8   7.2   7.6   8.1
// 2x 27    4.5  |4.5   4.5   4.6   4.7   4.9   5.1   5.4   5.7   6.0   6.4   6.7   7.1   7.5   7.9
// 2x 27    5    |5     5.0   5.1   5.2   5.4   5.6   5.8   6.1   6.4   6.7   7.1   7.4   7.8   8.2
// 2x 25    5.5  |5.5   5.5   5.6   5.7   5.9   6.0   6.3   6.5   6.8   7.1   7.4   7.8   8.1
// 2x 23    6    |6     6.0   6.1   6.2   6.3   6.5   6.7   6.9   7.2   7.5   7.8   8.1
// 2x 21    6.5  |6.5   6.5   6.6   6.7   6.8   7.0   7.2   7.4   7.6   7.9   8.2
// 2x 17    7    |7     7.0   7.1   7.2   7.3   7.4   7.6   7.8   8.1
// 2x 13    7.5  |7.5   7.5   7.6   7.6   7.8   7.9   8.1
// 2x 5     8    |8     8.0   8.1   8.1   8.2 
// ======
//    861
//
{
  // Tubular grid ctor (with spacing)
   boost::shared_ptr< geometry::grid_generator > var1( new geometry::tubular_grid( 31.0, 8.5, 2.5 ) );

  BOOST_CHECK( not var1->empty() );
  // Test base class behavior
  geometry_test::test_grid_generator( var1 );
}
{
  // Tubular grid ctor (with target grid point)
  boost::shared_ptr< geometry::grid_generator > var1( new geometry::tubular_grid( 31.0, 8.5, 500 ) );

  BOOST_CHECK_LE( 500, var1->size() );
  BOOST_CHECK_LE( 0.0, var1->spacing() );
  BOOST_CHECK( not var1->empty() );
}

{
  // Tubular grid test: constructed with defined spacing
   const double length{ 31.0 };
   const double radius{ 8.5 };
   const double spacing{ 0.5 };
  geometry::tubular_grid var1 (length, radius, spacing);
  BOOST_CHECK_EQUAL(var1.size(), 861*62);
  // Should have some grid points within 3/2*'spacing' of edge
  const double r_edge{ std::pow(radius - (3*spacing/2), 2) };
  const double z1_edge{ (length - 3*spacing)/2 };
  const double z2_edge{ -z1_edge };
  // should have no grid points within ('spacing'/2) of edge
  const double r_max{ std::pow(radius - spacing/2.0, 2) };
  const double z1_max{ (length - spacing)/ 2.0 };
  const double z2_max{ -z1_max };
  const double z_min{ spacing / 2.0 };
  // Number of grid points
  const std::size_t size{ var1.size() };
  std::set< double > zvalues;

  std::size_t counter_spacing_r1 = 0; // count of elements near r, when z>0
  std::size_t counter_spacing_r2 = 0; // count of elements near r, when z<0
  std::size_t counter_spacing_z1 = 0; // count of elements near +z
  std::size_t counter_spacing_z2 = 0; // count of elements near -z

  for (std::size_t idx = 0; idx != size; ++idx)
  {
    BOOST_CHECK_LT(0, var1.size());
    particle::coordinate pnt;
    var1.next(pnt);
    const double r(pnt.x*pnt.x + pnt.y*pnt.y);
    BOOST_CHECK_LE( r, r_max );
    BOOST_CHECK_LE( pnt.z, z1_max );
    BOOST_CHECK_LE( z2_max, pnt.z );
    BOOST_CHECK_LE( z_min, std::abs(pnt.z) );

    if (r > r_edge and pnt.z > 0.0) ++counter_spacing_r1;
    if (r > r_edge and pnt.z < 0.0) ++counter_spacing_r2;
    if (pnt.z > z1_edge) ++counter_spacing_z1;
    if (pnt.z < z2_edge) ++counter_spacing_z2;
    zvalues.insert( pnt.z );
  }
  log << "ZMIN " << z_min << " ZMAX " << z1_max << " ZEDGE " << z1_edge << " SPC " << spacing << "\n";
  for (double zz : zvalues )
  {
     log << zz << " ";
  }
  log << "\n";
  BOOST_CHECK_EQUAL( 0, var1.size() );
  BOOST_CHECK_LT( 0, counter_spacing_r1 );
  BOOST_CHECK_EQUAL( counter_spacing_r1, counter_spacing_r2 );
  // r count should be multiple of 4*60
  const std::size_t mod_60{ counter_spacing_r1 % 62 };
  BOOST_CHECK_MESSAGE( 0 == mod_60, "0 == (counter_spacing_r1 % 62)" );
  const std::size_t mod_120{ counter_spacing_r1 % (2*62) };
  BOOST_CHECK_MESSAGE( 0 == mod_120, "2 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (2*62))" );
  const std::size_t mod_240{ counter_spacing_r1 % (4*62) };
  BOOST_CHECK_MESSAGE( 0 == mod_240, "4 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (4*62))" );
  const std::size_t mod_480{ counter_spacing_r1 % (8*62) };
  BOOST_WARN_MESSAGE( 0 == mod_480, "8 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (4*62))" );


  BOOST_CHECK_LT( 0, counter_spacing_z1 );
  BOOST_CHECK_EQUAL( counter_spacing_z1, counter_spacing_z2 );
  // z count should be 861
  BOOST_CHECK_EQUAL( 861, counter_spacing_z1 );
}
{
  // Tubular grid: constructed with target grid point minimum count
   const double length{ 31.0 };
   const double radius{ 8.5 };
   geometry::tubular_grid var1( length, radius, 500);

  std::set< double > zvalues;

  // Should have no points within (spacing/2) of edge
  const double r_max( std::pow(radius - var1.spacing()/2.0, 2) );
  const double z1_max( (length - var1.spacing())/2.0 );
  const double z2_max( -z1_max );
  const double z_min( var1.spacing()/2.0 );
  // Should have some points within 1.5*spacing of edge
  const double r_edge( std::pow(radius - (3*var1.spacing()/2), 2) );
  const double z1_edge( (length - 3*var1.spacing())/2 );
  const double z2_edge( -z1_edge );

  std::size_t counter_ntarget_r1 = 0; // count of elements near r, when z>0
  std::size_t counter_ntarget_r2 = 0; // count of elements near r, when z<0
  std::size_t counter_ntarget_z1 = 0; // count of elements near +z
  std::size_t counter_ntarget_z2 = 0; // count of elements near -z

  particle::coordinate pnt;
  while ( var1.next( pnt ) )
  {
    const double r( pnt.x*pnt.x + pnt.y*pnt.y );
    // Test that no grid points get closer than 'spacing'/2 from edge
    BOOST_CHECK_LE( r, r_max );
    BOOST_CHECK_LE( pnt.z, z1_max );
    BOOST_CHECK_LE( z2_max, pnt.z );
    BOOST_CHECK_LE( z_min, std::abs( pnt.z ) );// no points nearer to z=0.0 than spacing/2

    if ( r > r_edge and pnt.z > 0.0 ) ++counter_ntarget_r1;
    if ( r > r_edge and pnt.z < 0.0 ) ++counter_ntarget_r2;
    if ( pnt.z > z1_edge ) ++counter_ntarget_z1;
    if ( pnt.z < z2_edge ) ++counter_ntarget_z2;
    zvalues.insert( pnt.z );
  }
  log << "ZMIN " << z_min << " ZMAX " << z1_max << " ZEDGE " << z1_edge << " SPC " << var1.spacing() << "\n";
  for (double zz : zvalues )
  {
     log << zz << " ";
  }
  log << "\n";
  BOOST_CHECK_EQUAL( 0, var1.size() );
  // Test that some  grid points get closer than 'spacing' from edge
  // and that there are the same number on each side of z=0
  BOOST_CHECK_LT( 0, counter_ntarget_r1 );
  BOOST_CHECK_EQUAL( counter_ntarget_r1, counter_ntarget_r2 );
  BOOST_CHECK_LT( 0, counter_ntarget_z1 );
  BOOST_CHECK_EQUAL( counter_ntarget_z1, counter_ntarget_z2 );
  const std::size_t mod_2{ counter_ntarget_r2 % 2 };
  BOOST_CHECK_MESSAGE( 0 == mod_2, "2 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 2)" );
  const std::size_t mod_4{ counter_ntarget_r2 % 4 };
  BOOST_CHECK_MESSAGE( 0 == mod_4, "4 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 4)" );
  const std::size_t mod_8{ counter_ntarget_r2 % 8 };
  BOOST_WARN_MESSAGE( 0 == mod_8, "8 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 8)" );
}
!!!1015344.cpp!!!	split_tube_grid_lifetime_test() : void
boost::shared_ptr< boost::mt19937> generator(new boost::mt19937);
std::stringstream log;
utility::random_distribution rgen(generator);
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< geometry::split_tube_grid >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< geometry::split_tube_grid >::type {} );
  BOOST_CHECK( not std::is_move_constructible< geometry::split_tube_grid >::type {} );
  BOOST_CHECK( not( std::is_assignable< geometry::split_tube_grid, geometry::split_tube_grid >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< geometry::split_tube_grid >::type {} );
}
std::stringstream ss;
{
  boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
  utility::random_distribution rgen( generator );
  // Cubic grid main ctor
  boost::shared_ptr< geometry::split_tube_grid > var1( new geometry::split_tube_grid( 10.0, 31.0, 8.5, 2.5, rgen ) );
  BOOST_CHECK_EQUAL( var1->size(), 300 );

  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  BOOST_REQUIRE_NO_THROW( oa << var1 );
  BOOST_CHECK_EQUAL( var1->size(), 300 );
}
{
  boost::shared_ptr< geometry::split_tube_grid > var1;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  BOOST_REQUIRE_NO_THROW( ia >> var1 );
  BOOST_CHECK_EQUAL( var1->size(), 300 );
}
!!!1015472.cpp!!!	split_tube_grid_test() : void
boost::shared_ptr< boost::mt19937> generator(new boost::mt19937);
std::stringstream log;
utility::random_distribution rgen(generator);
const double offset( 10.0 );
// Cylindrical grid 
// HLENGTH 31.0,
// RADIUS  8.5
// SPACING 0.5
// ZGRID = (31 - .5) / .5 = 61
// XYGRID = Y \   X
//             \        2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x    2x
//              \ 0     0.5   1     1.5   2     2.5   3     3.5   4     4.5   5     5.5   6     6.5   7     7.5   8
//               \---------------------------------------------------------------------------------------------------
//    33    0    |0     0.5   1     1.5   2     2.5   3     3.5   4     4.5   5     5.5   6     6.5   7     7.5   8.0
// 2x 33    0.5  |0.5   0.7   1.1   1.6   2.1   2.5   3.0   3.5   4.0   4.5   5.0   5.5   6.0   6.5   7.0   7.5   8.0
// 2x 33    1    |1     1.1   1.4   1.8   2.2   2.7   3.2   3.6   4.1   4.6   5.1   5.6   6.1   6.6   7.1   7.6   8.1
// 2x 33    1.5  |1.5   1.6   1.8   2.1   2.5   2.9   3.4   3.8   4.3   4.7   5.2   5.7   6.2   6.7   7.2   7.6   8.1
// 2x 33    2    |2     2.1   2.2   2.5   2.8   3.2   3.6   4.0   4.5   4.9   5.4   5.9   6.3   6.8   7.3   7.8   8.2
// 2x 31    2.5  |2.5   2.5   2.7   2.9   3.2   3.5   3.9   4.3   4.7   5.1   5.6   6.0   6.5   7.0   7.4   7.9
// 2x 31    3    |3     3.0   3.2   3.4   3.6   3.9   4.2   4.6   5.0   5.4   5.8   6.3   6.7   7.2   7.6   8.1
// 2x 29    3.5  |3.5   3.5   3.6   3.8   4.0   4.3   4.6   4.9   5.3   5.7   6.1   6.5   6.9   7.4   7.8
// 2x 29    4    |4     4.0   4.1   4.3   4.5   4.7   5.0   5.3   5.7   6.0   6.4   6.8   7.2   7.6   8.1
// 2x 27    4.5  |4.5   4.5   4.6   4.7   4.9   5.1   5.4   5.7   6.0   6.4   6.7   7.1   7.5   7.9
// 2x 27    5    |5     5.0   5.1   5.2   5.4   5.6   5.8   6.1   6.4   6.7   7.1   7.4   7.8   8.2
// 2x 25    5.5  |5.5   5.5   5.6   5.7   5.9   6.0   6.3   6.5   6.8   7.1   7.4   7.8   8.1
// 2x 23    6    |6     6.0   6.1   6.2   6.3   6.5   6.7   6.9   7.2   7.5   7.8   8.1
// 2x 21    6.5  |6.5   6.5   6.6   6.7   6.8   7.0   7.2   7.4   7.6   7.9   8.2
// 2x 17    7    |7     7.0   7.1   7.2   7.3   7.4   7.6   7.8   8.1
// 2x 13    7.5  |7.5   7.5   7.6   7.6   7.8   7.9   8.1
// 2x 5     8    |8     8.0   8.1   8.1   8.2 
// ======
//    861
//
{
  // Tubular grid ctor (with spacing)
   boost::shared_ptr< geometry::grid_generator > var1( new geometry::split_tube_grid( offset, 31.0, 8.5, 2.5 ) );

  BOOST_CHECK( not var1->empty() );
  // Test base class behavior
  geometry_test::test_grid_generator( var1 );
}
{
  // Tubular grid ctor (with target grid point)
  boost::shared_ptr< geometry::grid_generator > var1( new geometry::split_tube_grid( offset, 31.0, 8.5, 500 ) );

  BOOST_CHECK_LE( 500, var1->size() );
  BOOST_CHECK_LE( 0.0, var1->spacing() );
  BOOST_CHECK( not var1->empty() );
}

{
  // Tubular grid test: constructed with defined spacing
   const double length{ 31.0 };
   const double radius{ 8.5 };
   const double spacing{ 0.5 };
  geometry::split_tube_grid var1 (offset, length, radius, spacing);
  BOOST_CHECK_EQUAL(var1.size(), 861*62);
  // Should have some grid points within 3/2*'spacing' of edge
  const double r_edge{ std::pow(radius - (3*spacing/2), 2) };
  const double z1_edge{ (length - 3*spacing)/2 + offset };
  const double z2_edge{ -z1_edge };
  // should have no grid points within ('spacing'/2) of edge
  const double r_max{ std::pow(radius - spacing/2.0, 2) };
  const double z1_max{ (length - spacing)/ 2.0 + offset };
  const double z2_max{ -z1_max };
  const double z_min{ spacing / 2.0 + offset };
  // Number of grid points
  const std::size_t size{ var1.size() };
  std::set< double > zvalues;

  std::size_t counter_spacing_r1 = 0; // count of elements near r, when z>0
  std::size_t counter_spacing_r2 = 0; // count of elements near r, when z<0
  std::size_t counter_spacing_z1 = 0; // count of elements near +z
  std::size_t counter_spacing_z2 = 0; // count of elements near -z

  for (std::size_t idx = 0; idx != size; ++idx)
  {
    BOOST_CHECK_LT(0, var1.size());
    particle::coordinate pnt;
    var1.next(pnt);
    const double r(pnt.x*pnt.x + pnt.y*pnt.y);
    BOOST_CHECK_LE( r, r_max );
    BOOST_CHECK_LE( pnt.z, z1_max );
    BOOST_CHECK_LE( z2_max, pnt.z );
    BOOST_CHECK_LE( z_min, std::abs(pnt.z) );

    if (r > r_edge and pnt.z > 0.0) ++counter_spacing_r1;
    if (r > r_edge and pnt.z < 0.0) ++counter_spacing_r2;
    if (pnt.z > z1_edge) ++counter_spacing_z1;
    if (pnt.z < z2_edge) ++counter_spacing_z2;
    zvalues.insert( pnt.z );
  }
  log << "ZMIN " << z_min << " ZMAX " << z1_max << " ZEDGE " << z1_edge << " SPC " << spacing << "\n";
  for (double zz : zvalues )
  {
     log << zz << " ";
  }
  log << "\n";
  BOOST_CHECK_EQUAL( 0, var1.size() );
  BOOST_CHECK_LT( 0, counter_spacing_r1 );
  BOOST_CHECK_EQUAL( counter_spacing_r1, counter_spacing_r2 );
  // r count should be multiple of 4*60
  const std::size_t mod_60{ counter_spacing_r1 % 62 };
  BOOST_CHECK_MESSAGE( 0 == mod_60, "0 == (counter_spacing_r1 % 62)" );
  const std::size_t mod_120{ counter_spacing_r1 % (2*62) };
  BOOST_CHECK_MESSAGE( 0 == mod_120, "2 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (2*62))" );
  const std::size_t mod_240{ counter_spacing_r1 % (4*62) };
  BOOST_CHECK_MESSAGE( 0 == mod_240, "4 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (4*62))" );
  const std::size_t mod_480{ counter_spacing_r1 % (8*62) };
  BOOST_WARN_MESSAGE( 0 == mod_480, "8 FOLD SYMMETRY FAILURE: 0 == (counter_spacing_r1 % (4*62))" );


  BOOST_CHECK_LT( 0, counter_spacing_z1 );
  BOOST_CHECK_EQUAL( counter_spacing_z1, counter_spacing_z2 );
  // z count should be 861
  BOOST_CHECK_EQUAL( 861, counter_spacing_z1 );
}
{
  // Tubular grid: constructed with target grid point minimum count
   const double length{ 31.0 };
   const double radius{ 8.5 };
   geometry::split_tube_grid var1( offset, length, radius, 500);

  std::set< double > zvalues;

  // Should have no points within (spacing/2) of edge
  const double r_max( std::pow(radius - var1.spacing()/2.0, 2) );
  const double z1_max( (length - var1.spacing())/2.0 + offset );
  const double z2_max( -z1_max );
  const double z_min( var1.spacing()/2.0 + offset );
  // Should have some points within 1.5*spacing of edge
  const double r_edge( std::pow(radius - (3*var1.spacing()/2), 2) );
  const double z1_edge( (length - 3*var1.spacing())/2 + offset );
  const double z2_edge( -z1_edge );

  std::size_t counter_ntarget_r1 = 0; // count of elements near r, when z>0
  std::size_t counter_ntarget_r2 = 0; // count of elements near r, when z<0
  std::size_t counter_ntarget_z1 = 0; // count of elements near +z
  std::size_t counter_ntarget_z2 = 0; // count of elements near -z

  particle::coordinate pnt;
  while ( var1.next( pnt ) )
  {
    const double r( pnt.x*pnt.x + pnt.y*pnt.y );
    // Test that no grid points get closer than 'spacing'/2 from edge
    BOOST_CHECK_LE( r, r_max );
    BOOST_CHECK_LE( pnt.z, z1_max );
    BOOST_CHECK_LE( z2_max, pnt.z );
    BOOST_CHECK_LE( z_min, std::abs( pnt.z ) );// no points nearer to z=0.0 than spacing/2

    if ( r > r_edge and pnt.z > 0.0 ) ++counter_ntarget_r1;
    if ( r > r_edge and pnt.z < 0.0 ) ++counter_ntarget_r2;
    if ( pnt.z > z1_edge ) ++counter_ntarget_z1;
    if ( pnt.z < z2_edge ) ++counter_ntarget_z2;
    zvalues.insert( pnt.z );
  }
  log << "ZMIN " << z_min << " ZMAX " << z1_max << " ZEDGE " << z1_edge << " SPC " << var1.spacing() << "\n";
  for (double zz : zvalues )
  {
     log << zz << " ";
  }
  log << "\n";
  BOOST_CHECK_EQUAL( 0, var1.size() );
  // Test that some  grid points get closer than 'spacing' from edge
  // and that there are the same number on each side of z=0
  BOOST_CHECK_LT( 0, counter_ntarget_r1 );
  BOOST_CHECK_EQUAL( counter_ntarget_r1, counter_ntarget_r2 );
  BOOST_CHECK_LT( 0, counter_ntarget_z1 );
  BOOST_CHECK_EQUAL( counter_ntarget_z1, counter_ntarget_z2 );
  const std::size_t mod_2{ counter_ntarget_r2 % 2 };
  BOOST_CHECK_MESSAGE( 0 == mod_2, "2 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 2)" );
  const std::size_t mod_4{ counter_ntarget_r2 % 4 };
  BOOST_CHECK_MESSAGE( 0 == mod_4, "4 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 4)" );
  const std::size_t mod_8{ counter_ntarget_r2 % 8 };
  BOOST_WARN_MESSAGE( 0 == mod_8, "8 FOLD SYMMETRY FAILURE: 0 == (counter_ntarget_r2 % 8)" );
}
!!!1022640.cpp!!!	periodic_cube_region_lifetime_test() : void
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< geometry::periodic_cube_region >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< geometry::periodic_cube_region >::type {} );
  BOOST_CHECK( not std::is_move_constructible< geometry::periodic_cube_region >::type {} );
  BOOST_CHECK( not( std::is_assignable< geometry::periodic_cube_region, geometry::periodic_cube_region >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< geometry::periodic_cube_region >::type {} );
}
std::stringstream ss;
{
  // Cubic grid main ctor
  boost::shared_ptr< geometry::periodic_cube_region > var1( new geometry::periodic_cube_region( "bulk", 10.0 ) );
  BOOST_CHECK_EQUAL( var1->length(), 10.0 );
  BOOST_CHECK_EQUAL( var1->label(), "bulk" );
  BOOST_CHECK_EQUAL( var1->volume( 1.0 ), 1000.0 );

  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  BOOST_REQUIRE_NO_THROW( oa << var1 );
}
{
  boost::shared_ptr< geometry::periodic_cube_region > var1;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  BOOST_REQUIRE_NO_THROW( ia >> var1 );
  BOOST_CHECK_EQUAL( var1->length(), 10.0 );
  BOOST_CHECK_EQUAL( var1->label(), "bulk" );
  BOOST_CHECK_EQUAL( var1->volume( 1.0 ), 1000.0 );
}
!!!1022768.cpp!!!	periodic_cube_region_method_test() : void
const std::string label( "bulk" );
// Cubic grid main ctor
boost::shared_ptr< geometry::periodic_cube_region > var1( new geometry::periodic_cube_region( label, 10.0 ) );
BOOST_CHECK_EQUAL( var1->length(), 10.0 );

{
  particle::coordinate inside( 0.0, 10.0, 10.0 );
  particle::coordinate outside( 0.0, -0.1, 10.0 );
  double okradius( 1.0 );
  double bigradius( 10.1 );
  // tests fits, is_inside, new_position and new_position_offset
  geometry_test::region_new_position_test( *var1, inside, outside, okradius, bigradius );
  geometry_test::region_serialization_test( var1 );
}
// Test volume (should be the same regardless of size)
{
  BOOST_CHECK_EQUAL( var1->volume( 1.0 ), 1000.0 );
  BOOST_CHECK_EQUAL( var1->volume( 0.0 ), 1000.0 );
  // should throw on non-fitting radius
  BOOST_CHECK_THROW( var1->volume( 100.0 ), std::runtime_error );
}
// label / set_label
{
  BOOST_CHECK_EQUAL( var1->label(), "bulk" );
  BOOST_CHECK_NO_THROW( var1->set_label( "100" ) );
  BOOST_CHECK_EQUAL( var1->label(), "100" );
  BOOST_CHECK_NO_THROW( var1->set_label( label ) );
  BOOST_CHECK_EQUAL( var1->label(), label );
}
// Calculate distances
{
  // Uses wrapping
  particle::coordinate_set pnts;
  std::vector< double > target, result;
  pnts.resize( 10 );
  // First five points effectively wrap to origin
  pnts.set_x( 0, 0.0 );
  pnts.set_y( 0, 0.0 );
  pnts.set_z( 0 , 0.0 );
  pnts.set_x( 1, 10.0 );
  pnts.set_y( 1, 0.0 );
  pnts.set_z( 1 , 0.0 );
  pnts.set_x( 2, 0.0 );
  pnts.set_y( 2, 10.0 );
  pnts.set_z( 2 , 0.0 );
  pnts.set_x( 3, 0.0 );
  pnts.set_y( 3, 0.0 );
  pnts.set_z( 3 , 10.0 );
  pnts.set_x( 4, 10.0 );
  pnts.set_y( 4, 10.0 );
  pnts.set_z( 4 , 10.0 );
  pnts.set_x( 5, 1.0 );
  pnts.set_y( 5, 0.0 );
  pnts.set_z( 5 , 0.0 );
  pnts.set_x( 6, 0.0 );
  pnts.set_y( 6, 1.0 );
  pnts.set_z( 6 , 1.0 );
  pnts.set_x( 7, 1.0 );
  pnts.set_y( 7, 1.0 );
  pnts.set_z( 7 , 1.0 );
  pnts.set_x( 8, 2.0 );
  pnts.set_y( 8, 2.0 );
  pnts.set_z( 8 , 2.0 );
  pnts.set_x( 9, 5.0 );
  pnts.set_y( 9, 5.0 );
  pnts.set_z( 9 , 5.0 );

  target.resize( 10 );
  particle::coordinate newpos( 0.0, 5.0, 0.0 );
  target[0] = 5.0;
  target[1] = 5.0;
  target[2] = 5.0;
  target[3] = 5.0;
  target[4] = 5.0;
  target[5] = std::sqrt( 26.0 );
  target[6] = std::sqrt( 17.0 );
  target[7] = std::sqrt( 18.0 );
  target[8] = std::sqrt( 17.0 );
  target[9] = std::sqrt( 50.0 );

  geometry::geometry_manager man( var1 );

  man.calculate_distances( newpos, pnts, result, 0, 10 );
  BOOST_REQUIRE_EQUAL( result.size(), 10 );
  for( std::size_t ii = 0; ii != 10; ++ii )
  {
    BOOST_CHECK( utility::feq( result[ii], target[ii] ) );
    particle::coordinate otherpos( pnts.x( ii ), pnts.y( ii ), pnts.z( ii ) );
    BOOST_CHECK( utility::feq( man.calculate_distance_squared( newpos, otherpos ), std::pow( target[ii], 2 ) ) );
  }

}
// change volume
{
  geometry::geometry_manager man( var1 );
  BOOST_CHECK_EQUAL( var1->volume( 0.0 ), 1000.0 );

  BOOST_REQUIRE_NO_THROW( man.change_volume( 900.0, 3.0 ) );
  BOOST_CHECK( utility::feq( var1->volume( 3.0 ), 900.0 ) );
  BOOST_CHECK_EQUAL( var1->volume( 3.0 ), 900.0 );

  BOOST_REQUIRE_THROW( man.change_volume( 729.0, 5.0 ), std::runtime_error  );
}
// make_gridder
{
  geometry_test::region_make_gridder_test( *var1, 1, 500, 0.5, 11.0 );
}
!!!1039536.cpp!!!	cube_region_lifetime_test() : void
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< geometry::cube_region >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< geometry::cube_region >::type {} );
  BOOST_CHECK( not std::is_move_constructible< geometry::cube_region >::type {} );
  BOOST_CHECK( not( std::is_assignable< geometry::cube_region, geometry::cube_region >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< geometry::cube_region >::type {} );
}
std::stringstream ss;
particle::coordinate origin( 1.0, -2.0, 3.0 );
{
  // Cubic grid main ctor
  boost::shared_ptr< geometry::cube_region > var1( new geometry::cube_region( "bulk", 10.0, origin, true ) );
  BOOST_CHECK_EQUAL( var1->length(), 10.0 );
  BOOST_CHECK_EQUAL( var1->label(), "bulk" );
  BOOST_CHECK( var1->is_open() );
  BOOST_CHECK_EQUAL( var1->origin(), origin );

  geometry_test::region_serialization_test( var1 );

  boost::archive::text_oarchive oa( ss );
  // write class instance to archive
  BOOST_REQUIRE_NO_THROW( oa << var1 );
}
{
  boost::shared_ptr< geometry::cube_region > var1;
  boost::archive::text_iarchive ia( ss );
  // read class instance from archive
  BOOST_REQUIRE_NO_THROW( ia >> var1 );
  BOOST_CHECK_EQUAL( var1->length(), 10.0 );
  BOOST_CHECK_EQUAL( var1->label(), "bulk" );
  BOOST_CHECK( var1->is_open() );
  BOOST_CHECK_EQUAL( var1->origin(), origin );
}
!!!1039664.cpp!!!	cube_region_method_open_test() : void
const std::string label( "bulk" );
const particle::coordinate origin( 1.0, -1.0, -2.0 );
// OPEN cube
{
// Cubic grid main ctor
  boost::shared_ptr< geometry::cube_region > var1( new geometry::cube_region( label, 10.0, origin, true ) );
  BOOST_CHECK_EQUAL( var1->length(), 10.0 );

  {
    particle::coordinate inside( 1.0, 8.0, 8.0 );
    particle::coordinate outside( 1.0, -1.1, 8.0 );
    double okradius( 1.0 );
    double bigradius( -1.0 ); // negative number -> any radius fits
    // tests fits, is_inside, new_position and new_position_offset
    geometry_test::region_new_position_test( *var1, inside, outside, okradius, bigradius );
    geometry_test::region_serialization_test( var1 );
  }
  // Test volume (cube is open so should be the same regardless of size)
  {
    BOOST_CHECK_EQUAL( var1->volume( 1.0 ), 1000.0 );
    BOOST_CHECK_EQUAL( var1->volume( 0.0 ), 1000.0 );
    // Any radius fits
    BOOST_CHECK_EQUAL( var1->volume( 100.0 ), 1000.0 );
  }
  // label / set_label
  {
    BOOST_CHECK_EQUAL( var1->label(), "bulk" );
    BOOST_CHECK_NO_THROW( var1->set_label( "100" ) );
    BOOST_CHECK_EQUAL( var1->label(), "100" );
    BOOST_CHECK_NO_THROW( var1->set_label( label ) );
    BOOST_CHECK_EQUAL( var1->label(), label );
  }
  // Calculate distances
  {
    particle::coordinate_set pnts;
    std::vector< double > target, result;
    pnts.resize( 10 );
    pnts.set_x( 0, 0.0 );
    pnts.set_y( 0, 0.0 );
    pnts.set_z( 0, 0.0 );
    pnts.set_x( 1, 10.0 );
    pnts.set_y( 1, 0.0 );
    pnts.set_z( 1, 0.0 );
    pnts.set_x( 2, 0.0 );
    pnts.set_y( 2, 10.0 );
    pnts.set_z( 2, 0.0 );
    pnts.set_x( 3, 0.0 );
    pnts.set_y( 3, 0.0 );
    pnts.set_z( 3, 10.0 );
    pnts.set_x( 4, 10.0 );
    pnts.set_y( 4, 10.0 );
    pnts.set_z( 4, 10.0 );
    pnts.set_x( 5, 1.0 );
    pnts.set_y( 5, 0.0 );
    pnts.set_z( 5, 0.0 );
    pnts.set_x( 6, 0.0 );
    pnts.set_y( 6, 1.0 );
    pnts.set_z( 6, 1.0 );
    pnts.set_x( 7, 1.0 );
    pnts.set_y( 7, 1.0 );
    pnts.set_z( 7, 1.0 );
    pnts.set_x( 8, 2.0 );
    pnts.set_y( 8, 2.0 );
    pnts.set_z( 8, 2.0 );
    pnts.set_x( 9, 5.0 );
    pnts.set_y( 9, 5.0 );
    pnts.set_z( 9, 5.0 );

    target.resize( 10 );
    particle::coordinate newpos( 0.0, 5.0, 0.0 );
    target[0] = 5.0;
    target[1] = std::sqrt( 125.0 );
    target[2] = 5.0;
    target[3] = std::sqrt( 125.0 );
    target[4] = std::sqrt( 225.0 );
    target[5] = std::sqrt( 26.0 );
    target[6] = std::sqrt( 17.0 );
    target[7] = std::sqrt( 18.0 );
    target[8] = std::sqrt( 17.0 );
    target[9] = std::sqrt( 50.0 );

    geometry::geometry_manager man( var1 );

    man.calculate_distances( newpos, pnts, result, 0, 10 );
    BOOST_REQUIRE_EQUAL( result.size(), 10 );
    for( std::size_t ii = 0; ii != 10; ++ii )
    {
      BOOST_CHECK( utility::feq( result[ii], target[ii] ) );
      particle::coordinate otherpos( pnts.x( ii ), pnts.y( ii ), pnts.z( ii ) );
      BOOST_CHECK( utility::feq( man.calculate_distance_squared( newpos, otherpos ), std::pow( target[ii], 2 ) ) );
    }
  }

  // change volume
  geometry::geometry_manager man( var1 );
  BOOST_CHECK_EQUAL( var1->volume( 0.0 ), 1000.0 );

  BOOST_REQUIRE_NO_THROW( man.change_volume( 900.0, 3.0 ) );
  BOOST_CHECK( utility::feq( var1->volume( 3.0 ), 900.0 ) );
  // No radius should be too large for open cube.
  BOOST_CHECK_NO_THROW( man.change_volume( 729.0, 5.0 ) );

  // make_gridder
  geometry_test::region_make_gridder_test( *var1, 1, 500, 0.5, 3.0 );
}



!!!1039792.cpp!!!	cube_region_method_closed_test() : void
const std::string label( "bulk" );
const particle::coordinate origin( 1.0, -1.0, -2.0 );
// OPEN cube
{
// Cubic grid main ctor
  boost::shared_ptr< geometry::cube_region > var1( new geometry::cube_region( label, 10.0, origin, false ) );
  BOOST_CHECK_EQUAL( var1->length(), 10.0 );

  {
    particle::coordinate inside( 2.0, 7.0, 5.0 );
    particle::coordinate outside( 2.0, -0.1, 5.0 );
    double okradius( 1.0 );
    double bigradius( 10.1 );
    // tests fits, is_inside, new_position and new_position_offset
    geometry_test::region_new_position_test( *var1, inside, outside, okradius, bigradius );
  }
  // Test volume (cube is open so should be the same regardless of size)
  {
    BOOST_CHECK_EQUAL( var1->volume( 1.0 ), std::pow( 8, 3 ) );
    BOOST_CHECK_EQUAL( var1->volume( 0.0 ), 1000.0 );
    // should throw on non-fitting radius
    BOOST_CHECK_THROW( var1->volume( 10.1 ), std::runtime_error );
  }
  // label / set_label
  {
    BOOST_CHECK_EQUAL( var1->label(), "bulk" );
    BOOST_CHECK_NO_THROW( var1->set_label( "100" ) );
    BOOST_CHECK_EQUAL( var1->label(), "100" );
    BOOST_CHECK_NO_THROW( var1->set_label( label ) );
    BOOST_CHECK_EQUAL( var1->label(), label );
  }
  // Calculate distances
  {
    particle::coordinate_set pnts;
    std::vector< double > target, result;
    pnts.resize( 10 );
    pnts.set_x( 0, 0.0 );
    pnts.set_y( 0, 0.0 );
    pnts.set_z( 0, 0.0 );
    pnts.set_x( 1, 10.0 );
    pnts.set_y( 1, 0.0 );
    pnts.set_z( 1, 0.0 );
    pnts.set_x( 2, 0.0 );
    pnts.set_y( 2, 10.0 );
    pnts.set_z( 2, 0.0 );
    pnts.set_x( 3, 0.0 );
    pnts.set_y( 3, 0.0 );
    pnts.set_z( 3, 10.0 );
    pnts.set_x( 4, 10.0 );
    pnts.set_y( 4, 10.0 );
    pnts.set_z( 4, 10.0 );
    pnts.set_x( 5, 1.0 );
    pnts.set_y( 5, 0.0 );
    pnts.set_z( 5, 0.0 );
    pnts.set_x( 6, 0.0 );
    pnts.set_y( 6, 1.0 );
    pnts.set_z( 6, 1.0 );
    pnts.set_x( 7, 1.0 );
    pnts.set_y( 7, 1.0 );
    pnts.set_z( 7, 1.0 );
    pnts.set_x( 8, 2.0 );
    pnts.set_y( 8, 2.0 );
    pnts.set_z( 8, 2.0 );
    pnts.set_x( 9, 5.0 );
    pnts.set_y( 9, 5.0 );
    pnts.set_z( 9, 5.0 );

    target.resize( 10 );
    particle::coordinate newpos( 0.0, 5.0, 0.0 );
    target[0] = 5.0;
    target[1] = std::sqrt( 125.0 );
    target[2] = 5.0;
    target[3] = std::sqrt( 125.0 );
    target[4] = std::sqrt( 225.0 );
    target[5] = std::sqrt( 26.0 );
    target[6] = std::sqrt( 17.0 );
    target[7] = std::sqrt( 18.0 );
    target[8] = std::sqrt( 17.0 );
    target[9] = std::sqrt( 50.0 );

    geometry::geometry_manager man( var1 );

    man.calculate_distances( newpos, pnts, result, 0, 10 );
    BOOST_REQUIRE_EQUAL( result.size(), 10 );
    for( std::size_t ii = 0; ii != 10; ++ii )
    {
      BOOST_CHECK( utility::feq( result[ii], target[ii] ) );
      particle::coordinate otherpos( pnts.x( ii ), pnts.y( ii ), pnts.z( ii ) );
      BOOST_CHECK( utility::feq( man.calculate_distance_squared( newpos, otherpos ), std::pow( target[ii], 2 ) ) );
    }
  }
  // change volume
  geometry::geometry_manager man( var1 );
  BOOST_CHECK_EQUAL( var1->volume( 0.0 ), 1000.0 );

  BOOST_REQUIRE_NO_THROW( man.change_volume( 900.0, 3.0 ) );
  BOOST_CHECK( utility::feq( var1->volume( 3.0 ), 900.0 ) );

  BOOST_REQUIRE_NO_THROW( man.change_volume( 729.0, 5.0 ) );
  BOOST_CHECK( utility::feq( var1->volume( 5.0 ), 729.0 ) );
}
// make_gridder: see cube_region_method_open_test as gridder generation is
// always independent of open/closedness.



!!!1069104.cpp!!!	region_meta_lifetime_test() : void
{
  // Test is virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< geometry::region_meta >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< geometry::region_meta >::type {} );
  BOOST_CHECK( not std::is_move_constructible< geometry::region_meta >::type {} );
  BOOST_CHECK( not( std::is_assignable< geometry::region_meta, geometry::region_meta >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< geometry::region_meta >::type {} );
}
{
  boost::shared_ptr< geometry::geometry_manager > man;
  // main ctor
  boost::shared_ptr< geometry::region_meta > dobj( new geometry::region_meta( man ) );
  BOOST_CHECK_EQUAL( dobj->section_label(), core::strngs::fsregn() );
  BOOST_CHECK_EQUAL( dobj->multiple(), true );
  BOOST_CHECK_EQUAL( dobj->required(), false );
}

!!!1069232.cpp!!!	region_meta_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--open" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--origin" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--width" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\norigin 1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

  BOOST_CHECK_EQUAL( mngr->region_count(), 2ul );
  BOOST_CHECK_EQUAL( mngr->region_key( "bulk" ), 1ul );

  geometry::cube_region const* regptr;
  regptr = dynamic_cast< geometry::cube_region const* >( &( mngr->get_region( 1ul ) ) );
  BOOST_REQUIRE( regptr != nullptr );
  BOOST_CHECK_EQUAL( regptr->is_open(), true );
  BOOST_CHECK_EQUAL( regptr->length(), 8.0 );
  particle::coordinate canon_pos( 1.0, 1.0, 1.0 );
  BOOST_CHECK_EQUAL( regptr->origin(), canon_pos );
}
!!!1076144.cpp!!!	input_region_name_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Name is hidden by comment character
  std::string canon_input( "region\nname #\"bulk\"\norigin 1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Region \"name\" parameter must have a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1076528.cpp!!!	input_region_no_name_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Name is hidden by comment character
  std::string canon_input( "region\n#name \"bulk\"\norigin 1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "name was found" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1086256.cpp!!!	input_region_repeated_name_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\ntype cube\nname \"bulk\"\norigin 1.0 1.0 1.0\nwidth 8.0\nname channel\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Parameter \"name\" appears more than once in a single region section" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1076656.cpp!!!	input_region_no_type_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\norigin 1.0 1.0 1.0\nwidth 8.0\n#type cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "No region type was found" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1076784.cpp!!!	input_region_type_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\norigin 1.0 1.0 1.0\nwidth 8.0\ntype #cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Region \"type\" parameter must have a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1076912.cpp!!!	input_region_type_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\norigin 1.0 1.0 1.0\nwidth 8.0\ntype cubic\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Region \"type\" parameter value (cubic) is not" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1086128.cpp!!!	input_region_repeated_type_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\ntype cube\nname \"bulk\"\norigin 1.0 1.0 1.0\nwidth 8.0\ntype periodic_cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Parameter \"type\" appears more than once in a single region section" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1077040.cpp!!!	input_cube_region_no_width_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\norigin 1.0 1.0 1.0\n#width 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cube region \"width\" parameter missing in input" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1077296.cpp!!!	input_cube_region_width_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\norigin 1.0 1.0 1.0\nwidth #8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cube region \"width\" parameter requires a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1077424.cpp!!!	input_cube_region_width_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\norigin 1.0 1.0 1.0\nwidth eight\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cube region \"width\" parameter value (eight) is not a number" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1077552.cpp!!!	input_cube_region_width_poor_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\norigin 1.0 1.0 1.0\nwidth 0.8 pm\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cube region \"width\" parameter value (0.8 pm) is not a number" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1085360.cpp!!!	input_cube_region_width_negative_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\norigin 1.0 1.0 1.0\nwidth -1.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cube region \"width\" parameter value (-1.0) must be greater than zero" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1077168.cpp!!!	input_cube_region_no_origin_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname bulk\n#origin 1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cube region \"origin\" parameter missing in input" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1077680.cpp!!!	input_cube_region_origin_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname bulk\norigin #1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cube region \"origin\" parameter requires a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1077808.cpp!!!	input_cube_region_origin_short_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname bulk\norigin 1.0 1.0 #1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cube region \"origin\" coordinate data (1.0 1.0) should have 3 values" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1077936.cpp!!!	input_cube_region_origin_long_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname bulk\norigin 1.0 1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cube region \"origin\" coordinate data (1.0 1.0 1.0 1.0) should have 3 values" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1078064.cpp!!!	input_cube_region_origin_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname bulk\norigin 1.0 1.0 l.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cube region \"origin\" coordinate data (1.0 1.0 l.0) is invalid" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1078192.cpp!!!	input_cube_region_open_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname bulk\nopen\norigin 1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

  geometry::cube_region const* regptr;
  regptr = dynamic_cast< geometry::cube_region const* >( &( mngr->get_region( 1ul ) ) );
  BOOST_REQUIRE( regptr != nullptr );
  BOOST_CHECK_EQUAL( regptr->is_open(), true );
}
!!!1078448.cpp!!!	input_cube_region_open_false_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname bulk\nopen false\norigin 1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

  geometry::cube_region const* regptr;
  regptr = dynamic_cast< geometry::cube_region const* >( &( mngr->get_region( 1ul ) ) );
  BOOST_REQUIRE( regptr != nullptr );
  BOOST_CHECK_EQUAL( regptr->is_open(), false );
}
!!!1078576.cpp!!!	input_cube_region_open_true_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname bulk\nopen true\norigin 1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

  geometry::cube_region const* regptr;
  regptr = dynamic_cast< geometry::cube_region const* >( &( mngr->get_region( 1ul ) ) );
  BOOST_REQUIRE( regptr != nullptr );
  BOOST_CHECK_EQUAL( regptr->is_open(), true );
}
!!!1078320.cpp!!!	input_cube_region_open_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname bulk\nopen once\norigin 1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cube region \"open\" parameter value (once) is not a boolean" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1085872.cpp!!!	input_cube_region_unknown_param_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname bulk\nopen true\nunknown parameter\norigin 1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Parameter with name \"unknown\" is not valid for region type \"cube\"." ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1086000.cpp!!!	input_cube_region_repeated_param_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname bulk\nopen true\nwidth 6.0\norigin 1.0 1.0 1.0\nwidth 8.0\ntype cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Parameter \"width\" appears more than once in a single region section" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1085616.cpp!!!	input_periodic_cube_region_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::periodic_cube_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--width" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nwidth 8.0\ntype periodic-cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

  BOOST_CHECK_EQUAL( mngr->region_count(), 2ul );
  BOOST_CHECK_EQUAL( mngr->region_key( "bulk" ), 1ul );

  geometry::periodic_cube_region const* regptr;
  regptr = dynamic_cast< geometry::periodic_cube_region const* >( &( mngr->get_region( 1ul ) ) );
  BOOST_REQUIRE( regptr != nullptr );
  BOOST_CHECK_EQUAL( regptr->length(), 8.0 );
}
!!!1085488.cpp!!!	input_periodic_cube_no_width_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::periodic_cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\n#width 8.0\ntype periodic-cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Periodic cube region \"width\" parameter missing in input" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1086384.cpp!!!	input_periodic_cube_width_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::periodic_cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\nwidth #8.0\ntype periodic-cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Periodic cube region \"width\" parameter requires a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1086512.cpp!!!	input_periodic_cube_width_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::periodic_cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\nwidth 8.0 pm\ntype periodic-cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Periodic cube region \"width\" parameter value (8.0 pm) is not a number" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1086640.cpp!!!	input_periodic_cube_width_negative_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::periodic_cube_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }
  // Type is hidden by comment character
  std::string canon_input( "region\nname \"bulk\"\nwidth -8.0\ntype periodic-cube\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Periodic cube region \"width\" parameter value (-8.0) must be greater than zero" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1096880.cpp!!!	input_cylinder_region_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

  BOOST_CHECK_EQUAL( mngr->region_count(), 2ul );
  BOOST_CHECK_EQUAL( mngr->region_key( "bulk" ), 1ul );

  geometry::cylinder_region const* regptr;
  regptr = dynamic_cast< geometry::cylinder_region const* >( &( mngr->get_region( 1ul ) ) );
  BOOST_REQUIRE( regptr != nullptr );
  BOOST_CHECK_EQUAL( regptr->half_length(), 8.0 );
  BOOST_CHECK_EQUAL( regptr->radius(), 8.0 );
  BOOST_CHECK_EQUAL( regptr->volume( 0.0 ), core::constants::pi() * 1024 );
}
!!!1096752.cpp!!!	input_cylinder_no_halflength_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\n#half-length 8.0\ntype cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cylinder region \"half-length\" parameter missing" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1096624.cpp!!!	input_cylinder_halflength_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length #8.0\ntype cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cylinder region \"half-length\" parameter requires a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1096496.cpp!!!	input_cylinder_halflength_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length eight#8.0\ntype cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cylinder region \"half-length\" parameter value (eight) is not a number" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1096368.cpp!!!	input_cylinder_halflength_negative_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length -8.0\ntype cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cylinder region \"half-length\" parameter value (-8.0) must be greater than zero" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1096240.cpp!!!	input_cylinder_no_radius_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype cylinder\n#radius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cylinder region \"radius\" parameter missing" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1096112.cpp!!!	input_cylinder_radius_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype cylinder\nradius #8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cylinder region \"radius\" parameter requires a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1095984.cpp!!!	input_cylinder_radius_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype cylinder\nradius eight#8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cylinder region \"radius\" parameter value (eight) is not a number" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1095856.cpp!!!	input_cylinder_radius_negative_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype cylinder\nradius -8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Cylinder region \"radius\" parameter value (-8) must be greater than zero" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1093936.cpp!!!	input_open_cylinder_region_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype open-cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

  BOOST_CHECK_EQUAL( mngr->region_count(), 2ul );
  BOOST_CHECK_EQUAL( mngr->region_key( "bulk" ), 1ul );

  geometry::open_cylinder_region const* regptr;
  regptr = dynamic_cast< geometry::open_cylinder_region const* >( &( mngr->get_region( 1ul ) ) );
  BOOST_REQUIRE( regptr != nullptr );
  BOOST_CHECK_EQUAL( regptr->half_length(), 8.0 );
  BOOST_CHECK_EQUAL( regptr->radius(), 8.0 );
  BOOST_CHECK_EQUAL( regptr->volume( 0.0 ), core::constants::pi() * 1024 );
}
!!!1094832.cpp!!!	input_open_cylinder_no_halflength_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\n#half-length 8.0\ntype open-cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Open cylinder region \"half-length\" parameter missing" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1094960.cpp!!!	input_open_cylinder_halflength_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length #8.0\ntype open-cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Open cylinder region \"half-length\" parameter requires a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1095088.cpp!!!	input_open_cylinder_halflength_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length eight#8.0\ntype open-cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Open cylinder region \"half-length\" parameter value (eight) is not a number" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1095216.cpp!!!	input_open_cylinder_halflength_negative_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length -8.0\ntype open-cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Open cylinder region \"half-length\" parameter value (-8.0) must be greater than zero" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1095344.cpp!!!	input_open_cylinder_no_radius_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype open-cylinder\n#radius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Open cylinder region \"radius\" parameter missing" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1095472.cpp!!!	input_open_cylinder_radius_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype open-cylinder\nradius #8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Open cylinder region \"radius\" parameter requires a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1095600.cpp!!!	input_open_cylinder_radius_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype open-cylinder\nradius eight#8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Open cylinder region \"radius\" parameter value (eight) is not a number" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1095728.cpp!!!	input_open_cylinder_radius_negative_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype open-cylinder\nradius -8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Open cylinder region \"radius\" parameter value (-8) must be greater than zero" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1104816.cpp!!!	input_split_cylinder_region_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    core::input_help hlpr;
    m->add_documentation( hlpr );
    {
      std::stringstream ss;
      hlpr.print( ss );
      BOOST_CHECK( ss.str().find( "--name" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--type" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--radius" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--offset" ) < ss.str().size() );
      BOOST_CHECK( ss.str().find( "--half-length" ) < ss.str().size() );
    }
    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype split-cylinder\nradius 8\noffset 4\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );

  BOOST_CHECK_EQUAL( mngr->region_count(), 2ul );
  BOOST_CHECK_EQUAL( mngr->region_key( "bulk" ), 1ul );

  geometry::open_split_cylinder_region const* regptr;
  regptr = dynamic_cast< geometry::open_split_cylinder_region const* >( &( mngr->get_region( 1ul ) ) );
  BOOST_REQUIRE( regptr != nullptr );
  BOOST_CHECK_EQUAL( regptr->half_length(), 8.0 );
  BOOST_CHECK_EQUAL( regptr->radius(), 8.0 );
  BOOST_CHECK_EQUAL( regptr->offset(), 4.0 );
  BOOST_CHECK_EQUAL( regptr->volume( 0.0 ), core::constants::pi() * 1024 );
}
!!!1104688.cpp!!!	input_split_cylinder_no_halflength_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\n#half-length 8.0\ntype split-cylinder\nradius 8\noffset 4\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"half-length\" parameter missing" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1104560.cpp!!!	input_split_cylinder_halflength_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length #8.0\ntype split-cylinder\nradius 8\noffset 4\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"half-length\" parameter requires a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1104432.cpp!!!	input_split_cylinder_halflength_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length eight#8.0\ntype split-cylinder\noffset 4\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"half-length\" parameter value (eight) is not a number" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1104304.cpp!!!	input_split_cylinder_halflength_negative_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\noffset 4\nhalf-length -8.0\ntype split-cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"half-length\" parameter value (-8.0) must be greater than zero" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1104048.cpp!!!	input_split_cylinder_radius_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\noffset 4.0\nname \"bulk\"\nhalf-length 8.0\ntype split-cylinder\nradius #8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"radius\" parameter requires a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1103920.cpp!!!	input_split_cylinder_radius_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\noffset 4\nname \"bulk\"\nhalf-length 8.0\ntype split-cylinder\nradius eight#8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"radius\" parameter value (eight) is not a number" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1104176.cpp!!!	input_split_cylinder_no_radius_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype split-cylinder\n#radius 8\noffset 4\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"radius\" parameter missing" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1103792.cpp!!!	input_split_cylinder_radius_negative_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\noffset 4.0\nname \"bulk\"\nhalf-length 8.0\ntype split-cylinder\nradius -8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"radius\" parameter value (-8) must be greater than zero" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1105328.cpp!!!	input_split_cylinder_no_offset_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype split-cylinder\nradius 8\n#offset 4\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"offset\" parameter missing" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1105200.cpp!!!	input_split_cylinder_offset_no_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype split-cylinder\nradius 8\noffset #4\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"offset\" parameter requires a value" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1105072.cpp!!!	input_split_cylinder_offset_bad_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\nhalf-length 8.0\ntype split-cylinder\noffset eight#4\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"offset\" parameter value (eight) is not a number" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
!!!1104944.cpp!!!	input_split_cylinder_offset_negative_value_test() : void
// Test read input (specie meta)
{
  boost::shared_ptr< geometry::base_region > sys_rgn( new geometry::periodic_cube_region( "cell", 10.0 ) );
  boost::shared_ptr< geometry::geometry_manager > mngr( new geometry::geometry_manager( sys_rgn ) );
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< geometry::region_meta > m( new geometry::region_meta( mngr ) );
    geometry::open_split_cylinder_region::add_region_definition( *m );

    dg.add_input_delegate( m );
  }

  

  std::string canon_input( "region\nname \"bulk\"\noffset -4.2\nhalf-length 8.0\ntype split-cylinder\nradius 8\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  try
  {
    dg.read_input( reader );
    BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    BOOST_CHECK( msg.find( "Split cylinder region \"offset\" parameter value (-4.2) must be greater than zero" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string("exception thrown by \"dg.read_input( reader )\" was not expected type: ") + err.what() );
  }
}
