class input_reader
!!!555824.cpp!!!	add_buffer(in filename : path, in buffer : string) : void
boost::shared_ptr< std::istream > tmp( new std::stringstream( buffer ) );
this->file_stack_.push_back( input_reader::location_node( filename, tmp ) );

!!!1542831.cpp!!!	do_next() : bool
if (this->file_stack_.empty())
{
  return false;
}
// Keep going until we get a result or reach the end of all files.
while (true)
{
  // Get the top most stream
  std::istream &fid = *(this->file_stack_.back().stream_);
  if (not fid or fid.eof())
  {
    this->file_stack_.pop_back();
    if (this->file_stack_.empty())
    {
      return false;
    }
    continue;
  }
  std::string line;
  std::getline(fid, line);
  // Keep track of the current line number.
  ++this->file_stack_.back().line_no_;
  if ( not this->set_line( line ) ) continue;

  // Check for include.
  if (this->name() == core::strngs::fsincl())
  {
    boost::filesystem::path fn( this->value());
    if ( fn.has_relative_path() )
    {
       if ( this->file_stack_.back().path_.has_parent_path() )
       {
         fn = this->file_stack_.back().path_.parent_path() / fn;
       }
    }
    UTILITY_INPUT( this->file_stack_.size() < 100, "Include depth exceeding 100 levels, which probably indicates an include cycle", core::strngs::fsincl() );
    this->file_stack_.push_back( input_reader::location_node( fn ) );
    continue;
  }
  break;
}
return true;
!!!1542831.python!!!	do_next() : bool
if len(self.file_stack_) == 0:
  return False
# Keep going until we get a result or reach the end of all files.
while True:
  # Get the top most stream
  node = self.file_stack_[-1]
  self.name_ = None
  self.line_ = None
  self.value_ = None
  self.line_ = node.stream_.readline()
  if self.line_ == "":
    self.file_stack_.pop()
    if len(self.file_stack_) == 0:
      self.line_ = None
      return False
    continue
  # Keep track of the current line number.
  node.line_no_ += 1
  if self.line_ == "\n":
    continue
  self.line_ = input_reader.decomment(self.line_, '#')
  if self.line_ == "\n":
    continue
  self.line_ = self.line_.strip()
  if self.line_ == "":
    continue
  # Split line
  # have name/value ?? (look for ' ' or '=')
  if self.line_.find("=") >= 0:
    arr = self.line_.split("=",1)
    self.name_ = arr[0]
    if len(arr) > 1:
      self.value_ = arr[1]
  else:
    arr = self.line_.split(None,1)
    self.name_ = arr[0]
    if len(arr) > 1:
      self.value_ = arr[1]
  self.name_ = self.name_.strip()
  self.value_ = None if self.value_ == None else self.value_.strip()
  # Check for include.
  if self.name_ == "include":
    newnode = location_node()
    newnode.open(self.value_)
    self.file_stack_.append(newnode)
    continue
  break
return True
