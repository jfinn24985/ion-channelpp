class platform_test
!!!1821232.cpp!!!	mockup_particle_manager() : particle_manager
boost::shared_ptr< particle::particle_manager > pman( new particle::particle_manager );
//XX {
//XX   particle::specie spc1;
//XX   spc1.set_label( "CA" );
//XX   spc1.set_concentration( 1.0 );
//XX   spc1.set_radius( 0.11 );
//XX   spc1.set_rate( 0.2 );
//XX   spc1.set_valency( 1.0 );
//XX   spc1.set_excess_potential( 0.123 );
//XX   spc1.set_type( particle::specie::MOBILE );
//XX   spc1.append_position( particle::coordinate( 2.0, 2.0, 0.0 ), particle::centroid( 3.0, 2.0, 2.0, 0.0 ) );
//XX   pman->add_specie( spc1 );
//XX }
//XX {
//XX   particle::specie spc1;
//XX   spc1.set_label( "CO" );
//XX   spc1.set_concentration( 1.0 );
//XX   spc1.set_radius( 0.12 );
//XX   spc1.set_rate( 0.2 );
//XX   spc1.set_valency( -1.0 );
//XX   spc1.set_excess_potential( 0.123 );
//XX   spc1.set_type( particle::specie::FLEXIBLE );
//XX   spc1.append_position( particle::coordinate( 0.0, 0.0, 2.0 ), particle::centroid( 3.0, 0.0, 0.0, 2.0 ) );
//XX   pman->add_specie( spc1 );
//XX }
//XX {
//XX   particle::specie spc1;
//XX   spc1.set_label( "OX" );
//XX   spc1.set_concentration( 1.0 );
//XX   spc1.set_radius( 0.12 );
//XX   spc1.set_rate( 0.2 );
//XX   spc1.set_valency( -1.0 );
//XX   spc1.set_excess_potential( 0.123 );
//XX   spc1.set_type( particle::specie::CHANNEL_ONLY );
//XX   spc1.append_position( particle::coordinate( 2.0, 0.0, 2.0 ) );
//XX   pman->add_specie( spc1 );
//XX }
//XX {
//XX   particle::specie spc1;
//XX   spc1.set_label( "Na" );
//XX   spc1.set_concentration( 1.0 );
//XX   spc1.set_radius( 0.12 );
//XX   spc1.set_rate( 0.2 );
//XX   spc1.set_valency( 1.0 );
//XX   spc1.set_excess_potential( 0.123 );
//XX   spc1.set_type( particle::specie::SOLUTE );
//XX   spc1.append_position( particle::coordinate( 0.0, 0.0, 0.0 ) );
//XX   spc1.append_position( particle::coordinate( 2.0, 0.0, 0.0 ) );
//XX   pman->add_specie( spc1 );
//XX }
//XX {
//XX   particle::specie spc1;
//XX   spc1.set_label( "Cl" );
//XX   spc1.set_concentration( 1.0 );
//XX   spc1.set_radius( 0.2 );
//XX   spc1.set_rate( 0.2 );
//XX   spc1.set_valency( -1.0 );
//XX   spc1.set_excess_potential( 0.3123 );
//XX   spc1.set_type( particle::specie::SOLUTE );
//XX   spc1.append_position( particle::coordinate( 0.0, 2.0, 0.0 ) );
//XX   pman->add_specie( spc1 );
//XX }
//XX pman->add_predefined_particles();
return pman;
!!!1821360.cpp!!!	mockup_geometry_manager() : geometry_manager
boost::shared_ptr< geometry::geometry_manager > gman;
//XX boost::shared_ptr< geometry::base_region > regn( new geometry::periodic_cube_region( "cell", 5.0 ) );
//XX boost::shared_ptr< geometry::geometry_manager > gman( new geometry::geometry_manager( regn ) );
//XX {
//XX   boost::shared_ptr< geometry::base_region > bulk( new geometry::cube_region( "bulk", 4.0, particle::coordinate( 0.0, 0.0, 0.0 ), true ) );
//XX   gman->add_region( bulk );
//XX }
return gman;
!!!1821872.cpp!!!	base_storage_manager_test() : void
//Tested methods
//  * checkpoint_name
//  * default_checkpoint_name
//  * default_filename_base
//  * default_output_dir_fmt
//  * default_output_name
//  * default_run_number
//  * filename_base
//  * output_dir_fmt
//  * output_name
//  * run_number
//  * serialize
//  * set_checkpoint_name
//  * set_filename_base
//  * set_output_dir_fmt
//  * set_output_name
//  * set_run_number
//Not tested (undefined in simple_storage_manager)
//  checkpoint_path
//  compute_output_dir
//  find_input_filename
//  output_path
//  open_output
//  open_input
//  open_checkpoint
//  open_log
//  get_log (undefined because open_log is undefined.)
{
  // Test for virtual noncopy pattern
  BOOST_CHECK( std::is_default_constructible< platform_test::simple_storage_manager >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< platform_test::simple_storage_manager >::type {} );
  BOOST_CHECK( not std::is_move_constructible< platform_test::simple_storage_manager >::type {} );
  BOOST_CHECK( not( std::is_assignable< platform_test::simple_storage_manager, platform_test::simple_storage_manager >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< platform_test::simple_storage_manager >::type {} );
}
// static methods
const std::string cname( "checkpoint.arc" );
const std::string test_cname( "check.dat" );
const std::string fbase( "input.\%1$03d.inp" );
const std::string test_fbase( "channel.\%1$04d.inp" );
const std::string dbase( "\%1$03d" );
const std::string test_dbase( "\%1$04d.dat" );
const std::string oname( "output.dbm" );
const std::string test_oname( "result.zip" );
const std::size_t runnum( 1ul );
const std::size_t test_runnum( 5999ul );
{
  BOOST_CHECK_EQUAL( platform::storage_manager::default_checkpoint_name(), cname );
  BOOST_CHECK_EQUAL( platform::storage_manager::default_filename_base(), fbase );
  BOOST_CHECK_EQUAL( platform::storage_manager::default_output_dir_fmt(), dbase );
  BOOST_CHECK_EQUAL( platform::storage_manager::default_output_name(), oname );
  BOOST_CHECK_EQUAL( platform::storage_manager::default_run_number(), runnum );
}
std::stringstream store;
{
  // Public ctor 1
  boost::shared_ptr< platform_test::simple_storage_manager > var1( new platform_test::simple_storage_manager );
  BOOST_CHECK_EQUAL( var1->checkpoint_name(), cname );
  // compute_output_dir gives empty string so path and name should be equal
  BOOST_CHECK_EQUAL( var1->checkpoint_path(), cname );
  BOOST_CHECK_EQUAL( var1->filename_base(), fbase );
  BOOST_CHECK_EQUAL( var1->output_dir_fmt(), dbase );
  BOOST_CHECK_EQUAL( var1->output_name(), oname );
  BOOST_CHECK( var1->get_value().empty() );
  // compute_output_dir gives empty string so path and name should be equal
  BOOST_CHECK_EQUAL( var1->output_path(), oname );
  BOOST_CHECK_EQUAL( var1->run_number(), runnum );

  BOOST_CHECK_NO_THROW( var1->set_checkpoint_name( test_cname ) );
  BOOST_CHECK_NO_THROW( var1->set_filename_base( test_fbase ) );
  BOOST_CHECK_NO_THROW( var1->set_output_dir_fmt( test_dbase ) );
  BOOST_CHECK_NO_THROW( var1->set_output_name( test_oname ) );
  BOOST_CHECK_NO_THROW( var1->set_run_number( test_runnum ) );

  BOOST_CHECK_EQUAL( var1->checkpoint_name(), test_cname );
  BOOST_CHECK_EQUAL( var1->checkpoint_path(), test_cname );
  BOOST_CHECK_EQUAL( var1->filename_base(), test_fbase );
  BOOST_CHECK_EQUAL( var1->output_dir_fmt(), test_dbase );
  BOOST_CHECK_EQUAL( var1->output_name(), test_oname );
  BOOST_CHECK_EQUAL( var1->output_path(), test_oname );
  BOOST_CHECK_EQUAL( var1->run_number(), test_runnum );

  // write class instance to archive
  boost::archive::text_oarchive oa( store );
  oa << var1;
}
{
  boost::shared_ptr< platform_test::simple_storage_manager > var2;
  // read class instance from archive
  boost::archive::text_iarchive ia( store );
  ia >> var2;
  BOOST_CHECK_EQUAL( var2->checkpoint_name(), test_cname );
  BOOST_CHECK_EQUAL( var2->filename_base(), test_fbase );
  BOOST_CHECK_EQUAL( var2->output_dir_fmt(), test_dbase );
  BOOST_CHECK_EQUAL( var2->output_name(), test_oname );
  BOOST_CHECK_EQUAL( var2->run_number(), test_runnum );
  BOOST_CHECK( var2->get_value().empty() );

  // test open/get/set log methods
  {
    var2->get_log() << "TEST1";
    BOOST_CHECK_EQUAL( "TEST1", var2->thelog->str() );
  }
  {
    boost::shared_ptr< std::stringstream > ss( new std::stringstream );
    var2->set_log( ss );
    var2->get_log() << "TEST2";
    BOOST_CHECK_EQUAL( "TEST2", ss->str() );
  }
}

!!!1855152.cpp!!!	serial_storage_lifetime_test() : void
{
  // Test for virtual noncopy pattern
  BOOST_CHECK( std::is_default_constructible< platform::serial_storage >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< platform::serial_storage >::type {} );
  BOOST_CHECK( not std::is_move_constructible< platform::serial_storage >::type {} );
  BOOST_CHECK( not( std::is_assignable< platform::serial_storage, platform::serial_storage >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< platform::serial_storage >::type {} );
}
// static methods
const std::string cname( "checkpoint.arc" );
const std::string fbase( "input.\%1$03d.inp" );
const std::string dbase( "\%1$03d" );
const std::string oname( "output.dbm" );
const std::size_t runnum( 1ul );
{
  BOOST_CHECK_EQUAL( platform::storage_manager::default_checkpoint_name(), cname );
  BOOST_CHECK_EQUAL( platform::storage_manager::default_filename_base(), fbase );
  BOOST_CHECK_EQUAL( platform::storage_manager::default_output_dir_fmt(), dbase );
  BOOST_CHECK_EQUAL( platform::storage_manager::default_output_name(), oname );
  BOOST_CHECK_EQUAL( platform::storage_manager::default_run_number(), runnum );
  BOOST_CHECK_EQUAL( platform::serial_storage::type_label_(), "standard" );
}
{
  // Public ctor that inherits from base storage_manager
  boost::shared_ptr< platform::serial_storage > var1( new platform::serial_storage );
  BOOST_CHECK_EQUAL( var1->checkpoint_name(), cname );
  BOOST_CHECK_EQUAL( var1->filename_base(), fbase );
  BOOST_CHECK_EQUAL( var1->output_dir_fmt(), dbase );
  BOOST_CHECK_EQUAL( var1->output_name(), oname );
  BOOST_CHECK_EQUAL( var1->run_number(), runnum );
}

!!!1855024.cpp!!!	serial_storage_method_test() : void
//Tested methods
//  * checkpoint_name
//  * default_checkpoint_name
//  * default_filename_base
//  * default_output_dir_fmt
//  * default_output_name
//  * default_run_number
//  * filename_base
//  * get_label
//  * output_dir_fmt
//  * output_name
//  * run_number
//  * serialize
//  * set_checkpoint_name
//  * set_filename_base
//  * set_output_dir_fmt
//  * set_output_name
//  * set_run_number
//Not tested (undefined in simple_storage_manager)
//  * checkpoint_path
//  * compute_output_dir
//  * find_input_filename
//  * output_path
//  * open_output
//  * open_input
//  * open_checkpoint
//  ** open_log
//  ** get_log (undefined because open_log is undefined.)

const std::string cname( "checkpoint.arc" );
const std::string test_cname( "check.dat" );
const std::string fbase( "input.\%1$03d.inp" );
const std::string test_fbase( "channel.\%1$04d.inp" );
const std::string dbase( "\%1$03d" );
const std::string outpath( "001" );
const std::string outdir( "001/" );
const std::string test_dbase( "\%1$04d.dat" );
const std::string test_outpath( "5999.dat" );
const std::string test_outdir( "5999.dat/" );
const std::string oname( "output.dbm" );
const std::string test_oname( "result.zip" );
const std::size_t runnum( 1ul );
const std::size_t test_runnum( 5999ul );

std::stringstream store;
{
  // Public ctor 1
  boost::shared_ptr< platform::serial_storage > var1( new platform::serial_storage );
  BOOST_CHECK_EQUAL( var1->get_label(), "standard" );
  BOOST_CHECK_EQUAL( var1->checkpoint_name(), cname );
  BOOST_CHECK_EQUAL( var1->filename_base(), fbase );
  BOOST_CHECK_EQUAL( var1->output_dir_fmt(), dbase );
  BOOST_CHECK_EQUAL( var1->output_name(), oname );
  BOOST_CHECK_EQUAL( var1->run_number(), runnum );
  // compute_output_dir gives "001"
  BOOST_CHECK_EQUAL( var1->compute_output_dir(), outpath );
  BOOST_CHECK_EQUAL( var1->checkpoint_path(), outdir + cname );
  BOOST_CHECK_EQUAL( var1->output_path(), outdir + oname );

  var1->set_checkpoint_name( test_cname );
  var1->set_filename_base( test_fbase );
  var1->set_output_dir_fmt( test_dbase );
  var1->set_output_name( test_oname );
  var1->set_run_number( test_runnum );

  BOOST_CHECK_EQUAL( var1->checkpoint_name(), test_cname );
  BOOST_CHECK_EQUAL( var1->filename_base(), test_fbase );
  BOOST_CHECK_EQUAL( var1->output_dir_fmt(), test_dbase );
  BOOST_CHECK_EQUAL( var1->output_name(), test_oname );
  BOOST_CHECK_EQUAL( var1->run_number(), test_runnum );
  // compute_output_dir gives "5999.dat"
  BOOST_CHECK_EQUAL( var1->compute_output_dir(), test_outpath );
  BOOST_CHECK_EQUAL( var1->checkpoint_path(), test_outdir + test_cname );
  BOOST_CHECK_EQUAL( var1->output_path(), test_outdir + test_oname );

  // write class instance to archive
  boost::archive::text_oarchive oa( store );
  oa << var1;
}
{
  boost::shared_ptr< platform::serial_storage > var2;
  // read class instance from archive
  boost::archive::text_iarchive ia( store );
  ia >> var2;
  BOOST_CHECK_EQUAL( var2->checkpoint_name(), test_cname );
  BOOST_CHECK_EQUAL( var2->filename_base(), test_fbase );
  BOOST_CHECK_EQUAL( var2->output_dir_fmt(), test_dbase );
  BOOST_CHECK_EQUAL( var2->output_name(), test_oname );
  BOOST_CHECK_EQUAL( var2->run_number(), test_runnum );
  BOOST_CHECK_EQUAL( var2->compute_output_dir(), test_outpath );
  BOOST_CHECK_EQUAL( var2->checkpoint_path(), test_outdir + test_cname );
  BOOST_CHECK_EQUAL( var2->output_path(), test_outdir + test_oname );
  try
  {
    std::string fn;
    fn = var2->find_input_filename();
    BOOST_ERROR( "Unexpected \"var2->find_input_filename()\" found file named " + fn );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Unable to find input file(s) named: channel.5999.inp channel.inp" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"var2->find_input_filename()\" was not expected type: " ) + err.what() );
  }
  {
    auto ipath( boost::filesystem::unique_path( "input%%%%%.inp" ) );
    const std::string spath( ipath.native() );

    // USE PATH AS INPUT FILE NAME
    //////////////////////////////
    BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
    var2->set_filename_base( spath );
    BOOST_CHECK_EQUAL( var2->filename_base(), spath );
    // Try to find input after generating file
    try
    {
      {
        std::ofstream tmp( spath );
        tmp << "\n";
      }
      BOOST_CHECK_EQUAL( var2->find_input_filename(), spath );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"var2->find_input_filename()\" was not expected:" ) + err.what() );
    }
    // Try to open input
    try
    {
      auto reader_ptr = var2->open_input();
      BOOST_CHECK_EQUAL( reader_ptr->current_filename(), boost::filesystem::absolute( spath ).native() );
      BOOST_CHECK_EQUAL( reader_ptr->current_line_number(), 0 );
      BOOST_CHECK_EQUAL( reader_ptr->next(), false );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"var2->open_input()\" was not expected:" ) + err.what() );
    }
    if( boost::filesystem::exists( ipath ) )
    {
      boost::filesystem::remove( ipath );
    }
    var2->set_filename_base( test_fbase );
    // USE PATH AS OUTPUT DIR NAME
    //////////////////////////////
    BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
    var2->set_output_dir_fmt( spath );
    BOOST_CHECK_EQUAL( var2->output_dir_fmt(), spath );
    const std::string gen_cpath = var2->checkpoint_path();
    BOOST_CHECK_EQUAL( gen_cpath, spath + "/" + test_cname );
    const std::string gen_opath = var2->output_path();
    BOOST_CHECK_EQUAL( gen_opath, spath + "/" + test_oname );
    // Path should not be created until we open a file.
    BOOST_CHECK( not boost::filesystem::exists( ipath ) );
    try
    {
      {
        auto sink_ptr = var2->open_output();
        BOOST_CHECK( boost::filesystem::exists( ipath ) );
        BOOST_CHECK_EQUAL( sink_ptr->filename(), gen_opath );
        // Put entry in sink so that file is generated
        // if lazy opening is used.
        sink_ptr->write( "entry1", "Some value" );
      }
      // check for file after sink is closed.
      BOOST_CHECK( boost::filesystem::exists( gen_opath ) );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"var2->open_output()\" was not expected:" ) + err.what() );
    }
    if( boost::filesystem::exists( ipath ) )
    {
      boost::filesystem::remove_all( ipath );
    }
    try
    {
      {
        auto os_ptr = var2->open_checkpoint();
        BOOST_CHECK( boost::filesystem::exists( ipath ) );
        BOOST_CHECK( os_ptr.get() != nullptr );
        // Put text in checkpoint so that file is generated
        // if lazy opening is used.
        *( os_ptr ) << "Write some text\n";
      }
      // check for file after checkpoint is closed.
      BOOST_CHECK( boost::filesystem::exists( gen_cpath ) );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"var2->open_checkpoint()\" was not expected:" ) + err.what() );
    }
    if( boost::filesystem::exists( ipath ) )
    {
      boost::filesystem::remove_all( ipath );
    }
  }
  {
    boost::shared_ptr< std::stringstream > ss( new std::stringstream );
    var2->set_log( ss );
    var2->get_log() << "TEST";
    BOOST_CHECK_EQUAL( "TEST", ss->str() );
  }
  var2->get_log() << "TEST2";
  BOOST_CHECK_EQUAL( "TESTTEST2", dynamic_cast< std::stringstream& >(var2->get_log()).str() );
}

!!!1861808.cpp!!!	serial_storage_input_filename_noexist() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "input%%%%%.inp" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS INPUT FILE NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_filename_base( spath );
  BOOST_CHECK_EQUAL( sman_ptr->filename_base(), spath );
  // Try to find input before generating file
  try
  {
    std::string fn;
    fn = sman_ptr->find_input_filename();
    BOOST_ERROR( "Unexpected \"sman_ptr->find_input_filename()\" found file named " + fn );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Unable to find input file(s) named: " + spath ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->find_input_filename()\" was not expected type: " ) + err.what() );
  }
}
!!!1861936.cpp!!!	serial_storage_input_filename_is_dir() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "input%%%%%.inp" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS INPUT FILE NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_filename_base( spath );
  BOOST_CHECK_EQUAL( sman_ptr->filename_base(), spath );
  boost::filesystem::create_directories( ipath );
  try
  {
    std::string fn;
    fn = sman_ptr->find_input_filename();
    BOOST_ERROR( "Unexpected \"sman_ptr->find_input_filename()\" found file named " + fn );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Unable to find input file(s) named: " + spath ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->find_input_filename()\" was not expected type: " ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove_all( ipath );
  }
}

!!!1862064.cpp!!!	serial_storage_input_filename_is_not_accessible() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "input%%%%%.inp" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS INPUT FILE NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_filename_base( spath );
  BOOST_CHECK_EQUAL( sman_ptr->filename_base(), spath );
  // Try to find input after generating inaccessible file
  try
  {
    {
      std::ofstream tmp( spath );
      tmp << "\n";
    }
    boost::filesystem::permissions( spath, boost::filesystem::no_perms );
    BOOST_CHECK_EQUAL( sman_ptr->find_input_filename(), spath );
    BOOST_ERROR( "Unexpected \"sman_ptr->find_input_filename()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Unable to find input file(s) named: " + spath ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->find_input_filename()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1862192.cpp!!!	serial_storage_input_filename_is_not_readable() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "input%%%%%.inp" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS INPUT FILE NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_filename_base( spath );
  BOOST_CHECK_EQUAL( sman_ptr->filename_base(), spath );
  // Try to find input after generating inaccessible file
  try
  {
    {
      std::ofstream tmp( spath );
      tmp << "\n";
    }
    boost::filesystem::permissions( spath, boost::filesystem::owner_write );
    BOOST_CHECK_EQUAL( sman_ptr->find_input_filename(), spath );
    BOOST_ERROR( "Unexpected \"sman_ptr->find_input_filename()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Unable to find input file(s) named: " + spath ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->find_input_filename()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1863600.cpp!!!	serial_storage_open_output_output_directory_is_not_directory() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    {
      std::ofstream tmp( spath );
      tmp << "\n";
    }
    auto os_str = sman_ptr->open_output();
    BOOST_REQUIRE( os_str );
    BOOST_ERROR( "Unexpected \"sman_ptr->open_output()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Filesystem object at target output directory path [" + spath + "] is not a directory" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_output()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1863472.cpp!!!	serial_storage_open_output_output_directory_is_not_accessible() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    boost::filesystem::create_directories( ipath );
    boost::filesystem::permissions( ipath, boost::filesystem::no_perms );
    auto os_str = sman_ptr->open_output();
    BOOST_REQUIRE( os_str );
    BOOST_ERROR( "Unexpected \"sman_ptr->open_output()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Problem openning output file " + spath + "/" + sman_ptr->output_name() ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_output()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1863344.cpp!!!	serial_storage_open_output_output_directory_is_0W0() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    boost::filesystem::create_directories( ipath );
    boost::filesystem::permissions( ipath, boost::filesystem::owner_write );
    auto os_str = sman_ptr->open_output();
    BOOST_REQUIRE( os_str );
    BOOST_ERROR( "Unexpected \"sman_ptr->open_output()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Problem openning output file " + spath + "/" + sman_ptr->output_name() ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_output()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1863216.cpp!!!	serial_storage_open_output_output_directory_is_RW0() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    boost::filesystem::create_directories( ipath );
    boost::filesystem::permissions( ipath, boost::filesystem::owner_write | boost::filesystem::owner_read );
    auto os_str = sman_ptr->open_output();
    BOOST_REQUIRE( os_str );
    BOOST_ERROR( "Unexpected \"sman_ptr->open_output()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Problem openning output file " + spath + "/" + sman_ptr->output_name() ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_output()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1863088.cpp!!!	serial_storage_open_output_output_directory_is_0WX() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    boost::filesystem::create_directories( ipath );
    boost::filesystem::permissions( ipath, boost::filesystem::owner_write | boost::filesystem::owner_exe );
    auto os_str = sman_ptr->open_output();
    BOOST_REQUIRE( os_str );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_output()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::permissions( ipath, boost::filesystem::owner_read | boost::filesystem::owner_write | boost::filesystem::owner_exe );
    boost::filesystem::remove_all( ipath );
  }
}
!!!1862960.cpp!!!	serial_storage_open_output_output_directory_is_R0X() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    boost::filesystem::create_directories( ipath );
    boost::filesystem::permissions( ipath, boost::filesystem::owner_exe | boost::filesystem::owner_read );
    auto os_str = sman_ptr->open_output();
    BOOST_REQUIRE( os_str );
    BOOST_ERROR( "Unexpected \"sman_ptr->open_output()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Problem openning output file " + spath + "/" + sman_ptr->output_name() ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_output()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1862320.cpp!!!	serial_storage_open_checkpoint_output_directory_is_not_directory() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    {
      std::ofstream tmp( spath );
      tmp << "\n";
    }
    auto os_str = sman_ptr->open_checkpoint();
    BOOST_REQUIRE( *(os_str) );
    BOOST_ERROR( "Unexpected \"sman_ptr->open_checkpoint()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Filesystem object at target output directory path [" + spath + "] is not a directory" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_checkpoint()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1862448.cpp!!!	serial_storage_open_checkpoint_output_directory_is_not_accessible() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    boost::filesystem::create_directories( ipath );
    boost::filesystem::permissions( ipath, boost::filesystem::no_perms );
    auto os_str = sman_ptr->open_checkpoint();
    BOOST_REQUIRE( *(os_str) );
    BOOST_ERROR( "Unexpected \"sman_ptr->open_checkpoint()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Problem openning checkpoint file " + spath + "/" + sman_ptr->checkpoint_name() ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_checkpoint()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1862576.cpp!!!	serial_storage_open_checkpoint_output_directory_is_0W0() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    boost::filesystem::create_directories( ipath );
    boost::filesystem::permissions( ipath, boost::filesystem::owner_write );
    auto os_str = sman_ptr->open_checkpoint();
    BOOST_REQUIRE( *(os_str) );
    BOOST_ERROR( "Unexpected \"sman_ptr->open_checkpoint()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Problem openning checkpoint file " + spath + "/" + sman_ptr->checkpoint_name() ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_checkpoint()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1862704.cpp!!!	serial_storage_open_checkpoint_output_directory_is_RW0() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    boost::filesystem::create_directories( ipath );
    boost::filesystem::permissions( ipath, boost::filesystem::owner_write | boost::filesystem::owner_read );
    auto os_str = sman_ptr->open_checkpoint();
    BOOST_REQUIRE( *(os_str) );
    BOOST_ERROR( "Unexpected \"sman_ptr->open_checkpoint()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Problem openning checkpoint file " + spath + "/" + sman_ptr->checkpoint_name() ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_checkpoint()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1862832.cpp!!!	serial_storage_open_checkpoint_output_directory_is_0WX() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    boost::filesystem::create_directories( ipath );
    boost::filesystem::permissions( ipath, boost::filesystem::owner_write | boost::filesystem::owner_exe );
    auto os_str = sman_ptr->open_checkpoint();
    BOOST_REQUIRE( *(os_str) );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_checkpoint()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::permissions( ipath, boost::filesystem::owner_read | boost::filesystem::owner_write | boost::filesystem::owner_exe );
    boost::filesystem::remove_all( ipath );
  }
}
!!!1823920.cpp!!!	serial_storage_open_checkpoint_output_directory_is_R0X() : void
boost::shared_ptr< platform::serial_storage > sman_ptr( new platform::serial_storage );
{
  auto ipath( boost::filesystem::unique_path( "output%%%%%" ) );
  const std::string spath( ipath.native() );

  // USE PATH AS OUTPUT DIR NAME
  //////////////////////////////
  BOOST_REQUIRE( not boost::filesystem::exists( ipath ) );
  sman_ptr->set_output_dir_fmt( spath );
  BOOST_CHECK_EQUAL( sman_ptr->output_dir_fmt(), spath );
  // Try to get directory after generating file with same name
  try
  {
    boost::filesystem::create_directories( ipath );
    boost::filesystem::permissions( ipath, boost::filesystem::owner_exe | boost::filesystem::owner_read );
    auto os_str = sman_ptr->open_checkpoint();
    BOOST_REQUIRE( *(os_str) );
    BOOST_ERROR( "Unexpected \"sman_ptr->open_checkpoint()\" found file named " + spath );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    // std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Problem openning checkpoint file " + spath + "/" + sman_ptr->checkpoint_name() ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"sman_ptr->open_checkpoint()\" was not expected:" ) + err.what() );
  }
  if( boost::filesystem::exists( ipath ) )
  {
    boost::filesystem::remove( ipath );
  }
}
!!!1823024.cpp!!!	simulation_manager_lifetime_test() : void
{
  // Test for virtual object pattern
  BOOST_CHECK( std::is_default_constructible< platform::simulation_manager >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< platform::simulation_manager >::type {} );
  BOOST_CHECK( not std::is_move_constructible< platform::simulation_manager >::type {} );
  BOOST_CHECK( not ( std::is_assignable< platform::simulation_manager, platform::simulation_manager >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< platform::simulation_manager >::type {} );
}
{
  boost::shared_ptr< platform::simulation_manager > var( new platform::simulation_manager );
  BOOST_CHECK_EQUAL( var->equilibration_interval(), 0ul );
  BOOST_CHECK_EQUAL( var->production_interval(), 0ul );
}
!!!1822000.cpp!!!	simulation_manager_methods_test() : void
std::stringstream store;
{
  boost::shared_ptr< platform::simulation_manager > var( new platform::simulation_manager );
  BOOST_CHECK_EQUAL( var->equilibration_interval(), 0ul );
  BOOST_CHECK_EQUAL( var->production_interval(), 0ul );

  var->set_equilibration_interval( 100ul );
  var->set_production_interval( 1000ul );

  BOOST_CHECK_EQUAL( var->equilibration_interval(), 100ul );
  BOOST_CHECK_EQUAL( var->production_interval(), 1000ul );

  // write class instance to archive
  boost::archive::text_oarchive oa( store );
  oa << var;
}
{
  boost::shared_ptr< platform::simulation_manager > var2;
  // read class instance from archive
  boost::archive::text_iarchive ia( store );
  ia >> var2;

  BOOST_CHECK_EQUAL( var2->equilibration_interval(), 100ul );
  BOOST_CHECK_EQUAL( var2->production_interval(), 1000ul );
}
!!!1914928.cpp!!!	storage_meta_lifetime_test() : void
{
  // Test for virtual object pattern
  BOOST_CHECK( not std::is_default_constructible< platform::storage_meta >::type {} );
  BOOST_CHECK( not std::is_copy_constructible< platform::storage_meta >::type {} );
  BOOST_CHECK( not std::is_move_constructible< platform::storage_meta >::type {} );
  BOOST_CHECK( not ( std::is_assignable< platform::storage_meta, platform::storage_meta >::type {} ) );
  BOOST_CHECK( std::has_virtual_destructor< platform::storage_meta >::type {} );
}
{
  boost::shared_ptr< platform::storage_manager > tmp;
  boost::shared_ptr< platform::storage_meta > var( new platform::storage_meta( tmp ) );
  BOOST_CHECK_EQUAL( var->size(), 0ul );
  BOOST_CHECK( var->empty() );
}
{
  BOOST_CHECK_EQUAL( platform::storage_meta::checkpoint_name_label(), "checkname" );
  BOOST_CHECK_EQUAL( platform::storage_meta::output_name_label(), "outname" );
  BOOST_CHECK_EQUAL( platform::storage_meta::storage_label(), "run" );
}
!!!1914800.cpp!!!	storage_meta_methods_test() : void
{
  boost::shared_ptr< platform::storage_manager > tmp;
  boost::shared_ptr< platform::storage_meta > var( new platform::storage_meta( tmp ) );
  BOOST_CHECK_EQUAL( var->size(), 0ul );
  BOOST_CHECK( not var->has_type( platform::serial_storage::type_label_() ) );
  platform::serial_storage::add_definition( *var );
  BOOST_CHECK( var->has_type( platform::serial_storage::type_label_() ) );
}
!!!1915056.cpp!!!	run_input_test() : void
core::input_delegater dg( 1 );
std::string type_label( "test" );
const std::string cname( "checkpoint.arc" );
const std::string test_cname( "check.dat" );
const std::string fbase( "input.\%1$03d.inp" );
const std::string test_fbase( "channel.\%1$04d.inp" );
const std::string dbase( "\%1$03d" );
const std::string outpath( "001" );
const std::string outdir( "001/" );
const std::string test_dbase( "\%1$04d.dat" );
const std::string test_outpath( "5999.dat" );
const std::string test_outdir( "5999.dat/" );
const std::string oname( "output.dbm" );
const std::string test_oname( "result.zip" );
boost::shared_ptr< platform::platform_test::simple_storage_manager > fstype( new platform::platform_test::simple_storage_manager );
{
  boost::shared_ptr< platform::storage_meta > meta( new platform::storage_meta( fstype ) );
  std::string desc( "Test storage manager." );
  std::unique_ptr< storage_definition > defn( new storage_definition( type_label, desc ) );
  // no extra parameters
  meta->add_type( defn );

  BOOST_REQUIRE( meta->has_type( "test" ) );

  dg.add_input_delegate( meta );
}

BOOST_CHECK_EQUAL( fstype->checkpoint_name(), cname );
BOOST_CHECK_EQUAL( fstype->filename_base(), fbase );
BOOST_CHECK_EQUAL( fstype->output_dir_fmt(), dbase );
BOOST_CHECK_EQUAL( fstype->output_name(), oname );
 
// Should be valid input
/////////////////////////////
std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "Unexpected exception thrown by \"dg.read_input( reader )\": " ) + err.what() );
}

BOOST_CHECK_EQUAL( fstype->checkpoint_name(), test_cname );
BOOST_CHECK_EQUAL( fstype->filename_base(), fbase );
BOOST_CHECK_EQUAL( fstype->output_dir_fmt(), test_dbase );
BOOST_CHECK_EQUAL( fstype->output_name(), test_oname );
const std::string slog( fstype->thelog->str() );
BOOST_CHECK( slog.find( fbase ) < slog.size() );
BOOST_CHECK( slog.find( test_fbase ) < slog.size() );
//std::cout << "\n" << slog << "\n";
!!!1824048.cpp!!!	run_input_type_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< platform::storage_manager > fstype( new platform::platform_test::simple_storage_manager );
{
  boost::shared_ptr< platform::storage_meta > meta( new platform::storage_meta( fstype ) );
  std::string type_label( "test" );
  std::string desc( "Test storage manager." );
  std::unique_ptr< storage_definition > defn( new storage_definition( type_label, desc ) );
  // no extra parameters
  meta->add_type( defn );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "run\ntype #\"standard\"\noutdir \"%1$07d\"\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Parameter \"type\" requires a value in a run section." ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1824176.cpp!!!	run_input_type_bad_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< platform::storage_manager > fstype( new platform::platform_test::simple_storage_manager );
{
  boost::shared_ptr< platform::storage_meta > meta( new platform::storage_meta( fstype ) );
  std::string type_label( "test" );
  std::string desc( "Test storage manager." );
  std::unique_ptr< storage_definition > defn( new storage_definition( type_label, desc ) );
  // no extra parameters
  meta->add_type( defn );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "run\ntype \"standard\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Run \"type\" parameter value (standard) does not name a valid storage manager subtype for this application" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1824304.cpp!!!	run_input_duplicate_type_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< platform::storage_manager > fstype( new platform::platform_test::simple_storage_manager );
{
  boost::shared_ptr< platform::storage_meta > meta( new platform::storage_meta( fstype ) );
  std::string type_label( "test" );
  std::string desc( "Test storage manager." );
  std::unique_ptr< storage_definition > defn( new storage_definition( type_label, desc ) );
  // no extra parameters
  meta->add_type( defn );

  dg.add_input_delegate( meta );
}
// Type is repeated
/////////////////////////////
std::string canon_input( "run\ntype \"test\"\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Run \"type\" parameter appears more than once" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1824432.cpp!!!	run_input_checkname_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< platform::storage_manager > fstype( new platform::platform_test::simple_storage_manager );
{
  boost::shared_ptr< platform::storage_meta > meta( new platform::storage_meta( fstype ) );
  std::string type_label( "test" );
  std::string desc( "Test storage manager." );
  std::unique_ptr< storage_definition > defn( new storage_definition( type_label, desc ) );
  // no extra parameters
  meta->add_type( defn );

  dg.add_input_delegate( meta );
}
// Checkname is hidden by comment character
/////////////////////////////
std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname #check.dat\noutname result.zip\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Parameter \"checkname\" requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1824560.cpp!!!	run_input_outname_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< platform::storage_manager > fstype( new platform::platform_test::simple_storage_manager );
{
  boost::shared_ptr< platform::storage_meta > meta( new platform::storage_meta( fstype ) );
  std::string type_label( "test" );
  std::string desc( "Test storage manager." );
  std::unique_ptr< storage_definition > defn( new storage_definition( type_label, desc ) );
  // no extra parameters
  meta->add_type( defn );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname #result.zip\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  //std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Parameter \"outname\" requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}


!!!1824688.cpp!!!	run_input_outdir_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< platform::storage_manager > fstype( new platform::platform_test::simple_storage_manager );
{
  boost::shared_ptr< platform::storage_meta > meta( new platform::storage_meta( fstype ) );
  std::string type_label( "test" );
  std::string desc( "Test storage manager." );
  std::unique_ptr< storage_definition > defn( new storage_definition( type_label, desc ) );
  // no extra parameters
  meta->add_type( defn );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir #\"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Parameter \"outputdir\" requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1824816.cpp!!!	run_input_inputpattern_no_value_test() : void
core::input_delegater dg( 1 );
boost::shared_ptr< platform::storage_manager > fstype( new platform::platform_test::simple_storage_manager );
{
  boost::shared_ptr< platform::storage_meta > meta( new platform::storage_meta( fstype ) );
  std::string type_label( "test" );
  std::string desc( "Test storage manager." );
  std::unique_ptr< storage_definition > defn( new storage_definition( type_label, desc ) );
  // no extra parameters
  meta->add_type( defn );

  dg.add_input_delegate( meta );
}
// Type is hidden by comment character
/////////////////////////////
std::string canon_input( "run\ntype \"test\"\ninput #\"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
core::input_preprocess reader;
reader.add_buffer( "dummy", canon_input );

try
{
  dg.read_input( reader );
  BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
}
catch( std::runtime_error const& err )
{
  const std::string msg( err.what() );
  // std::cout << msg << "\n";
  BOOST_CHECK( msg.find( "Parameter \"input\" requires a value" ) < msg.size() );
}
catch( std::exception const& err )
{
  BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
}
!!!1824944.cpp!!!	trial_input_rate_nonnumber_value_test() : void
//XX core::input_delegater dg( 1 );
//XX boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
//XX {
//XX   boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );
//XX 
//XX   trial::move_choice::add_definition( *meta );
//XX 
//XX   BOOST_REQUIRE( meta->has_trial_type( "move" ) );
//XX 
//XX   dg.add_input_delegate( meta );
//XX }
//XX // Type is hidden by comment character
//XX /////////////////////////////
//XX std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
//XX core::input_preprocess reader;
//XX reader.add_buffer( "dummy", canon_input );
//XX 
//XX try
//XX {
//XX   dg.read_input( reader );
//XX   BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
//XX }
//XX catch( std::runtime_error const& err )
//XX {
//XX   const std::string msg( err.what() );
//XX   // std::cout << msg << "\n";
//XX   BOOST_CHECK( msg.find( "Trial \"rate\" parameter value (one) is not a number" ) < msg.size() );
//XX }
//XX catch( std::exception const& err )
//XX {
//XX   BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX }
//XX 
//XX 
!!!1825072.cpp!!!	trial_input_duplicate_rate_test() : void
//XX core::input_delegater dg( 1 );
//XX boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
//XX {
//XX   boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );
//XX 
//XX   trial::move_choice::add_definition( *meta );
//XX 
//XX   BOOST_REQUIRE( meta->has_trial_type( "move" ) );
//XX 
//XX   dg.add_input_delegate( meta );
//XX }
//XX // Type is hidden by comment character
//XX /////////////////////////////
//XX std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
//XX core::input_preprocess reader;
//XX reader.add_buffer( "dummy", canon_input );
//XX 
//XX try
//XX {
//XX   dg.read_input( reader );
//XX   BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
//XX }
//XX catch( std::runtime_error const& err )
//XX {
//XX   const std::string msg( err.what() );
//XX   // std::cout << msg << "\n";
//XX   BOOST_CHECK( msg.find( "Trial \"rate\" parameter appears more than once" ) < msg.size() );
//XX }
//XX catch( std::exception const& err )
//XX {
//XX   BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX }
//XX 
//XX 
!!!1825200.cpp!!!	trial_input_specielist_no_value_test() : void
//XX core::input_delegater dg( 1 );
//XX boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
//XX {
//XX   boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );
//XX 
//XX   trial::move_choice::add_definition( *meta );
//XX 
//XX   BOOST_REQUIRE( meta->has_trial_type( "move" ) );
//XX 
//XX   dg.add_input_delegate( meta );
//XX }
//XX // Type is hidden by comment character
//XX /////////////////////////////
//XX std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
//XX core::input_preprocess reader;
//XX reader.add_buffer( "dummy", canon_input );
//XX 
//XX try
//XX {
//XX   dg.read_input( reader );
//XX   BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
//XX }
//XX catch( std::runtime_error const& err )
//XX {
//XX   const std::string msg( err.what() );
//XX   //std::cout << msg << "\n";
//XX   BOOST_CHECK( msg.find( "Trial \"specie\" parameter requires a value" ) < msg.size() );
//XX }
//XX catch( std::exception const& err )
//XX {
//XX   BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX }
//XX 
//XX 
!!!1825328.cpp!!!	trial_input_duplicate_specielist_test() : void
//XX core::input_delegater dg( 1 );
//XX boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
//XX {
//XX   boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );
//XX 
//XX   trial::move_choice::add_definition( *meta );
//XX 
//XX   BOOST_REQUIRE( meta->has_trial_type( "move" ) );
//XX 
//XX   dg.add_input_delegate( meta );
//XX }
//XX // Type is hidden by comment character
//XX /////////////////////////////
//XX std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
//XX core::input_preprocess reader;
//XX reader.add_buffer( "dummy", canon_input );
//XX 
//XX try
//XX {
//XX   dg.read_input( reader );
//XX   BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
//XX }
//XX catch( std::runtime_error const& err )
//XX {
//XX   const std::string msg( err.what() );
//XX   // std::cout << msg << "\n";
//XX   BOOST_CHECK( msg.find( "Trial \"specie\" parameter appears more than once" ) < msg.size() );
//XX }
//XX catch( std::exception const& err )
//XX {
//XX   BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX }
//XX 
//XX 
!!!1825456.cpp!!!	trial_input_move_delta_no_value_test() : void
//XX core::input_delegater dg( 1 );
//XX boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
//XX {
//XX   boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );
//XX 
//XX   trial::move_choice::add_definition( *meta );
//XX 
//XX   BOOST_REQUIRE( meta->has_trial_type( "move" ) );
//XX 
//XX   dg.add_input_delegate( meta );
//XX }
//XX // Type is hidden by comment character
//XX /////////////////////////////
//XX std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
//XX core::input_preprocess reader;
//XX reader.add_buffer( "dummy", canon_input );
//XX auto pman = trial_test::mockup_particle_manager();
//XX auto gman = trial_test::mockup_geometry_manager();
//XX boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
//XX utility::random_distribution rgnr( generator );
//XX 
//XX try
//XX {
//XX   // attributes from parameters are only tested when choice object
//XX   // is created (e.g. in choice_manager::prepare)
//XX   BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
//XX   cman->prepare( pman->get_species(), *gman, rgnr );  
//XX   // If no exception then check for number of choices created.
//XX   BOOST_CHECK_EQUAL( cman->size(), 5 );
//XX   BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
//XX }
//XX catch( std::runtime_error const& err )
//XX {
//XX   const std::string msg( err.what() );
//XX   //std::cout << msg << "\n";
//XX   BOOST_CHECK( msg.find( "Move trial \"delta\" parameter requires a value" ) < msg.size() );
//XX }
//XX catch( std::exception const& err )
//XX {
//XX   BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX }
//XX 
//XX 
!!!1825584.cpp!!!	trial_input_move_delta_negative_value_test() : void
//XX core::input_delegater dg( 1 );
//XX boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
//XX {
//XX   boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );
//XX 
//XX   trial::move_choice::add_definition( *meta );
//XX 
//XX   BOOST_REQUIRE( meta->has_trial_type( "move" ) );
//XX 
//XX   dg.add_input_delegate( meta );
//XX }
//XX // Type is hidden by comment character
//XX /////////////////////////////
//XX std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
//XX core::input_preprocess reader;
//XX reader.add_buffer( "dummy", canon_input );
//XX 
//XX auto pman = trial_test::mockup_particle_manager();
//XX auto gman = trial_test::mockup_geometry_manager();
//XX boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
//XX utility::random_distribution rgnr( generator );
//XX try
//XX {
//XX   // attributes from parameters are only tested when choice object
//XX   // is created (e.g. in choice_manager::prepare)
//XX   BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
//XX   cman->prepare( pman->get_species(), *gman, rgnr );
//XX   BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
//XX }
//XX catch( std::runtime_error const& err )
//XX {
//XX   const std::string msg( err.what() );
//XX   // std::cout << msg << "\n";
//XX   BOOST_CHECK( msg.find( "Move trial \"delta\" parameter value (-0.5) must be greater than zero" ) < msg.size() );
//XX }
//XX catch( std::exception const& err )
//XX {
//XX   BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX }
//XX 
//XX 
!!!1825712.cpp!!!	trial_input_move_delta_zero_value_test() : void
//XX core::input_delegater dg( 1 );
//XX boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
//XX {
//XX   boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );
//XX 
//XX   trial::move_choice::add_definition( *meta );
//XX 
//XX   BOOST_REQUIRE( meta->has_trial_type( "move" ) );
//XX 
//XX   dg.add_input_delegate( meta );
//XX }
//XX // Type is hidden by comment character
//XX /////////////////////////////
//XX std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
//XX core::input_preprocess reader;
//XX reader.add_buffer( "dummy", canon_input );
//XX 
//XX auto pman = trial_test::mockup_particle_manager();
//XX auto gman = trial_test::mockup_geometry_manager();
//XX boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
//XX utility::random_distribution rgnr( generator );
//XX try
//XX {
//XX   // attributes from parameters are only tested when choice object
//XX   // is created (e.g. in choice_manager::prepare)
//XX   BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
//XX   cman->prepare( pman->get_species(), *gman, rgnr );  
//XX   // If no exception then check for number of choices created.
//XX   BOOST_CHECK_EQUAL( cman->size(), 5 );
//XX   BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
//XX }
//XX catch( std::runtime_error const& err )
//XX {
//XX   const std::string msg( err.what() );
//XX   // std::cout << msg << "\n";
//XX   BOOST_CHECK( msg.find( "Move trial \"delta\" parameter value (0.0) must be greater than zero" ) < msg.size() );
//XX }
//XX catch( std::exception const& err )
//XX {
//XX   BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX }
//XX 
//XX 
!!!1825840.cpp!!!	trial_input_move_delta_nonnumber_value_test() : void
//XX core::input_delegater dg( 1 );
//XX boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
//XX {
//XX   boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );
//XX 
//XX   trial::move_choice::add_definition( *meta );
//XX 
//XX   BOOST_REQUIRE( meta->has_trial_type( "move" ) );
//XX 
//XX   dg.add_input_delegate( meta );
//XX }
//XX // Type is hidden by comment character
//XX /////////////////////////////
//XX std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
//XX core::input_preprocess reader;
//XX reader.add_buffer( "dummy", canon_input );
//XX 
//XX auto pman = trial_test::mockup_particle_manager();
//XX auto gman = trial_test::mockup_geometry_manager();
//XX boost::shared_ptr< boost::mt19937> generator( new boost::mt19937 );
//XX utility::random_distribution rgnr( generator );
//XX try
//XX {
//XX   // attributes from parameters are only tested when choice object
//XX   // is created (e.g. in choice_manager::prepare)
//XX   BOOST_REQUIRE_NO_THROW( dg.read_input( reader ) );
//XX   cman->prepare( pman->get_species(), *gman, rgnr );  
//XX   // If no exception then check for number of choices created.
//XX   BOOST_CHECK_EQUAL( cman->size(), 5 );
//XX   BOOST_ERROR( "expected \"cman->prepare( ... )\" exception not thrown" );
//XX }
//XX catch( std::runtime_error const& err )
//XX {
//XX   const std::string msg( err.what() );
//XX   // std::cout << msg << "\n";
//XX   BOOST_CHECK( msg.find( "Move trial \"delta\" parameter value (one) is not a number" ) < msg.size() );
//XX }
//XX catch( std::exception const& err )
//XX {
//XX   BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX }
//XX 
//XX 
!!!1825968.cpp!!!	trial_input_move_duplicate_delta_test() : void
//XX core::input_delegater dg( 1 );
//XX boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
//XX {
//XX   boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );
//XX 
//XX   trial::move_choice::add_definition( *meta );
//XX 
//XX   BOOST_REQUIRE( meta->has_trial_type( "move" ) );
//XX 
//XX   dg.add_input_delegate( meta );
//XX }
//XX // Type is hidden by comment character
//XX /////////////////////////////
//XX std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
//XX core::input_preprocess reader;
//XX reader.add_buffer( "dummy", canon_input );
//XX 
//XX try
//XX {
//XX   dg.read_input( reader );
//XX   BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
//XX }
//XX catch( std::runtime_error const& err )
//XX {
//XX   const std::string msg( err.what() );
//XX   // std::cout << msg << "\n";
//XX   BOOST_CHECK( msg.find( "Trial \"delta\" parameter appears more than once" ) < msg.size() );
//XX }
//XX catch( std::exception const& err )
//XX {
//XX   BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX }
//XX 
//XX 
!!!1826096.cpp!!!	trial_input_move_unknown_parameter_test() : void
//XX core::input_delegater dg( 1 );
//XX boost::shared_ptr< trial::choice_manager > cman( new trial::choice_manager );
//XX {
//XX   boost::shared_ptr< trial::choice_meta > meta( new trial::choice_meta( cman ) );
//XX 
//XX   trial::move_choice::add_definition( *meta );
//XX 
//XX   BOOST_REQUIRE( meta->has_trial_type( "move" ) );
//XX 
//XX   dg.add_input_delegate( meta );
//XX }
//XX // Type is hidden by comment character
//XX /////////////////////////////
//XX std::string canon_input( "run\ntype \"test\"\ninput \"channel.\%1$04d.inp\"\noutputdir \"\%1$04d.dat\"\ncheckname check.dat\noutname result.zip\nend\n\n" );
//XX core::input_preprocess reader;
//XX reader.add_buffer( "dummy", canon_input );
//XX 
//XX try
//XX {
//XX   dg.read_input( reader );
//XX   BOOST_ERROR( "expected \"dg.read_input( reader )\" exception not thrown" );
//XX }
//XX catch( std::runtime_error const& err )
//XX {
//XX   const std::string msg( err.what() );
//XX   // std::cout << msg << "\n";
//XX   BOOST_CHECK( msg.find( "Trial \"DELTA\" parameter with value (0.5) is not understood by move trial" ) < msg.size() );
//XX }
//XX catch( std::exception const& err )
//XX {
//XX   BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
//XX }
//XX 
//XX 
!!!1822128.cpp!!!	add_specie_choice_test() : void
//XX const double prob = 0.1;
//XX {
//XX   // Test is virtual object pattern
//XX   BOOST_CHECK( not std::is_default_constructible< trial::add_specie >::type {} );
//XX   BOOST_CHECK( not std::is_copy_constructible< trial::add_specie >::type {} );
//XX   BOOST_CHECK( not std::is_move_constructible< trial::add_specie >::type {} );
//XX   BOOST_CHECK( not( std::is_assignable< trial::add_specie, trial::add_specie >::type {} ) );
//XX   BOOST_CHECK( std::has_virtual_destructor< trial::add_specie >::type {} );
//XX }
//XX particle::change_hash key1( 0, 0, 1, 0 );
//XX boost::shared_ptr< trial::add_specie > var1( new trial::add_specie( 0ul ) );
//XX BOOST_CHECK_EQUAL( var1->key(), key1 );
//XX BOOST_CHECK_EQUAL( var1->probability(), 0 );
//XX 
//XX BOOST_CHECK_NO_THROW( var1->set_probability( prob ) );
//XX BOOST_CHECK_EQUAL( var1->probability(), prob );
//XX 
//XX trial_test::test_base_choice_methods( var1 );
//XX 
//XX {
//XX   std::map< std::string, std::string > params;
//XX   trial_test::test_choice_generate< trial::add_specie >( params );
//XX 
//XX   trial_test::test_make_chooser_methods< trial::chooser_pair< trial::add_specie,trial::remove_specie  > >( params, "individual", "", 0.5, 4, 0.125 );
//XX }
//XX 
