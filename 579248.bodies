class lennard_jones
!!!1416112.cpp!!!	compute_potential(in pman : particle_manager, in gman : geometry_manager, inout changes : change_set) : void
auto const& ens = pman.get_ensemble();
// For each atom
for( auto &atom : changes )
{
  const std::size_t idx = atom.index;
  const std::size_t cache_offset = idx * pman.specie_count();
  double energy_old = 0.0;
  double energy_new = 0.0;
  // Use cache epsilon and sigma
  for( std::size_t j = 0; j != ens.size(); ++j )
  {
    // Only use active particles.
    if( j != idx and particle::specie_key::nkey != ens.key( j ) )
    {
      const std::size_t jspec = ens.key( j );
      const double eps_ij = this->epsilon_cache_[ cache_offset + jspec ];
      const double sig_ij = this->sigma_cache_[ cache_offset + jspec ];
      if( atom.do_new )
      {
        // NEW
        // Use atom.new_rij
        const double r6 { std::pow( sig_ij / atom.new_rij[ j ], 6 ) };
        const double r12 { std::pow( r6, 2 ) };
        energy_new += eps_ij * ( r12 - r6 );
      }
      if( atom.do_old )
      {
        // OLD
        // --------------------------------
        // Use atom.old_rij
        const double r6 { std::pow( sig_ij / atom.old_rij[ j ], 6 ) };
        const double r12 { std::pow( r6, 2 ) };
        energy_old += eps_ij * ( r12 - r6 );
      }
    }
  }
  atom.energy_new += energy_new;
  atom.energy_old += energy_old;
}

!!!1416112.python!!!	compute_potential(in pman : particle_manager, in gman : geometry_manager, inout changes : change_set) : void
if changes.fail:
  return
import numpy as np
ens = sys.get_ensemble()
nspec = sys.specie_count ()
spcs = sys.get_species()
## valency = np.array([x.valency for x in spcs]+[0,])
## radius = np.array([x.radius for x in spcs]+[0,])
for atom in changes.changes:
  idx = atom.index
  energy_old = 0.0
  energy_new = 0.0
  ri = spcs[ atom.key ].radius()
  ## if atom.do_new:
  ##   select_indices = np.where(np.logical_and(ens.key[start_index:len(ens)] != nspec, atom.new_rij[start_index:len(ens)] != 0.0))
  ##   changes.fail = np.any(atom.new_rij[select_indices] < radius[ ens.key[select_indices] ] + ri)
  ##   if changes.fail:
  ##     return
  ##   energy_new += np.sum(valency[ ens.key[select_indices] ] / atom.new_rij[select_indices])
  ## if atom.do_old:
  ##   select_indices = np.where(np.logical_and(ens.key[start_index:len(ens)] != nspec, atom.old_rij[start_index:len(ens)] != 0.0))
  ##   energy_old += np.sum(valency[ ens.key[select_indices] ] / atom.old_rij[select_indices])
  for jj, jspec in enumerate(ens.key[start_index:len(ens)], start_index):
    if jj != idx and jspec != nspec:
      if atom.do_new:
        if atom.new_rij[jj] < spcs[ jspec ].radius() + ri:
          changes.fail = True # set fail on overlap
          return
        # New energy
        energy_new += (spcs[ jspec ].valency() / atom.new_rij[jj])
      if atom.do_old:
        # Old energy
        energy_old += (spcs[ jspec ].valency() / atom.old_rij[jj])
  # scale the energy by constants and add to atom
  atom.energy_old += energy_old * spcs[ atom.key ].valency() * self.scalar_
  atom.energy_new += energy_new * spcs[ atom.key ].valency() * self.scalar_
!!!1416240.cpp!!!	compute_total_potential(in pman : particle_manager, in gman : geometry_manager) : double
// Calculate the pairwise coulomb energies between
// all charged particles.
double energy = 0.0;
auto const& ens = pman.get_ensemble();
std::vector< double > rij( ens.size(), 0.0 );

for( std::size_t idx = 0; idx != ens.size() - 1; ++idx )
{
  const std::size_t ispec = ens.key( idx );
  if( particle::specie_key::nkey == ispec )
  {
    continue;
  }
  const std::size_t cache_offset = ispec * pman.specie_count();
  // calculate rij vector
  gman.calculate_distances( ens.position( idx ), ens.get_coordinates(), rij, idx + 1, ens.size() );

  for( std::size_t jdx = idx + 1; jdx != ens.size(); ++jdx )
  {
    const std::size_t jspec = ens.key( jdx );
    if( particle::specie_key::nkey != jspec )
    {
      const double eps_ij = this->epsilon_cache_[ cache_offset + jspec ];
      const double sig_ij = this->sigma_cache_[ cache_offset + jspec ];
      const double r6 = std::pow( sig_ij / rij[ jdx ], 6 );
      const double r12 = std::pow( r6, 2 );
      energy += eps_ij * ( r12 - r6 );
    }
  }
}
return energy;

!!!1416240.python!!!	compute_total_potential(in pman : particle_manager, in gman : geometry_manager) : double
if changes.fail:
  return
import numpy as np
ens = sys.get_ensemble()
nspec = sys.specie_count ()
spcs = sys.get_species()
## valency = np.array([x.valency for x in spcs]+[0,])
## radius = np.array([x.radius for x in spcs]+[0,])
for atom in changes.changes:
  idx = atom.index
  energy_old = 0.0
  energy_new = 0.0
  ri = spcs[ atom.key ].radius()
  ## if atom.do_new:
  ##   select_indices = np.where(np.logical_and(ens.key[start_index:len(ens)] != nspec, atom.new_rij[start_index:len(ens)] != 0.0))
  ##   changes.fail = np.any(atom.new_rij[select_indices] < radius[ ens.key[select_indices] ] + ri)
  ##   if changes.fail:
  ##     return
  ##   energy_new += np.sum(valency[ ens.key[select_indices] ] / atom.new_rij[select_indices])
  ## if atom.do_old:
  ##   select_indices = np.where(np.logical_and(ens.key[start_index:len(ens)] != nspec, atom.old_rij[start_index:len(ens)] != 0.0))
  ##   energy_old += np.sum(valency[ ens.key[select_indices] ] / atom.old_rij[select_indices])
  for jj, jspec in enumerate(ens.key[start_index:len(ens)], start_index):
    if jj != idx and jspec != nspec:
      if atom.do_new:
        if atom.new_rij[jj] < spcs[ jspec ].radius() + ri:
          changes.fail = True # set fail on overlap
          return
        # New energy
        energy_new += (spcs[ jspec ].valency() / atom.new_rij[jj])
      if atom.do_old:
        # Old energy
        energy_old += (spcs[ jspec ].valency() / atom.old_rij[jj])
  # scale the energy by constants and add to atom
  atom.energy_old += energy_old * spcs[ atom.key ].valency() * self.scalar_
  atom.energy_new += energy_new * spcs[ atom.key ].valency() * self.scalar_
!!!1416368.cpp!!!	do_description(inout os : ostream) : void
os << " Compute the change in pair-wise Lennard-Jones potential\n";
auto getkeys = [](decltype(*this->epsilon_.begin()) & it) {
  return it.first; };
std::vector< std::string > keys(this->epsilon_.size());
std::transform( this->epsilon_.begin(), this->epsilon_.end(), keys.begin(), getkeys );
std::stringstream title, eps, sig;
for( auto const& label : keys )
{
  title << std::setw(6) << label << " ";
  eps   << std::setw(6) << std::setprecision(2) << this->epsilon_.at( label ) << " ";
  sig   << std::setw(6) << std::setprecision(2) << this->sigma_.at( label )   << " ";
}
os << " Species  : " << title.str() << "\n";
os << " Epsilons : " << eps.str() << "\n";
os << " Sigmas   : " << sig.str() << "\n";
!!!1416368.python!!!	do_description(inout os : ostream) : void
print >>os, "[evaluator] coulomb"
print >>os, " Calculate the change in interparticle Coulomb"
print >>os, " potential."
print >>os, " Independent scale factor: ", self.factor_
print >>os, " Temperature dep. factor : ", self.scalar_
pass
!!!1416752.cpp!!!	prepare(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager) : void
// It is an error in the input for a species not to have a
// matching entry in epsilon or sigma
UTILITY_INPUT( pman.specie_count() == this->epsilon_.size(), "Less species than epsilon values in Lennard-Jones potential evaluator.", core::strngs::evaluator_label() );
UTILITY_INPUT( pman.specie_count() == this->sigma_.size(), "Less species than sigma values in Lennard-Jones potential evaluator.", core::strngs::evaluator_label() );
// calculate "half" the epsilon and sigma value
std::vector< double > eps( pman.specie_count() );
std::vector< double > sig( pman.specie_count() );
for (std::size_t ispec = 0; ispec != pman.specie_count(); ++ispec )
{
  auto const& spc = pman.get_specie( ispec );
  UTILITY_INPUT( this->epsilon_.count( spc.label() ), "Missing epsilon value for \"" + spc.label() + "\" specie in Lennard-Jones potential evaluator.", core::strngs::evaluator_label() );
  UTILITY_INPUT( this->sigma_.count( spc.label() ), "Missing sigma value for \"" + spc.label() + "\" specie in Lennard-Jones potential evaluator.", core::strngs::evaluator_label() );
  eps[ ispec ] = std::sqrt( this->epsilon_.at( spc.label() ) );
  sig[ ispec ] = this->sigma_.at( spc.label() ) / 2;
}
// Build epsilon and sigma value cache
std::vector< double > epsilon( pman.specie_count() * pman.specie_count() );
std::vector< double > sigma( pman.specie_count() * pman.specie_count() );
for( std::size_t ispec = 0; ispec != pman.specie_count(); ++ispec )
{
  const std::size_t offset = ispec * pman.specie_count();
  const double ep1 = eps[ ispec ];
  const double sg1 = sig[ ispec ];
  for( std::size_t jspec = 0; jspec != pman.specie_count(); ++jspec )
  {
    epsilon[ offset + jspec ] = ep1 * eps[ jspec ];
    sigma[ offset + jspec ] = sg1 + sig[ jspec ];
  }
}
std::swap( this->epsilon_cache_, epsilon );
std::swap( this->sigma_cache_, sigma );
!!!1417008.cpp!!!	do_write_document(inout wr : input_document, in ix : size_t) : void
{
  std::stringstream val;
  for( auto const& entry : this->epsilon_ )
  {
    val << entry.first << " " << entry.second << " ";
  }
  std::string value( val.str() );
  value.resize( value.size() - 1 );
  wr[ ix ].add_entry( "epsilon", value );
}
{
  std::stringstream val;
  for( auto const& entry : this->sigma_ )
  {
    val << entry.first << " " << entry.second << " ";
  }
  std::string value( val.str() );
  value.resize( value.size() - 1 );
  wr[ ix ].add_entry( "sigma", value );
}
!!!1417136.cpp!!!	make_definition() : evaluator_definition
std::unique_ptr< evaluator_definition > defn( new evaluator_definition( lennard_jones::type_label_(), &lennard_jones::make_evaluator ) );
// add parameter definitions.
defn->add_definition( "epsilon", "[required, list(specie label,number)] A list of specie labels and energy minima between two ideal particles of the labelled type." );
defn->add_definition( "sigma", "[required, list(specie label,number)] A list of specie labels and the distance at the energy minima between two ideal particles of the labelled type." );

return defn;
!!!1417392.cpp!!!	make_evaluator(in param_set : string) : base_evaluator
// Check no parameters have been set
UTILITY_INPUT( param_set.size() == 2, "LJ evaluator requires two input parameters.", core::strngs::evaluator_label() );
std::unique_ptr< lennard_jones > cc( new lennard_jones );
std::map< std::string, double > eps, sig;
{
   std::stringstream is( param_set.at( "epsilon" ) );
   while( not is.eof() )
   {
      std::string label;
      double val;
      is >> label >> val;
      // Conversion failed so no more labels/numbers for conversion ?
      if (not is) break;
      label = core::input_base_reader::dequote( label );
      boost::algorithm::trim( label );
      UTILITY_INPUT( label.size() == 2 or label.size() == 1, "Specie label (" + label + ") is invalid in parameter \"epsilon\" value (" + param_set.at( "epsilon" ) + ") in a evaluator section.", core::strngs::evaluator_label() );
      eps.insert( std::make_pair( label, val ) );
   }
UTILITY_INPUT( is.eof(), "Parameter \"epsilon\" value (" + param_set.at( "epsilon" ) + ") not a list of (label value) pairs in evaluator section.", core::strngs::evaluator_label() );    
}
{
   std::stringstream is( param_set.at( "sigma" ) );
   while( not is.eof() )
   {
      std::string label;
      double val;
      is >> label >> val;
      // Conversion failed so no more labels/numbers for conversion ?
      if (not is) break;
      label = core::input_base_reader::dequote( label );
      boost::algorithm::trim( label );
      UTILITY_INPUT( label.size() == 2 or label.size() == 1, "Specie label (" + label + ") is invalid in parameter \"sigma\" value (" + param_set.at( "sigma" ) + ") in a evaluator section.", core::strngs::evaluator_label() );
      eps.insert( std::make_pair( label, val ) );
   }
UTILITY_INPUT( is.eof(), "Parameter \"sigma\" value (" + param_set.at( "sigma" ) + ") not a list of (label value) pairs in evaluator section.", core::strngs::evaluator_label() );    
}
UTILITY_INPUT( eps.size() == sig.size(), "Parameter \"epsilon\" value (" + param_set.at( "epsilon" ) + ") has a different size list to parameter \"sigma\" value (" + param_set.at( "sigma" ) + ") in a evaluator section.", core::strngs::evaluator_label() );
std::swap( cc->epsilon_, eps );
std::swap( cc->sigma_, sig );
return std::unique_ptr< base_evaluator >( cc.release() );

