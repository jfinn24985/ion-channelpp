class application
!!!576944.cpp!!!	main(in argc : int, in argv : char) : bool
// NOTE: The input decoders are not required to check that the final system is
// valid.
std::ostream &oslog( std::cout );
if (argc > 1)
{
   namespace po = boost::program_options;
   po::options_description cmdln_opts("Allowed Options");
   cmdln_opts.add_options()
   ("run", po::value<unsigned int>(), "Simulation run number (positive integer).")
   (core::strngs::inputpattern_label().c_str(), po::value<std::string>(), "Plain or printf style format string for generating input filename")
   ("seed", po::value<unsigned int>(), "Simulation random seed value (positive integer).")
   ("restart", po::value<std::string>(), "Check point file for simulation restart")
   ("help", "Produce help message");
   po::variables_map vm;
   try
   {
      po::store(po::parse_command_line(argc, argv, cmdln_opts), vm);
      po::notify(vm);
   }
   catch (std::exception &err)
   {
      oslog << "Error : " << err.what() << "\n";
      oslog << cmdln_opts << "\n";
      return false;
   }
   // After here, 'vm' will contain typed values as
   // specified via po::value<> statement or an error
   // would have been raised.
   if (vm.count("help"))
   {
      oslog << cmdln_opts << "\n";
      return false;
   }

   if (vm.count("restart"))
   {
      if (vm.count("seed"))
      {
         oslog << core::strngs::horizontal_bar () << "\n";
         oslog << "Random seed value on command line is ignored with restart.\n";
      }
      if (vm.count(core::strngs::inputpattern_label()))
      {
         oslog << core::strngs::horizontal_bar () << "\n";
         oslog << "Input filename on command line is ignored with restart.\n";
      }
      if (vm.count("run"))
      {
         oslog << core::strngs::horizontal_bar () << "\n";
         oslog << "Run number on command line is ignored with restart.\n";
      }
      const std::string fn { vm["restart"].as<std::string>() };
      UTILITY_INPUT( boost::filesystem::exists( fn ), "Filename \"" + fn + "\" does not exist.", core::strngs::simulator_label() );
      std::ifstream store( fn );
      UTILITY_INPUT( store, "Filename \"" + fn + "\" is not readable.", core::strngs::simulator_label() );
      boost::archive::text_iarchive ia( store );
      ia >> application::simulator_;
      if (not utility::fp_env::env_.no_except())
      {
         oslog << " Floating point exception during deserialization ignored : "
               << utility::fp_env::env_.error_message () << "\n";
         utility::fp_env::env_.reset();
      }
   }
   else
   {
      if (vm.count(core::strngs::inputpattern_label()))
      {
         application::simulator_->set_filename_base( vm[core::strngs::inputpattern_label()].as<std::string>() );
      }
      if (vm.count("run"))
      {
         application::simulator_->set_run_number( vm["run"].as<unsigned int>() );
      }

      // set random generator seed
      const unsigned int seedval( vm.count("seed") ? vm["seed"].as<unsigned int>() : application::simulator_->random_seed_value() );
      oslog << core::strngs::horizontal_bar () << "\n";
      oslog << "Random seed value : " << seedval << ".\n";
      application::simulator_->set_random_seed( seedval );

      const std::string fn( application::simulator_->find_input_filename() );
      oslog << core::strngs::horizontal_bar () << "\n";
      oslog << "Reading input file '" << fn << "'\n";
      core::input_reader reader;
      reader.add_include( fn );
      application::simulator_->read_input( reader, oslog );

      application::simulator_->generate_simulation( oslog );
   }
}
else
{
   // set random generator seed
   const unsigned int seedval( application::simulator_->random_seed_value() );
   oslog << core::strngs::horizontal_bar () << "\n";
   oslog << "Random seed value : " << seedval << ".\n";
   application::simulator_->set_random_seed( seedval );

   // initialize system from defaults
   const std::string fn( application::simulator_->find_input_filename() );
   oslog << core::strngs::horizontal_bar() << "\n";
   oslog << "Reading input file '"<< fn <<"'\n";
   core::input_reader reader;
   reader.add_include( fn );
   application::simulator_->read_input( reader, oslog );

   application::simulator_->generate_simulation( oslog );
}
// Register signals.
application::simulator_->get_reporter().enrol();
application::simulator_->set_checkpoint_function( &application::write_checkpoint );

// Output settings
application::simulator_->description ( oslog );

// Output copy of the original input file
{
   oslog << core::strngs::horizontal_bar () << "\n";
   core::input_document wr( application::simulator_->get_max_input_version() );
   application::simulator_->write_document( wr );
   wr.write( oslog );
   oslog << core::strngs::horizontal_bar () << "\n";
}

// ----------
// After processing input we can now set up the 
// output location.
boost::shared_ptr< utility::base_sink > sink( new utility::gdbm_sink( platform::application::simulator_->compute_output_dir()+"/output.dbm" ) );
platform::application::simulator_->get_reporter().set_sink( sink );
platform::application::checkpoint_path = platform::application::simulator_->compute_output_dir()+"/checkpoint.arc";
// Run the simulation
platform::application::simulator_->run( std::cout );


return true;
!!!807601.cpp!!!	write_checkpoint(in sim : simulator) : void
UTILITY_REQUIRE( sim == application::simulator_.get(),
                 "Simulator given as argument is not this application's simulator" );
boost::filesystem::path temp { application::checkpoint_path };
temp.replace_extension( "tmp" );
{
   std::ofstream store( temp.string() );
   boost::archive::text_oarchive oa( store );
   oa << application::simulator_;
}
// Rename new checkpoint file to correct name
boost::filesystem::rename( temp, application::checkpoint_path );
