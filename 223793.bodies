class particle_test
!!!420145.cpp!!!	change_atom_lifetime_test() : void
const std::vector< double > nrij { 1.0, 1.3, 2.4 };
const std::vector< double > orij { 1.1, 1.4, 2.0 };
const double epsdefault{ 80.0 };
const double epsw{ 70.0 };
{
  // Test is canonical pattern
  BOOST_CHECK( std::is_default_constructible< particle::change_atom >::type{} );
  BOOST_CHECK( std::is_copy_constructible< particle::change_atom >::type{} );
  BOOST_CHECK( std::is_move_constructible< particle::change_atom >::type{} );
  BOOST_CHECK( (std::is_assignable< particle::change_atom, particle::change_atom >::type{}) );
  BOOST_CHECK( not std::has_virtual_destructor< particle::change_atom >::type{} );
}
{
  // Default ctor
  particle::change_atom var1;
  BOOST_CHECK_EQUAL(var1.new_position.x, 0.0);
  BOOST_CHECK_EQUAL(var1.new_position.y, 0.0);
  BOOST_CHECK_EQUAL(var1.new_position.z, 0.0);
  BOOST_CHECK_EQUAL(var1.old_position.x, 0.0);
  BOOST_CHECK_EQUAL(var1.old_position.y, 0.0);
  BOOST_CHECK_EQUAL(var1.old_position.z, 0.0);
  BOOST_CHECK_EQUAL(var1.energy_old, 0.0);
  BOOST_CHECK_EQUAL(var1.energy_new, 0.0);
  BOOST_CHECK_EQUAL(var1.eps_old, 0.0);
  BOOST_CHECK_EQUAL(var1.eps_new, 0.0);
  BOOST_CHECK_EQUAL(var1.index, 0);
  BOOST_CHECK_EQUAL(var1.key, static_cast< std::size_t >(particle::specie_key::nkey));
  BOOST_CHECK_EQUAL(var1.do_old, true);
  BOOST_CHECK_EQUAL(var1.do_new, true);
  BOOST_CHECK(var1.old_rij.empty());
  BOOST_CHECK(var1.new_rij.empty());

}
std::stringstream store;
{
  // Ctor with arg
  particle::change_atom var1(2);
  BOOST_CHECK_EQUAL(var1.new_position.x, 0.0);
  BOOST_CHECK_EQUAL(var1.new_position.y, 0.0);
  BOOST_CHECK_EQUAL(var1.new_position.z, 0.0);
  BOOST_CHECK_EQUAL(var1.old_position.x, 0.0);
  BOOST_CHECK_EQUAL(var1.old_position.y, 0.0);
  BOOST_CHECK_EQUAL(var1.old_position.z, 0.0);
  BOOST_CHECK_EQUAL(var1.energy_old, 0.0);
  BOOST_CHECK_EQUAL(var1.energy_new, 0.0);
  BOOST_CHECK_EQUAL(var1.eps_old, 0.0);
  BOOST_CHECK_EQUAL(var1.eps_new, 0.0);
  BOOST_CHECK_EQUAL(var1.index, 0);
  BOOST_CHECK_EQUAL(var1.key, 2); // ONLY NON-DEFAULT VALUE
  BOOST_CHECK_EQUAL(var1.do_old, true);
  BOOST_CHECK_EQUAL(var1.do_new, true);
  BOOST_CHECK(var1.old_rij.empty());
  BOOST_CHECK(var1.new_rij.empty());

  // Set atom "start" values
  var1.do_old = true;
  var1.do_new = true;
  var1.index = 10;
  var1.old_position.x = 1.0;
  var1.old_position.y = 10.0;
  var1.old_position.z = 2.0;
  var1.new_position.x = 0.9;
  var1.new_position.y = 9.8;
  var1.new_position.z = 2.15;
  var1.eps_old = epsdefault;
  var1.eps_new = epsw;
  // Set "calculated" values
  var1.energy_old = 0.001;
  var1.energy_new = 0.02;
  var1.old_rij = orij;
  var1.new_rij = nrij;
  // Use var1 to make copies
  {
    // Copy ctor.
    particle::change_atom var2(var1);
    BOOST_CHECK(var2.equivalent(var1));
  }
  {
    // Assignment operator
    particle::change_atom var2;
    // Check differs
    BOOST_CHECK(not var2.equivalent(var1));
    // check equivalent
    var2 = var1;
    BOOST_CHECK(var2.equivalent(var1));
  }
  {
    particle::change_atom var2;
    particle::change_atom var3(var1);

    // Check differs  
    BOOST_CHECK(not var2.equivalent(var3));

    var2.swap (var3);
    // Check still differs
    BOOST_CHECK(not var2.equivalent(var3));
  }
  boost::archive::text_oarchive oa(store);
  // write class instance to archive
  oa << var1;
}
{
  particle::change_atom var1;

  boost::archive::text_iarchive ia(store);
  // get class instance from archive
  ia >> var1;

  BOOST_CHECK_EQUAL( var1.do_old, true );
  BOOST_CHECK_EQUAL( var1.do_new, true );
  BOOST_CHECK_EQUAL( var1.index, 10 );
  BOOST_CHECK_EQUAL( var1.old_position.x, 1.0 );
  BOOST_CHECK_EQUAL( var1.old_position.y, 10.0 );
  BOOST_CHECK_EQUAL( var1.old_position.z, 2.0 );
  BOOST_CHECK_EQUAL( var1.new_position.x, 0.9 );
  BOOST_CHECK_EQUAL( var1.new_position.y, 9.8 );
  BOOST_CHECK_EQUAL( var1.new_position.z, 2.15 );
  BOOST_CHECK_EQUAL( var1.key, 2 );
  BOOST_CHECK_EQUAL( var1.energy_old, 0.001 );
  BOOST_CHECK_EQUAL( var1.energy_new, 0.02 );
  BOOST_CHECK_EQUAL( var1.eps_old, epsdefault );
  BOOST_CHECK_EQUAL( var1.eps_new, epsw );
  BOOST_CHECK_EQUAL_COLLECTIONS( var1.old_rij.begin(), var1.old_rij.end()
        , orij.begin(), orij.end() );
  BOOST_CHECK_EQUAL_COLLECTIONS( var1.new_rij.begin(), var1.new_rij.end()
        , nrij.begin(), nrij.end() );
}
!!!922800.cpp!!!	change_atom_comparison_test() : void
const std::vector< double > nrij { 1.0, 1.3, 2.4 };
const std::vector< double > orij { 1.1, 1.4, 2.0 };
const double epsdefault{ 80.0 };
const double epsw{ 70.0 };

// Ctor with arg
particle::change_atom var1( 2 );
// Set atom "start" values
var1.do_old = true;
var1.do_new = true;
var1.index = 10;
var1.old_position.x = 1.0;
var1.old_position.y = 10.0;
var1.old_position.z = 2.0;
var1.new_position.x = 0.9;
var1.new_position.y = 9.8;
var1.new_position.z = 2.15;
var1.eps_old = epsdefault;
var1.eps_new = epsw;
// Set "calculated" values
var1.energy_old = 0.001;
var1.energy_new = 0.02;
var1.old_rij = orij;
var1.new_rij = nrij;
// Use var1 to make copies
{
  // Copy ctor.
  particle::change_atom var2( var1 );
  BOOST_CHECK_EQUAL( var2.new_position.x, var1.new_position.x );
  BOOST_CHECK_EQUAL( var2.new_position.y, var1.new_position.y );
  BOOST_CHECK_EQUAL( var2.new_position.z, var1.new_position.z );
  BOOST_CHECK_EQUAL( var2.old_position.x, var1.old_position.x );
  BOOST_CHECK_EQUAL( var2.old_position.y, var1.old_position.y );
  BOOST_CHECK_EQUAL( var2.old_position.z, var1.old_position.z );
  BOOST_CHECK_EQUAL( var2.index, var1.index );
  BOOST_CHECK_EQUAL( var2.key, var1.key );
  BOOST_CHECK_EQUAL( var2.do_old, var1.do_old );
  BOOST_CHECK_EQUAL( var2.do_new, var1.do_new );
  BOOST_CHECK_EQUAL( var2.energy_old, var1.energy_old );
  BOOST_CHECK_EQUAL( var2.energy_new, var1.energy_new );
  BOOST_CHECK_EQUAL( var2.eps_old, var1.eps_old );
  BOOST_CHECK_EQUAL( var2.eps_new, var1.eps_new );
  BOOST_CHECK_EQUAL_COLLECTIONS( var2.old_rij.begin(), var2.old_rij.end()
                                 , orij.begin(), orij.end() );
  BOOST_CHECK_EQUAL_COLLECTIONS( var2.new_rij.begin(), var2.new_rij.end()
                                 , nrij.begin(), nrij.end() );
  // Test equivalent is true when all data is the same
  BOOST_CHECK_EQUAL( var2, var1 );
}
{
  // TEST equivalent is sensitive to change in any one parameter
  BOOST_CHECK( var1.equivalent( var1 ) );
  {
    particle::change_atom var2( var1 );
    var2.new_position.x += 0.1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.new_position.y += 0.1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.new_position.z += 0.1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.old_position.x += 0.1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.old_position.y += 0.1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.old_position.z += 0.1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.energy_old += 0.1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.energy_new += 0.1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.eps_old += 0.1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.eps_new += 0.1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.do_old = not var2.do_old;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.do_new = not var2.do_new;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.key += 1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.index += 1;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.new_rij = orij;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
  {
    particle::change_atom var2( var1 );
    var2.old_rij = nrij;
    BOOST_CHECK( not var2.equivalent( var1 ) );
  }
}


!!!426673.cpp!!!	change_set_lifetime_test() : void
const double epsw { 80.0 };
auto set_atom = []( particle::change_atom &a, bool b1, bool b2, std::size_t idx, particle::coordinate p1, particle::coordinate p2, double eps1, double eps2 )->void
{
  a.do_old = b1;
  a.do_new = b2;
  a.index = idx;
  a.old_position = p1;
  a.new_position = p2;
  a.eps_old = eps1;
  a.eps_new = eps2;
};
{
  // Test is canonical pattern
  BOOST_CHECK( std::is_default_constructible< particle::change_set >::type {} );
  BOOST_CHECK( std::is_copy_constructible< particle::change_set >::type {} );
  BOOST_CHECK( std::is_move_constructible< particle::change_set >::type {} );
  BOOST_CHECK( ( std::is_assignable< particle::change_set, particle::change_set >::type {} ) );
  BOOST_CHECK( not std::has_virtual_destructor< particle::change_set >::type {} );
}
{
  // Default ctor
  particle::change_set var1;
  BOOST_CHECK_EQUAL( var1.accept(), false );
  BOOST_CHECK( var1.begin() == var1.end() );
  BOOST_CHECK_EQUAL( var1.energy(), 0.0 );
  BOOST_CHECK_EQUAL( var1.exponential_factor(), 0.0 );
  BOOST_CHECK_EQUAL( var1.fail(), false );
  BOOST_CHECK_EQUAL( var1.metropolis_factor(), 1.0 );
  BOOST_CHECK_EQUAL( var1.probability_factor(), 1.0 );
  BOOST_CHECK_EQUAL( var1.size(), 0ul );
}
{
  std::stringstream store;
  {
    particle::change_set var1;
    // Make non-default 
    var1.update_exponential_factor( 0.05 );
    var1.update_probability_factor( 0.5 );
    particle::change_atom s1( 1 );
    set_atom( s1, true, true, 1, particle::coordinate( -0.1, 0.1, 0.1 ), particle::coordinate(), epsw, epsw );
    // Check add
    var1.add_atom( s1 );

    boost::archive::text_oarchive oa( store );
    // write class instance to archive
    oa << var1;

    // Make a copy
    {
      particle::change_set var2( var1 );
      BOOST_CHECK_EQUAL( var2.energy(), var1.energy() );
      BOOST_CHECK_EQUAL( var2.exponential_factor(), var1.exponential_factor() );
      BOOST_CHECK_EQUAL( var2.probability_factor(), var1.probability_factor() );
      BOOST_CHECK_EQUAL( var2.size(), var1.size() );

      BOOST_CHECK_EQUAL( var2[0].new_position.x, var1[0].new_position.x );
      BOOST_CHECK_EQUAL( var2[0].new_position.y, var1[0].new_position.y );
      BOOST_CHECK_EQUAL( var2[0].new_position.z, var1[0].new_position.z );
      BOOST_CHECK_EQUAL( var2[0].old_position.x, var1[0].old_position.x );
      BOOST_CHECK_EQUAL( var2[0].old_position.y, var1[0].old_position.y );
      BOOST_CHECK_EQUAL( var2[0].old_position.z, var1[0].old_position.z );
      BOOST_CHECK_EQUAL( var2[0].key, var1[0].key );
      BOOST_CHECK_EQUAL( var2[0].index, var1[0].index );
    }
    // Make a move
    {
      particle::change_set var3( var1 );
      particle::change_set var2( std::move( var3 ) );
      BOOST_CHECK_EQUAL( var2.energy(), var1.energy() );
      BOOST_CHECK_EQUAL( var2.exponential_factor(), var1.exponential_factor() );
      BOOST_CHECK_EQUAL( var2.probability_factor(), var1.probability_factor() );
      BOOST_CHECK_EQUAL( var2.size(), var1.size() );

      BOOST_CHECK_EQUAL( var2[0].new_position.x, var1[0].new_position.x );
      BOOST_CHECK_EQUAL( var2[0].new_position.y, var1[0].new_position.y );
      BOOST_CHECK_EQUAL( var2[0].new_position.z, var1[0].new_position.z );
      BOOST_CHECK_EQUAL( var2[0].old_position.x, var1[0].old_position.x );
      BOOST_CHECK_EQUAL( var2[0].old_position.y, var1[0].old_position.y );
      BOOST_CHECK_EQUAL( var2[0].old_position.z, var1[0].old_position.z );
      BOOST_CHECK_EQUAL( var2[0].key, var1[0].key );
      BOOST_CHECK_EQUAL( var2[0].index, var1[0].index );
    }
    // Assign a copy
    {
      particle::change_set var2;
      // Use var2 to stop compiler eliding assignment to a copy.
      BOOST_CHECK_EQUAL( var2.accept(), false );

      var2 = var1;
      BOOST_CHECK_EQUAL( var2.energy(), var1.energy() );
      BOOST_CHECK_EQUAL( var2.exponential_factor(), var1.exponential_factor() );
      BOOST_CHECK_EQUAL( var2.probability_factor(), var1.probability_factor() );
      BOOST_CHECK_EQUAL( var2.size(), var1.size() );

      BOOST_CHECK_EQUAL( var2[0].new_position.x, var1[0].new_position.x );
      BOOST_CHECK_EQUAL( var2[0].new_position.y, var1[0].new_position.y );
      BOOST_CHECK_EQUAL( var2[0].new_position.z, var1[0].new_position.z );
      BOOST_CHECK_EQUAL( var2[0].old_position.x, var1[0].old_position.x );
      BOOST_CHECK_EQUAL( var2[0].old_position.y, var1[0].old_position.y );
      BOOST_CHECK_EQUAL( var2[0].old_position.z, var1[0].old_position.z );
      BOOST_CHECK_EQUAL( var2[0].key, var1[0].key );
      BOOST_CHECK_EQUAL( var2[0].index, var1[0].index );
    }
  }
  {
    // Test serialization
    particle::change_set var2;
    boost::archive::text_iarchive ia( store );
    // get class instance from archive
    ia >> var2;

    BOOST_CHECK_EQUAL( var2.energy(), 0.0 );
    BOOST_CHECK_EQUAL( var2.exponential_factor(), 0.05 );
    BOOST_CHECK_EQUAL( var2.probability_factor(), 0.5 );
    BOOST_CHECK_EQUAL( var2.size(), 1ul );

    BOOST_CHECK_EQUAL( var2[0].new_position.x, 0.0 );
    BOOST_CHECK_EQUAL( var2[0].new_position.y, 0.0 );
    BOOST_CHECK_EQUAL( var2[0].new_position.z, 0.0 );
    BOOST_CHECK_EQUAL( var2[0].old_position.x, -0.1 );
    BOOST_CHECK_EQUAL( var2[0].old_position.y, 0.1 );
    BOOST_CHECK_EQUAL( var2[0].old_position.z, 0.1 );
    BOOST_CHECK_EQUAL( var2[0].key, 1 );
    BOOST_CHECK_EQUAL( var2[0].index, 1 );
  }
}

!!!922928.cpp!!!	change_set_methods_test() : void
const double epsw { 70.0 };
auto set_atom = []( particle::change_atom &a, bool b1, bool b2, std::size_t idx, particle::coordinate p1, particle::coordinate p2, double eps1, double eps2 )->void
{
  a.do_old = b1;
  a.do_new = b2;
  a.index = idx;
  a.old_position = p1;
  a.new_position = p2;
  a.eps_old = eps1;
  a.eps_new = eps2;
};

{
  // Test attempt to set a bad probability value
  // Valid only if VALUE > 0.0
  particle::change_set var2;
  BOOST_CHECK_EQUAL( var2.probability_factor(), 1.0 );
  BOOST_CHECK_THROW( var2.update_probability_factor( 0.0 ), std::runtime_error );
  BOOST_CHECK_THROW( var2.update_probability_factor( -1.0 ), std::runtime_error );
}
{
  // Test add steps
  particle::change_set var1;

  particle::change_atom s1( 0 );
  set_atom( s1, true, true, 0, particle::coordinate(), particle::coordinate( 0.1, 0.0, 0.1 ), epsw, epsw );

  // Add once have individual jump move
  var1.add_atom( s1 );
  // Variable that should be changed
  BOOST_CHECK( var1.begin() != var1.end() );
  BOOST_REQUIRE_EQUAL( var1.size(), 1ul );
  BOOST_CHECK( s1.equivalent( var1[0] ) );
  BOOST_CHECK( s1.equivalent( *var1.begin() ) );

  // Add again: now have salt jump move
  s1.old_position.x += 3.0;
  s1.new_position.x += 3.0;
  s1.key = 1;
  var1.add_atom( s1 );
  // Variable that should be changed
  BOOST_CHECK( var1.begin() != var1.end() );
  BOOST_CHECK_EQUAL( var1.size(), 2ul );
  BOOST_CHECK( s1.equivalent( var1[1] ) );
  BOOST_CHECK( s1.equivalent( *( var1.begin() + 1 ) ) );

  // Add third time: still have salt jump move
  s1.old_position.y += 3.0;
  s1.new_position.y += 3.0;
  var1.add_atom( s1 );
  // Variable that should be changed
  BOOST_CHECK( var1.begin() != var1.end() );
  BOOST_CHECK_EQUAL( var1.size(), 3ul );
  BOOST_CHECK( s1.equivalent( var1[2] ) );
  BOOST_CHECK( s1.equivalent( *( var1.begin() + 2 ) ) );
  // Variables that should be unchanged
  BOOST_CHECK_EQUAL( var1.accept(), false );
  BOOST_CHECK_EQUAL( var1.energy(), 0.0 );
  BOOST_CHECK_EQUAL( var1.exponential_factor(), 0.0 );
  BOOST_CHECK_EQUAL( var1.fail(), false );
  BOOST_CHECK_EQUAL( var1.metropolis_factor(), 1.0 );
  BOOST_CHECK_EQUAL( var1.probability_factor(), 1.0 );

  // test equivalent()
  particle::change_set var2( var1 );
  // Verify individually
  BOOST_CHECK_EQUAL( var1.accept(), var2.accept() );
  BOOST_CHECK_EQUAL( var1.exponential_factor(), var2.exponential_factor() );
  BOOST_CHECK_EQUAL( var1.fail(), var2.fail() );
  BOOST_CHECK_EQUAL( var1.probability_factor(), var2.probability_factor() );
  BOOST_CHECK_EQUAL_COLLECTIONS( var1.begin(), var1.end()
                                 , var2.begin(), var2.end() );
  // before using class method.
  BOOST_CHECK_EQUAL( var1, var2 );

}
// Test factor adjustments
{
  particle::change_set var2;
  particle::change_atom a1;
  var2.add_atom( a1 );
  BOOST_CHECK_EQUAL( var2.exponential_factor(), 0.0 );
  BOOST_CHECK_EQUAL( var2.probability_factor(), 1.0 );
  {
    // Test metropolis factor
    //  energy==0 exp==0.0 prob==1 beta=1
    //  prob.e( -(beta*energy-exp ))
    //  1 . e -( 0 - 0 ) == 1
    const double metro( var2.metropolis_factor() );
    if( not utility::feq( metro, 1.0 ) )
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 1.0" );
    }
  }
  {
    // Test update_energy and metropolis
    //  energy==0.1 expf==0.0 probf==1 beta=1
    //  probf.e( -(beta*energy-expf ))
    // 1 . e( -(0.1 - 0 )) == 0.90483741803596
    var2.begin()->energy_new = 0.1;
    BOOST_CHECK( utility::feq( var2.energy(), 0.1 ) );

    const double metro( var2.metropolis_factor() );
    if( not utility::feq( metro, 0.90483741803596 ) )
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 0.90483741803596" );
    }
  }
  {
    // Test update_probability_factor and metropolis
    //  energy==0.1 expf==0.0 probf==0.1 beta=1
    //  probf.e( -(beta*energy-expf ))
    // 0.3 . e( -(0.1 - 0 )) == 0.3 * 0.90484 = 0.27145
    var2.update_probability_factor( 0.1 );
    BOOST_CHECK( utility::feq( var2.probability_factor(), 0.1 ) );
    var2.update_probability_factor( 3.0 );
    BOOST_CHECK( utility::feq( var2.probability_factor(), 0.3 ) );

    const double metro( var2.metropolis_factor() );
    if( not utility::feq( metro, 0.271451225411, 1 << 12 ) )
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 0.271451225411" );
    }
  }
  {
    // Test update_exponential_factor
    //  energy==0.1 expf==0.1 probf==0.1 beta=1
    //  probf.e( -(beta*energy-expf )) ->0.1
    // 0.3 . e( -(0.1 - 0.1 )) == 0.3 * 1 = 0.3
    var2.update_exponential_factor( 0.1 );
    BOOST_CHECK_EQUAL( var2.exponential_factor(), 0.1 );

    const double metro( var2.metropolis_factor() );
    if( not utility::feq( metro, 0.3 ) )
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 0.3" );
    }
  }
  {
    // Test update_exponential_factor
    //  energy==0.1 expf==0.1 probf==0.1 beta=1
    //  probf.e( -(beta*energy-expf )) ->0.1
    // 0.3 . e( -(1.2 - 0.1 ) == 0.3 * 0.33287 == 0.09986
    var2.begin()->energy_new += 1.1;
    BOOST_CHECK( utility::feq( var2.energy(), 1.2 ) );

    const double metro( var2.metropolis_factor() );
    BOOST_CHECK_NE( metro, 0.0 );
    if( not utility::feq( metro, 0.0998613251094, 1 << 12 ) )
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 0.0998613251094" );
    }
  }
  {
    // Test update_energy with large energy
    //  energy==100.1 expf==0.1 probf==0.1 beta=1
    //  probf.e( -(beta*energy-expf )) ->0.0....
    // 0.3 . e( -(101.3 - 0.1 ) == 0.3 * 1.238e-44 == 3.3614e-45

    var2.begin()->energy_new += 100.1;
    BOOST_CHECK( utility::feq( var2.energy(), 101.3 ) );

    const double metro( var2.metropolis_factor() );
    BOOST_CHECK_NE( metro, 0.0 );
    if( not utility::feq( metro, 3.36139605555e-45, 1 << 13 ) )
    {
      BOOST_ERROR( "metropolis_factor ["<<metro<<"] not expected value 3.36139605555e-45" );
    }
  }
}

!!!413489.cpp!!!	coordinate_test() : void
auto test_coord = [](particle::coordinate const& p1, double x, double y, double z)
{
  BOOST_CHECK_EQUAL(p1.x, x);
  BOOST_CHECK_EQUAL(p1.y, y);
  BOOST_CHECK_EQUAL(p1.z, z);
};

{
  // Test is canonical pattern
  BOOST_CHECK( std::is_default_constructible< particle::coordinate >::type{} );
  BOOST_CHECK( std::is_copy_constructible< particle::coordinate >::type{} );
  BOOST_CHECK( std::is_move_constructible< particle::coordinate >::type{} );
  BOOST_CHECK( (std::is_assignable< particle::coordinate, particle::coordinate >::type{}) );
  BOOST_CHECK( not std::has_virtual_destructor< particle::coordinate >::type{} );
}

// Constructor tests:
std::stringstream store;
{
  particle::coordinate p1;
  test_coord(p1, 0.0, 0.0, 0.0);

  particle::coordinate p2 (0.1, 0.3, 0.2);
  test_coord(p2, 0.1, 0.3, 0.2);

  particle::coordinate p3 {0.3, 0.2, 0.1};
  test_coord(p3, 0.3, 0.2, 0.1);

  test_coord({0.1,0.2,0.3},0.1,0.2,0.3);

  BOOST_CHECK(not p1.equivalent(p2));
  BOOST_CHECK( p1 != p2 );

  boost::archive::text_oarchive oa(store);
  // write class instances to archive
  oa << p1 << p2 << p3;

  p1 = p2;
  BOOST_CHECK(p1.equivalent(p2));
  BOOST_CHECK( p1 == p2 );

  {
    std::stringstream lstore;
    lstore << p1;
    p3.write( lstore );
    {
      particle::coordinate p4, p5;

      BOOST_CHECK( not p1.equivalent( p4 ) );
      BOOST_CHECK( p3 != p5 );

      lstore >> p4;
      p5.read( lstore ); 
  
      BOOST_CHECK( p1.equivalent(p4) );
      BOOST_CHECK( p3 == p5 );
    }
  }
}
{
  particle::coordinate P1, P2, P3;
  boost::archive::text_iarchive ia(store);
  // read class instances from archive
  ia >> P1 >> P2 >> P3;
  test_coord(P1, 0.0, 0.0, 0.0);
  test_coord(P2, 0.1, 0.3, 0.2);
  test_coord(P3, 0.3, 0.2, 0.1);
}
// Test read
{
   particle::coordinate var;
   const static std::string canon{"0.1 0.2 0.3\n2.0\n1.0 0.3 0.5 0.1\n1.1 " };
   std::stringstream ss( canon );
   var.read(ss);
   test_coord( var, 0.1, 0.2, 0.3 );
   ss >> var;
   test_coord( var, 2.0, 1.0, 0.3 );
   var.read(ss);
   test_coord( var, 0.5, 0.1, 1.1 );
}
!!!297776.cpp!!!	centroid_test() : void
auto test_coord = [](particle::centroid const& p1, double r, double x, double y, double z)
{
  BOOST_CHECK_EQUAL(p1.r, r);
  BOOST_CHECK_EQUAL(p1.x, x);
  BOOST_CHECK_EQUAL(p1.y, y);
  BOOST_CHECK_EQUAL(p1.z, z);
};
{
  // Test is canonical pattern
  BOOST_CHECK( std::is_default_constructible< particle::centroid >::type{} );
  BOOST_CHECK( std::is_copy_constructible< particle::centroid >::type{} );
  BOOST_CHECK( std::is_move_constructible< particle::centroid >::type{} );
  BOOST_CHECK( (std::is_assignable< particle::centroid, particle::centroid >::type{}) );
  BOOST_CHECK( not std::has_virtual_destructor< particle::centroid >::type{} );
} 
// Constructor tests:
std::stringstream store;
{
   // default ctor
  particle::centroid p1;
  test_coord(p1, 0.0, 0.0, 0.0, 0.0);

  // param ctor
  particle::centroid p2(1.0, 0.1, 0.3, 0.2);
  test_coord(p2, 1.0, 0.1, 0.3, 0.2);

  // initializer list
  particle::centroid p3 {1.0, 0.3, 0.2, 0.1};
  test_coord(p3, 1.0, 0.3, 0.2, 0.1);

  // initializer list
  test_coord({1.0, 0.1, 0.2, 0.3}, 1.0, 0.1, 0.2, 0.3 );

  // copy
  particle::centroid p4( p3 );
  test_coord(p4, 1.0, 0.3, 0.2, 0.1);

  // move
  particle::centroid p5( std::move( particle::centroid( p3 ) ) );
  test_coord(p5, 1.0, 0.3, 0.2, 0.1);

  // assignment
  p5 = p2;
  test_coord(p5, 1.0, 0.1, 0.3, 0.2);

  BOOST_CHECK( not p1.equivalent( p2 ) );
  BOOST_CHECK( p1 != p2 );

  boost::archive::text_oarchive oa(store);
  // write class instances to archive
  oa << p1 << p2 << p3;

  p1 = p2;
  BOOST_CHECK( p1.equivalent( p2 ) );
  BOOST_CHECK( p1 == p2 );

  {
    std::stringstream lstore;
    lstore << p1 << " ";
    p3.write( lstore );
    {
    particle::centroid p4, p5;

    BOOST_CHECK( not p1.equivalent( p4 ) );
    BOOST_CHECK( p3 != p5 );

    p4.read( lstore );
    lstore >> p5; 
  
    BOOST_CHECK( p1.equivalent( p4 ) );
    BOOST_CHECK( p3 ==  p5 );
    }
  }
}
{
  particle::centroid P1, P2, P3;
  boost::archive::text_iarchive ia( store );
  // read class instances from archive
  ia >> P1 >> P2 >> P3;
  test_coord( P1, 0.0, 0.0, 0.0, 0.0 );
  test_coord( P2, 1.0, 0.1, 0.3, 0.2 );
  test_coord( P3, 1.0, 0.3, 0.2, 0.1 );
}
// Test read
{
   particle::centroid var;
   const static std::string canon{"1.0 0.1 0.2 0.3\n2.0\n1.0 0.3 0.5 0.1\n1.1 2.0 1.0" };
   std::stringstream ss( canon );
   var.read(ss);
   test_coord( var, 1.0, 0.1, 0.2, 0.3 );
   ss >> var;
   test_coord( var, 2.0, 1.0, 0.3, 0.5 );
   var.read(ss);
   test_coord( var, 0.1, 1.1, 2.0, 1.0 );
}
!!!413617.cpp!!!	ensemble_lifetime_test() : void
// Test framework
std::vector< particle::specie > specie_list( 3 );
specie_list[ 0 ].set_label( "Na" );
specie_list[ 0 ].set_valency( 1.0 );
specie_list[ 0 ].set_type( particle::specie::SOLUTE );
specie_list[ 1 ].set_label( "Ka" );
specie_list[ 1 ].set_valency( 1.0 );
specie_list[ 1 ].set_type( particle::specie::SOLUTE );
specie_list[ 2 ].set_label( "Cl" );
specie_list[ 2 ].set_valency( -1.0 );
specie_list[ 2 ].set_type( particle::specie::SOLUTE );
const double epsw = 80.0;

auto set_atom = []( particle::change_atom &a, bool b1, bool b2, std::size_t idx, particle::coordinate p1, particle::coordinate p2, double eps1, double eps2 )->void
{
  a.do_old = b1;
  a.do_new = b2;
  a.index = idx;
  a.old_position = p1;
  a.new_position = p2;
  a.eps_old = eps1;
  a.eps_new = eps2;
};
{
  // Test is canonical pattern
  BOOST_CHECK( std::is_default_constructible< particle::ensemble >::type {} );
  BOOST_CHECK( std::is_copy_constructible< particle::ensemble >::type {} );
  BOOST_CHECK( std::is_move_constructible< particle::ensemble >::type {} );
  BOOST_CHECK( ( std::is_assignable< particle::ensemble, particle::ensemble >::type {} ) );
  BOOST_CHECK( not std::has_virtual_destructor< particle::ensemble >::type {} );
}
{
  // default ctor.
  particle::ensemble ens;
  BOOST_CHECK_EQUAL( ens.charge(), 0.0 );
  BOOST_CHECK_EQUAL( ens.count(), 0 );
  BOOST_CHECK_EQUAL( ens.max_size(), 0 );
  BOOST_CHECK_EQUAL( ens.size(), 0 );
  BOOST_CHECK_NO_THROW( ens.check_invariants( specie_list ) );

  // Resize ensemble
  ens.resize( 64 );
  // Max size should be multiple of 64 larger than
  // argument given to resize
  BOOST_CHECK_EQUAL( ens.count(), 0 );
  BOOST_CHECK_GE( ens.max_size(), 64 );
  BOOST_CHECK_EQUAL( ( ens.max_size() % 64 ), 0 );
  BOOST_CHECK_EQUAL( ens.size(), 0 );

  // Add a Na particle so no longer default object
  std::size_t ispec( 0 );
  {
    const particle::coordinate pos
    {
      1.62127193214, 9.29177995257, 5.25370757073
    };
    ens.append_position( ispec, specie_list[ ispec ].valency(), pos, epsw );
    // size should increase by one, charge should be set but specie
    // count should be unaltered.
    BOOST_CHECK_EQUAL( ens.count(), 1 );
    BOOST_CHECK_GE( ens.max_size(), 64 );
    BOOST_CHECK_EQUAL( ens.size(), 1 );
    BOOST_CHECK_EQUAL( ens.charge(), 1.0 );
    BOOST_CHECK_EQUAL( specie_list[ ispec ].count(), 0 );
    // Invariant should fail before setting count in specie_list.
    BOOST_CHECK_THROW( ens.check_invariants( specie_list ), std::runtime_error );
    specie_list[ ispec ].set_count( 1 );
    // Invariant should now pass.
    BOOST_CHECK_NO_THROW( ens.check_invariants( specie_list ) );
    // Check set values
    BOOST_CHECK_EQUAL( ens.key( 0 ), ispec );
    BOOST_CHECK_EQUAL( ens.x( 0 ), pos.x );
    BOOST_CHECK_EQUAL( ens.y( 0 ), pos.y );
    BOOST_CHECK_EQUAL( ens.z( 0 ), pos.z );
    BOOST_CHECK_EQUAL( ens.position( 0 ), pos );
    BOOST_CHECK_EQUAL( ens.eps( 0 ), epsw );
  }

  // copy ctor
  {
    particle::ensemble ens1( ens );
    BOOST_CHECK( ens == ens1 );
  }
  // move ctor
  {
    particle::ensemble ens2( ens );
    particle::ensemble ens1( std::move( ens2 ) );

    BOOST_CHECK( ens == ens1 );
  }

  // assignment
  {
    particle::ensemble ens1;
    BOOST_CHECK_NO_THROW( ens.check_invariants( specie_list ) );
    ens1 = ens;
    BOOST_CHECK( ens == ens1 );
  }

}

!!!930608.cpp!!!	ensemble_methods_test() : void
// Test framework
std::vector< particle::specie > specie_list( 3 );
specie_list[ 0 ].set_label( "Na" );
specie_list[ 0 ].set_valency( 1.0 );
specie_list[ 0 ].set_type( particle::specie::SOLUTE );
specie_list[ 1 ].set_label( "Ka" );
specie_list[ 1 ].set_valency( 1.0 );
specie_list[ 1 ].set_type( particle::specie::SOLUTE );
specie_list[ 2 ].set_label( "Cl" );
specie_list[ 2 ].set_valency( -1.0 );
specie_list[ 2 ].set_type( particle::specie::SOLUTE );
const double epsw = 80.0;

auto set_atom = [](particle::change_atom &a, bool b1, bool b2, std::size_t idx, particle::coordinate p1, particle::coordinate p2, double eps1, double eps2)->void{
  a.do_old = b1;
  a.do_new = b2;
  a.index = idx;
  a.old_position = p1;
  a.new_position = p2;
  a.eps_old = eps1;
  a.eps_new = eps2;
};

// for testing serialization
std::stringstream store;
{
   particle::ensemble ens;
   BOOST_CHECK_EQUAL( ens.charge (), 0.0 );
   BOOST_CHECK_EQUAL( ens.count (), 0 );
   BOOST_CHECK_EQUAL( ens.max_size (), 0 );
   BOOST_CHECK_EQUAL( ens.size (), 0 );
   BOOST_CHECK_NO_THROW( ens.check_invariants( specie_list ) );

   // Resize ensemble
   ens.resize( 64 );
   // Max size should be multiple of 64 larger than
   // argument given to resize
   BOOST_CHECK_EQUAL( ens.count(), 0 );
   BOOST_CHECK_GE( ens.max_size(), 64 );
   BOOST_CHECK_EQUAL( ( ens.max_size() % 64 ), 0 );
   BOOST_CHECK_EQUAL( ens.size(), 0 );

   // Add a Na particle
   std::size_t ispec( 0 );
   {
      const particle::coordinate pos { 1.62127193214, 9.29177995257, 5.25370757073 };
      ens.append_position( ispec, specie_list[ ispec ].valency(), pos, epsw );
      // size should increase by one, charge should be set but specie
      // count should be unaltered.
      BOOST_CHECK_EQUAL( ens.count(), 1 );
      BOOST_CHECK_GE( ens.max_size(), 64 );
      BOOST_CHECK_EQUAL( ens.size(), 1 );
      BOOST_CHECK_EQUAL( ens.charge (), 1.0 );
      BOOST_CHECK_EQUAL( specie_list[ ispec ].count(), 0 );
      // Invariant should fail before setting count in specie_list.
      BOOST_CHECK_THROW( ens.check_invariants( specie_list ), std::runtime_error );
      specie_list[ ispec ].set_count( 1 );
      // Invariant should now pass.
      BOOST_CHECK_NO_THROW( ens.check_invariants( specie_list ) );
      ens.check_invariants( specie_list );
      // Check set values
      BOOST_CHECK_EQUAL( ens.key( 0 ), ispec );
      BOOST_CHECK_EQUAL( ens.x( 0 ), pos.x );
      BOOST_CHECK_EQUAL( ens.y( 0 ), pos.y );
      BOOST_CHECK_EQUAL( ens.z( 0 ), pos.z );
      BOOST_CHECK_EQUAL( ens.position( 0 ), pos );
      BOOST_CHECK_EQUAL( ens.eps( 0 ), epsw );
   }

   // Add some more particles
   ispec = 1;
   ens.append_position( 1, specie_list[ 1 ].valency(), { 0.629669015988, 9.4781017778, 0.436567124972 }, epsw );
   ispec = 2;
   ens.append_position( 2, specie_list[ 2 ].valency(), { 1.81235688249, 6.99878476378, 6.05346341778 }, epsw );
   ens.append_position( 2, specie_list[ 2 ].valency(), { 9.86409500135, 8.03444072878, 6.96346891359 }, epsw );
   ens.append_position( 0, specie_list[ 0 ].valency(), { 6.12488878987, 0.936444546808, 7.92035117147 }, epsw );
   ens.append_position( 2, specie_list[ 2 ].valency(), { 4.02705270915, 4.9878484368, 9.33967304135 }, epsw );
   ens.append_position( 1, specie_list[ 1 ].valency(), { 8.8153046596, 8.25296759285, 9.27222366556 }, epsw );
   ens.append_position( 2, specie_list[ 2 ].valency(), { 3.01632820001, 3.43431356454, 0.880214873216 }, epsw );
   ispec = 0;

   specie_list[ 0 ].set_count( 2 );
   specie_list[ 1 ].set_count( 2 );
   specie_list[ 2 ].set_count( 4 );

   BOOST_CHECK_NO_THROW( ens.check_invariants( specie_list ) );

   std::size_t gidx;
   std::size_t lidx;
   BOOST_CHECK_NO_THROW( gidx = ens.nth_specie_index( 0, 0 ) );
   BOOST_CHECK_EQUAL( gidx, 0 );
   BOOST_CHECK_NO_THROW( lidx = ens.specie_index( gidx ) ); 
   BOOST_CHECK_EQUAL( lidx, 0 );
   BOOST_CHECK_NO_THROW( gidx = ens.nth_specie_index( 0, 1 ) );
   BOOST_CHECK_EQUAL( gidx, 4 );
   BOOST_CHECK_NO_THROW( lidx = ens.specie_index( gidx ) ); 
   BOOST_CHECK_EQUAL( lidx, 1 );

   BOOST_CHECK_NO_THROW( gidx = ens.nth_specie_index( 1, 0 ) );
   BOOST_CHECK_EQUAL( gidx, 1 );
   BOOST_CHECK_NO_THROW( lidx = ens.specie_index( gidx ) ); 
   BOOST_CHECK_EQUAL( lidx, 0 );
   BOOST_CHECK_NO_THROW( gidx = ens.nth_specie_index( 1, 1 ) );
   BOOST_CHECK_EQUAL( gidx, 6 );
   BOOST_CHECK_NO_THROW( lidx = ens.specie_index( gidx ) ); 
   BOOST_CHECK_EQUAL( lidx, 1 );

   BOOST_CHECK_NO_THROW( gidx = ens.nth_specie_index( 2, 0 ) );
   BOOST_CHECK_EQUAL( gidx, 2 );
   BOOST_CHECK_NO_THROW( lidx = ens.specie_index( gidx ) ); 
   BOOST_CHECK_EQUAL( lidx, 0 );
   BOOST_CHECK_NO_THROW( gidx = ens.nth_specie_index( 2, 1 ) );
   BOOST_CHECK_EQUAL( gidx, 3 );
   BOOST_CHECK_NO_THROW( lidx = ens.specie_index( gidx ) ); 
   BOOST_CHECK_EQUAL( lidx, 1 );
   BOOST_CHECK_NO_THROW( gidx = ens.nth_specie_index( 2, 2 ) );
   BOOST_CHECK_EQUAL( gidx, 5 );
   BOOST_CHECK_NO_THROW( lidx = ens.specie_index( gidx ) ); 
   BOOST_CHECK_EQUAL( lidx, 2 );
   BOOST_CHECK_NO_THROW( gidx = ens.nth_specie_index( 2, 3 ) );
   BOOST_CHECK_EQUAL( gidx, 7 );
   BOOST_CHECK_NO_THROW( lidx = ens.specie_index( gidx ) ); 
   BOOST_CHECK_EQUAL( lidx, 3 );

   BOOST_CHECK_THROW( gidx = ens.nth_specie_index( 0, 2 ), std::runtime_error );
   BOOST_CHECK_THROW( gidx = ens.nth_specie_index( 1, 2 ), std::runtime_error );
   BOOST_CHECK_THROW( gidx = ens.nth_specie_index( 2, 4 ), std::runtime_error );
   BOOST_CHECK_THROW( lidx = ens.specie_index( 8 ), std::runtime_error ); 
   // test nth_index
   // ---------------
   // NOTE: deletion list is empty so nth index will
   // always be identical to n
   BOOST_CHECK_EQUAL( ens.count(), ens.size() );
   for (std::size_t itry = 0; itry != ens.count(); ++itry)
   {
      const std::size_t i1 = ens.nth_index(itry);
      BOOST_CHECK_EQUAL(i1, itry);
   }

   // test commit
   // Create changesets to (1) add, (2) move and (3) delete a particle
   {
      // ADD
      particle::change_set trial;
      const particle::coordinate pos { 7.45423699019, 5.14523134204, 2.44775178272 };
      particle::change_atom at(0);
      set_atom(at, false, true, ens.size(), {}, pos, epsw, epsw);
      trial.add_atom(at);

      // Check system before change
      BOOST_CHECK_EQUAL( ens.count(), 8 );
      BOOST_CHECK_EQUAL( ens.size(), 8 );
      BOOST_CHECK_EQUAL( ens.charge (), 0.0 );
      BOOST_CHECK_EQUAL( specie_list[ 0 ].count(), 2 );

      ens.commit( trial, specie_list );

      // Check for changes.
      BOOST_CHECK_NO_THROW( ens.check_invariants( specie_list ) );
      BOOST_CHECK_EQUAL( ens.count(), 9 );
      BOOST_CHECK_EQUAL( ens.size(), 9 );
      BOOST_CHECK_EQUAL( ens.charge (), 1.0 );
      BOOST_CHECK_EQUAL( specie_list[ 0 ].count(), 3 );
      BOOST_CHECK_EQUAL( ens.position( 8 ), pos );
      BOOST_CHECK_EQUAL( ens.key( 8 ), 0 );
      BOOST_CHECK_EQUAL( ens.eps( 8 ), epsw );
      BOOST_CHECK_EQUAL( ens.count(), ens.size() );
      BOOST_CHECK_NO_THROW( gidx = ens.nth_specie_index( 0, 2 ) );
      BOOST_CHECK_EQUAL( gidx, 8 );
   }
   {
      // MOVE
      particle::change_set trial;
      const std::size_t index { 4 };
      const particle::coordinate pos { 3.51095035114, 1.08643570153, 0.603658014653 };
      particle::change_atom at( ens.key( index ) );
      set_atom( at, true, true, index, ens.position( index ), pos, ens.eps( index ), epsw );
      trial.add_atom(at);

      // Check system before change
      BOOST_CHECK_EQUAL( ens.count(), 9 );
      BOOST_CHECK_EQUAL( ens.size(), 9 );
      BOOST_CHECK_EQUAL( ens.charge (), 1.0 );
      BOOST_CHECK_EQUAL( specie_list[ 0 ].count(), 3 );
      BOOST_CHECK_EQUAL( ens.key( index ), 0 );

      ens.commit( trial, specie_list );

      // Check there are no changes.
      BOOST_CHECK_NO_THROW( ens.check_invariants( specie_list ) );
      BOOST_CHECK_EQUAL( ens.count(), 9 );
      BOOST_CHECK_EQUAL( ens.size(), 9 );
      BOOST_CHECK_EQUAL( ens.charge (), 1.0 );
      BOOST_CHECK_EQUAL( specie_list[ 0 ].count(), 3 );
      BOOST_CHECK_EQUAL( ens.key( index ), 0 );
      BOOST_CHECK_EQUAL( ens.position( index ), pos );
      BOOST_CHECK_EQUAL( ens.eps( index ), epsw );
      BOOST_CHECK_EQUAL( ens.count(), ens.size() );
   }
   {
      // DELETE
      particle::change_set trial;
      const std::size_t index { 4 };
      particle::change_atom at( 0 );
      set_atom( at, true, false, index, ens.position( index ), {}, epsw, epsw );
      trial.add_atom(at);

      // Check system before change
      BOOST_CHECK_EQUAL( ens.count(), 9 );
      BOOST_CHECK_EQUAL( ens.size(), 9 );
      BOOST_CHECK_EQUAL( ens.charge (), 1.0 );
      BOOST_CHECK_EQUAL( specie_list[ 0 ].count(), 3 );

      ens.commit( trial, specie_list );

      // Check for changes.
      BOOST_CHECK_NO_THROW( ens.check_invariants( specie_list ) );
      BOOST_CHECK_EQUAL( ens.count(), 8 );
      BOOST_CHECK_EQUAL( ens.size(), 9 );
      BOOST_CHECK_EQUAL( ens.charge (), 0.0 );
      BOOST_CHECK_EQUAL( specie_list[ 0 ].count(), 2 );
      BOOST_CHECK_EQUAL( ens.key( index ), particle::specie_key::nkey );
      BOOST_CHECK_NE( ens.count(), ens.size() );
      BOOST_CHECK_NO_THROW( gidx = ens.nth_specie_index( 0, 1 ) );
      BOOST_CHECK_EQUAL( gidx, 8 );

      // test nth_index
      // ---------------
      // NOTE: deletion list is not empty so nth index will
      // not always be identical to n
      BOOST_CHECK_NE( ens.count(), ens.size() );
      for (std::size_t itry = 0; itry != ens.count(); ++itry)
      {
         const std::size_t i1 = ens.nth_index(itry);
         if ( itry >= index )
         {
            BOOST_CHECK_EQUAL(i1, itry + 1);
         }
         else
         {
            BOOST_CHECK_EQUAL(i1, itry);
         }

      }
   }
   // conf::serialize
   // ---------------
   boost::archive::text_oarchive oa(store);
   // write class instance to archive
   oa << ens << specie_list;
}
{
   particle::ensemble ens2;
   boost::archive::text_iarchive ia( store );
   // get class instance from archive
   ia >> ens2 >> specie_list;
   BOOST_CHECK_EQUAL( ens2.charge (), 0.0 );
   BOOST_CHECK_EQUAL( ens2.count (), 8 );
   BOOST_CHECK_EQUAL( ens2.size(), 9 );
   BOOST_CHECK_EQUAL( ens2.max_size (), 64*2 );
   BOOST_CHECK_EQUAL( specie_list[ 0 ].count(), 2 );
   BOOST_CHECK_EQUAL( specie_list[ 1 ].count(), 2 );
   BOOST_CHECK_EQUAL( specie_list[ 2 ].count(), 4 );
   BOOST_CHECK_NE( ens2.count(), ens2.size() );

   std::size_t gidx;
   BOOST_CHECK_NO_THROW( gidx = ens2.nth_specie_index( 0, 1 ) );
   BOOST_CHECK_EQUAL( gidx, 8 );
   BOOST_CHECK_NO_THROW( gidx = ens2.nth_specie_index( 0, 0 ) );
   BOOST_CHECK_EQUAL( gidx, 0 );

   BOOST_CHECK_NO_THROW( ens2.check_invariants( specie_list ) );
}
!!!413105.cpp!!!	specie_meta_test() : void
// TEST management of keywords
for ( std::string kw : { core::strngs::fsname(), core::strngs::fstype(), core::strngs::fsrtsp(), core::strngs::fsd(), core::strngs::fsz(), core::strngs::fsctrg(), core::strngs::fschex(), core::strngs::fsn() } )
{
   BOOST_CHECK( particle::specie_meta::is_standard_keyword( kw ) );
}
// Matches keyword so should throw an error
BOOST_CHECK_THROW( particle::specie_meta::add_keyword( "ratspc" ), std::runtime_error );

if ( not particle::specie_meta::has_keyword( "ratexc" ) )
{
   particle::specie_meta::add_keyword( "ratexc" );
}
if ( not particle::specie_meta::has_keyword( "ratgr" ) )
{
   particle::specie_meta::add_keyword( "ratgr" );
}
if ( not particle::specie_meta::has_keyword( "ratreg" ) )
{
   particle::specie_meta::add_keyword( "ratreg" );
}
if ( not particle::specie_meta::has_keyword( "ratmov" ) )
{
   particle::specie_meta::add_keyword( "ratmov" );
}

// Need a dummy application
boost::shared_ptr< particle::particle_manager > appl( new particle::particle_manager );

// Test read input (specie meta)
{
  core::input_delegater dg( 1 );
  {
    boost::shared_ptr< core::input_base_meta > m( new particle::specie_meta( appl ) );
    dg.add_input_delegate( m );
  }

  std::string canon_input( "specie\nname \"Ca\"\nratspc 1.0\nratmov 1.0\nratexc 2.0\nratgr 3.0\nratreg 0.3 0.3 0.3 0.1\nz 2.0\nd 1.1\nchex 0.792\ntype free\nend\n\n" );

  core::input_preprocess reader;
  reader.add_buffer( "dummy", canon_input );
  dg.read_input( reader );

  BOOST_CHECK_EQUAL( appl->specie_count(), 1ul );
  BOOST_CHECK_NO_THROW( appl->get_specie( 0 ) );
  BOOST_CHECK( appl->has_specie( "Ca" ) );
  const particle::specie &var1( appl->get_specie( appl->get_specie_key("Ca") ) );
  BOOST_CHECK( var1.is_valid() );
  BOOST_CHECK( var1.has_parameter( "ratreg" ) );
  BOOST_CHECK( var1.has_parameter( "ratmov" ) );
  BOOST_CHECK( var1.has_parameter( "ratexc" ) );
  BOOST_CHECK( var1.has_parameter( "ratgr" ) );
  BOOST_CHECK( var1.is_solute() );
  BOOST_CHECK_EQUAL( var1.label(), "Ca" );
  BOOST_CHECK_EQUAL( var1.rate(), 1.0 );
  BOOST_CHECK_EQUAL( var1.parameter( "ratmov" ), "1.0" );
  BOOST_CHECK_EQUAL( var1.parameter( "ratexc" ), "2.0" );
  BOOST_CHECK_EQUAL( var1.parameter( "ratgr" ), "3.0" );
  BOOST_CHECK_EQUAL( var1.valency(), 2.0 );
  BOOST_CHECK_EQUAL( var1.radius(), 0.55 );
  BOOST_CHECK_EQUAL( var1.excess_potential(), 0.792 );
  BOOST_CHECK_EQUAL( var1.is_solute(), true );
  BOOST_CHECK_EQUAL( var1.parameter( "ratreg" ), "0.3 0.3 0.3 0.1" );

// TEST WRITE OUTPUT
//  std::string alt_input( "specie\nname \"Ca\"\ntype free\nd 1.1\nz 2\nchex 0.792\nratexc 2.0\nratgr 3.0\nratmov 1.0\nratreg 0.3 0.3 0.3 0.1\nratspc 1.0\nend\n\n" );
//
//  std::stringstream os;
//  dg.write_input_file( os );
//  std::string actual_input( os.str() );
//
//  BOOST_CHECK_EQUAL(alt_input, actual_input);

  // Invalid/Valid inputs
  {
    std::string canon_input( "specie\nname \"Ca\"\nratspc 1.0\nratmov 1.0\nratexc 2.0\nratgr 3.0\nratreg 0.3 -0.3 0.3 0.1\nz 2.0\nd 1.1\nchex 0.792\ntype freeze\nend\n\n" );
    core::input_preprocess reader;
    reader.add_buffer( "dummy", canon_input );
    BOOST_CHECK_THROW( dg.read_input( reader ), std::runtime_error );
  }
  {
    std::string canon_input( "specie freeze\nname \"Ca\"\nratspc 1.0\nratmov 1.0\nratexc 2.0\nratgr 3.0\nratreg 0.3 -0.3 0.3 0.1\nz 2.0\nd 1.1\nchex 0.792\nend\n\n" );
    core::input_preprocess reader;
    reader.add_buffer( "dummy", canon_input );
    BOOST_CHECK_THROW( dg.read_input( reader ), std::runtime_error );
  }

  {
    std::string canon_input( "specie\ntype \"free\"  \nname \"Ca\"\nratspc 1.0\nratmov 1.0\nratexc 2.0\nratgr 3.0\nratreg 0.3 -0.3 0.3 0.1\nz 2.0\nd 1.1\nchex 0.792\nend\n\n" );
    core::input_preprocess reader;
    reader.add_buffer( "dummy", canon_input );
    BOOST_CHECK_NO_THROW( dg.read_input( reader ) );
  }

  {
    std::string canon_input("specie\ntype free\nname \"Ca\"\nratspc 1.0\nratmov 1.0\nratexc 2.0\nratgr 3.0\nratreg 0.3 -0.3 0.3 0.1\nz 2.0\nd 1.1\nchex 0.792\nend\n\n");
    core::input_preprocess reader;
    reader.add_buffer( "dummy", canon_input );
    BOOST_CHECK_NO_THROW( dg.read_input( reader ) );
  }
}


!!!413361.cpp!!!	specie_test() : void
//Lambda to test specie validity
auto specie_validation = [](particle::specie const& aspec)
{
   if (not aspec.is_valid ())
   {
      BOOST_CHECK(not (aspec.is_localized () or aspec.is_flexible ()
                       or aspec.is_solute () or aspec.is_channel_only ()
                       or aspec.is_mobile ()));
      BOOST_CHECK(aspec.label ().empty ());
      BOOST_CHECK_EQUAL(aspec.sub_type(), particle::specie::INVALID);
   }
   else
   {
      BOOST_CHECK(aspec.is_flexible () xor aspec.is_channel_only ()
                  xor aspec.is_mobile () xor aspec.is_solute ());
      BOOST_CHECK(not aspec.is_localized () or (aspec.is_flexible () or aspec.is_mobile ()));
      BOOST_CHECK_NE(aspec.sub_type(), particle::specie::INVALID);
      BOOST_CHECK(not aspec.label ().empty ());
      BOOST_CHECK_EQUAL(aspec.label ().size (), 2u);
   }
};

// Test static methods
{
   bool ifset { false };
   const particle::specie::specie_type orig { particle::specie::INVALID };
   BOOST_CHECK_EQUAL( particle::specie::type_label( particle::specie::MOBILE ), core::strngs::fsmobl() );
   BOOST_CHECK_EQUAL( particle::specie::string_to_specie_type( core::strngs::fsmobl(), orig, ifset ), particle::specie::MOBILE );
   BOOST_CHECK( ifset );
   ifset = false;
   BOOST_CHECK_EQUAL( particle::specie::type_label( particle::specie::FLEXIBLE ), core::strngs::fsflxd() );
   BOOST_CHECK_EQUAL( particle::specie::string_to_specie_type( core::strngs::fsflxd(), orig, ifset ), particle::specie::FLEXIBLE );
   BOOST_CHECK( ifset );
   ifset = false;
   BOOST_CHECK_EQUAL( particle::specie::type_label( particle::specie::CHANNEL_ONLY ), core::strngs::fschon() );
   BOOST_CHECK_EQUAL( particle::specie::string_to_specie_type( core::strngs::fschon(), orig, ifset ), particle::specie::CHANNEL_ONLY );
   BOOST_CHECK( ifset );
   ifset = false;
   BOOST_CHECK_EQUAL( particle::specie::type_label( particle::specie::SOLUTE ), core::strngs::fsfree() );
   BOOST_CHECK_EQUAL( particle::specie::string_to_specie_type( core::strngs::fsfree(), orig, ifset ), particle::specie::SOLUTE );
   BOOST_CHECK( ifset );
   ifset = false;
   // Unrecognised string value, should return orig and ifset = false
   BOOST_CHECK_EQUAL( particle::specie::string_to_specie_type( core::strngs::fsspec(), orig, ifset ), particle::specie::INVALID );
   BOOST_CHECK( not ifset );
   // Unrecognised string value, should return particle::specie::SOLUTE and
   // ifset = false
   ifset = true;
   BOOST_CHECK_EQUAL( particle::specie::string_to_specie_type( core::strngs::fsspec(), particle::specie::SOLUTE, ifset ), particle::specie::SOLUTE );
   BOOST_CHECK( not ifset );

   BOOST_CHECK_EQUAL( particle::specie::type_label( particle::specie::INVALID ), "invalid" );
   BOOST_CHECK_THROW( particle::specie::type_label( particle::specie::INVALID + 1 ), std::runtime_error );
}
// Test default ctor
{
   particle::specie var1;
   BOOST_CHECK(not var1.is_valid ());
   specie_validation(var1);
}
{
   // store for serialize test.
   std::stringstream store;
   // store for description test.
   std::stringstream desc;
   // Test values
   const double concentration { 0.1 };
   const double excess_potential { 0.1 };
   const double chem_pot { std::log( concentration/core::constants::to_SI() ) + excess_potential };
   const double radius { 0.9 };
   const double rate { 0.5 };
   const double valency { -1.0 };
   const std::size_t count { 3ul };
   const std::string label { "Na" };
   const std::string k1 { "key1" };
   const std::string v1 { "value 1" };
   const std::string k2 { "key 2" };
   const std::string v2 { "value2" };
   const std::string k3 { "key3" };
   const std::string v3 { "value\n3" };
   const std::string k4 { "key4" };
   const std::string v4 { "value\t4" };
   const std::string k5 { "key5" };
   const std::string v5 { "value5" };
   const particle::coordinate pos1( 2.0, 0.0, 0.0 );
   const particle::coordinate pos2( 0.0, 2.0, 0.0 );
   const particle::coordinate pos3( 0.0, 0.0, 2.0 );
   const particle::coordinate pos4( -2.0, 0.0, 2.0 );
   const particle::centroid ctr1( 2.4, 2.1, 0.0, 0.0 );
   const particle::centroid ctr2( 2.4, 0.0, 2.1, 0.0 );
   const particle::centroid ctr3( 2.4, 0.0, 0.0, 2.1 );
   {
      particle::specie var;
      BOOST_CHECK(not var.is_valid ());

      // Test getters/setters
      BOOST_CHECK_EQUAL( var.concentration(), 0.0 );
      BOOST_CHECK_NO_THROW( var.set_concentration( concentration ) );
      BOOST_CHECK_EQUAL( var.concentration(), concentration );

      BOOST_CHECK_EQUAL( var.excess_potential(), 0.0 );
      BOOST_CHECK_NO_THROW( var.set_excess_potential( excess_potential ) );
      BOOST_CHECK_EQUAL( var.excess_potential(), excess_potential );
      BOOST_CHECK_EQUAL( var.chemical_potential(), chem_pot );

      BOOST_CHECK_EQUAL( var.radius(), 0.0 );
      BOOST_CHECK_NO_THROW( var.set_radius( radius ) );
      BOOST_CHECK_EQUAL( var.radius(), radius );

      BOOST_CHECK_EQUAL( var.rate(), 0.0 );
      BOOST_CHECK_NO_THROW( var.set_rate( rate ) );
      BOOST_CHECK_EQUAL( var.rate(), rate );

      BOOST_CHECK_EQUAL( var.valency(), 0.0 );
      BOOST_CHECK_NO_THROW( var.set_valency( valency ) );
      BOOST_CHECK_EQUAL( var.valency(), valency );

     BOOST_CHECK( var.label().empty() );
      // NOTE : set_label assume label is valid and will not throw
      // an error with an invalid label
      BOOST_CHECK_NO_THROW( var.set_label( "" ) ); // Empty string is invalid
      BOOST_CHECK_NO_THROW( var.set_label( "  " ) ); // All white space is invalid
      BOOST_CHECK_NO_THROW( var.set_label( "N" ) ); // Single character is invalid
      BOOST_CHECK_NO_THROW( var.set_label( "Nab" ) ); // More than two characters is invalid
      BOOST_CHECK_NO_THROW( var.set_label( label ) );
      BOOST_CHECK_EQUAL( var.label(), label );

      BOOST_CHECK_EQUAL( var.sub_type(), particle::specie::INVALID );
      BOOST_CHECK( not var.is_valid() );

      BOOST_CHECK_NO_THROW( var.set_type( particle::specie::MOBILE ) );
      BOOST_CHECK_EQUAL( var.sub_type(), particle::specie::MOBILE );
      BOOST_CHECK( not var.is_channel_only() );
      BOOST_CHECK( not var.is_flexible() );
      BOOST_CHECK(     var.is_localized() );
      BOOST_CHECK(     var.is_mobile() );
      BOOST_CHECK( not var.is_solute() );
      BOOST_CHECK(     var.is_valid() );

      BOOST_CHECK_NO_THROW( var.set_type( particle::specie::FLEXIBLE ) );
      BOOST_CHECK_EQUAL( var.sub_type(), particle::specie::FLEXIBLE );
      BOOST_CHECK( not var.is_channel_only() );
      BOOST_CHECK(     var.is_flexible() );
      BOOST_CHECK(     var.is_localized() );
      BOOST_CHECK( not var.is_mobile() );
      BOOST_CHECK( not var.is_solute() );
      BOOST_CHECK(     var.is_valid() );

      BOOST_CHECK_NO_THROW( var.set_type( particle::specie::CHANNEL_ONLY ) );
      BOOST_CHECK_EQUAL( var.sub_type(), particle::specie::CHANNEL_ONLY );
      BOOST_CHECK(     var.is_channel_only() );
      BOOST_CHECK( not var.is_flexible() );
      BOOST_CHECK( not var.is_localized() );
      BOOST_CHECK( not var.is_mobile() );
      BOOST_CHECK( not var.is_solute() );
      BOOST_CHECK(     var.is_valid() );

      BOOST_CHECK_NO_THROW( var.set_type( particle::specie::INVALID ) );
      BOOST_CHECK_EQUAL( var.sub_type(), particle::specie::INVALID );
      BOOST_CHECK( not var.is_channel_only() );
      BOOST_CHECK( not var.is_flexible() );
      BOOST_CHECK( not var.is_localized() );
      BOOST_CHECK( not var.is_mobile() );
      BOOST_CHECK( not var.is_solute() );
      BOOST_CHECK( not var.is_valid() );

      BOOST_CHECK_NO_THROW( var.set_type( particle::specie::SOLUTE ) );
      BOOST_CHECK_EQUAL( var.sub_type(), particle::specie::SOLUTE );
      BOOST_CHECK( not var.is_channel_only() );
      BOOST_CHECK( not var.is_flexible() );
      BOOST_CHECK( not var.is_localized() );
      BOOST_CHECK( not var.is_mobile() );
      BOOST_CHECK(     var.is_solute() );
      BOOST_CHECK(     var.is_valid() );

      // DO these test after setting type to SOLUTE
      var.append_position( pos1 );
      var.append_position( pos2 );
      var.append_position( pos3 );
      BOOST_CHECK_EQUAL( var.count(), 0ul );
      BOOST_CHECK_NO_THROW( var.set_count( count ) );
      BOOST_CHECK_EQUAL( var.count(), count );
      BOOST_CHECK_NO_THROW( var.increment() );
      BOOST_CHECK_EQUAL( var.count(), count + 1 );
      BOOST_CHECK_NO_THROW( var.decrement() );
      BOOST_CHECK_EQUAL( var.count(), count );
      BOOST_CHECK_EQUAL( var.get_position( 0 ), pos1 );
      BOOST_CHECK_EQUAL( var.get_position( 1 ), pos2 );
      BOOST_CHECK_EQUAL( var.get_position( 2 ), pos3 );

       // Test parameter handling
      BOOST_CHECK( not var.has_parameter( k1 ) );
      BOOST_CHECK_NO_THROW( var.set_parameter( k1, v1 ) );
      BOOST_CHECK( var.has_parameter( k1 ) );
      BOOST_CHECK_EQUAL( var.parameter( k1 ), v1 );

      BOOST_CHECK( not var.has_parameter( k2 ) );
      BOOST_CHECK_NO_THROW( var.set_parameter( k2, v2 ) );
      BOOST_CHECK( var.has_parameter( k2 ) );
      BOOST_CHECK_EQUAL( var.parameter( k2 ), v2 );

      BOOST_CHECK( not var.has_parameter( k3 ) );
      BOOST_CHECK_NO_THROW( var.set_parameter( k3, v3 ) );
      BOOST_CHECK( var.has_parameter( k3 ) );
      BOOST_CHECK_EQUAL( var.parameter( k3 ), v3 );

      BOOST_CHECK( not var.has_parameter( k4 ) );
      BOOST_CHECK_NO_THROW( var.set_parameter( k4, v4 ) );
      BOOST_CHECK( var.has_parameter( k4 ) );
      BOOST_CHECK_EQUAL( var.parameter( k4 ), v4 );

      BOOST_CHECK( not var.has_parameter( k5 ) );
      BOOST_CHECK_NO_THROW( var.set_parameter( k5, v5 ) );
      BOOST_CHECK( var.has_parameter( k5 ) );
      BOOST_CHECK_EQUAL( var.parameter( k5 ), v5 );

      // overwrite existing value not allowed
      BOOST_CHECK( var.has_parameter( k1 ) );
      BOOST_CHECK_THROW( var.set_parameter( k1, v2 ), std::runtime_error );
      BOOST_CHECK( var.has_parameter( k1 ) );
      BOOST_CHECK_EQUAL( var.parameter( k1 ), v1 );

      specie_validation(var);

      var.description( desc );
      // Test serialization
      boost::archive::text_oarchive oa(store);
      // write class instance to archive
      oa << var;
   }
   {
      particle::specie var;
      BOOST_CHECK(not var.is_valid ());

      // Test centroid append_position
      BOOST_CHECK_NO_THROW( var.set_concentration( concentration ) );
      BOOST_CHECK_NO_THROW( var.set_excess_potential( excess_potential ) );
      BOOST_CHECK_NO_THROW( var.set_radius( radius ) );
      BOOST_CHECK_NO_THROW( var.set_rate( rate ) );
      BOOST_CHECK_NO_THROW( var.set_valency( valency ) );
      BOOST_CHECK_NO_THROW( var.set_label( label ) );
      BOOST_CHECK_NO_THROW( var.set_parameter( k1, v1 ) );
      BOOST_CHECK_NO_THROW( var.set_parameter( k2, v2 ) );
      BOOST_CHECK_NO_THROW( var.set_parameter( k3, v3 ) );
      BOOST_CHECK_NO_THROW( var.set_parameter( k4, v4 ) );
      BOOST_CHECK_NO_THROW( var.set_parameter( k5, v5 ) );

      var.append_position( pos1, ctr1 );
      var.append_position( pos2, ctr2 );
      var.append_position( pos3, ctr3 );
      BOOST_CHECK_EQUAL( var.count(), 0ul );
      BOOST_CHECK_NO_THROW( var.set_count( count ) );

      BOOST_CHECK_EQUAL( var.get_position( 0 ), pos1 );
      BOOST_CHECK_EQUAL( var.get_localization_data( 0 ), ctr1 );
      BOOST_CHECK_EQUAL( var.get_position( 1 ), pos2 );
      BOOST_CHECK_EQUAL( var.get_localization_data( 1 ), ctr2 );
      BOOST_CHECK_EQUAL( var.get_position( 2 ), pos3 );
      BOOST_CHECK_EQUAL( var.get_localization_data( 2 ), ctr3 );

      BOOST_CHECK_EQUAL( var.sub_type(), particle::specie::MOBILE );

      // Current count (3) should disallow next update
      BOOST_CHECK_THROW( var.update_position( 3, pos4 ), std::runtime_error );
      // Increment count (to 4) disallowed
      BOOST_CHECK_THROW( var.increment(), std::runtime_error );

      // Test serialization
      boost::archive::text_oarchive oa(store);
      // write class instance to archive
      oa << var;
   }
   {
      // Test (de)serialization
      particle::specie var;
      boost::archive::text_iarchive ia(store);
      // get class instance from archive
      ia >> var;

      specie_validation(var);

      BOOST_CHECK_EQUAL( var.concentration(), concentration );
      BOOST_CHECK_EQUAL( var.excess_potential(), excess_potential );
      BOOST_CHECK_EQUAL( var.chemical_potential(), chem_pot );
      BOOST_CHECK_EQUAL( var.radius(), radius );
      BOOST_CHECK_EQUAL( var.rate(), rate );
      BOOST_CHECK_EQUAL( var.valency(), valency );
      BOOST_CHECK_EQUAL( var.count(), count );
      BOOST_CHECK_EQUAL( var.get_position( 0 ), pos1 );
      BOOST_CHECK_EQUAL( var.get_position( 1 ), pos2 );
      BOOST_CHECK_EQUAL( var.get_position( 2 ), pos3 );
      BOOST_CHECK_EQUAL( var.label(), label );
      BOOST_CHECK_EQUAL( var.sub_type(), particle::specie::SOLUTE );
      BOOST_CHECK( not var.is_channel_only() );
      BOOST_CHECK( not var.is_flexible() );
      BOOST_CHECK( not var.is_localized() );
      BOOST_CHECK( not var.is_mobile() );
      BOOST_CHECK(     var.is_solute() );
      BOOST_CHECK(     var.is_valid() );

      BOOST_CHECK( var.has_parameter( k1 ) );
      BOOST_CHECK_EQUAL( var.parameter( k1 ), v1 );
      BOOST_CHECK( var.has_parameter( k2 ) );
      BOOST_CHECK_EQUAL( var.parameter( k2 ), v2 );
      BOOST_CHECK( var.has_parameter( k3 ) );
      BOOST_CHECK_EQUAL( var.parameter( k3 ), v3 );
      BOOST_CHECK( var.has_parameter( k4 ) );
      BOOST_CHECK_EQUAL( var.parameter( k4 ), v4 );
      BOOST_CHECK( var.has_parameter( k5 ) );
      BOOST_CHECK_EQUAL( var.parameter( k5 ), v5 );

      BOOST_CHECK_EQUAL( var.get_position( 0 ), pos1 );
      BOOST_CHECK_EQUAL( var.get_position( 1 ), pos2 );
      BOOST_CHECK_EQUAL( var.get_position( 2 ), pos3 );

      // Test copy ctor
      particle::specie var2(var);

      BOOST_CHECK( var.equivalent( var2 ) );
      BOOST_CHECK( var2.equivalent( var ) );

      // Test assignment
      particle::specie var3;
      BOOST_CHECK( not var.equivalent( var3 ) );
      var3 = var;
      BOOST_CHECK( var.equivalent( var3 ) );

      // Test move
      particle::specie var4( std::move( particle::specie( var ) ) );
      BOOST_CHECK( var.equivalent( var4 ) );

      // Test invalid append_position (NOT MOBILE or FLEXIBLE)
      BOOST_CHECK_THROW( var.append_position( pos1, ctr1 ), std::runtime_error );
      var4.set_type( particle::specie::MOBILE );
      // Test invalid append_position (already have locations without local_data)
      BOOST_CHECK_THROW( var4.append_position( pos1, ctr1 ), std::runtime_error );

      // Test update_position.
      var4.update_position( 0, pos2 );
      var4.update_position( 1, pos3 );
      var4.update_position( 2, pos1 );
      // Current count (3) should disallow next update
      BOOST_CHECK_THROW( var4.update_position( 3, pos4 ), std::runtime_error );
      // Increment count (to 4) should allow next update
      var4.set_type( particle::specie::SOLUTE );
      var4.increment();
      var4.update_position( 3, pos4 );
      BOOST_CHECK_EQUAL( var4.get_position( 0 ), pos2 );
      BOOST_CHECK_EQUAL( var4.get_position( 1 ), pos3 );
      BOOST_CHECK_EQUAL( var4.get_position( 2 ), pos1 );
      BOOST_CHECK_EQUAL( var4.get_position( 3 ), pos4 );
   }
   {
      // Test (de)serialization (should have ctrd)
      particle::specie var;
      boost::archive::text_iarchive ia(store);
      // get class instance from archive
      ia >> var;
      BOOST_CHECK_EQUAL( var.concentration(), concentration );
      BOOST_CHECK_EQUAL( var.excess_potential(), excess_potential );
      BOOST_CHECK_EQUAL( var.chemical_potential(), chem_pot );
      BOOST_CHECK_EQUAL( var.radius(), radius );
      BOOST_CHECK_EQUAL( var.rate(), rate );
      BOOST_CHECK_EQUAL( var.valency(), valency );
      BOOST_CHECK_EQUAL( var.count(), count );
      BOOST_CHECK_EQUAL( var.get_position( 0 ), pos1 );
      BOOST_CHECK_EQUAL( var.get_position( 1 ), pos2 );
      BOOST_CHECK_EQUAL( var.get_position( 2 ), pos3 );
      BOOST_CHECK_EQUAL( var.label(), label );
      BOOST_CHECK_EQUAL( var.sub_type(), particle::specie::MOBILE );

      BOOST_CHECK( var.has_parameter( k1 ) );
      BOOST_CHECK_EQUAL( var.parameter( k1 ), v1 );
      BOOST_CHECK( var.has_parameter( k2 ) );
      BOOST_CHECK_EQUAL( var.parameter( k2 ), v2 );
      BOOST_CHECK( var.has_parameter( k3 ) );
      BOOST_CHECK_EQUAL( var.parameter( k3 ), v3 );
      BOOST_CHECK( var.has_parameter( k4 ) );
      BOOST_CHECK_EQUAL( var.parameter( k4 ), v4 );
      BOOST_CHECK( var.has_parameter( k5 ) );
      BOOST_CHECK_EQUAL( var.parameter( k5 ), v5 );

      BOOST_CHECK_EQUAL( var.get_position( 0 ), pos1 );
      BOOST_CHECK_EQUAL( var.get_localization_data( 0 ), ctr1 );
      BOOST_CHECK_EQUAL( var.get_position( 1 ), pos2 );
      BOOST_CHECK_EQUAL( var.get_localization_data( 1 ), ctr2 );
      BOOST_CHECK_EQUAL( var.get_position( 2 ), pos3 );
      BOOST_CHECK_EQUAL( var.get_localization_data( 2 ), ctr3 );
      // Test write_document
      core::input_document wrtr( 1 );
      BOOST_CHECK( wrtr.empty() );
      var.write_document( wrtr );
      BOOST_CHECK( not wrtr.empty() );
      BOOST_CHECK_EQUAL( wrtr.size(), 1 );
      auto const& isec = wrtr[ 0 ];
      // DEBUG isec.write( std::cout );
      BOOST_CHECK_EQUAL( isec.label(), core::strngs::fsspec() );
      // Check for all entries
      auto quote = [](std::string s){ return '"' + s + '"'; };

      BOOST_REQUIRE( isec.has_entry( core::strngs::fsctrg() ) );
      BOOST_CHECK_EQUAL( std::stod( isec.get_entry( core::strngs::fsctrg() ) ), concentration );
      BOOST_CHECK( isec.has_entry( core::strngs::fsname() ) );
      BOOST_CHECK_EQUAL( isec.get_entry( core::strngs::fsname() ), quote(label) );
      BOOST_REQUIRE( isec.has_entry( core::strngs::fsd() ) );
      BOOST_CHECK_EQUAL( std::stod( isec.get_entry( core::strngs::fsd() ) )/2, radius );
      BOOST_REQUIRE( isec.has_entry( core::strngs::fsz() ) );
      BOOST_CHECK_EQUAL( std::stod( isec.get_entry( core::strngs::fsz() ) ), valency );
      BOOST_REQUIRE( isec.has_entry( core::strngs::rate_label() ) );
      BOOST_CHECK_EQUAL( std::stod( isec.get_entry( core::strngs::rate_label() ) ), rate );
      BOOST_REQUIRE( isec.has_entry( core::strngs::fschex() ) );
      BOOST_CHECK_EQUAL( std::stod( isec.get_entry( core::strngs::fschex() ) ), excess_potential );
      BOOST_REQUIRE( isec.has_entry( core::strngs::fstype() ) );
      BOOST_CHECK_EQUAL( isec.get_entry( core::strngs::fstype() ), core::strngs::fsmobl() );
      BOOST_REQUIRE( isec.has_entry( quote( k1 ) ) );
      BOOST_CHECK_EQUAL( isec.get_entry( quote( k1 ) ), quote( v1 ) );
      BOOST_REQUIRE( isec.has_entry( quote( k2 ) ) );
      BOOST_CHECK_EQUAL( isec.get_entry( quote( k2 ) ), quote( v2 ) );
      BOOST_REQUIRE( isec.has_entry( quote( k3 ) ) );
      BOOST_CHECK_EQUAL( isec.get_entry( quote( k3 ) ), quote( v3 ) );
      BOOST_REQUIRE( isec.has_entry( quote( k4 ) ) );
      BOOST_CHECK_EQUAL( isec.get_entry( quote( k4 ) ), quote( v4 ) );
      BOOST_REQUIRE( isec.has_entry( quote( k5 ) ) );
      BOOST_CHECK_EQUAL( isec.get_entry( quote( k5 ) ), quote( v5 ) );
      BOOST_REQUIRE( isec.has_entry( core::strngs::fsn() ) );
      const std::string value( isec.get_entry( core::strngs::fsn() ) );
      std::stringstream iss( value );
      std::size_t ncount;
      iss >> ncount;
      BOOST_CHECK_EQUAL( ncount, count );
      particle::coordinate pos;
      particle::centroid ctr;
      iss >> pos >> ctr;
      BOOST_CHECK_EQUAL( pos, pos1 );
      BOOST_CHECK_EQUAL( ctr, ctr1 );
      iss >> pos >> ctr;
      BOOST_CHECK_EQUAL( pos, pos2 );
      BOOST_CHECK_EQUAL( ctr, ctr2 );
      iss >> pos >> ctr;
      BOOST_CHECK_EQUAL( pos, pos3 );
      BOOST_CHECK_EQUAL( ctr, ctr3 );

   }
   {
      // Parse description
      while( true )
      {
         std::string line;
         std::getline( desc, line );
         // DEBUG : std::cout << "LINE[" << line << "]\n";
         if ( desc.eof() )
         {
            break;
         }
         if ( line.empty() )
         {
            continue;
         }
         const std::size_t split_pos { line.find(':') };
         if ( std::string::npos != split_pos )
         {
            std::size_t beg( 0 ), end( 0 );
            for (end = split_pos - 1; std::isspace(line[end]) and end != 0; --end)
               {}
            if (not std::isspace(line[end])) ++end;
            BOOST_REQUIRE( end != 0 );

            for (beg = 0; std::isspace( line[beg] ) and beg != end; ++beg)
               {};
            BOOST_REQUIRE_NE( beg, end );

            const std::string name( line.substr( beg, end - beg ) );

            end = line.size();
            for ( end = line.size() - 1; std::isspace( line[end] ) and end != split_pos + 1; --end )
               {}
            if ( not std::isspace( line[end] ) ) ++end;
            for ( beg = split_pos + 1; std::isspace( line[beg] ) and beg != end; ++beg )
               {};
            if (beg != split_pos + 1) --beg;
            BOOST_REQUIRE_LE( beg, end );

            const std::string value( line.substr( beg, end - beg ) );
            // DEBUG std::cout << "CHECK [" << name << "][" << value << "]\n";
            if (name == "label")
            {
               BOOST_CHECK_EQUAL( value, label );
            }
            else if (name == "radius" )
            {
               BOOST_CHECK( utility::feq( std::stod( value ), radius ) );
            }
            else if (name == "rate" )
            {
               BOOST_CHECK( utility::feq( std::stod( value ), rate ) );
            }
            else if (name == "valency" )
            {
               BOOST_CHECK( utility::feq( std::stod( value ), valency ) );
            }
            else if (name == "excess c.p." )
            {
               BOOST_CHECK( utility::feq( std::stod( value ), excess_potential ) );
            }
            else if (name == "chem. pot." )
            {
               const double cp { std::stod( value ) };
               BOOST_CHECK_LT( cp, chem_pot + 0.000005 );
               BOOST_CHECK_GT( cp, chem_pot - 0.000005 );
            }
            else if (name == "target conc." )
            {
               BOOST_CHECK( utility::feq( std::stod( value ), concentration ) );
            }
            else if (name == "count" )
            {
               BOOST_CHECK_EQUAL( std::stoul( value ), count );
            }
            else if (name == "type" )
            {
               BOOST_CHECK_EQUAL( value, particle::specie::type_label(particle::specie::SOLUTE) );
            }
            else if (name == "radius" )
            {
               BOOST_CHECK( utility::feq( std::stod( value ), radius ) );
            }
            else if (name == k1 )
            {
               BOOST_CHECK_EQUAL( v1, value );
            }
            else if (name == k2 )
            {
               BOOST_CHECK_EQUAL( v2, value );
            }
            else if (name == k3 )
            {
               std::string value2;
               std::getline( desc, value2 );
               value2.insert( 0, "\n" );
               value2.insert( 0, value );
               BOOST_CHECK_EQUAL( v3, value2 );
            }
            else if (name == k4 )
            {
               BOOST_CHECK_EQUAL( v4, value );
            }
            else if (name == k5 )
            {
               BOOST_CHECK_EQUAL( v5, value );
            }
            else
            {
               std::cout << "Unchecked [" << name << "][" << value << "]\n";
            }
         }
      }
   }
}
