format 75
"geometry" // geometry
  revision 36
  modified_by 48 "finnerty"
  owner 48 "finnerty"
  // class settings
  //class diagram settings
  draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
  //use case diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default class_drawing_mode default shadow default show_stereotype_properties default
  //sequence diagram settings
  show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
  //collaboration diagram settings
  show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
  //object diagram settings
   write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
  //component diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //deployment diagram settings
  package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //state diagram settings
  package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
  show_activities default region_horizontally default drawing_language default show_stereotype_properties default
  //activity diagram settings
  package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
  show_infonote default drawing_language default show_stereotype_properties default
  
  stereotype "library"
  cpp_h_dir "geometry"
  cpp_src_dir "geometry"
  cpp_namespace "geometry"
  comment " Manager information about the geometry of
 the system.

 The geometry of the system can be
 arbitrary.  It might support periodic
 boundaries in one or more dimensions or
 solid edges.  The simulation cell could
 be any shape. Furthermore the space could
 be divided into an arbitrary number of
 sub-spaces or **regions**. To this end the
 geometry manager is responsible for:

 + Calculation of volume(s).

 + Determining which region a particle
 is in.

 + Calculating distances between two points
 (accounting for periodicity).

 + Managing access to regions.

 + Solid objects may occlude space in the
 system. Most particles may not be inside
 or overlap such an object.

 Assumptions:

 + Calculation of distances is dependent on
 the system geometry but not the regions,
 in other words distance is not calculated
 in a different way in different regions.

 + No relation between regions can
 be inferred //a priori//. They can be
 contained within other regions, intersect
 other regions or represent disjoint
 sub-spaces.

 + Each region must manages the calculation
 of its volume.

 + One region encompasses the whole system.

 + Each region is responsible for
 calculating a random position within its
 borders.

 + Solid objects are responsible for
 calculating if a particle is inside or
 overlaps the object.

"
  classview 180784 "geometry classes"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    associated_deployment_view deploymentview_ref 156592 // geometry source
    classdiagram 265648 "geometry classes"
      draw_all_relations default hide_attributes yes hide_operations yes hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      size A4
    end

    sequencediagram 272304 "Use grid to generate new positions"
      show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
      comment " Look at interactions between geometry system and the
 simulation while using a gridder to generate new
 positions"
      overlapping_bars size A4
    end

    sequencediagram 272560 "New, random particle postion"
      show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
      comment " Finding a new position for a particle that is to be added or jump moved.

 This sequence is similar for both the initial system generation and 
 when particles are added or jump moved during the simulation."
      overlapping_bars size A4
    end

    activity 128048 "generate ensemble"
      comment " What the geometry library does during initialisation of the
 ensemble.

 * For the simulation you need particles in the solution.
 These are provided in the input file or randomly generated.
 Non-solute specie types must have all particles defined in
 the input. Solute specie particles will be randomly
 generated on a grid if not present in the input file. If
 present in the input file the actual number of particles
 is compared to the target number (as determined from
 the input file OR from concentration and volume). If
 the simulation includes grand canonical moves then 
 if actual number from the input file is within a 
 reasonable number of the target no new particles are
 generated, otherwise particles are added or removed.
 If the simulation does not include grand canonical
 moves then particles are added/removed until the
 target number is reached. In this case insertion at 
random positions are attempted."
      activitydiagram 272432 "fill ensemble"
	package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations no shadow default
	show_infonote default drawing_language default show_stereotype_properties default
	size A4
      end

      activityobject 128048 "initialise solute particles in simulation"
	 explicit_type ""
	unordered 
      end

      activityaction 128048 "calc. per-specie target particle number"
	opaque_action
	flow 137136 "<flow>"
	  on activitynode_ref 135344 // join
	end
      end

      activitynode 128048 decision "compare( input, target )"
	flow 128432 "target << input count OR non-GC"
	  on activityaction_ref 128176 // activity action place particles randomly
	end

	flow 129456 "GC AND target ~ input count"
	  on activitynode_ref 128560 // activity_final
	end
      end

      activityaction 128176 "place particles randomly"
	opaque_action
	flow 129328 "<flow>"
	  on activitynode_ref 128560 // activity_final
	end
      end

      activitynode 128304 decision ""
	flow 128688 "particles defined in input"
	  on activitynode_ref 128048 // decision
	end

	flow 128816 "no particles predefined"
	  on activityaction_ref 128304 // activity action place particles on a grid
	end
      end

      activityaction 128304 "place particles on a grid"
	opaque_action
	flow 129200 "<flow>"
	  on activitynode_ref 128560 // activity_final
	end
      end

      activitynode 128432 initial_node "initialise solute particles"
	flow 136240 "species have target count"
	  on activitynode_ref 135216 // decision
	end
      end

      activitynode 128560 activity_final "continue initialisation"
      end

      activityaction 134832 "volume = concentration / particles"
	opaque_action
	flow 136752 "<flow>"
	  on activityaction_ref 135088 // activity action set volume
	end
      end

      activityaction 134960 "total particles = concentration / volume"
	opaque_action
	flow 136624 "<flow>"
	  on activityaction_ref 128048 // activity action calc. per-specie target particle number
	end
      end

      activitynode 135216 decision ""
	flow 136368 "yes"
	  on activityaction_ref 134832 // activity action volume = concentration / particles
	end

	flow 136496 "no"
	  on activityaction_ref 134960 // activity action total particles = concentration / volume
	end
      end

      activityaction 135088 "set volume"
	opaque_action
	flow 136880 "<flow>"
	  on activitynode_ref 128304 // decision
	end

	flow 137008 "<flow>"
	  on activitynode_ref 135344 // join
	end
      end

      activitynode 135344 join ""
	flow 137264 "have solute particles defined in input?"
	  on activitynode_ref 128304 // decision
	end
      end
    end

    activity 134704 "generate trial"
      comment " What the geometry library does during trial generation."
      activitydiagram 279088 "generate trial coordinate"
	package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
	show_infonote default drawing_language default show_stereotype_properties default
	size A4
      end

      activitynode 135472 initial_node ""
	flow 137392 "<flow>"
	  on activityaction_ref 135472 // activity action get region
	end
      end

      activitynode 135600 decision ""
	flow 137648 "move"
	  on activityaction_ref 135344 // activity action new_position_offset
	end

	flow 137776 "jump or add"
	  on activityaction_ref 135216 // activity action new_position
	end
      end

      activityaction 135216 "new_position"
	opaque_action
	flow 138160 "<flow>"
	  on activitynode_ref 135856 // join
	end
      end

      activityaction 135344 "new_position_offset"
	opaque_action
	flow 138544 "is_inside"
	  on activitynode_ref 136240 // decision
	end
      end

      activityobject 134576 "select region"
	 explicit_type ""
	unordered 
      end

      activityaction 135472 "get region"
	opaque_action
	flow 137520 "<flow>"
	  on activitynode_ref 135600 // decision
	end
      end

      activitynode 135856 join ""
	flow 138288 "<flow>"
	  on activityaction_ref 135600 // activity action calculate_distances
	end
      end

      activityaction 135600 "calculate_distances"
	opaque_action
	flow 138416 "<flow>"
	  on activitynode_ref 135984 // activity_final
	end
      end

      activitynode 135984 activity_final "run trial"
      end

      activitynode 136112 activity_final "fail"
      end

      activitynode 136240 decision ""
	flow 138672 "true"
	  on activitynode_ref 135856 // join
	end

	flow 138800 "false"
	  on activitynode_ref 136112 // activity_final
	end
      end
    end

    class 452912 "base_region"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " A region of coordinate space."
      classrelation 617648 // <generalisation>
	relation 616752 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 617648 // <generalisation>
	  b parent class_ref 466608 // distance_calculator
      end

      classrelation 617904 // <dependency>
	relation 617008 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 617904 // <dependency>
	  b parent class_ref 912431 // access
      end

      attribute 508848 "label_"
	private explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " A user-defined label for the region."
      end

      operation 1023152 "base_region"
	public explicit_return_type ""
	nparams 1
	  param in name "label" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw}
: label_( ${p0} )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1023280 "base_region"
	protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Default ctor for serialization only"
      end

      operation 990128 "~base_region"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 438064 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1030960 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
  ar & this->label_;
}
"
	
	
	
	
	comment "Write the grid parameters to an archive"
      end

      operation 1114672 "extent"
	const public explicit_return_type "void"
	nparams 3
	  param out name "small_corner" type class_ref 986799 // coordinate
	  param out name "big_corner" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} & ${p1}, ${t2} ${p2}${)}${const}${volatile}${throw}
{
  UTILITY_REQUIRE( this->fits( ${p2} ), \"Can not calculate extent for sphere that does not fit the region.\" );
  return this->do_${name}( ${p0}, ${p1}, ${p2} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate a bounding box for the valid positions of spheres
 of the given radius within the region. The bounding box is
 defined by its most negative (small_corner) and most positive
 (big_corner).

 \\pre fits(radius) 
 \\post big.(x|y|z) - small.(x|y|z) >= 0
"
      end

      operation 1114800 "do_extent"
	abstract const cpp_virtual private explicit_return_type "void"
	nparams 3
	  param out name "small_corner" type class_ref 986799 // coordinate
	  param out name "big_corner" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate a bounding box for the valid positions of
 spheres of the given radius within the region. The
 bounding box is defined by its most negative
 (small_corner) and most positive (big_corner).

 \\pre fits(radius)
 \\post big.(x|y|z) - small.(x|y|z) >= 0"
      end

      operation 991152 "fits"
	const public explicit_return_type "bool"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  return ${p0} >= 0.0 and this->do_${name}( ${p0} );
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " True if there is any position in the region where a spherical
 particle of the given size can be in a valid position.

 False if radius is negative.

 * NOTE: for periodic systems the sphere diameter must be 
 less than the periodicity in the periodic dimensions."
      end

      operation 1023664 "do_fits"
	abstract const cpp_virtual private explicit_return_type "bool"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " True if there is any position in the region where a spherical
 particle of the given size can be in a valid position.

 False if radius is negative.

 * NOTE: for periodic systems the sphere diameter must be 
 less than the periodicity in the periodic dimensions."
      end

      operation 988976 "is_inside"
	const public explicit_return_type "bool"
	nparams 2
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  return this->fits( ${p1} ) and this->do_${name}( ${p0}, ${p1} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate if a sphere centred at the given point and with
 the given radius is in a valid position within the region.

 false if r < 0
 not fits(r) --> not is_inside(..., r)

 * NOTE: Key point is that this returns whether the position
 is a valid position in the region. For periodic systems
 this implies the radius must be ignored in the periodic
 dimension(s).
"
      end

      operation 1023792 "do_is_inside"
	abstract const cpp_virtual private explicit_return_type "bool"
	nparams 2
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate if a sphere centred at the given point and with
 the given radius is in a valid position within the region.

 not fits(r) --> not is_inside(..., r)

 * NOTE: Key point is that this returns whether the position
 is a valid position in the region. For periodic systems
 this implies the radius must be ignored in the periodic
 dimension(s).
"
      end

      operation 1004208 "label"
	const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} const& ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->label_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the region label"
      end

      operation 1046832 "make_gridder"
	const public return_type class_ref 289841 // grid_generator
	nparams 2
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  return this->do_${name}( ${p0}, (${p1} == 0 ? 1 : ${p1}) );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create a gridder object for this system. The gridder is
 guarranteed to have the minimum given number of points.
 The gridder provides the positions in a random sequence.

 (if count = 0 it is incremented to 1).

 As the grid is highly regular, the number of nodes will be an
 integral function of the number of points in each dimension.
 For a cube will always have the same number of nodes in
 each dimension and so the total number will be the cube of a
 whole number. The actual number of nodes will therefore be
 the smallest solution to this node function that is larger
 than count.
"
      end

      operation 1047728 "do_make_gridder"
	abstract const cpp_virtual private return_type class_ref 289841 // grid_generator
	nparams 2
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create a gridder object for this system. The gridder is
 guarranteed to have the minimum given number of points.
 The gridder provides the positions in a random sequence.

 (if count = 0 it is incremented to 1).

 As the grid is highly regular, the number of nodes will be an
 integral function of the number of points in each dimension.
 For a cube will always have the same number of nodes in
 each dimension and so the total number will be the cube of a
 whole number. The actual number of nodes will therefore be
 the smallest solution to this node function that is larger
 than count.
"
      end

      operation 1046704 "make_gridder"
	const public return_type class_ref 289841 // grid_generator
	nparams 2
	  param in name "spacing" explicit_type "double"
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  UTILITY_REQUIRE( this->fits( ${p0} / 2 ), \"Requested inter-node spacing is too large for region.\" );
  return this->do_${name}( ${p0}, ${p1} );
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create a gridder object for this system. The gridder inter-node
 distance is guarranteed to have the given minimum spacing.
 Every node is also guarranteed to be a minimum of (spacing/2)
 distant from any side.  The gridder provides the positions
 in a random sequence.

 \\pre fits(spacing/2)

 The spacing may be increased slightly to more evenly fit the
 particles into the region. The gridder calculates the maximum
 number of nodes that can fit within the region and have the
 given spacing. It then relaxes the grid to evenly fit in the
 region and recalculates the spacing.
"
      end

      operation 1047600 "do_make_gridder"
	abstract const cpp_virtual private return_type class_ref 289841 // grid_generator
	nparams 2
	  param in name "spacing" explicit_type "double"
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create a gridder object for this system. The gridder inter-node
 distance is guarranteed to have the given minimum spacing.
 Every node is also guarranteed to be a minimum of (spacing/2)
 distant from any side.  The gridder provides the positions
 in a random sequence.

 The spacing may be increased slightly to more evenly fit the
 particles into the region. The gridder calculates the maximum
 number of nodes that can fit within the region and have the
 given spacing. It then relaxes the grid to evenly fit in the
 region and recalculates the spacing.
"
      end

      operation 989360 "new_position"
	const public return_type class_ref 986799 // coordinate
	nparams 2
	  param inout name "rgnr" type class_ref 463407 // random_distribution
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  UTILITY_REQUIRE( this->fits( ${p1} ), \"Particle can not fit in region.\" );
  return this->do_${name}( ${p0}, ${p1} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate new random position for particle of the given radius to
 be in a valid position in the region.  The position distribution
 function should be equivolumetric.

 \\pre fits(radius)
 \\post is_inside(result, radius)"
      end

      operation 991280 "do_new_position"
	abstract const cpp_virtual private return_type class_ref 986799 // coordinate
	nparams 2
	  param inout name "rgnr" type class_ref 463407 // random_distribution
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate new random position for particle of the given radius to
 be inside the system."
      end

      operation 994608 "new_position_offset"
	const public explicit_return_type "bool"
	nparams 4
	  param inout name "rgnr" type class_ref 463407 // random_distribution
	  param inout name "pos" type class_ref 986799 // coordinate
	  param in name "offset" explicit_type "double"
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} & ${p1}, ${t2} ${p2}, ${t3} ${p3}${)}${const}${volatile}${throw}
{
  UTILITY_REQUIRE( this->fits( ${p3} ), \"Particle can not fit in region.\" );
  UTILITY_REQUIRE( this->is_inside( ${p1}, ${p3} ), \"Particle must start inside region.\" );
  this->do_offset( ${p0}, ${p1}, ${p2} );
  return this->do_new_position_wrap( ${p1}, ${p3} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate new random position in a sphere centred on pos and
 assign to pos. The particle is displaced a uniform linear
 distance in a random direction. This means that it is not an
 equivolume distribution (unlike new_position)

 * NOTE: for periodic systems the position should be 
 automatically wrapped to be inside the system and
 so should always return true.

 \\pre is_inside(pos, radius) and fits(radius)
 \\return is_inside(pos, radius)
"
      end

      operation 995120 "do_offset"
	class_operation public explicit_return_type "void"
	nparams 3
	  param inout name "rgnr" type class_ref 463407 // random_distribution
	  param inout name "pos" type class_ref 986799 // coordinate
	  param in name "offset" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} & ${p1}, ${t2} ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate new random position in a sphere centred on pos and
 assign to pos. The particle is displaced a uniform linear
 distance in a random direction. This means that it is not an
 equivolume distribution (unlike new_position)

 pos.x += r cos(theta) sin(phi)

 pos.y += r sin(theta) sin(phi)

 pos.z += r cos(phi)
"
      end

      operation 994736 "do_new_position_wrap"
	abstract const cpp_virtual private explicit_return_type "bool"
	nparams 2
	  param inout name "pos" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Try to bring new position into region.

 \\return is_inside(pos, radius)"
      end

      operation 1004336 "set_label"
	public explicit_return_type "void"
	nparams 1
	  param in name "label" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->label_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the region label"
      end

      operation 988720 "volume"
	const public explicit_return_type "double"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  UTILITY_REQUIRE( this->fits( radius ), \"Sphere must fit in space to be able to calculate the volume.\" );
  return this->do_${name}( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate volume accessible to centre-points of spherical particles
 with the given radius. 

 \\pre fits(radius)"
      end

      operation 1023536 "do_volume"
	abstract const cpp_virtual private explicit_return_type "double"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate volume accessible to centre-points of spherical particles
 with the given radius. 

 NOTE: can assume fits(radius)"
      end

      operation 1309360 "write_document"
	const public explicit_return_type "void"
	nparams 1
	  param inout name "wr" type class_ref 163632 // input_document
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Add an input file section to wr.

 Output of this method is something like

 region
 name [label]
 <call do_write_input_section>
 end
"
      end

      operation 1309232 "do_write_document"
	abstract const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Update wr[ix] section with information from the derived class."
      end
    end

    class 473136 "cube_region"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Non-periodic cube region. Can be open or closed.

 An open cube sees all objects whose centrepoint is inside
 the cube as being inside the cube. A closed cube sees only
 objects that are completely within the cube as being in the
 cube.

 The cube extent = [ origin.x : origin.x + length ],
 [origin.y : origin.y + length ], [ origin.z : origin.z + length ] "
      classrelation 624944 // <generalisation>
	relation 624048 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 624944 // <generalisation>
	  b parent class_ref 459952 // non_periodic_region
      end

      classrelation 631600 // <dependency>
	relation 630704 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 631600 // <dependency>
	  b parent class_ref 868655 // cubic_grid
      end

      attribute 515888 "origin_"
	private type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The most negative position in the cube."
      end

      attribute 515632 "length_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Length of the cube"
      end

      attribute 515760 "is_open_"
	private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Whether the cube is open or closed."
      end

      operation 1039024 "cube_region"
	private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " For serialization only"
      end

      operation 1038896 "cube_region"
	public explicit_return_type ""
	nparams 4
	  param in name "label" explicit_type "string"
	  param in name "len" explicit_type "double"
	  param in name "origin" type class_ref 986799 // coordinate
	  param in name "is_open" explicit_type "bool"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, const ${t2} & ${p2}${v2}, ${t3} ${p3}${v3}${)}${volatile}${throw}
: non_periodic_region( ${p0} )
, origin_( ${p2} )
, length_( ${p1} )
, is_open_( ${p3} )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create cube with the given dimension.

 \\param label : region label
 \\param len : the length of the cube.
 \\param origin : The most negative corner of the cube.
 \\param is_open : Whether cube is open of closed. (see class desc)"
      end

      operation 1038768 "~cube_region"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 444848 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1038640 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
    ar & boost::serialization::base_object< geometry::base_region >(*this);
    ar & this->origin_;
    ar & this->length_;
    ar & this->is_open_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      extra_member 444720 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1037616 "do_change_volume"
	cpp_virtual private explicit_return_type "void"
	nparams 2
	  param in name "vol" explicit_type "double"
	  param in name "rad" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Adjust cube length to accomodate volume.

 if is_open()
  len = cuberoot( vol )
 else
  len + 2 rad = cuberoot( vol )

 * NOTE: can never give: not fits(rad)"
      end

      operation 1115056 "do_extent"
	const private explicit_return_type "void"
	nparams 3
	  param out name "small_corner" type class_ref 986799 // coordinate
	  param out name "big_corner" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} & ${p1}, ${t2} ${p2}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate a bounding box for the valid positions of
 spheres of the given radius within the region. The
 bounding box is defined by its most negative
 (small_corner) and most positive (big_corner).

 \\pre fits(radius)
 \\post big.(x|y|z) - small.(x|y|z) >= 0"
      end

      operation 1038512 "do_fits"
	const cpp_virtual private explicit_return_type "bool"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  return this->is_open_ or this->length_ >= (2 * radius);
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " True if there is any position in the region where a spherical
 particle of the given size can be in a valid position. 

 * NOTE: While a particle of any size can theoretically exist
 anywhere in a periodic cube, particles that are larger than the cube
 would occlude themselves and are therefore said not to fit."
      end

      operation 1038384 "do_is_inside"
	const private explicit_return_type "bool"
	nparams 2
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Check if sphere at the given position and radius is inside
 the cube. As all positions can be mapped inside the
 cube, this method answers the question of whether the
 position is inside the primary cube. 

 not fits(r) --> not is_inside(..., r)

 * NOTE: Does not consider periodicity but ignores the radius if
 fits(radius) is true."
      end

      operation 1039280 "is_open"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->is_open_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Is this cube open or closed (see class desc)"
      end

      operation 1047088 "do_make_gridder"
	const cpp_virtual private return_type class_ref 289841 // grid_generator
	nparams 2
	  param in name "spacing" explicit_type "double"
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  return geometry::cubic_grid::make_grid( this->length_, spacing, rgenr );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create a gridder object for this system. The gridder inter-node
 distance is guarranteed to have the given minimum spacing.
 Every node is also guarranteed to be a minimum of (spacing/2)
 distant from any side.  The gridder provides the positions
 in a random sequence.

 The spacing may be increased slightly to more evenly fit the
 particles into the region. The gridder calculates the maximum
 number of nodes that can fit within the region and have the
 given spacing. It then relaxes the grid to evenly fit in the
 region and recalculates the spacing.
"
      end

      operation 1046960 "do_make_gridder"
	const cpp_virtual private return_type class_ref 289841 // grid_generator
	nparams 2
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  return geometry::cubic_grid::make_grid( this->length_, ${p0}, ${p1} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create a gridder object for this system. The gridder is
 guarranteed to have the minimum given number of points.
 The gridder provides the positions in a random sequence.

 As the grid is highly regular, the number of nodes will be an
 integral function of the number of points in each dimension.
 For a cube will always have the same number of nodes in
 each dimension and so the total number will be the cube of a
 whole number. The actual number of nodes will therefore be
 the smallest solution to this node function that is larger
 than count.
"
      end

      operation 1038256 "do_new_position"
	const cpp_virtual private return_type class_ref 986799 // coordinate
	nparams 2
	  param inout name "rgnr" type class_ref 463407 // random_distribution
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate new random position for particle. IGNORES RADIUS

 * NOTE: For this periodic system all positions are valid and
 so any new position should be anywhere in the cube. Limiting
 particle to be all inside would not be the desired behavior. 
"
      end

      operation 1038000 "length"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the radius"
      end

      operation 1037872 "length"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name}_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the radius"
      end

      operation 1039408 "origin"
	const public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} const& ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->origin_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get cube's origin point"
      end

      operation 1037744 "do_volume"
	const private explicit_return_type "double"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate volume accessible to centre-points of spherical particles
 with the given radius. For this periodic system this is always 
 equivalent to volume().

 NOTE: can assume fits(radius)"
      end

      operation 1309488 "do_write_document"
	const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Update wr[ix] section with information from the derived class."
      end

      operation 1069360 "region_factory"
	class_operation private return_type class_ref 452912 // base_region
	nparams 2
	  param in name "label" explicit_type "string"
	  param in name "params" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, const std::map< ${t1}, ${t1} > & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} ${p0}, const std::map< ${t1}, ${t1} > & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Factory method for creating cube_region objects from
 input data."
      end

      operation 1069488 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 479664 // region_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a region_definition to the meta object."
      end

      operation 1309616 "type_label"
	class_operation private explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  const static ${type} result( \"cube\" );
  return result;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end
    end

    class 183856 "cylinder_region"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Cylindrical region centred on the origin with linear axis in z
 direction. All sides are hard edges when considering valid
 positions.

 Coordinate range:
 * x*x + y*y <= rad*rad
 * -len/2 <= x <= +len/2"
      classrelation 597296 // <generalisation>
	relation 596400 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 597296 // <generalisation>
	  b parent class_ref 459952 // non_periodic_region
      end

      classrelation 189872 // <dependency>
	relation 189616 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 189872 // <dependency>
	  b parent class_ref 912431 // access
      end

      attribute 213808 "radius_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Radius of the cylinder"
      end

      attribute 213936 "half_length_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
      end

      extra_member 171056 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 251440 "cylinder_region"
	protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " For serialization only"
      end

      operation 252464 "cylinder_region"
	public explicit_return_type ""
	nparams 3
	  param in name "label" explicit_type "string"
	  param in name "rad" explicit_type "double"
	  param in name "half_len" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw}
: non_periodic_region( ${p0} )
, radius_( ${p1} )
, half_length_( ${p2} )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create new cylinder with the given dimensions.

 \\param label : the user defined name of the region.
 \\param rad : the radius of the cylinder.
 \\param half_len : half the length of the cylinder."
      end

      operation 251568 "~cylinder_region"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 170800 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 252208 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
    ar & boost::serialization::base_object< geometry::non_periodic_region >(*this);
    ar & this->radius_;
    ar & this->half_length_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      extra_member 170928 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1094448 "do_change_volume"
	cpp_virtual private explicit_return_type "void"
	nparams 2
	  param in name "vol" explicit_type "double"
	  param in name "rad" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Increase or decrease the system dimensions to match the new
 volume. Cylinders maintain ratio of half_length to radius.

 * NOTE : This is expected to be used only during system
 initialization, ie before checking particle positions or
 asking for new particle positions. Whether any check or
 particle postion calculated before calling this method is
 still valid is undefined.
"
      end

      operation 1114928 "do_extent"
	const private explicit_return_type "void"
	nparams 3
	  param out name "small_corner" type class_ref 986799 // coordinate
	  param out name "big_corner" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} & ${p1}, ${t2} ${p2}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate a bounding box for the valid positions of
 spheres of the given radius within the region. The
 bounding box is defined by its most negative
 (small_corner) and most positive (big_corner).

 \\pre fits(radius)
 \\post big.(x|y|z) - small.(x|y|z) >= 0"
      end

      operation 991408 "do_fits"
	const cpp_virtual private explicit_return_type "bool"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " True if there is any position in the region where a spherical
 particle of the given size can be completely included."
      end

      operation 990512 "do_is_inside"
	const cpp_virtual private explicit_return_type "bool"
	nparams 2
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate if a sphere centred at the given point and with
 the given radius is within the region."
      end

      operation 1094064 "do_make_gridder"
	const private return_type class_ref 289841 // grid_generator
	nparams 2
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create a gridder object for this system. The gridder is
 guarranteed to have the minimum given number of points.
 The gridder provides the positions in a random sequence.

 (if count = 0 it is incremented to 1).

 As the grid is highly regular, the number of nodes will be an
 integral function of the number of points in each dimension.
 For a cube will always have the same number of nodes in
 each dimension and so the total number will be the cube of a
 whole number. The actual number of nodes will therefore be
 the smallest solution to this node function that is larger
 than count.
"
      end

      operation 1094320 "do_make_gridder"
	const private return_type class_ref 289841 // grid_generator
	nparams 2
	  param in name "spacing" explicit_type "double"
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create a gridder object for this system. The gridder inter-node
 distance is guarranteed to have the given minimum spacing.
 Every node is also guarranteed to be a minimum of (spacing/2)
 distant from any side.  The gridder provides the positions
 in a random sequence.

 The spacing may be increased slightly to more evenly fit the
 particles into the region. The gridder calculates the maximum
 number of nodes that can fit within the region and have the
 given spacing. It then relaxes the grid to evenly fit in the
 region and recalculates the spacing.
"
      end

      operation 991024 "do_new_position"
	const cpp_virtual private return_type class_ref 986799 // coordinate
	nparams 2
	  param inout name "rgnr" type class_ref 463407 // random_distribution
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate new random position for particle of the given radius to
 be fully inside the region.

 \\pre fits(radius)
 \\post is_inside(pos, radius)"
      end

      operation 252592 "radius"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the radius"
      end

      operation 252720 "radius"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name}_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the radius"
      end

      operation 252848 "half_length"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the half length"
      end

      operation 252976 "half_length"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name}_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the half length"
      end

      operation 990640 "do_volume"
	const private explicit_return_type "double"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override
{
  return compute_volume( this->radius_ - radius, ( this->half_length_ - radius ) * 2 );
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate volume accessible to centre-points of spherical particles
 with the given radius

 NOTE: can assume fits(radius)"
      end

      operation 1309872 "do_write_document"
	const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Update wr[ix] section with information from the derived class."
      end

      operation 255024 "compute_volume"
	class_operation public explicit_return_type "double"
	nparams 2
	  param in name "rad" explicit_type "double"
	  param in name "len" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  return core::constants::pi() * rad * rad * len;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " volume = pi * rad * rad * len

 * NOTE: len is cylinder length **not** half length"
      end

      operation 1093296 "region_factory"
	class_operation private return_type class_ref 452912 // base_region
	nparams 2
	  param in name "label" explicit_type "string"
	  param in name "params" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, const std::map< ${t1}, ${t1} > & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} ${p0}, const std::map< ${t1}, ${t1} > & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Factory method for creating cube_region objects from
 input data."
      end

      operation 1093168 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 479664 // region_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a region_definition to the meta object."
      end

      operation 1309744 "type_label"
	class_operation private explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  const static ${type} result( \"cylinder\" );
  return result;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end
    end

    class 466608 "distance_calculator"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Abstract class to allow friend relation between geometry_manager and
 distance calculation methods."
      classrelation 617520 // <generalisation>
	relation 616624 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 617520 // <generalisation>
	  b parent class_ref 275887 // noncopyable
      end

      classrelation 617776 // <dependency>
	relation 616880 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 617776 // <dependency>
	  b parent class_ref 912431 // access
      end

      classrelation 618416 // <dependency>
	relation 617520 -_->
	  stereotype "friend"
	  a package
	    comment " Friend class to access distance calculation methods."
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 618416 // <dependency>
	  b parent class_ref 452656 // geometry_manager
      end

      extra_member 417072 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 991536 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {}
"
	
	
	
	
	comment "Write the grid parameters to an archive"
      end

      operation 1005104 "calculate_distances"
	const protected explicit_return_type "void"
	nparams 5
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "others" type class_ref 223792 // coordinate_set
	  param inout name "result" explicit_type "double"
	  param in name "startindex" explicit_type "size_t"
	  param in name "endindex" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, std::vector< ${t2} > & ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}${)}${const}${volatile}${throw}${abstract};"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, std::vector< ${t2} > & ${p2}, ${t3} ${p3}, ${t4} ${p4}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate distance between the given position and
 all positions in the given coordinate set. The
 result vector will contain the distances in the
 same sequence as the coordinate set.

 NOTE: This is hidden because it should
 only be called throw a geometry_manager
 object.

 \\pre startindex < endindex
 \\pre endindex <= others.size
 \\post result.size == end_index
 \\post result[0:start_index] == 0.0"
      end

      operation 1007280 "do_calculate_distances"
	abstract const cpp_virtual private explicit_return_type "void"
	nparams 5
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "others" type class_ref 223792 // coordinate_set
	  param inout name "result" explicit_type "double"
	  param in name "startindex" explicit_type "size_t"
	  param in name "endindex" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, std::vector< ${t2} > & ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate distance between the given position and
 all positions in the given coordinate set. The
 result vector will contain the distances in the
 same sequence as the coordinate set.

 \\post result.size == end_index
 \\post result[0:start_index] == 0.0"
      end

      operation 1004976 "calculate_distance_squared"
	abstract const cpp_virtual protected explicit_return_type "double"
	nparams 2
	  param in name "pos1" type class_ref 986799 // coordinate
	  param in name "pos2" type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate square of distance between two points.

 NOTE: This is hidden because it should
 only be called throw a geometry_manager
 object."
      end

      operation 1004848 "change_volume"
	protected explicit_return_type "void"
	nparams 2
	  param in name "vol" explicit_type "double"
	  param in name "rad" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  UTILITY_CHECK( not (${p0} < 0), \"A negative volume is invalid.\" );
  UTILITY_CHECK( not (${p1} < 0), \"A negative radius is invalid.\" );
  this->do_${name}( ${p0}, ${p1} );
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Increase or decrease the system dimensions to match the new
 volume. Derived classes each have rules to decide how the
 region's dimensions change to accomodate the new volume. For
 example a cube simply adjusts one length while a cylinder must
 distribute the change over the radial and linear dimensions.

 \\pre rad >= 0 
 \\pre vol >= 0 
 \\post volume(rad) == vol ** may be unchecked **

 \\pre AFTER VOLUME CHANGE fits(rad) : It is considered an
 argument error if after changing the volume the system can
 not fit an object of the given radius. ** should only checked 
 where it may fail **"
      end

      operation 1046320 "do_change_volume"
	abstract cpp_virtual private explicit_return_type "void"
	nparams 2
	  param in name "vol" explicit_type "double"
	  param in name "rad" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Increase or decrease the system dimensions to match the new
 volume. Derived classes each have rules to decide how the
 region's dimensions change to accomodate the new volume. For
 example a cube simply adjusts one length while a cylinder must
 distribute the change over the radial and linear dimensions.

 * NOTE : This is expected to be used only during system
 initialization, ie before checking particle positions or
 asking for new particle positions. Whether any check or
 particle postion calculated before calling this method is
 still valid is undefined.
"
      end
    end

    class 452656 "geometry_manager"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Manager facets of the systems geometry.

 The geometry of the system can be arbitrary.  It might support
 periodic boundaries in one or more dimensions or solid edges.
 The simulation cell could be any shape. Furthermore the 
 space could be divided into an arbitrary number of sub-spaces
 or _regions_. To this end the geometry manager is responsible for:

 * Calculation of volume(s).

 * Determining which region a particle is in.

 * Calculating distances between two points (accounting
   for periodicity).

 * Managing access to regions and region nesting"
      classrelation 596912 // <generalisation>
	relation 596016 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 596912 // <generalisation>
	  b parent class_ref 275887 // noncopyable
      end

      classrelation 618160 // <dependency>
	relation 617264 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 618160 // <dependency>
	  b parent class_ref 912431 // access
      end

      classrelation 596656 // regions_ (<directional composition>)
	relation 595760 *-->
	  stereotype "vector"
	  a role_name "regions_" multiplicity "*" private
	    comment " Regions in the simulation. The order implies no inter-region
 relationships. The first entry will always encompass the entire
 simulation (ie is the \"system\" region.) The vector will always
 have at least this system region."
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}< boost::shared_ptr< ${type} > > ${name}${value};
"
	    python "${comment}${self}${name} = ${stereotype}()
"
	    classrelation_ref 596656 // regions_ (<directional composition>)
	  b parent class_ref 452912 // base_region
      end

      operation 1004464 "geometry_manager"
	private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " For serialization only."
      end

      operation 1005360 "geometry_manager"
	public explicit_return_type ""
	nparams 1
	  param in name "system_region" type class_ref 452912 // base_region
	cpp_decl "    ${comment}${inline}${name}${(}boost::shared_ptr< ${t0} > ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}boost::shared_ptr< ${t0} > ${p0}${)}${throw}
: regions_()
{
  this->regions_.push_back( ${p0} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1004592 "~geometry_manager"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 424496 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1005872 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  ar & this->regions_;
}
"
	
	
	
	
	comment "Write the grid parameters to an archive"
      end

      operation 1005232 "add_region"
	public explicit_return_type "void"
	nparams 1
	  param in name "regn" type class_ref 452912 // base_region
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}boost::shared_ptr< ${t0} > ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}boost::shared_ptr< ${t0} > ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Add region to manager. If a region with the same label
 exists in the manager, the new object replaces the old."
      end

      operation 1030448 "calculate_distances"
	const public explicit_return_type "void"
	nparams 5
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "others" type class_ref 223792 // coordinate_set
	  param inout name "result" explicit_type "double"
	  param in name "startindex" explicit_type "size_t"
	  param in name "endindex" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, std::vector< ${t2} > & ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}${)}${const}${volatile}${throw}${abstract}
{
  this->regions_[0]->${name}( ${p0}, ${p1}, ${p2}, ${p3}, ${p4} );
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate distance between the given position and
 all positions in the given coordinate set. The
 result vector will contain the distances in the
 same sequence as the coordinate set.

 \\pre startindex < endindex
 \\pre endindex <= others.size
 \\post result.size == end_index
 \\post result[0:start_index] == 0.0"
      end

      operation 1030320 "calculate_distance_squared"
	const public explicit_return_type "double"
	nparams 2
	  param in name "pos1" type class_ref 986799 // coordinate
	  param in name "pos2" type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  return this->regions_[0]->${name}( ${p0}, ${p1} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate square of distance between two points."
      end

      operation 1003696 "change_volume"
	public explicit_return_type "void"
	nparams 2
	  param in name "vol" explicit_type "double"
	  param in name "rad" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  this->regions_[0]->${name}( ${p0}, ${p1} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Increase or decrease the system dimensions to match the new
 volume. Derived classes each have rules to decide how the
 region's dimensions change to accomodate the new volume. For
 example a cube simply adjusts one length while a cylinder must
 distribute the change over the radial and linear dimensions.

 Pre/post-conditions from region.change_volume(...)

 \\pre rad >= 0

 \\pre vol >= 0

 \\post volume(rad) == vol

 \\pre AFTER VOLUME CHANGE fits(rad)

 * NOTE : This is expected to be used only during system
 initialization, ie before checking particle positions or
 asking for new particle positions. Whether any check or
 particle postion calculated before calling this method is
 still valid is undefined.
"
      end

      operation 1004080 "get_region"
	stereotype "const"
	const public return_type class_ref 452912 // base_region
	nparams 1
	  param in name "idx" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} const& ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  return *(this->regions_.at(${p0}));
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get a region by index.

 \\pre idx < region_count : (throws same error as vector::at)"
      end

      operation 989744 "locate_region"
	const public explicit_return_type "void"
	nparams 3
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "rad" explicit_type "double"
	  param inout name "regns" type class_ref 452912 // base_region
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}, std::vector< boost::shared_ptr< ${t2} > >& ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} ${p1}, std::vector< boost::shared_ptr< ${t2} > >& ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Puts the set of regions the given point is in into
 regns. The set may be empty."
      end

      operation 1004720 "region_count"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->regions_.size();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The number of regions"
      end

      operation 1003824 "region_key"
	const public explicit_return_type "size_t"
	nparams 1
	  param in name "label" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Find a regions key from its label/name

 \\return index if found or region_count if not found."
      end

      operation 1973040 "size"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->regions_.size();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The number of regions defined.

 \\invariant >0"
      end

      operation 989872 "system_region"
	const public return_type class_ref 452912 // base_region
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} const& ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return *(this->regions_[0]);
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the region representing the entire system."
      end

      operation 1309104 "write_document"
	const public explicit_return_type "void"
	nparams 1
	  param inout name "wr" type class_ref 163632 // input_document
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Get all samplers to write their input information."
      end

      operation 1786288 "build_input_delegater"
	class_operation public explicit_return_type "void"
	nparams 2
	  param inout name "gman" type class_ref 452656 // geometry_manager
	  param inout name "delegate" type class_ref 1012655 // input_delegater
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}boost::shared_ptr< ${t0} > ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}boost::shared_ptr< ${t0} > ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Adds factory methods and input parsers for all the types that can be instantiated from 
 the input file."
      end
    end

    class 486448 "membrane_cylinder_region"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Cylindrical region centred on the origin with linear axis
 in z direction. All walls are considered hard. Cylinder has
 a membrane bissecting the cell in the centre providing two
 large compartments.  The two compartments are displaced by
 \"offset\" from the origin along the z-axis. A tube with rounded
 edges links the two compartments.

 Dimensions:

 Rad : Compartment radius
 HL  : Compartment length
 offset : Membrane half width
 rad : Radius of joining tube (rad << Rad)
 arc : Radius of rounded edge at tube mouth (rad + arc < Rad and arc < offset) 

 Valid coordinate range: 

 Compartments
 * [offset <= |z| <= offset + HL] and [x*x + y*y <= Rad*Rad]

 Tube
 * [|z| < offset] and [x*x + y*y <= rad*rad]
 * plus [offset - arc < |z| < offset] and in arc section.

"
      classrelation 658480 // <generalisation>
	relation 657584 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 658480 // <generalisation>
	  b parent class_ref 183856 // cylinder_region
      end

      classrelation 658608 // <dependency>
	relation 657712 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 658608 // <dependency>
	  b parent class_ref 912431 // access
      end

      extra_member 451376 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      attribute 529712 "channel_half_length_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Offset of cell compartments from origin along z-axis."
      end

      attribute 536240 "channel_radius_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The radius of the connecting tube/channel."
      end

      attribute 536368 "arc_radius_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The radius of the arc that rounds the tube into the membrane wall."
      end

      operation 1105712 "membrane_cylinder_region"
	private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " For serialization only"
      end

      operation 1105840 "membrane_cylinder_region"
	public explicit_return_type ""
	nparams 6
	  param in name "label" explicit_type "string"
	  param in name "rad" explicit_type "double"
	  param in name "half_len" explicit_type "double"
	  param in name "offset" explicit_type "double"
	  param in name "tube_radius" explicit_type "double"
	  param in name "arc_radius" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}${)}${volatile}${throw}
: cylinder_region( ${p0}, ${p1}, ${p2} )
, channel_half_length_( ${p3} )
, channel_radius_( ${p4} )
, arc_radius_( ${p5} )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create new cylinder with the given dimensions.

 Cylinder extent is z in +/-(offset + half_len) 

 \\param rad : the radius of the cylinder.
 \\param half_len : half the length of the cylinder.
 \\param offset : the offset along the z-axis."
      end

      operation 1105968 "~membrane_cylinder_region"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 451504 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1106096 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  ar & boost::serialization::base_object< geometry::cylinder_region >(*this);
  ar & this->channel_half_length_;
  ar & this->channel_radius_;
  ar & this->arc_radius_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      extra_member 451632 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1114160 "arc_radius"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the halflength of the gap between the two cylinder halves"
      end

      operation 1114032 "arc_radius"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name}_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the halflength of the gap between the two cylinder halves"
      end

      operation 1106224 "do_change_volume"
	cpp_virtual private explicit_return_type "void"
	nparams 2
	  param in name "vol" explicit_type "double"
	  param in name "rad" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Increase or decrease the system dimensions to match the new
 volume. Cylinders maintain ratio of half_length to radius.

 * NOTE : This is expected to be used only during system
 initialization, ie before checking particle positions or
 asking for new particle positions. Whether any check or
 particle postion calculated before calling this method is
 still valid is undefined.
"
      end

      operation 1106736 "channel_half_length"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the halflength of the gap between the two cylinder halves"
      end

      operation 1106864 "channel_half_length"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name}_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the halflength of the gap between the two cylinder halves"
      end

      operation 1113776 "channel_radius"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the halflength of the gap between the two cylinder halves"
      end

      operation 1113904 "channel_radius"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name}_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the halflength of the gap between the two cylinder halves"
      end

      operation 1144496 "do_extent"
	const private explicit_return_type "void"
	nparams 3
	  param out name "small_corner" type class_ref 986799 // coordinate
	  param out name "big_corner" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} & ${p1}, ${t2} ${p2}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate a bounding box for the valid positions of
 spheres of the given radius within the region. The
 bounding box is defined by its most negative
 (small_corner) and most positive (big_corner).

 \\pre fits(radius)
 \\post big.(x|y|z) - small.(x|y|z) >= 0"
      end

      operation 1106352 "do_fits"
	const cpp_virtual private explicit_return_type "bool"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  return true;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " True if there is any position in the region where a spherical
 particle of the given size can be completely included, this
 ignores the length."
      end

      operation 1106480 "do_is_inside"
	const cpp_virtual private explicit_return_type "bool"
	nparams 2
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate if a sphere centred at the given point and with
 the given radius is within the region. The checks if the
 sphere is in the cell compartments or the channel."
      end

      operation 1106608 "do_new_position"
	const cpp_virtual private return_type class_ref 986799 // coordinate
	nparams 2
	  param inout name "rgnr" type class_ref 463407 // random_distribution
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate new random position for particle of the given radius to
 be inside the region. The position distribution should be uniform 
 over the volume.

 \\pre fits(radius)
 \\post is_inside(pos, radius)"
      end

      operation 1106992 "do_volume"
	const private explicit_return_type "double"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override
{
  return compute_volume( this->radius(), this->half_length() * 2 );
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate volume accessible to centre-points of spherical particles
 with the given radius

 NOTE: can assume fits(radius)"
      end

      operation 1310128 "do_write_document"
	const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Update wr[ix] section with information from the derived class."
      end

      operation 1310000 "type_label"
	class_operation private explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  const static ${type} result( \"cell-membrane\" );
  return result;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1107120 "region_factory"
	class_operation private return_type class_ref 452912 // base_region
	nparams 2
	  param in name "label" explicit_type "string"
	  param in name "params" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, const std::map< ${t1}, ${t1} > & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} ${p0}, const std::map< ${t1}, ${t1} > & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Factory method for creating cube_region objects from
 input data."
      end

      operation 1107248 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 479664 // region_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a region_definition to the meta object."
      end

      operation 1114416 "volume_of_rotation"
	class_operation public explicit_return_type "double"
	nparams 5
	  param in name "axial_disp" explicit_type "double"
	  param in name "radial_disp" explicit_type "double"
	  param in name "arc_radius" explicit_type "double"
	  param in name "z_0" explicit_type "double"
	  param in name "z_1" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${)}:
${docstring}${body}
"
	
	comment " Calculate the volume of rotation _underneath_ an arc between z_0
 and z_1.

 This calculates the volume of rotation underneath an arc whose
 centrepoint is (axial_disp,radial_disp) and has the given arc_radius.
 The volume is the slice between the z_0 and z_1 .

 \\pre radial_disp > arc_radius
"
      end

      operation 1114288 "volume_of_rotation"
	class_operation public explicit_return_type "double"
	nparams 2
	  param in name "radial_disp" explicit_type "double"
	  param in name "arc_radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  return volume_of_rotation( 0.0, ${p0}, ${p1}, 0.0, ${p1} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${)}:
${docstring}${body}
"
	
	comment " Calculate the volume of rotation _underneath_ an arc whose
 centrepoint is (0.0,radial_disp) and has the given arc_radius.
 The volume is the slice between the 0.0 and arc_radius. In
 other words it is the volume under the half arc.

 \\pre radial_disp > arc_radius
"
      end
    end

    class 459952 "non_periodic_region"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 597168 // <generalisation>
	relation 596272 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 597168 // <generalisation>
	  b parent class_ref 452912 // base_region
      end

      classrelation 618032 // <dependency>
	relation 617136 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 618032 // <dependency>
	  b parent class_ref 912431 // access
      end

      operation 1006896 "non_periodic_region"
	protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1023408 "non_periodic_region"
	public explicit_return_type ""
	nparams 1
	  param in name "label" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}${)}${volatile}${throw}
: base_region( ${p0} )
{}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1007024 "~non_periodic_region"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 424624 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1007152 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
    ar & boost::serialization::base_object< geometry::base_region >(*this);
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 1006768 "do_calculate_distances"
	const private explicit_return_type "void"
	nparams 5
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "others" type class_ref 223792 // coordinate_set
	  param inout name "result" explicit_type "double"
	  param in name "startindex" explicit_type "size_t"
	  param in name "endindex" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, std::vector< ${t2} >& ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, std::vector< ${t2} >& ${p2}, ${t3} ${p3}, ${t4} ${p4}${)}${const}${throw}
{
  ${body}
}
"
	
	
	
	
	comment "Compute the distances between given position and existing positions.

\\pre rij.size == endindex
\\post rij[0:startindex] === 0"
      end

      operation 1006640 "calculate_distance_squared"
	const protected explicit_return_type "double"
	nparams 2
	  param in name "pos1" type class_ref 986799 // coordinate
	  param in name "pos2" type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  const double dx = ${p0}.x - ${p1}.x;
  const double dy = ${p0}.y - ${p1}.y;
  const double dz = ${p0}.z - ${p1}.z;
  return (dx*dx + dy*dy + dz*dz);
}
"
	
	
	
	
	comment "Compute distance between two coordinates."
      end

      operation 995248 "do_new_position_wrap"
	const cpp_virtual private explicit_return_type "bool"
	nparams 2
	  param inout name "pos" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  return this->is_inside( ${p0}, ${p1} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Can not wrap particle so just return is_inside(pos, radius)

 \\return is_inside(pos, radius)"
      end
    end

    class 453424 "open_cylinder_region"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Cylindrical region centred on the origin with linear axis in z
 direction. The curved wall is considered a hard wall but the
 ends are not when considering valid positions.

 Coordinate range:
 * x*x + y*y <= rad*rad
 * -len/2 <= x <= +len/2"
      classrelation 597424 // <generalisation>
	relation 596528 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 597424 // <generalisation>
	  b parent class_ref 183856 // cylinder_region
      end

      classrelation 590000 // <dependency>
	relation 589104 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 590000 // <dependency>
	  b parent class_ref 912431 // access
      end

      extra_member 417712 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 995376 "open_cylinder_region"
	protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " For serialization only"
      end

      operation 995504 "open_cylinder_region"
	public explicit_return_type ""
	nparams 3
	  param in name "label" explicit_type "string"
	  param in name "rad" explicit_type "double"
	  param in name "half_len" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw}
: cylinder_region( ${p0}, ${p1}, ${p2} )
{}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create new cylinder with the given dimensions.

 \\param label : user-defined label for the region.
 \\param rad : the radius of the cylinder.
 \\param half_len : half the length of the cylinder."
      end

      operation 995632 "~open_cylinder_region"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 417840 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 995760 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  ar & boost::serialization::base_object< geometry::cylinder_region >(*this);
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      extra_member 417968 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1094576 "do_change_volume"
	cpp_virtual private explicit_return_type "void"
	nparams 2
	  param in name "vol" explicit_type "double"
	  param in name "rad" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Increase or decrease the system dimensions to match the new
 volume. Cylinders maintain ratio of half_length to radius.

 * NOTE : This is expected to be used only during system
 initialization, ie before checking particle positions or
 asking for new particle positions. Whether any check or
 particle postion calculated before calling this method is
 still valid is undefined.
"
      end

      operation 995888 "do_fits"
	const cpp_virtual private explicit_return_type "bool"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " True if there is any position in the region where a spherical
 particle of the given size can be completely included, this
 ignores the length."
      end

      operation 996016 "do_is_inside"
	const cpp_virtual private explicit_return_type "bool"
	nparams 2
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate if a sphere centred at the given point and with
 the given radius is within the region. This class ignores the 
 radius when considering the z direction."
      end

      operation 996144 "do_new_position"
	const cpp_virtual private return_type class_ref 986799 // coordinate
	nparams 2
	  param inout name "rgnr" type class_ref 463407 // random_distribution
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate new random position for particle of the given radius to
 be inside the region. This class ignores the radius when calculating
 the new z coordinate.

 \\pre fits(radius)
 \\post is_inside(pos, radius)"
      end

      operation 997040 "do_volume"
	const private explicit_return_type "double"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override
{
  return compute_volume( this->radius() - radius, this->half_length() * 2 );
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate volume accessible to centre-points of spherical particles
 with the given radius

 NOTE: can assume fits(radius)"
      end

      operation 1310384 "do_write_document"
	const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Update wr[ix] section with information from the derived class."
      end

      operation 1310256 "type_label"
	class_operation private explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  const static ${type} result( \"open-cylinder\" );
  return result;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1093552 "region_factory"
	class_operation private return_type class_ref 452912 // base_region
	nparams 2
	  param in name "label" explicit_type "string"
	  param in name "params" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, const std::map< ${t1}, ${t1} > & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} ${p0}, const std::map< ${t1}, ${t1} > & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Factory method for creating cube_region objects from
 input data."
      end

      operation 1093424 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 479664 // region_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a region_definition to the meta object."
      end
    end

    class 460080 "open_split_cylinder_region"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Cylindrical region centred on the origin with linear axis in z
 direction. All walls are considered soft. Cylinder is cut in the
 centre and the two parts displaced \"offset\" from the origin
 along the z-axis.

 Coordinate range:
 * x*x + y*y <= rad*rad
 * -(len/2 + offset) <= z <= -(offset) AND (offset) <= z <= +(len/2 + offset)"
      classrelation 597552 // <generalisation>
	relation 596656 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 597552 // <generalisation>
	  b parent class_ref 183856 // cylinder_region
      end

      classrelation 597680 // <dependency>
	relation 596784 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 597680 // <dependency>
	  b parent class_ref 912431 // access
      end

      extra_member 424752 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      attribute 508976 "offset_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Offset from origin along z-axis."
      end

      operation 1007408 "open_split_cylinder_region"
	protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " For serialization only"
      end

      operation 1007536 "open_split_cylinder_region"
	public explicit_return_type ""
	nparams 4
	  param in name "label" explicit_type "string"
	  param in name "rad" explicit_type "double"
	  param in name "half_len" explicit_type "double"
	  param in name "offset" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}${)}${volatile}${throw}
: cylinder_region( ${p0}, ${p1}, ${p2} )
, offset_( ${p3} )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create new cylinder with the given dimensions.

 Cylinder extent is z in +/-(offset + half_len) 

 \\param rad : the radius of the cylinder.
 \\param half_len : half the length of the cylinder.
 \\param offset : the offset along the z-axis."
      end

      operation 1007664 "~open_split_cylinder_region"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 424880 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1007792 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  ar & boost::serialization::base_object< geometry::cylinder_region >(*this);
  ar & this->offset_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      extra_member 425008 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1094704 "do_change_volume"
	cpp_virtual private explicit_return_type "void"
	nparams 2
	  param in name "vol" explicit_type "double"
	  param in name "rad" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Increase or decrease the system dimensions to match the new
 volume. Cylinders maintain ratio of half_length to radius.

 * NOTE : This is expected to be used only during system
 initialization, ie before checking particle positions or
 asking for new particle positions. Whether any check or
 particle postion calculated before calling this method is
 still valid is undefined.
"
      end

      operation 1007920 "do_fits"
	const cpp_virtual private explicit_return_type "bool"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  return true;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " True if there is any position in the region where a spherical
 particle of the given size can be completely included, this
 ignores the length."
      end

      operation 1008048 "do_is_inside"
	const cpp_virtual private explicit_return_type "bool"
	nparams 2
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate if a sphere centred at the given point and with
 the given radius is within the region. This class ignores the 
 radius when considering the z direction."
      end

      operation 1008176 "do_new_position"
	const cpp_virtual private return_type class_ref 986799 // coordinate
	nparams 2
	  param inout name "rgnr" type class_ref 463407 // random_distribution
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate new random position for particle of the given radius to
 be inside the region. This class ignores the radius when calculating
 the new z coordinate.

 \\pre fits(radius)
 \\post is_inside(pos, radius)"
      end

      operation 1105456 "offset"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->offset_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the halflength of the gap between the two cylinder halves"
      end

      operation 1105584 "offset"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->offset_ = ${p0};
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the halflength of the gap between the two cylinder halves"
      end

      operation 1008432 "do_volume"
	const private explicit_return_type "double"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override
{
  return compute_volume( this->radius(), this->half_length() * 2 );
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate volume accessible to centre-points of spherical particles
 with the given radius

 NOTE: can assume fits(radius)"
      end

      operation 1310640 "do_write_document"
	const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Update wr[ix] section with information from the derived class."
      end

      operation 1310512 "type_label"
	class_operation private explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  const static ${type} result( \"split-cylinder\" );
  return result;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1093808 "region_factory"
	class_operation private return_type class_ref 452912 // base_region
	nparams 2
	  param in name "label" explicit_type "string"
	  param in name "params" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, const std::map< ${t1}, ${t1} > & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} ${p0}, const std::map< ${t1}, ${t1} > & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Factory method for creating cube_region objects from
 input data."
      end

      operation 1093680 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 479664 // region_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a region_definition to the meta object."
      end
    end

    class 453296 "periodic_cube_region"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Cube with periodic boundaries with the origin at
 one corner. Can be used as a system region.

 Coordinate range:
 * x % len
 * y % len
 * z % len"
      classrelation 589616 // <generalisation>
	relation 588720 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 589616 // <generalisation>
	  b parent class_ref 452912 // base_region
      end

      classrelation 589744 // <dependency>
	relation 588848 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 589744 // <dependency>
	  b parent class_ref 912431 // access
      end

      classrelation 631728 // <dependency>
	relation 630832 -_->
	  a default
	    cpp default "#include in source"
	    python "${type}"
	    classrelation_ref 631728 // <dependency>
	  b parent class_ref 868655 // cubic_grid
      end

      attribute 501552 "length_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Length of the cube"
      end

      attribute 501808 "volume_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Cached volume"
      end

      extra_member 417328 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 991792 "periodic_cube_region"
	private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " For serialization only"
      end

      operation 991920 "periodic_cube_region"
	public explicit_return_type ""
	nparams 2
	  param in name "label" explicit_type "string"
	  param in name "len" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw}
: base_region( ${p0} )
, length_( ${p1} )
, volume_( std::pow( ${p1}, 3 ) )
{}

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create cube with the given dimension.

 \\param label : region label
 \\param len : the length of the cube."
      end

      operation 992048 "~periodic_cube_region"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 417456 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 992176 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
    ar & boost::serialization::base_object< geometry::base_region >(*this);
    ar & this->length_;
    ar & this->volume_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      extra_member 417584 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 296881 "do_calculate_distances"
	const private explicit_return_type "void"
	nparams 5
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "others" type class_ref 223792 // coordinate_set
	  param inout name "result" explicit_type "double"
	  param in name "startindex" explicit_type "size_t"
	  param in name "endindex" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, std::vector< ${t2} >& ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} ${p4}${v4}${)}${const}${volatile}${throw} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}, std::vector< ${t2} >& ${p2}, ${t3} ${p3}, ${t4} ${p4}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self, ${p0}${v0}, ${p1}${v1}, ${p3}${v3}${)}:
${docstring}${body}
"
	
	comment "Compute the distances between any new position and existing positions.

\\post result.size == end_index
\\post result[0:start_index] == 0.0
"
      end

      operation 218673 "calculate_distance_squared"
	const protected explicit_return_type "double"
	nparams 2
	  param in name "pos1" type class_ref 986799 // coordinate
	  param in name "pos2" type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	
	
	comment " Compute square of distance between two coordinates in 
 a periodic box."
      end

      operation 1046448 "do_change_volume"
	cpp_virtual private explicit_return_type "void"
	nparams 2
	  param in name "vol" explicit_type "double"
	  param in name "rad" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Adjust cube length to accomodate volume.

 len = cuberoot( vol )

 * NOTE: _can_ give: not fits(rad) after volume change"
      end

      operation 1115184 "do_extent"
	const private explicit_return_type "void"
	nparams 3
	  param out name "small_corner" type class_ref 986799 // coordinate
	  param out name "big_corner" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} & ${p1}, ${t2} ${p2}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate a bounding box for the valid positions of
 spheres of the given radius within the region. The
 bounding box is defined by its most negative
 (small_corner) and most positive (big_corner).

 \\pre fits(radius)
 \\post big.(x|y|z) - small.(x|y|z) >= 0"
      end

      operation 992304 "do_fits"
	const cpp_virtual private explicit_return_type "bool"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  return this->length_ >= (2 * radius);
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " True if there is any position in the region where a spherical
 particle of the given size can be in a valid position. 

 * NOTE: While a particle of any size can theoretically exist
 anywhere in a periodic cube, particles that are larger than the cube
 would occlude themselves and are therefore said not to fit."
      end

      operation 992560 "do_is_inside"
	const private explicit_return_type "bool"
	nparams 2
	  param in name "pos" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Check if sphere at the given position and radius is inside
 the cube. As all positions can be mapped inside the
 cube, this method answers the question of whether the
 position is inside the primary cube. 

 not fits(r) --> not is_inside(..., r)

 * NOTE: Does not consider periodicity but ignores the radius if
 fits(radius) is true."
      end

      operation 1054768 "do_make_gridder"
	const cpp_virtual private return_type class_ref 289841 // grid_generator
	nparams 2
	  param in name "spacing" explicit_type "double"
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} ${p0}, ${t1} & ${p1}${)}${const}${volatile}${throw}
{
  return geometry::cubic_grid::make_grid( this->length_, spacing, rgenr );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create a gridder object for this system. The gridder inter-node
 distance is guarranteed to have the given minimum spacing.
 Every node is also guarranteed to be a minimum of (spacing/2)
 distant from any side.  The gridder provides the positions
 in a random sequence.

 The spacing may be increased slightly to more evenly fit the
 particles into the region. The gridder calculates the maximum
 number of nodes that can fit within the region and have the
 given spacing. It then relaxes the grid to evenly fit in the
 region and recalculates the spacing.
"
      end

      operation 1054640 "do_make_gridder"
	const cpp_virtual private return_type class_ref 289841 // grid_generator
	nparams 2
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  return geometry::cubic_grid::make_grid( this->length_, ${p0}, ${p1} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create a gridder object for this system. The gridder is
 guarranteed to have the minimum given number of points.
 The gridder provides the positions in a random sequence.

 As the grid is highly regular, the number of nodes will be an
 integral function of the number of points in each dimension.
 For a cube will always have the same number of nodes in
 each dimension and so the total number will be the cube of a
 whole number. The actual number of nodes will therefore be
 the smallest solution to this node function that is larger
 than count.
"
      end

      operation 992816 "do_new_position"
	const cpp_virtual private return_type class_ref 986799 // coordinate
	nparams 2
	  param inout name "rgnr" type class_ref 463407 // random_distribution
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate new random position for particle. IGNORES RADIUS

 * NOTE: For this periodic system all positions are valid and
 so any new position should be anywhere in the cube. Limiting
 particle to be all inside would not be the desired behavior. 
"
      end

      operation 994224 "do_new_position_wrap"
	const cpp_virtual private explicit_return_type "bool"
	nparams 2
	  param inout name "pos" type class_ref 986799 // coordinate
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Wrap position for particle inside cube. IGNORES RADIUS

 * NOTE: For this periodic system all positions are valid and
 so position should be anywhere in the cube. Limiting
 particle to be all inside would not be the desired behavior. "
      end

      operation 993200 "length"
	stereotype "get"
	const public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->${name}_;
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Get the radius"
      end

      operation 993328 "length"
	stereotype "set"
	public explicit_return_type "void"
	nparams 1
	  param in name "val" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} set_${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  this->${name}_ = ${p0};
  this->volume_ = std::pow( ${p0}, 3 );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Set the radius"
      end

      operation 993584 "do_volume"
	const private explicit_return_type "double"
	nparams 1
	  param in name "radius" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override
{
  return this->volume_;
}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Calculate volume accessible to centre-points of spherical particles
 with the given radius. For this periodic system this is always 
 equivalent to volume().

 NOTE: can assume fits(radius)"
      end

      operation 1310896 "do_write_document"
	const cpp_virtual private explicit_return_type "void"
	nparams 2
	  param inout name "wr" type class_ref 163632 // input_document
	  param in name "ix" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Update wr[ix] section with information from the derived class."
      end

      operation 1310768 "type_label"
	class_operation private explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  const static ${type} result( \"periodic-cube\" );
  return result;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1085232 "region_factory"
	class_operation private return_type class_ref 452912 // base_region
	nparams 2
	  param in name "label" explicit_type "string"
	  param in name "params" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, const std::map< ${t1}, ${t1} > & ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} ${p0}, const std::map< ${t1}, ${t1} > & ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Factory method for creating cube_region objects from
 input data."
      end

      operation 1085104 "add_definition"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "meta" type class_ref 479664 // region_meta
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Create and add a region_definition to the meta object."
      end
    end
  end

  classview 501551 "grid builders"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    associated_deployment_view deploymentview_ref 156592 // geometry source
    classdiagram 563631 "Grid Builders"
      draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      size A4
    end

    class 289841 "grid_generator"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 604208 // <generalisation>
	relation 603312 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 604208 // <generalisation>
	  b parent class_ref 275887 // noncopyable
      end

      operation 699697 "empty"
	abstract const cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment " Test if any grid points remain."
      end

      operation 626865 "next"
	abstract cpp_virtual public explicit_return_type "bool"
	nparams 1
	  param inout name "pnt" type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment "  Get the next coordinate in grid. Return false when there are
  no coordinates left in the grid.

  if true then pnt is a valid unique point in the grid
  if false then pnt is not set"
      end

      operation 626993 "size"
	abstract const cpp_virtual public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	comment " The number of remaining grid points defined by the generator"
      end

      operation 264112 "spacing"
	abstract const cpp_virtual public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  The inter-gridpoint distance."
      end

      operation 598448 "~grid_generator"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      classrelation 197424 // <dependency>
	relation 197168 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 197424 // <dependency>
	  b parent class_ref 912431 // access
      end

      extra_member 417200 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 991664 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {}
"
	
	
	
	
	comment "Write the grid parameters to an archive"
      end
    end

    class 868655 "cubic_grid"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl "class ${name}(object):
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment "Generate a grid of points within a cube. The grid starts half
the 'spacing' distance from the //lower// cube edges and no
less than half the 'spacing' distance from the //upper// cube
edges. Grid points are retrieved sequentially.
"
      classrelation 427057 // <generalisation>
	relation 426545 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 427057 // <generalisation>
	  b parent class_ref 289841 // grid_generator
      end

      attribute 332081 "steps_"
	private explicit_type "size_t"
	init_value "int(pow(npart, 1.0/3.0))+1"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "The number of points in each dimension"
      end

      attribute 1090095 "delta_"
	private explicit_type "double"
	init_value "length / float(self.steps_)"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " inter-grid spacing"
      end

      attribute 402097 "sequence_"
	private explicit_type "size_t"
	multiplicity "*"
	init_value "None"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "The random sequence of indices"
      end

      operation 1988527 "__init__"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 4
	  param in name "self" explicit_type ""
	  param in name "length" explicit_type "double"
	  param in name "npart" explicit_type "size_t"
	  param inout name "rgen" type class_ref 463407 // random_distribution
	
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}, ${p1}${v1}, ${p2}${v2}, ${p3}${v3}${)}:
${docstring}super(${class}, self).__init__()
${body}
"
	
	comment " Initialise the cube grids with the given lengths.

 This leaves a minimum of 'spacing' distance between any grid
 point and the cube edge. There will be an even number of grid
 points in each direction.

\\param length : The length of the cube
\\param npart : The approximate, minimum number of grid points.
  ( size >= npart | size == ceil(cbrt(npart))^3 )"
      end

      operation 1054512 "cubic_grid"
	preserve_cpp_body_indent protected explicit_return_type ""
	nparams 3
	  param in name "space" explicit_type "double"
	  param in name "per_dim" explicit_type "size_t"
	  param inout name "rgen" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} & ${p2}${v2}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} & ${p2}${)}${volatile}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}, ${p1}${v1}, ${p2}${v2}, ${p3}${v3}${)}:
${docstring}super(${class}, self).__init__()
${body}
"
	
	comment " Initialise the cube grids with the given lengths, inter-node 
 spacing and nodes per dimension.

 This leaves a minimum of 'spacing' distance between any grid
 point and the cube edge. There will be an even number of grid
 points in each direction.

 \\param space : the inter-node spacing
 \\param per_dim : The number of nodes in each dimension.

 * For cube with width/length = space * per_dim
"
      end

      operation 2035887 "cubic_grid"
	preserve_cpp_body_indent private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;

"
	
	
	
	
	comment " Default ctor (for serialize only)"
      end

      operation 598704 "~cubic_grid"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 448815 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      classrelation 1169071 // <dependency>
	relation 1131951 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 1169071 // <dependency>
	  b parent class_ref 912431 // access
      end

      operation 2035503 "serialize"
	stereotype "template"
	private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
    ar & boost::serialization::base_object< geometry::grid_generator >(*this);
    ar & steps_;
    ar & delta_;
    ar & sequence_;
  }
"
	
	
	
	
	comment "Write the grid parameters to an archive"
      end

      extra_member 258353 "COMMON"
	
	stereotype "access"
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 699569 "empty"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} override
{
  return this->sequence_.${name}();
}
"
	
	
	
	
	comment " The number of remaining points in the grid."
      end

      operation 1531055 "next"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 1
	  param inout name "pnt" type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Get the next location from the grid with
 indication of iteration ending.

 \\return size > 0"
      end

      operation 1531183 "size"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} override
{
  return this->sequence_.${name}();
}
"
	
	
	python_def "${@}${static}${abstract}def __len__${(}self${)}:
${docstring}return len(self.sequence_)
"
	
	comment " The number of remaining points in the grid."
      end

      operation 264240 "spacing"
	const cpp_virtual public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw} override
{
  return this->delta_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  The inter-gridpoint distance."
      end

      operation 1054256 "make_grid"
	class_operation public return_type class_ref 868655 // cubic_grid
	nparams 3
	  param in name "cube_width" explicit_type "double"
	  param in name "spacing" explicit_type "double"
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} & ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} & ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Generate a regular grid of nodes that fits in a cube of the given
 width. The requested grid must have the given minimum inter-node
 spacing and have a minimum of spacing/2 between the nodes and the
 cube walls.

 \\pre spacing < cube_width
"
      end

      operation 1054384 "make_grid"
	class_operation public return_type class_ref 868655 // cubic_grid
	nparams 3
	  param in name "cube_width" explicit_type "double"
	  param inout name "rgenr" type class_ref 463407 // random_distribution
	  param in name "count" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, ${t1} & ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}boost::shared_ptr< ${type} > ${class}::${name}${(}${t0} ${p0}, ${t1} & ${p1}, ${t2} ${p2}${)}${const}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Generate a regular grid of nodes that fits in a cube of the given
 width. The requested grid must have the given minimum inter-node
 spacing and have a minimum of spacing/2 between the nodes and the
 cube walls.

 \\pre spacing < cube_width
"
      end
    end

    class 868783 "tubular_grid"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl "class ${name}(object):
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Generate a cubic grid of points within a
 cylinder/tube. The grid starts a minimum of half
 the 'spacing' distance from the cylinder walls
 and end. Grid points are retrieved sequentially
 or in random order.

 NOTES:

 * cylinder axis is along z direction with centre of the cylinder at z=0.

 * cylinder circle is in xy plane
 
 * z-grid equally spaced in positive and negative direction
 
 * absolute minimum value in z direction = spacing/2

 * absolute minimum in xy plane is (0,0)

 Given tubelength and radius to generate the grid:

 * absolute maximum in z direction is <= (tubelength/2 - spacing/2)

 * absolute maximum in xy place sqrt(x*x + y*y) < (radius - spacing/2)
"
      classrelation 427185 // <generalisation>
	relation 426673 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 427185 // <generalisation>
	  b parent class_ref 289841 // grid_generator
      end

      attribute 1090607 "spacing_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " inter-grid spacing"
      end

      attribute 229552 "min_spacing"
	class_attribute const_attribute private explicit_type "double"
	init_value "{ 0.1 }"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment "  Minimum value the spacing can reach when attempting
  to build a grid with a target number of positions."
      end

      attribute 1090735 "zmax_"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " maximum grid widths in direction of tube"
      end

      classrelation 197168 // circle_ (<directional composition>)
	relation 196912 *-->
	  a role_name "circle_" private
	    comment "  The XY circle grid slice."
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    python "${comment}${self}${name} = ${type}()
"
	    classrelation_ref 197168 // circle_ (<directional composition>)
	  b parent class_ref 190768 // circle_grid
      end

      attribute 1091247 "selector_"
	private explicit_type "std::size_t"
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${stereotype}()
"
	idl_decl ""
	comment " Grid point selector array"
      end

      operation 1531311 "tubular_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 3
	  param in name "tubelength" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "spacing" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Initialise the tubular grid with the given length and radius.

 This leaves a minimum of 'spacing' distance between any grid
 point and the cylinder edge. Point closest to origin
 will be (0,0,+/-spacing/2) or no points.

\\param tubelength : Z coordinates will be within | -(tubelength-spacing)/2 <= z <= (tubelength-spacing)/2 |
\\param radius : XY coordinates will satisfy sqrt(x*x + y*y) <= radius - (spacing/2)
\\param spacing : No two grid points will be less than spacing apart and closer than spacing/2 to cylinder bounds."
      end

      operation 263984 "tubular_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 3
	  param in name "tubelength" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "npart" explicit_type "size_t"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Initialise the tubular grid with the given length and radius. Vary grid spacing until
 we have approximately npart grid points.

 This leaves a minimum of 'spacing' distance between any grid
 point and the cylinder edge. Point closest to origin
 will be (0,0,+/-spacing/2) or no points.

\\param tubelength : Z coordinates will be within | -(tubelength-spacing)/2 <= z <= (tubelength-spacing)/2 |
\\param radius : XY coordinates will satisfy sqrt(x*x + y*y) <= radius - (spacing/2)
\\param npart : Target number of grid points."
      end

      operation 265136 "tubular_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 3
	  param in name "tubelength" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "npart" explicit_type "int"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw}
: tubular_grid( ${p0}, ${p1}, std::size_t( ${p2} ) )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Initialise the tubular grid with the given length and radius. Vary grid spacing until
 we have approximately npart grid points.

 This leaves a minimum of 'spacing' distance between any grid
 point and the cylinder edge. Point closest to origin
 will be (0,0,+/-spacing/2) or no points.

\\param tubelength : Z coordinates will be within | -(tubelength-spacing)/2 <= z <= (tubelength-spacing)/2 |
\\param radius : XY coordinates will satisfy sqrt(x*x + y*y) <= radius - (spacing/2)
\\param npart : Target number of grid points."
      end

      operation 263216 "tubular_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 4
	  param in name "tubelength" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "spacing" explicit_type "double"
	  param inout name "shuffler" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} & ${p3}${v3}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} & ${p3}${)}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Initialise the tubular grid with the given length and radius.

 This leaves a minimum of 'spacing' distance between any grid
 point and the cylinder edge. Point closest to origin
 will be (0,0,+/-spacing/2) or no points.

\\param tubelength : Z coordinates will be within | -(tubelength-spacing)/2 <= z <= (tubelength-spacing)/2 |
\\param radius : XY coordinates will satisfy sqrt(x*x + y*y) <= radius - (spacing/2)
\\param spacing : No two grid points will be less than spacing apart and closer than spacing/2 to cylinder bounds.
\\param shuffler : object to randomly reorder the access sequence."
      end

      operation 265264 "tubular_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 4
	  param in name "tubelength" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "npart" explicit_type "int"
	  param inout name "ranf" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} & ${p3}${v3}${)}${volatile}${throw}
: tubular_grid( ${p0}, ${p1}, std::size_t( ${p2} ), ${p3} )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Initialise the tubular grid with the given length and radius. Vary grid spacing until
 we have approximately npart grid points.

 This leaves a minimum of 'spacing' distance between any grid
 point and the cylinder edge. Point closest to origin
 will be (0,0,+/-spacing/2) or no points.

\\param tubelength : Z coordinates will be within | -(tubelength-spacing)/2 <= z <= (tubelength-spacing)/2 |
\\param radius : XY coordinates will satisfy sqrt(x*x + y*y) <= radius - (spacing/2)
\\param npart : Target number of grid points."
      end

      operation 264624 "tubular_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 4
	  param in name "tubelength" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "npart" explicit_type "size_t"
	  param inout name "shuffler" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} & ${p3}${v3}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} & ${p3}${)}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Initialise the tubular grid with the given length and radius. Vary grid spacing until
 we have approximately npart grid points.

 This leaves a minimum of 'spacing' distance between any grid
 point and the cylinder edge. Point closest to origin
 will be (0,0,+/-spacing/2) or no points.

\\param tubelength : Z coordinates will be within | -(tubelength-spacing)/2 <= z <= (tubelength-spacing)/2 |
\\param radius : XY coordinates will satisfy sqrt(x*x + y*y) <= radius - (spacing/2)
\\param npart : Target number of grid points.
\\param shuffler : object to randomly reorder the access sequence."
      end

      operation 2035759 "tubular_grid"
	preserve_cpp_body_indent protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Default ctor (for serialize only)"
      end

      operation 598576 "~tubular_grid"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 425647 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      classrelation 1169199 // <dependency>
	relation 1132079 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 1169199 // <dependency>
	  b parent class_ref 912431 // access
      end

      operation 1872687 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
    ar & boost::serialization::base_object< geometry::grid_generator >(*this);
    ar & spacing_;
    ar & zmax_;
    ar & circle_;
    ar & selector_;
  };
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end

      operation 699825 "empty"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} override
{
  return this->selector_.empty();
}
"
	
	
	
	
	comment " The number of remaining points in the grid."
      end

      operation 1531439 "next"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 1
	  param inout name "pnt" type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Get the next location from the grid.

 @require size > 0"
      end

      operation 1988399 "next"
	preserve_cpp_body_indent public return_type class_ref 986799 // coordinate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  ${type} Result;
  this->next (Result);
  return Result;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Get the next location from the grid.

 @require size > 0"
      end

      operation 1531567 "size"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
    return this->selector_.size();
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " The number of remaining points in the grid."
      end

      operation 264368 "spacing"
	const cpp_virtual public explicit_return_type "double"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw} override
{
  return this->spacing_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment "  The inter-gridpoint distance."
      end
    end

    class 190768 "circle_grid"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " 2D grid in circle"
      attribute 229296 "spacing_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " inter-grid spacing"
      end

      attribute 229168 "width_"
	private explicit_type "std::size_t"
	multiplicity "*"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${stereotype}()
"
	idl_decl ""
	comment " The number of x grid elements at a particular y"
      end

      attribute 229040 "xy_size_"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The number of elements in an xy slice"
      end

      operation 262832 "circle_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 2
	  param in name "radius" explicit_type "double"
	  param in name "spacing" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Initialise the tubular grid with the given length and radius.

 This leaves a minimum of 'spacing' distance between any grid
 point and the cylinder edge. Will have a grid point at origin (0,0,0)
 or no points.

\\param tubelength : Z coordinates will be within | -(tubelength-spacing)/2 <= z <= (tubelength-spacing)/2 |
\\param radius : XY coordinates will satisfy sqrt(x*x + y*y) <= radius - (spacing/2)
\\param spacing : No two grid points will be less than spacing apart and closer than spacing/2 to cylinder bounds.
\\param shuffle : whether to provide grid points in linear (false)
   or random (true) order"
      end

      operation 262704 "circle_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw}
: spacing_(0.0)
, width_()
, xy_size_(0)
{}"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Default ctor (for serialize only)"
      end

      operation 263472 "circle_grid"
	stereotype "copy"
	public explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 190768 // circle_grid
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw}
: spacing_( ${p0}.spacing_ )
, width_( ${p0}.width_ )
, xy_size_( ${p0}.xy_size_ )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 263856 "circle_grid"
	stereotype "move"
	public explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 190768 // circle_grid
	cpp_decl "    ${comment}${inline}${name}${(}${t0} && ${p0}${)}${volatile}${throw}
: spacing_( std::move( ${p0}.spacing_ ) )
, width_( std::move( ${p0}.width_ ) )
, xy_size_( std::move( ${p0}.xy_size_ ) )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 263600 "operator="
	public return_type class_ref 190768 // circle_grid
	nparams 1
	  param in name "source" type class_ref 190768 // circle_grid
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${abstract}
{
  this->swap( ${p0} );
  return *this;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 263344 "~circle_grid"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 263728 "swap"
	public explicit_return_type "void"
	nparams 1
	  param inout name "source" type class_ref 190768 // circle_grid
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract}
{
  std::swap( spacing_, ${p0}.spacing_ );
  std::swap( width_, ${p0}.width_ );
  std::swap( xy_size_, ${p0}.xy_size_ );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 263088 "size"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract}
{
  return this->xy_size_;
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The number of grid points in the circle"
      end

      operation 262960 "set_xy"
	preserve_cpp_body_indent const public explicit_return_type "void"
	nparams 2
	  param inout name "pnt" type class_ref 986799 // coordinate
	  param in name "index" explicit_type "size_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Set the  pnt.x and pnt.y based on the given index 
 into the circle grid

 @require index < size"
      end

      extra_member 177712 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      classrelation 197040 // <dependency>
	relation 196784 -_->
	  a package
	    cpp default "#include in header"
	    python "${type}"
	    classrelation_ref 197040 // <dependency>
	  b parent class_ref 912431 // access
      end

      operation 262576 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
    ar & spacing_;
    ar & width_;
    ar & xy_size_;
  };
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end
    end

    class 177328 "split_tube_grid"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment "  Adapt the standard tubular grid by splitting the tube into two
  equal parts and inserting a non-grid space in between. This
  inserts the zoffset space into the z coordinate output by the
  gridder.

"
      classrelation 197296 // <generalisation>
	relation 197040 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 197296 // <generalisation>
	  b parent class_ref 868783 // tubular_grid
      end

      attribute 206512 "zoffset_"
	private explicit_type "double"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The membrane half width."
      end

      operation 244912 "split_tube_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 5
	  param in name "offset" explicit_type "double"
	  param in name "length" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "npart" explicit_type "size_t"
	  param inout name "ranf" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} & ${p4}${v4}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} & ${p4}${)}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create a cubic grid of points within a bisected tube of the given 
 half length, bisection offset and radius. NOTE: the outer extent
 of the tube is offset + length/2 in -ve and +ve z direction.

 NOTES:

 * Grid z coordinate will be either +ve or -ve

 * Z coordinate range offset < |z| < length/2 + offset

 * XY coordinates in circle of given radius

 * Sequence of coordinates generated by next are in random
 a order.

"
      end

      operation 265008 "split_tube_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 4
	  param in name "offset" explicit_type "double"
	  param in name "length" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "npart" explicit_type "size_t"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}${)}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create a cubic grid of points within a bisected tube of the given 
 half length, bisection offset and radius.  NOTE: the outer extent
 of the tube is -/+(offset + length/2) in z direction.

 NOTES:

 * Grid z coordinate will be either +ve or -ve

 * Z coordinate range offset < |z| < length/2 + offset

 * XY coordinates in circle of given radius

 * Sequence of coordinates generated by next are sequential
 in z.

"
      end

      operation 1015856 "split_tube_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 5
	  param in name "offset" explicit_type "double"
	  param in name "length" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "npart" explicit_type "int"
	  param inout name "ranf" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} & ${p4}${v4}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} & ${p4}${)}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create a cubic grid of points within a bisected tube of the given 
 half length, bisection offset and radius. NOTE: the outer extent
 of the tube is +/-(offset + length/2) in z direction.

 NOTES:

 * Grid z coordinate will be either +ve or -ve

 * Z coordinate range offset < |z| < length/2 + offset

 * XY coordinates in circle of given radius

 * Sequence of coordinates generated by next are in random
 a order.

"
      end

      operation 1015984 "split_tube_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 4
	  param in name "offset" explicit_type "double"
	  param in name "length" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "npart" explicit_type "int"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}${)}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create a cubic grid of points within a bisected tube of the given 
 half length, bisection offset and radius.  NOTE: the outer extent
 of the tube is +/-(offset + length/2) in z direction.

 NOTES:

 * Grid z coordinate will be either +ve or -ve

 * Z coordinate range offset < |z| < length/2 + offset

 * XY coordinates in circle of given radius

 * Sequence of coordinates generated by next are sequential
 in z.

"
      end

      operation 1015600 "split_tube_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 5
	  param in name "offset" explicit_type "double"
	  param in name "length" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "spacing" explicit_type "double"
	  param inout name "ranf" type class_ref 463407 // random_distribution
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}, ${t4} & ${p4}${v4}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} & ${p4}${)}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create a cubic grid of points within a bisected tube of the given 
 half length, bisection offset and radius. NOTE: the outer extent
 of the tube is +/-(offset + length/2) in z direction.

 NOTES:

 * Grid z coordinate will be either +ve or -ve

 * Z coordinate range offset < |z| < length/2 + offset

 * XY coordinates in circle of given radius

 * Sequence of coordinates generated by next are in random
 a order.

"
      end

      operation 1015728 "split_tube_grid"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 4
	  param in name "offset" explicit_type "double"
	  param in name "length" explicit_type "double"
	  param in name "radius" explicit_type "double"
	  param in name "spacing" explicit_type "double"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}, ${t3} ${p3}${v3}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}${)}${throw}
${body}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Create a cubic grid of points within a bisected tube of the given 
 half length, bisection offset and radius.  NOTE: the outer extent
 of the tube is +/-(offset + length/2) in z direction.

 NOTES:

 * Grid z coordinate will be either +ve or -ve

 * Z coordinate range offset < |z| < length/2 + offset

 * XY coordinates in circle of given radius

 * Sequence of coordinates generated by next are sequential
 in z.

"
      end

      operation 244784 "split_tube_grid"
	preserve_cpp_body_indent private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Default ctor (for serialize)"
      end

      operation 264880 "~split_tube_grid"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 244528 "next"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 1
	  param inout name "pnt" type class_ref 986799 // coordinate
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}
{
  const bool result{ this->tubular_grid::${name}( pnt ) };
  if (result) pnt.z += (pnt.z < 0.0 ? -this->zoffset_ : this->zoffset_);
  return result; 
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment " Get the next location from the grid.

 @require size > 0"
      end

      extra_member 164272 "friend"
	
	cpp "
  friend class boost::serialization::access;" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 244144 "serialize"
	stereotype "template"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "ar" explicit_type "Archive"
	  param in name "version" explicit_type "unsigned int"
	cpp_decl "    ${comment}template<class Archive>
  ${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
   ar & boost::serialization::base_object< geometry::tubular_grid >(*this);
    ar & zoffset_;
  }
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
      end
    end
  end

  classview 187440 "geometry meta classes"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    associated_deployment_view deploymentview_ref 156592 // geometry source
    classdiagram 285616 "geometry from input"
      draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      size A4
    end

    sequencediagram 285744 "read input"
      show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
      overlapping_bars size A4
    end

    class 479792 "region_definition"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      comment " Information about a region class's input data."
      classrelation 747952 // <generalisation>
	relation 747056 ---|>
	  a private
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 747952 // <generalisation>
	  b parent class_ref 539568 // input_definition
      end

      class 479920 "generator_fn"
	visibility package stereotype "typedef" base_type class_ref 452912 // base_region
	cpp_decl "${comment}typedef boost::shared_ptr< ${type} > (*${name})(std::string label, std::map< std::string, std::string > const& params);
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl "${comment}typedef ${type} ${name};
"
	explicit_switch_type ""
	
	comment " Function signature for creating new region."
      end

      attribute 523056 "factory_"
	private type class_ref 479920 // generator_fn
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " Creator of region objects."
      end

      extra_member 509616 "LIFETIME"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1294128 "region_definition"
	const public explicit_return_type ""
	nparams 3
	  param in name "label" explicit_type "string"
	  param in name "desc" explicit_type "string"
	  param in name "fn" type class_ref 479920 // generator_fn
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw}
: input_definition( ${p0}, ${p1} )
, factory_( ${p2} )
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Main Ctor

 \\param label : name of the region subtype.
 \\param desc : description of the region subtype.
 \\param fn : constructor for region subtype."
      end

      operation 1293488 "region_definition"
	const private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1293616 "~region_definition"
	cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1293744 "region_definition"
	stereotype "move"
	private explicit_return_type ""
	nparams 1
	  param inout name "source" type class_ref 479792 // region_definition
	cpp_decl "    ${comment}${inline}${name}${(}${t0} && ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1293872 "region_definition"
	stereotype "copy"
	private explicit_return_type ""
	nparams 1
	  param in name "source" type class_ref 479792 // region_definition
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1294000 "operator="
	private return_type class_ref 479792 // region_definition
	nparams 1
	  param in name "source" type class_ref 479792 // region_definition
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${abstract} = delete;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      extra_member 509744 "METHODS"
	
	cpp "" ""
	java ""
	php ""
	python ""
	idl ""
      end

      operation 1294256 "operator()"
	const public return_type class_ref 452912 // base_region
	nparams 2
	  param in name "label" explicit_type "string"
	  param in name "params" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}boost::shared_ptr< ${type} > ${name}${(}${t0} ${p0}${v0}, const std::map< ${t1}, ${t1} > & ${p1}${v1}${)}${const}${volatile}${throw}${abstract}
{
  return (*(this->factory_))( ${p0}, ${p1} );
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Generate a base_region from the given label 
 and parameters."
      end

      extra_member 509872 "access base class methods"
	
	stereotype "using"
	cpp "using input_definition::add_definition;
using input_definition::empty;
using input_definition::has_definition;
using input_definition::label;
using input_definition::publish_help;
using input_definition::size;
" ""
	java ""
	php ""
	python ""
	idl ""
      end
    end

    class 479664 "region_meta"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit}
 {
${members}
};
${inlines}
"
      java_decl ""
      php_decl ""
      python_decl "class ${name}${inherit}:
${docstring}${members}
"
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 638256 // <generalisation>
	relation 637360 ---|>
	  a public
	    cpp default "${type}"
	    python "${type}"
	    classrelation_ref 638256 // <generalisation>
	  b parent class_ref 1082671 // input_base_meta
      end

      classrelation 638384 // manager_ (<directional composition>)
	relation 637488 *-->
	  stereotype "shared_ptr"
	  a role_name "manager_" multiplicity "0..1" private
	    comment " Where we put newly defined regions"
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}< ${type} > ${name}${value};
"
	    python "${comment}${self}${name} = ${stereotype}()
"
	    classrelation_ref 638384 // manager_ (<directional composition>)
	  b parent class_ref 452656 // geometry_manager
      end

      classrelation 638640 // type_to_object_ (<directional composition>)
	relation 637744 *-->
	  stereotype "ptr_vector"
	  a role_name "type_to_object_" multiplicity "*" private
	    comment " Build type from object."
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}< ${type} > ${name}${value};
"
	    python "${comment}${self}${name} = ${stereotype}()
"
	    classrelation_ref 638640 // type_to_object_ (<directional composition>)
	  b parent class_ref 479792 // region_definition
      end

      attribute 522416 "label_"
	private explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The region's label. This must be unique within a simulation."
      end

      attribute 522544 "type_name_"
	private explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${value}
"
	idl_decl ""
	comment " The label identifying the region's class."
      end

      attribute 522800 "parameter_set_"
	private explicit_type "string"
	multiplicity "*"
	stereotype "map"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}, ${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl "${comment}${self}${name} = ${stereotype}()
"
	idl_decl ""
	comment " Set of parameters for this region type. This should be 
 defined by the individual regions."
      end

      operation 1061680 "region_meta"
	private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw} = default;
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Inaccessible default ctor."
      end

      operation 1061296 "region_meta"
	public explicit_return_type ""
	nparams 1
	  param in name "man" type class_ref 452656 // geometry_manager
	cpp_decl "    ${comment}${inline}${name}${(}boost::shared_ptr< ${t0} > ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}boost::shared_ptr< ${t0} > ${p0}${)}${throw}
: input_base_meta( core::strngs::fsregn(), true, false ) // multiple + not required
, manager_( ${p0} )
, type_to_object_()
, label_()
, type_name_()
, parameter_set_()
{}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Main ctor."
      end

      operation 1061424 "~region_meta"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1062448 "add_definition"
	public explicit_return_type "void"
	nparams 1
	  param inout name "defn" type class_ref 479792 // region_definition
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}std::unique_ptr< ${t0} > & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}std::unique_ptr< ${t0} > & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Add a new region type definition.

 \\pre not has_definition(defn.type_name_)"
      end

      operation 1370544 "empty"
	const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return this->type_to_object_.${name}(); }

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Ary there no evaluator definitions?"
      end

      operation 1061552 "publish_help"
	const cpp_virtual public explicit_return_type "void"
	nparams 1
	  param inout name "helper" type class_ref 1004335 // input_help
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
      end

      operation 1062576 "has_definition"
	public explicit_return_type "bool"
	nparams 1
	  param in name "type_name" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Do we have a region with this typename?"
      end

      operation 1062064 "do_read_entry"
	cpp_virtual private explicit_return_type "bool"
	nparams 1
	  param inout name "reader" type class_ref 313392 // input_base_reader
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}self${)}:
${docstring}${body}
"
	
	comment "Read a name/value entry in the input file. Return true if the entry was processed.

throw an error if input file is incorrect (using UTILITY_INPUT macro)"
      end

      operation 1061936 "do_read_end"
	cpp_virtual private explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Perform checks at the end of reading a section and create/add result to
 simulations. If multiple sections may be read, this method must also
 reset the meta object state."
      end

      operation 1061808 "do_reset"
	cpp_virtual private explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} override;
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}
{
  ${body}
}
"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " Reset the object state on entry into read_seaction. This
 provides a stronger exception safety if the delegate is
 reused after raising an exception in read_section."
      end

      operation 1370416 "size"
	const public explicit_return_type "size_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return this->type_to_object_.${name}(); }

"
	
	
	python_def "${@}${static}${abstract}def ${name}${(}${p0}${v0}${)}:
${docstring}${body}
"
	
	comment " The number of evaluator definitions"
      end
    end
  end

  deploymentview 156592 "geometry source"
    //deployment diagram settings
    package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
    draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
    artifact 450352 "base_region"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
class geometry_manager;

${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual include
// for pi()
#include \"core/constants.hpp\"
#include \"core/strngs.hpp\"
//-
${namespace_start}
${members}
${namespace_end}

//#include <boost/serialization/export.hpp>
//BOOST_CLASS_EXPORT_GUID(geometry::base_region, \"geometry::base_region\");"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 452912 // base_region
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 477872 "cube_region"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( geometry::cube_region );

#endif"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
#include \"core/input_base_reader.hpp\"
#include \"core/strngs.hpp\"
// -
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( geometry::cube_region );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 473136 // cube_region
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 450864 "cubic_grid"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY(geometry::cubic_grid);
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT(geometry::cubic_grid);"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 868655 // cubic_grid
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 169008 "cylinder_region"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( geometry::cylinder_region );

#endif"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// Manual includes
#include \"core/constants.hpp\"
#include \"core/input_base_reader.hpp\"
#include \"core/strngs.hpp\"
#include \"geometry/tubular_grid.hpp\"
// -
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( geometry::cylinder_region );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 183856 // cylinder_region
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 471344 "distance_calculator"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
// manual decl
#include \"utility/utility.hpp\"
//-
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
${namespace_start}
${members}
${namespace_end}"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 466608 // distance_calculator
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 450224 "geometry_manager"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual
#include \"geometry/cube_region.hpp\"
#include \"geometry/cylinder_region.hpp\"
#include \"geometry/open_cylinder_region.hpp\"
#include \"geometry/open_split_cylinder_region.hpp\"
#include \"geometry/periodic_cube_region.hpp\"
#include \"geometry/region_meta.hpp\"
// -
${namespace_start}
${members}
${namespace_end}"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 452656 // geometry_manager
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 578479 "grid"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
// manual
#include \"utility/random.hpp\"
// -
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
${namespace_start}
${members}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_GUID(geometry::grid_generator, \"geometry::grid_generator\");"
      associated_classes
	class_ref 289841 // grid_generator
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 497584 "membrane_cylinder_region"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( geometry::membrane_cylinder_region );

#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// - manual includes
#include \"core/constants.hpp\"
#include \"core/input_base_reader.hpp\"
#include \"core/strngs.hpp\"
#include \"utility/fuzzy_equals.hpp\"
// -
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( geometry::membrane_cylinder_region );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 486448 // membrane_cylinder_region
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 458288 "non_periodic_region"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( geometry::non_periodic_region );

#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( geometry::non_periodic_region );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 459952 // non_periodic_region
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 450608 "open_cylinder_region"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( geometry::open_cylinder_region );

#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// Manual includes
#include \"core/constants.hpp\"
#include \"core/input_base_reader.hpp\"
#include \"core/strngs.hpp\"
// =
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( geometry::open_cylinder_region );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 453424 // open_cylinder_region
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 464816 "open_split_cylinder_region"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( geometry::open_split_cylinder_region );

#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// Manual includes
#include \"core/constants.hpp\"
#include \"core/input_base_reader.hpp\"
#include \"core/strngs.hpp\"
// =
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( geometry::open_split_cylinder_region );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 460080 // open_split_cylinder_region
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 450736 "periodic_cube_region"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY( geometry::periodic_cube_region );

#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual includes
//#include \"core/input_base_reader.hpp\"
#include \"core/strngs.hpp\"
// -
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT( geometry::periodic_cube_region );"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 453296 // periodic_cube_region
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 484400 "region_meta"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// Manual includes
#include \"core/input_error_messages.hpp\"
#include \"core/strngs.hpp\"
// -
${namespace_start}
${members}
${namespace_end}
"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 479792 // region_definition
	class_ref 479664 // region_meta
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 450992 "tubular_grid"
      stereotype "source"
      cpp_h "#ifndef @{PROJECT}${NAMESPACE}_${NAME}_HPP
#define @{PROJECT}${NAMESPACE}_${NAME}_HPP

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif

#include <boost/serialization/export.hpp>
BOOST_CLASS_EXPORT_KEY(geometry::tubular_grid);
BOOST_CLASS_EXPORT_KEY(geometry::split_tube_grid);"
      cpp_src "${comment}

#ifndef DEBUG
#define DEBUG 0
#endif

${includes}
// manual include
// for pi()
#include \"core/constants.hpp\"
//-
${namespace_start}
${members}
${namespace_end}

BOOST_CLASS_EXPORT_IMPLEMENT(geometry::tubular_grid);
BOOST_CLASS_EXPORT_IMPLEMENT(geometry::split_tube_grid);"
      python_src "${comment}
${import}
${definition}"
      associated_classes
	class_ref 190768 // circle_grid
	class_ref 868783 // tubular_grid
	class_ref 177328 // split_tube_grid
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end

    artifact 449840 "libionch_geometry"
      stereotype "library"
      associated_artifacts
	artifact_ref 169008 // cylinder_region
	artifact_ref 450224 // geometry_manager
	artifact_ref 450352 // base_region
	artifact_ref 450608 // open_cylinder_region
	artifact_ref 450736 // periodic_cube_region
	artifact_ref 450864 // cubic_grid
	artifact_ref 450992 // tubular_grid
	artifact_ref 458288 // non_periodic_region
	artifact_ref 464816 // open_split_cylinder_region
	artifact_ref 471344 // distance_calculator
	artifact_ref 477872 // cube_region
	artifact_ref 484400 // region_meta
	artifact_ref 497584 // membrane_cylinder_region
	artifact_ref 578479 // grid
      end
      comment "----------------------------------------------------------------------
This source file is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------
"
    end
  end

  package_ref 156592 // geometry tests
end
