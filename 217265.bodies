class core_test_suite
!!!555312.cpp!!!	test_read_input_buffer() : void
const std::string dummy_input( "\n\n# A comment\nsection # Another comment\nname1 = value1\n1 2.3 4 not a num # 6.2\nname1 value1" );
const std::string dummy_filename( "dummy" );
const boost::filesystem::path dummy_path( boost::filesystem::absolute( "dummy" ) );
const std::string dummy_path_str( dummy_path.string() );

{
  Reader rdr;
  // TEST reader next part 1
  rdr.add_buffer( dummy_filename, dummy_input );
  BOOST_CHECK( rdr.next() );
  BOOST_CHECK_EQUAL( "section # Another comment", rdr.line() );
  BOOST_CHECK_EQUAL( "section", rdr.name() );
  BOOST_CHECK_EQUAL( "", rdr.value() );
  BOOST_CHECK_EQUAL( 4, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_path_str, rdr.current_filename() );
  BOOST_CHECK_NE( dummy_filename, rdr.current_filename() );

  // TEST reader next part 2
  BOOST_CHECK( rdr.next() );
  BOOST_CHECK_EQUAL( "name1 = value1", rdr.line() );
  BOOST_CHECK_EQUAL( "name1", rdr.name() );
  BOOST_CHECK_EQUAL( "value1", rdr.value() );
  BOOST_CHECK_EQUAL( 5, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_path_str, rdr.current_filename() );
  BOOST_CHECK_NE( dummy_filename, rdr.current_filename() );
  // TEST reader next part 3
  BOOST_CHECK( rdr.next() );
  BOOST_CHECK_EQUAL( "1 2.3 4 not a num # 6.2", rdr.line() );
  BOOST_CHECK_EQUAL( "1", rdr.name() );
  BOOST_CHECK_EQUAL( "2.3 4 not a num", rdr.value() );
  BOOST_CHECK_EQUAL( 6, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_path_str, rdr.current_filename() );
  BOOST_CHECK_NE( dummy_filename, rdr.current_filename() );
  // TEST reader next part 4
  BOOST_CHECK( rdr.next() );
  BOOST_CHECK_EQUAL( "name1 value1", rdr.line() );
  BOOST_CHECK_EQUAL( "name1", rdr.name() );
  BOOST_CHECK_EQUAL( "value1", rdr.value() );
  BOOST_CHECK_EQUAL( 7, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_path_str, rdr.current_filename() );
  BOOST_CHECK_NE( dummy_filename, rdr.current_filename() );
  // TEST reader next part 5
  BOOST_CHECK( not rdr.next() );
  BOOST_CHECK_EQUAL( "", rdr.line() );
  BOOST_CHECK_EQUAL( "", rdr.name() );
  BOOST_CHECK_EQUAL( "", rdr.value() );
  // zero line number and "" indicate no file.
  BOOST_CHECK_EQUAL( 0, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( "", rdr.current_filename() );
  // Check stability of calling next after last element.
  BOOST_CHECK( not rdr.next() );
  BOOST_CHECK_EQUAL( "", rdr.line() );
  BOOST_CHECK_EQUAL( "", rdr.name() );
  BOOST_CHECK_EQUAL( "", rdr.value() );
  // zero line number and "" indicate no file.
  BOOST_CHECK_EQUAL( 0, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( "", rdr.current_filename() );
}
!!!898992.cpp!!!	test_input_base_meta() : void
//// CTOR TESTS
{
  // Static Lifetime method tests
  BOOST_CHECK( not typename std::is_default_constructible< Meta >::type{} );
  BOOST_CHECK( not typename std::is_copy_constructible< Meta >::type{} );
  BOOST_CHECK( not typename std::is_move_constructible< Meta >::type{} );
  BOOST_CHECK( not (typename std::is_assignable< Meta, Meta >::type{}) );
  BOOST_CHECK( typename std::has_virtual_destructor< Meta >::type{} );
}
// ----------
const std::string label( "name" );
{
  std::unique_ptr< core::input_base_meta > dobj( new Meta( label, false, false ) );
  BOOST_CHECK_EQUAL( dobj->section_label(), label );
  BOOST_CHECK_EQUAL( dobj->multiple(), false );
  BOOST_CHECK_EQUAL( dobj->required(), false );
}
{
  std::unique_ptr< core::input_base_meta > dobj( new Meta( label, true, false ) );
  BOOST_CHECK_EQUAL( dobj->section_label(), label );
  BOOST_CHECK_EQUAL( dobj->multiple(), true );
  BOOST_CHECK_EQUAL( dobj->required(), false );
}
{
  std::unique_ptr< core::input_base_meta > dobj( new Meta( label, false, true ) );
  BOOST_CHECK_EQUAL( dobj->section_label(), label );
  BOOST_CHECK_EQUAL( dobj->multiple(), false );
  BOOST_CHECK_EQUAL( dobj->required(), true );
}
{
  std::unique_ptr< core::input_base_meta > dobj( new Meta( label, true, true ) );
  BOOST_CHECK_EQUAL( dobj->section_label(), label );
  BOOST_CHECK_EQUAL( dobj->multiple(), true );
  BOOST_CHECK_EQUAL( dobj->required(), true );
}


!!!406193.cpp!!!	input_help_test() : void
{
  // Static Lifetime method tests

  BOOST_CHECK( std::is_default_constructible< core::input_help >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< core::input_help >::type{} );
  BOOST_CHECK( not std::is_move_constructible< core::input_help >::type{} );
  BOOST_CHECK( ( not std::is_assignable< core::input_help, core::input_help >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< core::input_help >::type{} );
}

std::string section1( core::strngs::fsspec() );
std::string section2( core::strngs::fssalt() );
std::string sectdesc1( "Specie definition input section variables and expected values." );
std::string sectdesc2( "Salt definition input section variables and expected values." );
core::help_entry entry1( core::strngs::fsname(), "two letters", "", "required", "Specie code name (quotes optional)." );
core::help_entry entry2( core::strngs::fsrtgr(), "number", "[0,1)", "required", "\""+core::strngs::fsfree()+"\" type only, Relative probability this specie is used in an individual ion grand-canonical trial compared to other species." );
core::help_entry entry3( core::strngs::fsname(), "four letters", "", "required", "Salt code name (quotes optional), letters should be code of the two species that make up the salt (e.g. NaCl, CaCl)." );

{
  // test adding a section
  core::input_help tmp;

  BOOST_CHECK( tmp.empty() );
  BOOST_CHECK_EQUAL( tmp.size(), 0ul );
  BOOST_CHECK( not tmp.has_section( section1 ) );

  tmp.add_section( { section1, sectdesc1 } );

  BOOST_CHECK( not tmp.empty() );
  BOOST_CHECK_EQUAL( tmp.size(), 1ul );
  BOOST_CHECK( tmp.has_section( section1 ) );

  // test adding an option after adding section
  tmp.get_section( section1 ).add_entry( entry1 );

  {
  // test adding a section (with description) after section has been added.
  // This should simply add the description to the existing option.
  try
  {
    tmp.add_section( { section1, sectdesc2 } );
    BOOST_ERROR( "expected \"tmp.add_section\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Can not add two sections with the same name: specie" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"tmp.add_section\" was not expected type: " ) + err.what() );
  }
  }
}
{
  // test adding two sections
  core::input_help tmp;

  BOOST_CHECK( tmp.empty() );
  BOOST_CHECK_EQUAL( tmp.size(), 0ul );
  BOOST_CHECK( not tmp.has_section( section1 ) );

  tmp.add_section( { section1, sectdesc1 } );

  BOOST_CHECK( not tmp.empty() );
  BOOST_CHECK_EQUAL( tmp.size(), 1ul );
  BOOST_CHECK( tmp.has_section( section1 ) );

  // test adding an option
  tmp.get_section( section1 ).add_entry( entry1 );
  tmp.get_section( section1 ).add_entry( entry2 );

  BOOST_CHECK( not tmp.has_section( section2 ) );
  tmp.add_section( { section2, sectdesc2 } );

  BOOST_CHECK_EQUAL( tmp.size(), 2ul );
  BOOST_CHECK( tmp.has_section( section1 ) );
  BOOST_CHECK( tmp.has_section( section2 ) );

  // test adding an option (note entry2 already on section1 )
  tmp.get_section( section2 ).add_entry( entry2 );
  tmp.get_section( section2 ).add_entry( entry3 );

  {
    // test of printing a section
    std::stringstream os;
    tmp.write( section1, os );
    const std::string output( os.str() );
    boost::tokenizer<> tok( output );
    boost::tokenizer<> toksearch1( sectdesc1 );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch1.begin(), toksearch1.end() ) );
    // Check description of section 2 is not present
    boost::tokenizer<> toksearch2( sectdesc2 );
    BOOST_CHECK( tok.end() == std::search( tok.begin(), tok.end(), toksearch2.begin(), toksearch2.end() ) );
    boost::tokenizer<> toksearch3( entry1.description() );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch3.begin(), toksearch3.end() ) );
    boost::tokenizer<> toksearch4( entry3.description() );
    BOOST_CHECK( tok.end() == std::search( tok.begin(), tok.end(), toksearch4.begin(), toksearch4.end() ) );
  }
  {
    // test printing everything
    std::stringstream os;
    tmp.write( os );
    const std::string output( os.str() );
    boost::tokenizer<> tok( output );
    boost::tokenizer<> toksearch1( sectdesc1 );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch1.begin(), toksearch1.end() ) );
    // Check description of section 2 is present
    boost::tokenizer<> toksearch2( sectdesc2 );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch2.begin(), toksearch2.end() ) );
    boost::tokenizer<> toksearch3( entry2.description() );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch3.begin(), toksearch3.end() ) );
    boost::tokenizer<> toksearch4( entry3.description() );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch4.begin(), toksearch4.end() ) );
  }
}


!!!405297.cpp!!!	dictionary_test() : void
// A
BOOST_CHECK_EQUAL( core::strngs::fsaccu(), "accum" );
BOOST_CHECK_EQUAL( core::strngs::fsadd(),  "add" );
// B
BOOST_CHECK_EQUAL( core::strngs::bulk_label(), "bulk" );
// C
BOOST_CHECK_EQUAL( core::strngs::fscgin(), "calgin" );
BOOST_CHECK_EQUAL( core::strngs::fschex(), "chex" );
BOOST_CHECK_EQUAL( core::strngs::fschnl(), "channel" );
BOOST_CHECK_EQUAL( core::strngs::fschon(), "chonly" );
BOOST_CHECK_EQUAL( core::strngs::fschpt(), "usepot" );
BOOST_CHECK_EQUAL( core::strngs::fsclac(), "calacc" );
BOOST_CHECK_EQUAL( core::strngs::fsclmb(), "calmob" );
BOOST_CHECK_EQUAL( core::strngs::fsconf(), "conf" );
BOOST_CHECK_EQUAL( core::strngs::fscrdf(), "calrdf" );
BOOST_CHECK_EQUAL( core::strngs::fsctrg(), "ctarg" );
BOOST_CHECK_EQUAL( core::strngs::comment_begin(), "#" );
BOOST_CHECK_EQUAL( core::strngs::comment_end(), "" );
// D
BOOST_CHECK_EQUAL( core::strngs::fsd(),    "d" );
BOOST_CHECK_EQUAL( core::strngs::fsdrg(),  "drg" );
BOOST_CHECK_EQUAL( core::strngs::fsdrmi(), "drmaxin" );
BOOST_CHECK_EQUAL( core::strngs::fsdrmo(), "drmaxout" );
BOOST_CHECK_EQUAL( core::strngs::fsdxf(),  "dxf" );
BOOST_CHECK_EQUAL( core::strngs::fsdxw(),  "dxw" );
BOOST_CHECK_EQUAL( core::strngs::fsdzg(),  "dzg" );
// E
BOOST_CHECK_EQUAL( core::strngs::fsend(),  "end" );
BOOST_CHECK_EQUAL( core::strngs::fsenth(), "enthalpy" );
BOOST_CHECK_EQUAL( core::strngs::fsentr(), "entropy" );
BOOST_CHECK_EQUAL( core::strngs::fsepsc(), "epsch" );
BOOST_CHECK_EQUAL( core::strngs::fsepsp(), "epspr" );
BOOST_CHECK_EQUAL( core::strngs::fsepsw(), "epsw" );
BOOST_CHECK_EQUAL( core::strngs::fsexct(), "excited" );
BOOST_CHECK_EQUAL( core::strngs::evaluator_label(), "evaluator" );
// F
BOOST_CHECK_EQUAL( core::strngs::fsflxd(), "flex" );
BOOST_CHECK_EQUAL( core::strngs::fsfree(), "free" );
BOOST_CHECK_EQUAL( core::strngs::fsfver(), "fileversion" );
// G
BOOST_CHECK_EQUAL( core::strngs::fsgeom(), "geom" );
BOOST_CHECK_EQUAL( core::strngs::fsgrid(), "usegrid" );
BOOST_CHECK_EQUAL( core::strngs::fsgrl1(), "rl1" );
BOOST_CHECK_EQUAL( core::strngs::fsgrl4(), "rl4" );
BOOST_CHECK_EQUAL( core::strngs::fsgrl5(), "rl5" );
BOOST_CHECK_EQUAL( core::strngs::fsgrlc(), "rlcurv" );
BOOST_CHECK_EQUAL( core::strngs::fsgrlv(), "rlvest" );
BOOST_CHECK_EQUAL( core::strngs::fsgrnd(), "ground" );
BOOST_CHECK_EQUAL( core::strngs::fsgzl1(), "zl1" );
BOOST_CHECK_EQUAL( core::strngs::fsgzl4(), "zl4" );
BOOST_CHECK_EQUAL( core::strngs::fsgzlm(), "zlimit" );
BOOST_CHECK_EQUAL( core::strngs::fsgzoc(), "zocc" );
// H
BOOST_CHECK_EQUAL( core::strngs::horizontal_bar(), "----------------------------------------------------------------------" );
// I
BOOST_CHECK_EQUAL( core::strngs::fsincl(), "include" );
BOOST_CHECK_EQUAL( core::strngs::fsisav(), "isave" );
BOOST_CHECK_EQUAL( core::strngs::fsislt(), "cation" );
BOOST_CHECK_EQUAL( core::strngs::fsiwid(), "iwidom" );
BOOST_CHECK_EQUAL( core::strngs::imc_label(), "super-looper" );
BOOST_CHECK_EQUAL( core::strngs::inner_label(), "inner" );
BOOST_CHECK_EQUAL( core::strngs::inputpattern_label(), "input" );
// J
// K
BOOST_CHECK_EQUAL( core::strngs::fskmob(), "mobk" );
// L
BOOST_CHECK_EQUAL( core::strngs::localizer_label(), "localize" );
// M
BOOST_CHECK_EQUAL( core::strngs::fsmobl(), "mob" );
// N
BOOST_CHECK_EQUAL( core::strngs::fsname(), "name" );
BOOST_CHECK_EQUAL( core::strngs::fsnavr(), "naver" );
BOOST_CHECK_EQUAL( core::strngs::fsnmcf(), "multiconf" );
BOOST_CHECK_EQUAL( core::strngs::fsn(),    "n" );
BOOST_CHECK_EQUAL( core::strngs::fsnoch(), "nocharge" );
BOOST_CHECK_EQUAL( core::strngs::fsnsrt(), "oldreg" );
BOOST_CHECK_EQUAL( core::strngs::fsnstp(), "nstep" );
BOOST_CHECK_EQUAL( core::strngs::fsnsub(), "nsub" );
BOOST_CHECK_EQUAL( core::strngs::fsntrg(), "ntarg" );
BOOST_CHECK_EQUAL( core::strngs::fsnblk(), "nbulk" );
// O
BOOST_CHECK_EQUAL( core::strngs::outputdir_label(), "outputdir" );
// P
BOOST_CHECK_EQUAL( core::strngs::fsptch(), "patch" );
// Q
// R
BOOST_CHECK_EQUAL( core::strngs::fsregn(), "region" );
BOOST_CHECK_EQUAL( core::strngs::fsrtex(), "ratexc" );
BOOST_CHECK_EQUAL( core::strngs::fsrtgr(), "ratgr" );
BOOST_CHECK_EQUAL( core::strngs::fsrtid(), "ratind" );
BOOST_CHECK_EQUAL( core::strngs::fsrtjp(), "ratjmp" );
BOOST_CHECK_EQUAL( core::strngs::fsrtmv(), "ratmov" );
BOOST_CHECK_EQUAL( core::strngs::fsrtrg(), "ratreg" );
BOOST_CHECK_EQUAL( core::strngs::fsrtsl(), "ratslt" );
BOOST_CHECK_EQUAL( core::strngs::fsrtsp(), "ratspc" );
BOOST_CHECK_EQUAL( core::strngs::fsrtsw(), "ratswap" );
BOOST_CHECK_EQUAL( core::strngs::rate_label(), "rate" );
// S
BOOST_CHECK_EQUAL( core::strngs::fssalt(), "salt" );
BOOST_CHECK_EQUAL( core::strngs::fsspec(), "specie" );
BOOST_CHECK_EQUAL( core::strngs::fssubs(), "subspecie" );
BOOST_CHECK_EQUAL( core::strngs::sampler_label(), "sampler" );
BOOST_CHECK_EQUAL( core::strngs::simulator_label(), "simulator" );
// T
BOOST_CHECK_EQUAL( core::strngs::fstry(),  "trial" );
BOOST_CHECK_EQUAL( core::strngs::fstsi(),  "kelvin" );
BOOST_CHECK_EQUAL( core::strngs::fstype(), "type" );
// U, V
// W
BOOST_CHECK_EQUAL( core::strngs::fswidm(), "calwid" );
// X, Y
// Z
BOOST_CHECK_EQUAL( core::strngs::fsz(),    "z" );

!!!1372080.cpp!!!	input_error_message_test() : void
BOOST_CHECK_EQUAL( str( core::input_error_messages::bad_boolean_value() % "type" % "green" % "world" ), "Parameter \"type\" value (green) is not an expected boolean value in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::bad_number_value() % "type" % "green" % "world" ), "Parameter \"type\" value (green) is not an expected numerical value in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::bad_subtype_value() % "type" % "green" % "world" ), "Parameter \"type\" value (green) does not name a valid world subtype (see documentation)." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::bad_value() % "type" % "green" % "world" ), "Parameter \"type\" value (green) is not valid in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::duplicate_parameter() % "green" % "world" ), "Parameter \"green\" appears more than once in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::missing_parameter() % "green" % "world" ), "Required parameter \"green\" was not found in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::missing_parameters() % "world" ), "Required parameters were not found in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::missing_value() % "green" % "world" ), "Parameter \"green\" requires a value in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::invalid_parameter() % "green" % "world" ), "Parameter \"green\" is not valid in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::invalid_parameter_subtype() % "green" %  "world" % "colour" ), "Parameter \"green\" is not valid in a world \"colour\" type section." );
!!!899504.cpp!!!	strngs_has_spaces_test() : void
std::vector< std::pair< std::string, std::size_t > > words;
words.push_back( std::make_pair( "test case", true ) );
words.push_back( std::make_pair( " case", true ) );
words.push_back( std::make_pair( "case ", true ) );
words.push_back( std::make_pair( "case\tpp", true ) );
words.push_back( std::make_pair( "case\npp", true ) );
words.push_back( std::make_pair( "case", false ) );
words.push_back( std::make_pair( "ca4e", false ) );
words.push_back( std::make_pair( "456.7", false ) );
for( auto item : words )
{
  BOOST_CHECK_EQUAL( core::strngs::has_spaces( item.first ), item.second );
}

!!!899760.cpp!!!	strngs_is_one_word_test() : void
std::vector< std::pair< std::string, std::size_t > > words;
words.push_back( std::make_pair( "test case", false ) );
words.push_back( std::make_pair( " case", false ) );
words.push_back( std::make_pair( "case ", false ) );
words.push_back( std::make_pair( "case\tpp", false ) );
words.push_back( std::make_pair( "case\npp", false ) );
words.push_back( std::make_pair( "case", true ) );
words.push_back( std::make_pair( "ca4e", false ) );
words.push_back( std::make_pair( "456.7", false ) );
for( auto item : words )
{
  BOOST_CHECK_EQUAL( core::strngs::is_one_word( item.first ), item.second );
}

!!!900016.cpp!!!	strngs_is_valid_name() : void
std::vector< std::pair< std::string, std::size_t > > words;
words.push_back( std::make_pair( "test case", false ) );
words.push_back( std::make_pair( " case", false ) );
words.push_back( std::make_pair( "case ", false ) );
words.push_back( std::make_pair( "case\tpp", false ) );
words.push_back( std::make_pair( "case\npp", false ) );
words.push_back( std::make_pair( "case_pp", true ) );
words.push_back( std::make_pair( "case_", true ) );
words.push_back( std::make_pair( "case", true ) );
words.push_back( std::make_pair( "ca4e", true ) );
words.push_back( std::make_pair( "456.7", true ) );
for( auto item : words )
{
  BOOST_CHECK_EQUAL( core::strngs::is_valid_name( item.first ), item.second );
}

!!!405425.cpp!!!	numerical_constants_test() : void
// Invariant : file_version always less/equal to file_version_max
BOOST_CHECK_EQUAL( core::constants::filver, 1 );
BOOST_CHECK_EQUAL( core::constants::fvermx, 1 );
BOOST_CHECK_LE( core::constants::filver, core::constants::fvermx );
// TEST CONSTANTS HAVE FIXED VALUES
BOOST_CHECK_EQUAL( core::constants::angstrom(), 1.0E-10 );
BOOST_CHECK_EQUAL( core::constants::avogadro_number(), 6.02214E23 );
BOOST_CHECK_EQUAL( core::constants::boltzmann_constant(), 1.3806E-23 );
BOOST_CHECK_EQUAL( core::constants::electron_charge(), 1.6021917E-19 );
BOOST_CHECK_EQUAL( core::constants::epsilon_0(), 8.8542E-12 );
BOOST_CHECK_EQUAL( core::constants::pi(), 3.141592653589793 );
BOOST_CHECK_EQUAL( core::constants::to_SI(), 1660.539276735512625080121 );


!!!855856.cpp!!!	input_base_reader_statics_test() : void
{
  // Static Lifetime method tests

  // NOTE, not default constructible because it is an abstract class
  BOOST_CHECK( not std::is_default_constructible< core::input_base_reader >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< core::input_base_reader >::type{} );
  BOOST_CHECK( not std::is_move_constructible< core::input_base_reader >::type{} );
  BOOST_CHECK( (not std::is_assignable< core::input_base_reader, core::input_base_reader >::type{}) );
  BOOST_CHECK( std::has_virtual_destructor< core::input_base_reader >::type{} );
}
{
  // TEST BOOL CONVERTERS
  {
    // Converting string to bool
    // Converting string to bool: true -> true
    const std::string test ("true");
    bool pass = false;
    pass = core::input_base_reader::read_as_bool(test);
    BOOST_CHECK_EQUAL(pass, true);
  }
  {
    // Converting string to bool
    // Converting string to bool: false -> false
    const std::string test ("false");
    bool pass = true;
    pass = core::input_base_reader::read_as_bool(test);
    BOOST_CHECK_EQUAL(pass, false);
  }
  {
    // Converting string to bool
    // Converting string to bool: 0 -> false
    const std::string test ("0");
    bool pass = true;
    pass = core::input_base_reader::read_as_bool(test);
    BOOST_CHECK_EQUAL(pass, false);
  }
  {
    // Converting string to bool
    // Converting string to bool: 1 -> true
    const std::string test ("1");
    bool pass = false;
    pass = core::input_base_reader::read_as_bool(test);
    BOOST_CHECK_EQUAL(pass, true);

  }
  {
    // Converting string to bool
    // Converting string to bool: .false. -> false
    const std::string test (".false.");
    bool pass = true;
    pass = core::input_base_reader::read_as_bool(test);
    BOOST_CHECK_EQUAL(pass, false);
  }
  {
    // Converting string to bool
    // Converting string to bool: 2.0 -> ?true?
    const std::string test ("2.0");
    bool pass = true;
    BOOST_CHECK_THROW(pass = core::input_base_reader::read_as_bool(test), boost::bad_lexical_cast);
    BOOST_CHECK_EQUAL(pass, true);
  }
  {
    // Converting string to bool
    // Converting string to bool: 2 -> ?true?
    const std::string test ("2");
    bool pass = true;
    BOOST_CHECK_THROW(pass = core::input_base_reader::read_as_bool(test), boost::bad_lexical_cast);
    BOOST_CHECK_EQUAL(pass, true);
  }

}
{
  // Test of dequoting
  {
    const std::string expect("abc  ");
    const std::string input1("'abc  '");   // -> |abc  |
    const std::string input2("\"abc  \""); // -> |abc  |
    const std::string input3("\"abc  '");  // unchanged
    const std::string input4("\"abc  \" ");// -> |abc  |
    const std::string input5("\"abc  ' "); // unchanged
    std::string result;

    result = core::input_base_reader::dequote(input1);
    BOOST_CHECK_EQUAL(result, expect);

    result = core::input_base_reader::dequote(input2);
    BOOST_CHECK_EQUAL(result, expect);

    result = core::input_base_reader::dequote(input3);
    BOOST_CHECK_EQUAL(result, input3);

    result = core::input_base_reader::dequote(input4);
    BOOST_CHECK_EQUAL(result, expect);

    result = core::input_base_reader::dequote(input5);
    BOOST_CHECK_EQUAL(result, input5);
  }
  {
    // No quotes
    // Unquoted text: unchanged
    std::string result = "The lazy dog.";
    const std::string pass = "The lazy dog.";
    result = core::input_base_reader::dequote(result);
    BOOST_CHECK_EQUAL(result, pass);
  }
  {
    // Uneven quoted (front) text: unchanged
    std::string result = "\"The lazy dog.";
    const std::string pass = "\"The lazy dog.";
    result = core::input_base_reader::dequote(result);
    BOOST_CHECK_EQUAL(result, pass);
  }
  {
    // Uneven quotes (back) text: unchanged
    std::string result = "The lazy dog.\"";
    const std::string pass = "The lazy dog.\"";
    result = core::input_base_reader::dequote(result);
    BOOST_CHECK_EQUAL(result, pass);
  }
  {
    // Matched quotes [\"] text: strip quotes
    std::string result = "\"The lazy dog.\"";
    const std::string pass = "The lazy dog.";
    result = core::input_base_reader::dequote(result);
    BOOST_CHECK_EQUAL(result, pass);
  }
  {
    // Matched multi-quoted text: strip one set of quotes
    std::string result = "\"\"The lazy dog.\"\"";
    const std::string pass = "\"The lazy dog.\"";
    result = core::input_base_reader::dequote(result);
    BOOST_CHECK_EQUAL(result, pass);
  }
  {
    // Matched quoted with one end embedded in text: unchanged
    std::string result = "\"The\" lazy dog.";
    const std::string pass = "\"The\" lazy dog.";
    result = core::input_base_reader::dequote(result);
    BOOST_CHECK_EQUAL(result, pass);
  }
  {
    // Matched quoted ['] text: strip quotes
    std::string result = "'The lazy dog.'";
    const std::string pass = "The lazy dog.";
    result = core::input_base_reader::dequote(result);
    BOOST_CHECK_EQUAL(result, pass);
  }
  {
    // Mismatched quoted [\"...'] text: unchanged
    std::string result = "\"The lazy dog.'";
    const std::string pass = "\"The lazy dog.'";
    result = core::input_base_reader::dequote(result);
    BOOST_CHECK_EQUAL(result, pass);
  }
  {
    // Matched quoted [\"] text with external spacing: strip quotes and
    // whitespace
    std::string result = "\"The lazy dog. \" ";
    const std::string pass = "The lazy dog. ";
    result = core::input_base_reader::dequote(result);
    BOOST_CHECK_EQUAL(result, pass);
  }
  {
    // Matched quoted [\"] text with internal spacing: strip quotes, leave
    // internal whitespace
    std::string result = "\"The lazy dog. \"";
    const std::string pass = "The lazy dog. ";
    result = core::input_base_reader::dequote(result);
    BOOST_CHECK_EQUAL(result, pass);
  }
}
{
  // TEST Decommenting
  const std::string input1("#abc  '"); // empty

  const std::string expect2(" ");
  const std::string input2(" #abc  "); // -> | |

  const std::string expect3("abc  ");
  const std::string input3("abc  # "); // -> |abc  |

  const std::string input4("abc   ");  // unchanged

  const std::string input5("abc  \\# "); // unchanged

  const std::string input6("\"abc  # \""); // unchanged

  const std::string expect7("\'abc\'  ");
  const std::string input7("\'abc\'  # ");

  const std::string input8("\"abc\"  \"# "); // -> unchanged

  const std::string expect9("\"abc\'  \"");
  const std::string input9("\"abc\'  \"# ");

  const std::string expectA("abc  \\\\");
  const std::string inputA("abc  \\\\# ");
  std::string result;

  result = core::input_base_reader::decomment(input1);
  BOOST_CHECK(result.empty());

  result = core::input_base_reader::decomment(input2);
  BOOST_CHECK_EQUAL(result, expect2);

  result = core::input_base_reader::decomment(input3);
  BOOST_CHECK_EQUAL(result, expect3);

  result = core::input_base_reader::decomment(input4);
  BOOST_CHECK_EQUAL(result, input4);

  result = core::input_base_reader::decomment(input5);
  BOOST_CHECK_EQUAL(result, input5);

  result = core::input_base_reader::decomment(input6);
  BOOST_CHECK_EQUAL(result, input6);

  result = core::input_base_reader::decomment(input7);
  BOOST_CHECK_EQUAL(result, expect7);

  result = core::input_base_reader::decomment(input8);
  BOOST_CHECK_EQUAL(result, input8);

  result = core::input_base_reader::decomment(input9);
  BOOST_CHECK_EQUAL(result, expect9);

  result = core::input_base_reader::decomment(inputA);
  BOOST_CHECK_EQUAL(result, expectA);

}
// READ AS FLOATS
{
  std::vector< double > result;
  BOOST_CHECK( core::input_base_reader::read_as_floats("-1.0 2.4 1.3", result) );
  BOOST_CHECK_EQUAL( result.size(), 3 );
  BOOST_CHECK_EQUAL( result[0], -1.0 );
  BOOST_CHECK_EQUAL( result[1], 2.4 );
  BOOST_CHECK_EQUAL( result[2], 1.3 );
}
{
  std::vector< double > result;
  BOOST_CHECK( not core::input_base_reader::read_as_floats("1 2 3 ABC 4", result) );
  BOOST_CHECK_EQUAL( result.size(), 3 );
  BOOST_CHECK_EQUAL( result[0], 1.0 );
  BOOST_CHECK_EQUAL( result[1], 2.0 );
  BOOST_CHECK_EQUAL( result[2], 3.0 );
}
{
  std::vector< double > result;
  BOOST_CHECK( core::input_base_reader::read_as_floats("1", result) );
  BOOST_CHECK_EQUAL(result.size(),1);
  BOOST_CHECK_EQUAL(result[0],1.0);
}
{
  // core::input_base_reader::ordinal_input( name, val, title, sec, targ );
  const std::string name( "label" );
  const std::string title( "Test Base Reader" );
  const std::string sec( "core" );
  // VALID INPUTS
  {
    std::size_t targ{ 0ul };
    //BOOST_CHECK_NO_THROW(
    core::input_base_reader::ordinal_input( name, "1", title, sec, targ ); // );
    BOOST_CHECK_EQUAL( targ, 1ul );
    BOOST_CHECK_NO_THROW( core::input_base_reader::ordinal_input( name, "100", title, sec, targ ) );
    BOOST_CHECK_EQUAL( targ, 100ul );
    BOOST_CHECK_NO_THROW( core::input_base_reader::ordinal_input( name, "31", title, sec, targ ) );
    BOOST_CHECK_EQUAL( targ, 31ul );
    BOOST_CHECK_NO_THROW( core::input_base_reader::ordinal_input( name, "18446744073709551614", title, sec, targ ) );
    BOOST_CHECK_EQUAL( targ, 18446744073709551614ul );
    BOOST_CHECK_NO_THROW( core::input_base_reader::ordinal_input( name, "0", title, sec, targ ) );
    BOOST_CHECK_EQUAL( targ, 0ul );
    // Leading whitespace is not an error
    BOOST_CHECK_NO_THROW( core::input_base_reader::ordinal_input( name, " 1", title, sec, targ ) );
    BOOST_CHECK_EQUAL( targ, 1ul );
    // Trialing whitespace is not an error
    BOOST_CHECK_NO_THROW( core::input_base_reader::ordinal_input( name, "10  ", title, sec, targ ) );
    BOOST_CHECK_EQUAL( targ, 10ul );
  }
  // INVALID INPUTS
  {
    try
    {
      // NEGATIVE
      std::size_t targ{ 0ul };
      core::input_base_reader::ordinal_input( name, "-1", title, sec, targ );
      BOOST_CHECK_EQUAL( targ, 0ul );
      BOOST_ERROR( "expected \"core::input_base_reader::ordinal_input\" exception on NEGATIVE input not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Test Base Reader \"label\" parameter value (-1) cannot be negative." ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"core::input_base_reader::ordinal_input\" was not expected type: " ) + err.what() );
    }
    try
    {
      std::size_t targ{ 0ul };
      // OVERFLOW
      core::input_base_reader::ordinal_input( name, "18446744073709551616", title, sec, targ );
      BOOST_CHECK_EQUAL( targ, 0ul );
      BOOST_ERROR( "expected \"core::input_base_reader::ordinal_input\" exception on NEGATIVE input not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Test Base Reader \"label\" parameter value (18446744073709551616) outside numeric range." ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"core::input_base_reader::ordinal_input\" was not expected type: " ) + err.what() );
    }
    try
    {
      std::size_t targ{ 0ul };
      // TRIALING CHARACTERS
      core::input_base_reader::ordinal_input( name, "1KL", title, sec, targ );
      BOOST_CHECK_EQUAL( targ, 0ul );
      BOOST_ERROR( "expected \"core::input_base_reader::ordinal_input\" exception on NEGATIVE input not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Test Base Reader \"label\" parameter value (1KL) is not a number." ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"core::input_base_reader::ordinal_input\" was not expected type: " ) + err.what() );
    }
    try
    {
      std::size_t targ{ 0ul };
      // ONLY WHITESPACE CHARACTERS
      core::input_base_reader::ordinal_input( name, " \t\n", title, sec, targ );
      BOOST_CHECK_EQUAL( targ, 0ul );
      BOOST_ERROR( "expected \"core::input_base_reader::ordinal_input\" exception on NEGATIVE input not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Test Base Reader \"label\" parameter requires a value." ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"core::input_base_reader::ordinal_input\" was not expected type: " ) + err.what() );
    }
    try
    {
      std::size_t targ{ 0ul };
      // LEADING CHARACTERS
      core::input_base_reader::ordinal_input( name, "K1", title, sec, targ );
      BOOST_CHECK_EQUAL( targ, 0ul );
      BOOST_ERROR( "expected \"core::input_base_reader::ordinal_input\" exception on NEGATIVE input not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Test Base Reader \"label\" parameter value (K1) is not a number." ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"core::input_base_reader::ordinal_input\" was not expected type: " ) + err.what() );
    }
    try
    {
      std::size_t targ{ 0ul };
      // NOT A NUMBER
      core::input_base_reader::ordinal_input( name, "ten", title, sec, targ );
      BOOST_CHECK_EQUAL( targ, 0ul );
      BOOST_ERROR( "expected \"core::input_base_reader::ordinal_input\" exception on NEGATIVE input not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Test Base Reader \"label\" parameter value (ten) is not a number." ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"core::input_base_reader::ordinal_input\" was not expected type: " ) + err.what() );
    }
  }
}
!!!554672.cpp!!!	input_base_reader_test() : void
////////////
// Simple (no-op) derived class to enable testing of base class methods
class test_reader: public core::input_base_reader
{
public:
  bool do_next() override
  {
    return false;
  };
  std::string current_filename() const override
  {
    return std::string();
  }
  std::size_t current_line_number() const override
  {
    return 0;
  }
  void add_buffer(const boost::filesystem::path &, std::string) override {}
  void add_include(const boost::filesystem::path &) override {}
};
//--template < class Archive >
//--void serialize( Archive &ar, input_base_reader &rr, const int version = 0)
//--{
//--   rr.serialize( ar );
//--};
{
  // TEST reader ctor
  test_reader test;
  BOOST_CHECK_EQUAL( test.line().size(), 0 );
  BOOST_CHECK_EQUAL( test.name().size(), 0 );
  BOOST_CHECK_EQUAL( test.value().size(), 0 );
}
std::stringstream store;
{
  // TEST set_line
  test_reader test;

  // serialization
  boost::archive::text_oarchive oa( store );
  {
    // name only
    const std::string ll( "section" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), ll );
    BOOST_CHECK_EQUAL( test.name(), ll );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // name value with '=' separator
    const std::string ll( "name1 = value1" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), ll );
    BOOST_CHECK_EQUAL( test.name(), "name1" );
    BOOST_CHECK_EQUAL( test.value(), "value1" );

    // SAVE POINT 1
    oa << test;

    BOOST_CHECK_NE( test.line().size(), 0 );
    BOOST_CHECK_NE( test.name().size(), 0 );
    BOOST_CHECK_NE( test.value().size(), 0 );
    test.clear();
    BOOST_CHECK_EQUAL( test.line().size(), 0 );
    BOOST_CHECK_EQUAL( test.name().size(), 0 );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // name value with ' ' separator
    const std::string ll( "name2    value2" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), ll );
    BOOST_CHECK_EQUAL( test.name(), "name2" );
    BOOST_CHECK_EQUAL( test.value(), "value2" );

    // SAVE POINT 2
    oa << test;

    BOOST_CHECK_NE( test.line().size(), 0 );
    BOOST_CHECK_NE( test.name().size(), 0 );
    BOOST_CHECK_NE( test.value().size(), 0 );
    BOOST_CHECK( not test.next() );
    BOOST_CHECK_EQUAL( test.line().size(), 0 );
    BOOST_CHECK_EQUAL( test.name().size(), 0 );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // comment line
    const std::string ll( "# section" );
    BOOST_CHECK( not test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), "" );
    BOOST_CHECK_EQUAL( test.name().size(), 0 );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // empty line
    const std::string ll( "" );
    BOOST_CHECK( not test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), ll );
    BOOST_CHECK_EQUAL( test.name().size(), 0 );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // line with values separated by spaces and a comment
    const std::string ll( "1 2.3 4 not a num # COMMENT" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), "1 2.3 4 not a num" );
    BOOST_CHECK_EQUAL( test.name(), "1" );
    BOOST_CHECK_EQUAL( test.value(), "2.3 4 not a num" );
  }
  {
    // name only with a comment
    const std::string ll( "section # COMMENT" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.name(), "section" );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // value only ??
    const std::string ll( " = section" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.name().size(), 0  );
    BOOST_CHECK_EQUAL( test.value(), "section" );
  }

}
{

  boost::archive::text_iarchive ia( store );
  {
    test_reader test;
    // FROM SAVE POINT 1
    ia >> test;
    BOOST_CHECK_EQUAL( test.line(), "name1 = value1" );
    BOOST_CHECK_EQUAL( test.name(), "name1" );
    BOOST_CHECK_EQUAL( test.value(), "value1" );
  }
  {
    test_reader test;
    // FROM SAVE POINT 2
    ia >> test;
    BOOST_CHECK_EQUAL( test.line(), "name2    value2" );
    BOOST_CHECK_EQUAL( test.name(), "name2" );
    BOOST_CHECK_EQUAL( test.value(), "value2" );
  }
}

!!!550960.cpp!!!	input_node_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( std::is_default_constructible< core::input_node >::type{} );
  BOOST_CHECK( std::is_copy_constructible< core::input_node >::type{} );
  BOOST_CHECK( std::is_move_constructible< core::input_node >::type{} );
  BOOST_CHECK( (std::is_assignable< core::input_node, core::input_node >::type{}) );
  BOOST_CHECK( not std::has_virtual_destructor< core::input_node >::type{} );
}

const std::string dummy_input("\n\n# A comment\nsection # Another comment\nname1 = value1\n1 2.3 4 not a num # 6.2\nname1 value1\n\n");
const std::string  dummy_filename("dummy");
const boost::filesystem::path dummy_path( boost::filesystem::absolute( "dummy" ) );
const std::vector< std::string > lines = { "", "", "# A comment", "section # Another comment", "name1 = value1", "1 2.3 4 not a num # 6.2", "name1 value1", "", "", "" };
const std::vector< std::size_t > pos = { 1, 2, 14, 40, 55, 79, 92, 93, 94, 94 };
const std::vector< std::size_t > linenums = { 1, 2, 3, 4, 5, 6, 7, 8, 8, 8 };

std::stringstream store;
{
  core::input_node node;
  node.set_buffer( dummy_filename, dummy_input );

  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
  BOOST_CHECK_EQUAL( node.eof(), false );

  boost::archive::text_oarchive oa( store );
  oa << node;

  for (std::size_t ii = 0; ii != 10; ++ii )
  {
    std::string line;
    node.getline( line );
    BOOST_CHECK( node.eof() == (ii >= 7) );
    BOOST_CHECK_EQUAL( line, lines[ii] );
    BOOST_CHECK_EQUAL( node.file_position(), pos[ii] );
    BOOST_CHECK_EQUAL( node.line_number(), linenums[ii] );
    BOOST_CHECK_EQUAL( node.path(), dummy_path );
  }
  node.rewind();
  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
  for (std::size_t ii = 0; ii != 8; ++ii )
  {
    std::string line;
    node.getline( line );
    BOOST_CHECK( node.eof() == (ii >= 7) );
    BOOST_CHECK_EQUAL( line, lines[ii] );
    BOOST_CHECK_EQUAL( node.file_position(), pos[ii] );
    BOOST_CHECK_EQUAL( node.line_number(), linenums[ii] );
    BOOST_CHECK_EQUAL( node.path(), dummy_path );
  }
}
{
  core::input_node node;
  boost::archive::text_iarchive ia( store );
  ia >> node;
  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );

  for (std::size_t ii = 0; ii != 8; ++ii )
  {
    std::string line;
    node.getline( line );
    BOOST_CHECK( node.eof() == (ii >= 7) );
    BOOST_CHECK_EQUAL( line, lines[ii] );
    BOOST_CHECK_EQUAL( node.file_position(), pos[ii] );
    BOOST_CHECK_EQUAL( node.line_number(), linenums[ii] );
    BOOST_CHECK_EQUAL( node.path(), dummy_path );
  }
}

// Test of input that is a single line without \n
{
  const std::string single_input("section ");
  core::input_node node;
  node.set_buffer( dummy_filename, single_input );

  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
  BOOST_CHECK_EQUAL( node.eof(), false );

  std::string line;
  node.getline( line );
  BOOST_CHECK( node.eof() );
  BOOST_CHECK_EQUAL( line, single_input );
  BOOST_CHECK_EQUAL( node.file_position(), single_input.size() );
  BOOST_CHECK_EQUAL( node.line_number(), 1 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
}

// Test of empty input
{
  const std::string empty_input{};
  core::input_node node;
  node.set_buffer( dummy_filename, empty_input );

  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
  BOOST_CHECK_EQUAL( node.eof(), true );
}

// Test of empty single line input
{
  const std::string empty_input{"\n"};
  core::input_node node;
  node.set_buffer( dummy_filename, empty_input );

  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
  BOOST_CHECK_EQUAL( node.eof(), false );
  std::string line;
  node.getline( line );
  BOOST_CHECK( node.eof() );
  BOOST_CHECK_EQUAL( line, "" );
  BOOST_CHECK_EQUAL( node.file_position(), 1 );
  BOOST_CHECK_EQUAL( node.line_number(), 1 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
}

!!!554800.cpp!!!	input_preprocess_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( std::is_default_constructible< core::input_preprocess >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< core::input_preprocess >::type{} );
  BOOST_CHECK( not std::is_move_constructible< core::input_preprocess >::type{} );
  BOOST_CHECK( (not std::is_assignable< core::input_preprocess, core::input_preprocess >::type{}) );
  BOOST_CHECK( std::has_virtual_destructor< core::input_preprocess >::type{} );
}
{
   // TEST reader ctor
   core::input_preprocess test;
   BOOST_CHECK_EQUAL( "", test.line() );
   BOOST_CHECK_EQUAL( "", test.name() );
   BOOST_CHECK_EQUAL( "", test.value() );
   BOOST_CHECK_EQUAL( 0, test.current_line_number() );
   BOOST_CHECK_EQUAL( "", test.current_filename() );
}
{
   // Test standard reader behavior (uses memory buffers only). 
   core_test_suite::test_read_input_buffer< core::input_preprocess >();
}
// test serialization
//
// input_preprocess should read the content of the input files, including any
// "include" files, into internal buffers that can be serialized.
std::stringstream store;
const std::string dummy_input("\n\n# A comment\nsection # Another comment\nname1 = value1\n1 2.3 4 not a num # 6.2\nname1 value1");
const std::string  dummy_filename("dummy");
const boost::filesystem::path dummy_path( boost::filesystem::absolute( "dummy" ) );
{
   core::input_preprocess test;
   test.add_buffer( dummy_filename, dummy_input );
   boost::archive::text_oarchive oa( store );
   oa << test;
}
{
   core::input_preprocess rdr;
   boost::archive::text_iarchive ia( store );
   ia >> rdr;

   BOOST_CHECK( rdr.next() );
   BOOST_CHECK_EQUAL( "section # Another comment", rdr.line() );
   BOOST_CHECK_EQUAL( "section", rdr.name() );
   BOOST_CHECK_EQUAL( "", rdr.value() );
   BOOST_CHECK_EQUAL( 4, rdr.current_line_number() );
   BOOST_CHECK_EQUAL( dummy_path, rdr.current_filename() );

   // TEST reader next part 2
   BOOST_CHECK(rdr.next());
   BOOST_CHECK_EQUAL("name1 = value1",rdr.line());
   BOOST_CHECK_EQUAL("name1",rdr.name());
   BOOST_CHECK_EQUAL("value1",rdr.value());
   BOOST_CHECK_EQUAL(5,rdr.current_line_number());
   BOOST_CHECK_EQUAL(dummy_path,rdr.current_filename());

   // TEST reader next part 3
   BOOST_CHECK(rdr.next());
   BOOST_CHECK_EQUAL("1 2.3 4 not a num # 6.2",rdr.line());
   BOOST_CHECK_EQUAL("1",rdr.name());
   BOOST_CHECK_EQUAL("2.3 4 not a num",rdr.value());
   BOOST_CHECK_EQUAL(6,rdr.current_line_number());
   BOOST_CHECK_EQUAL(dummy_path,rdr.current_filename());

   // TEST reader next part 4
   BOOST_CHECK(rdr.next());
   BOOST_CHECK_EQUAL("name1 value1",rdr.line());
   BOOST_CHECK_EQUAL("name1",rdr.name());
   BOOST_CHECK_EQUAL("value1",rdr.value());
   BOOST_CHECK_EQUAL(7,rdr.current_line_number());
   BOOST_CHECK_EQUAL(dummy_path,rdr.current_filename());

   // TEST reader next part 5
   BOOST_CHECK(not rdr.next());
   BOOST_CHECK_EQUAL("",rdr.line());
   BOOST_CHECK_EQUAL("",rdr.name());
   BOOST_CHECK_EQUAL("",rdr.value());
}

!!!406065.cpp!!!	input_reader_test() : void
std::string dummy_input( "\n\n# A comment\nsection # Another comment\nname1 = value1\n1 2.3 4 not a num # 6.2\nname1 value1" );
std::string dummy_filename( boost::filesystem::absolute( "dummy" ).string() );

{
  core_test_suite::test_read_input_buffer< core::input_reader >();
}
{
  // TEST reader ctor
  std::istringstream input( dummy_input );
  core::input_reader test( dummy_filename,input );
  BOOST_CHECK_EQUAL( "",test.line() );
  BOOST_CHECK_EQUAL( "",test.name() );
  BOOST_CHECK_EQUAL( "",test.value() );
  BOOST_CHECK_EQUAL( 0,test.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_filename,test.current_filename() );

}
{
  // TEST reader next part 1
  std::istringstream input( dummy_input );
  core::input_reader test( dummy_filename,input );
  BOOST_CHECK( test.next() );
  BOOST_CHECK_EQUAL( "section # Another comment",test.line() );
  BOOST_CHECK_EQUAL( "section",test.name() );
  BOOST_CHECK_EQUAL( "",test.value() );
  BOOST_CHECK_EQUAL( 4,test.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_filename,test.current_filename() );

  // TEST reader next part 2
  BOOST_CHECK( test.next() );
  BOOST_CHECK_EQUAL( "name1 = value1",test.line() );
  BOOST_CHECK_EQUAL( "name1",test.name() );
  BOOST_CHECK_EQUAL( "value1",test.value() );
  BOOST_CHECK_EQUAL( 5,test.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_filename,test.current_filename() );

  // TEST reader next part 3
  BOOST_CHECK( test.next() );
  BOOST_CHECK_EQUAL( "1 2.3 4 not a num # 6.2",test.line() );
  BOOST_CHECK_EQUAL( "1",test.name() );
  BOOST_CHECK_EQUAL( "2.3 4 not a num",test.value() );
  BOOST_CHECK_EQUAL( 6,test.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_filename,test.current_filename() );

  {
    std::vector< double > result;
    test.read_as_floats( test.line(), result );
    BOOST_CHECK_EQUAL( result.size(),3 );
    BOOST_CHECK_EQUAL( result[0],1.0 );
    BOOST_CHECK_EQUAL( result[1],2.3 );
    BOOST_CHECK_EQUAL( result[2],4.0 );
  }
  // TEST reader next part 4
  BOOST_CHECK( test.next() );
  BOOST_CHECK_EQUAL( "name1 value1",test.line() );
  BOOST_CHECK_EQUAL( "name1",test.name() );
  BOOST_CHECK_EQUAL( "value1",test.value() );
  BOOST_CHECK_EQUAL( 7,test.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_filename,test.current_filename() );

  // TEST reader next part 5
  BOOST_CHECK( not test.next() );
  BOOST_CHECK_EQUAL( "",test.line() );
  BOOST_CHECK_EQUAL( "",test.name() );
  BOOST_CHECK_EQUAL( "",test.value() );
  // zero line number and "" indicate no file.
  BOOST_CHECK_EQUAL( 0,test.current_line_number() );
  BOOST_CHECK_EQUAL( "",test.current_filename() );
  // Check stability of calling next after last element.
  BOOST_CHECK( not test.next() );
  BOOST_CHECK_EQUAL( "",test.line() );
  BOOST_CHECK_EQUAL( "",test.name() );
  BOOST_CHECK_EQUAL( "",test.value() );
  // zero line number and "" indicate no file.
  BOOST_CHECK_EQUAL( 0,test.current_line_number() );
  BOOST_CHECK_EQUAL( "",test.current_filename() );

}

!!!484528.cpp!!!	input_section_test() : void
// CTOR TESTS
// ----------
const std::string empty_str;
const std::string label1 { "label1" };
const std::string name1 { "name1" };
const std::string name2 { "name2" };
const std::string name3 { "name3" };
const std::string name4 { "name4" };
const std::string value1 { "value1" };
const double value2 { 1.25 };
const std::string svalue2 { "1.250000" };
const std::size_t value3 { 125ul };
const std::string svalue3 { "125" };
const bool value4 { true };
const std::string svalue4 { "true" };
std::stringstream store;
{
   // default empty ctor
   core::input_section isec;
   BOOST_CHECK_EQUAL( isec.label(), empty_str );
   BOOST_CHECK_EQUAL( isec.size(), 0 );
   BOOST_CHECK_EQUAL( isec.empty(), true );

   isec.set_label( label1 );
   BOOST_CHECK_EQUAL( isec.label(), label1 );
   BOOST_CHECK_EQUAL( isec.size(), 0 );
   BOOST_CHECK_EQUAL( isec.empty(), true );

   BOOST_CHECK_EQUAL( isec.has_entry( name1 ), false );
   isec.add_entry( name1, value1 );
   BOOST_CHECK_EQUAL( isec.label(), label1 );
   BOOST_CHECK_EQUAL( isec.has_entry( name1 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name1 ), value1 );
   BOOST_CHECK_EQUAL( isec.size(), 1 );
   BOOST_CHECK_EQUAL( isec.empty(), false );

   BOOST_CHECK_EQUAL( isec.has_entry( name2 ), false );
   isec.add_entry( name2, value2 );
   BOOST_CHECK_EQUAL( isec.has_entry( name2 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name2 ), svalue2 );
   BOOST_CHECK_EQUAL( isec.size(), 2 );

   BOOST_CHECK_EQUAL( isec.has_entry( name3 ), false );
   isec.add_entry( name3, value3 );
   BOOST_CHECK_EQUAL( isec.has_entry( name3 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name3 ), svalue3 );
   BOOST_CHECK_EQUAL( isec.size(), 3 );

   BOOST_CHECK_EQUAL( isec.has_entry( name4 ), false );
   isec.add_entry( name4, value4 );
   BOOST_CHECK_EQUAL( isec.has_entry( name4 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name4 ), svalue4 );
   BOOST_CHECK_EQUAL( isec.size(), 4 );

   {
      // serialization
      boost::archive::text_oarchive oa( store );
      oa << isec;
      BOOST_CHECK_EQUAL( isec.label(), label1 );
      BOOST_CHECK_EQUAL( isec.has_entry( name1 ), true );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), value1 );
      BOOST_CHECK_EQUAL( isec.has_entry( name2 ), true );
      BOOST_CHECK_EQUAL( isec.get_entry( name2 ), svalue2 );
      BOOST_CHECK_EQUAL( isec.has_entry( name3 ), true );
      BOOST_CHECK_EQUAL( isec.get_entry( name3 ), svalue3 );
      BOOST_CHECK_EQUAL( isec.has_entry( name4 ), true );
      BOOST_CHECK_EQUAL( isec.get_entry( name4 ), svalue4 );
      BOOST_CHECK_EQUAL( isec.size(), 4 );
      BOOST_CHECK_EQUAL( isec.empty(), false );
   }

   {
      // copy ctor
      core::input_section isec_copy( isec );
      BOOST_CHECK_EQUAL( isec_copy.label(), label1 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name1 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name1 ), value1 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name2 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name2 ), svalue2 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name3 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name3 ), svalue3 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name4 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name4 ), svalue4 );
      BOOST_CHECK_EQUAL( isec_copy.size(), 4 );
      BOOST_CHECK_EQUAL( isec_copy.empty(), false );
   }
   {
      // assignment
      core::input_section isec_copy;
      BOOST_CHECK_EQUAL( isec_copy.label(), empty_str );
      BOOST_CHECK_EQUAL( isec_copy.size(), 0 );
      BOOST_CHECK_EQUAL( isec_copy.empty(), true );

      isec_copy = isec;

      BOOST_CHECK_EQUAL( isec_copy.label(), label1 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name1 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name1 ), value1 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name2 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name2 ), svalue2 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name3 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name3 ), svalue3 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name4 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name4 ), svalue4 );
      BOOST_CHECK_EQUAL( isec_copy.size(), 4 );
      BOOST_CHECK_EQUAL( isec_copy.empty(), false );
   }

   {
      // move
      core::input_section isec_copy( isec );
      core::input_section isec_move( std::move( isec_copy ) );
      BOOST_CHECK_EQUAL( isec_copy.label(), empty_str );
      BOOST_CHECK_EQUAL( isec_copy.size(), 0 );
      BOOST_CHECK_EQUAL( isec_copy.empty(), true );

      BOOST_CHECK_EQUAL( isec_move.label(), label1 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name1 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name1 ), value1 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name2 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name2 ), svalue2 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name3 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name3 ), svalue3 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name4 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name4 ), svalue4 );
      BOOST_CHECK_EQUAL( isec_move.size(), 4 );
      BOOST_CHECK_EQUAL( isec_move.empty(), false );
   }

   {
      // swap
      core::input_section isec_copy( isec );
      core::input_section isec_move;

      std::swap( isec_move, isec_copy );

      BOOST_CHECK_EQUAL( isec_copy.label(), empty_str );
      BOOST_CHECK_EQUAL( isec_copy.size(), 0 );
      BOOST_CHECK_EQUAL( isec_copy.empty(), true );

      BOOST_CHECK_EQUAL( isec_move.label(), label1 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name1 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name1 ), value1 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name2 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name2 ), svalue2 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name3 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name3 ), svalue3 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name4 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name4 ), svalue4 );
      BOOST_CHECK_EQUAL( isec_move.size(), 4 );
      BOOST_CHECK_EQUAL( isec_move.empty(), false );
   }
}
{
   // test add_entry
   // add_entry(string)  ABOVE
   // add_entry(unsigned long) as size_t ABOVE
   // add_entry(double) ABOVE
   {
      // add_entry(bool)
      core::input_section isec;
      isec.add_entry( name1, true );
      isec.add_entry( name2, false );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "true" );
      BOOST_CHECK_EQUAL( isec.get_entry( name2 ), "false" );
   }
   {
      // add_entry(int)
      core::input_section isec;
      int value { -170465 };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "-170465" );
   }
   {
      // add_entry(long)
      core::input_section isec;
      int64_t value { -17046500000000000L };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "-17046500000000000" );
   }
   {
      // add_entry(long long)
      core::input_section isec;
      long long value { -1704650000000000000LL };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "-1704650000000000000" );
   }
   {
      // add_entry(uint)
      core::input_section isec;
      uint32_t value { 170465 };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "170465" );
   }
   {
      // add_entry(unsigned long long)
      core::input_section isec;
      unsigned long long value { 170465000000000000ULL };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "170465000000000000" );
   }
   {
      // add_entry(float)
      core::input_section isec;
      float value { 1.125E15F };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "1.125e+15" );
   }
   {
      // add_entry(long double)
      core::input_section isec;
      long double value { 1.125E500L };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "1.125e+500" );
   }
   {
      // template< class T > add_entry(T)
      core::input_section isec;
      particle::coordinate value { 17.0, 4.0, 1965.0 };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "17 4 1965" );
   }
}
{
   // deserialization
   core::input_section isec;
   boost::archive::text_iarchive ia( store );
   ia >> isec;

   BOOST_CHECK_EQUAL( isec.label(), label1 );
   BOOST_CHECK_EQUAL( isec.has_entry( name1 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name1 ), value1 );
   BOOST_CHECK_EQUAL( isec.has_entry( name2 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name2 ), svalue2 );
   BOOST_CHECK_EQUAL( isec.has_entry( name3 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name3 ), svalue3 );
   BOOST_CHECK_EQUAL( isec.has_entry( name4 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name4 ), svalue4 );
   BOOST_CHECK_EQUAL( isec.size(), 4 );
   BOOST_CHECK_EQUAL( isec.empty(), false );

   // Write test
   {
      std::stringstream output;
      isec.write( output );
      const std::string result { output.str() };
      boost::tokenizer< boost::escaped_list_separator< char > > tok(result, { "\\", " \n\t", "\"\'" } );
      std::vector< std::string > wordlist = { label1, name1, value1, name2, svalue2, name3, svalue3, name4, svalue4, "end" };
      BOOST_CHECK( std::equal( wordlist.begin(), wordlist.end(), tok.begin() ) );
      auto t_iter = tok.begin();
      for (auto w_iter = wordlist.begin(); w_iter != wordlist.end(); ++w_iter, ++t_iter)
      {
         BOOST_CHECK_EQUAL( *t_iter, *w_iter );
      }
   }
}
!!!1286704.cpp!!!	input_document_test() : void
// CTOR TESTS
// ----------
const std::size_t version{ 21 };
std::stringstream store;
const std::string label1 { "label1" };
const std::string label2 { "label2" };
{
   // default
   core::input_document idoc( version );
   BOOST_CHECK_EQUAL( idoc.size(), 0 );
   BOOST_CHECK_EQUAL( idoc.empty(), true );
   BOOST_CHECK_EQUAL( idoc.version(), version );

   std::size_t idx;
   idx = idoc.add_section( label1 );

   BOOST_CHECK_EQUAL( idx, 0 );
   BOOST_CHECK_EQUAL( idoc[ idx ].label(), label1 );
   BOOST_CHECK_EQUAL( idoc.size(), 1 );
   BOOST_CHECK_EQUAL( idoc.empty(), false );
   BOOST_CHECK_EQUAL( idoc.version(), version );

   idx = idoc.add_section( label2 );

   BOOST_CHECK_EQUAL( idx, 1 );
   BOOST_CHECK_EQUAL( idoc[ idx ].label(), label2 );
   BOOST_CHECK_EQUAL( idoc.size(), 2 );

   boost::archive::text_oarchive oa( store );
   oa << idoc;

   {
      // copy ctor
      core::input_document idoc2( idoc );
      BOOST_CHECK_EQUAL( idoc2.version(), version );
      BOOST_CHECK_EQUAL( idoc2[ 0 ].label(), label1 );
      BOOST_CHECK_EQUAL( idoc2[ 1 ].label(), label2 );
      BOOST_CHECK_EQUAL( idoc2.size(), 2 );
      BOOST_CHECK_EQUAL( idoc2.empty(), false );
      // check idoc unchanged
      BOOST_CHECK_EQUAL( idoc.version(), version );
      BOOST_CHECK_EQUAL( idoc[ 0 ].label(), label1 );
      BOOST_CHECK_EQUAL( idoc[ 1 ].label(), label2 );
      BOOST_CHECK_EQUAL( idoc.size(), 2 );
      BOOST_CHECK_EQUAL( idoc.empty(), false );
   }

   {
      // assignement
      core::input_document idoc2( 1 );
      BOOST_CHECK_EQUAL( idoc2.size(), 0 );
      BOOST_CHECK_EQUAL( idoc2.empty(), true );
      BOOST_CHECK_EQUAL( idoc2.version(), 1 );

      idoc2 = idoc;
      BOOST_CHECK_EQUAL( idoc2.version(), version );
      BOOST_CHECK_EQUAL( idoc2[ 0 ].label(), label1 );
      BOOST_CHECK_EQUAL( idoc2[ 1 ].label(), label2 );
      BOOST_CHECK_EQUAL( idoc2.size(), 2 );
      BOOST_CHECK_EQUAL( idoc2.empty(), false );
      // check idoc unchanged
      BOOST_CHECK_EQUAL( idoc.version(), version );
      BOOST_CHECK_EQUAL( idoc[ 0 ].label(), label1 );
      BOOST_CHECK_EQUAL( idoc[ 1 ].label(), label2 );
      BOOST_CHECK_EQUAL( idoc.size(), 2 );
      BOOST_CHECK_EQUAL( idoc.empty(), false );
   }

   {
      // move
      core::input_document idoc2( idoc );
      core::input_document idoc3( std::move( idoc2 ) );
      BOOST_CHECK_EQUAL( idoc2.size(), 0 );
      BOOST_CHECK_EQUAL( idoc2.empty(), true );
      // value of idoc2.version is probably implementation dependent

      BOOST_CHECK_EQUAL( idoc3.version(), version );
      BOOST_CHECK_EQUAL( idoc3[ 0 ].label(), label1 );
      BOOST_CHECK_EQUAL( idoc3[ 1 ].label(), label2 );
      BOOST_CHECK_EQUAL( idoc3.size(), 2 );
      BOOST_CHECK_EQUAL( idoc3.empty(), false );
   }
}
{
   core::input_document idoc( 0 );
   boost::archive::text_iarchive ia( store );
   ia >> idoc;

   // check idoc unchanged
   BOOST_CHECK_EQUAL( idoc.version(), version );
   BOOST_CHECK_EQUAL( idoc[ 0 ].label(), label1 );
   BOOST_CHECK_EQUAL( idoc[ 1 ].label(), label2 );
   BOOST_CHECK_EQUAL( idoc.size(), 2 );
   BOOST_CHECK_EQUAL( idoc.empty(), false );
   // Write test
   {
      std::stringstream output;
      idoc.write( output );
      const std::string result { output.str() };
      boost::tokenizer< boost::escaped_list_separator< char > > tok(result, { "\\", " \n\t", "\"\'" } );
      std::vector< std::string > wordlist = { core::strngs::fsfver(), "21", "", label1, "end", "", label2, "end" };
      BOOST_CHECK( std::equal( wordlist.begin(), wordlist.end(), tok.begin() ) );
      auto t_iter = tok.begin();
      for (auto w_iter = wordlist.begin(); w_iter != wordlist.end(); ++w_iter, ++t_iter)
      {
         BOOST_CHECK_EQUAL( *t_iter, *w_iter );
      }
   }}
!!!471856.cpp!!!	input_definition_test() : void
{
  // Static Lifetime method tests: noncopyable virtual pattern
  BOOST_CHECK( not std::is_default_constructible< core::input_definition >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< core::input_definition >::type{} );
  BOOST_CHECK( not std::is_move_constructible< core::input_definition >::type{} );
  BOOST_CHECK( not( std::is_assignable< core::input_definition, core::input_definition >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< core::input_definition >::type{} );
}
// ----------
const std::string label1 { "label1" };
const std::string description1 { "blab blah belch" };
const std::string seclabel { "label2" };
const std::string name1 { "name1" };
const std::string desc1 { "desc1" };
const std::string name2 { "name2" };
const std::string desc2 { "desc2" };
{
  // default
  core::input_definition idoc( label1, description1 );
  BOOST_CHECK_EQUAL( idoc.label(), label1 );
  BOOST_CHECK_EQUAL( idoc.description(), description1 );
  BOOST_CHECK_EQUAL( idoc.size(), 0 );
  BOOST_CHECK_EQUAL( idoc.empty(), true );

  BOOST_CHECK_NO_THROW( idoc.add_definition( { name1, "", "", "", desc1 } ) );
  BOOST_CHECK( idoc.has_definition( name1 ) );
  BOOST_CHECK_EQUAL( idoc.size(), 1 );
  BOOST_CHECK_EQUAL( idoc.empty(), false );

  BOOST_CHECK_NO_THROW( idoc.add_definition( { name2, "", "", "", desc2 } ) );
  BOOST_CHECK( idoc.has_definition( name2 ) );
  BOOST_CHECK_EQUAL( idoc.size(), 2 );

  core::input_help helper;

  idoc.publish_help( helper, seclabel );

  std::stringstream store;
  std::string nul_string;
  helper.write( nul_string, store );

  const std::string msg( store.str() );
  //std::cout << msg << "\n";
  BOOST_CHECK_LT( msg.find( name1 + "\n          " + desc1 ), msg.size() );
  BOOST_CHECK_LT( msg.find( name2 + "\n          " + desc2 ), msg.size() );

  // Attempt to add definition with existing name.
  try
  {
    idoc.add_definition( { name1, "", "", "", desc1 } );
    BOOST_ERROR( "expected \"idoc.add_definition( name1, desc1 )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Can not overwrite existing definition" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}


!!!899120.cpp!!!	test_meta_lifetime_test() : void
// CTOR TESTS
core_test_suite::test_input_base_meta< test_meta >();
// test test_meta attribute initialisation.
{
  const std::string label( "name" );
  std::unique_ptr< test_meta > dobj( new test_meta( label, true, false ) );
  BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 0ul );
  BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 0ul );
  BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 0ul );
}
!!!899248.cpp!!!	test_meta_publish_help_test() : void
{
  // 
  // Call publish_help, all other attributes unaffected.
  // 
  std::unique_ptr< test_meta > dobj( new test_meta( "label" ) );
  BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 0ul );
  {
    core::input_help dummy;
    dobj->publish_help( dummy );
    BOOST_CHECK_EQUAL( dobj->entry_map().size(), 0ul );
    BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 0ul );
    BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 0ul );
    BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 1ul );
  }
}
!!!891952.cpp!!!	test_meta_read_section_test() : void
const std::string label( "name" );
{
  //
  // Read section with no name/value pairs
  //
  std::unique_ptr< test_meta > dobj( new test_meta( label ) );
  {
    core::input_reader dummy;
    dummy.add_buffer( "test_filename", "name\n# comment\nend\n" );
    while( dummy.next() )
    {
      if( dummy.name() == "name" )
      {
        dobj->read_section( dummy );
        BOOST_CHECK_EQUAL( dobj->entry_map().size(), 0ul );
        BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 0ul );
        BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 0ul );
      }
    }
  }
  {
    core::input_help dummy;
    dobj->publish_help( dummy );
    BOOST_CHECK_EQUAL( dobj->entry_map().size(), 0ul );
    BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 0ul );
    BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 1ul );
  }
}
{
  //
  // Read section with one name/value pair
  //
  std::unique_ptr< test_meta > dobj( new test_meta( label ) );
  {
    core::input_reader dummy;
    dummy.add_buffer( "test_filename", "name\nhello world\nend\n" );
    while( dummy.next() )
    {
      if( dummy.name() == "name" )
      {
        dobj->read_section( dummy );
        BOOST_CHECK_EQUAL( dobj->entry_map().size(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
      }
    }
  }
}
{
  //
  // Read section with three name/value pair
  //
  std::unique_ptr< test_meta > dobj( new test_meta( label ) );
  {
    core::input_reader dummy;
    dummy.add_buffer( "test_filename", "name\n# comment\na\nb c\nd e # hmm\nend\n" );
    while( dummy.next() )
    {
      if( dummy.name() == "name" )
      {
        dobj->read_section( dummy );
        BOOST_CHECK_EQUAL( dobj->entry_map().size(), 3ul );
        BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 3ul );
        BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 0ul );
      }
    }
  }
  {
    core::input_help dummy;
    dobj->publish_help( dummy );
    BOOST_CHECK_EQUAL( dobj->entry_map().size(), 3ul );
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "a" ), 1 );
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "b" ), 1 );
    if( dobj->entry_map().count( "b" ) >= 1 )
    {
      BOOST_CHECK_EQUAL( dobj->entry_map().find( "b" )->second, "c" );
    }
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "d" ), 1 );
    if( dobj->entry_map().count( "d" ) >= 1 )
    {
      BOOST_CHECK_EQUAL( dobj->entry_map().find( "d" )->second, "e" );
    }
    BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 3ul );
    BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 1ul );
  }
}
{
  //
  // Read section with three name/value pair, one duplicated
  //
  std::unique_ptr< test_meta > dobj( new test_meta( label ) );
  {
    core::input_reader dummy;
    dummy.add_buffer( "test_filename", "name\n# comment\na\nb c\nb e # hmm\nend\n" );
    // second value of "b" silently ignored.
    while( dummy.next() )
    {
      if( dummy.name() == "name" )
      {
        dobj->read_section( dummy );
        BOOST_CHECK_EQUAL( dobj->entry_map().size(), 2ul );
        BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 3ul );
        BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 0ul );
      }
    }
  }
  {
    core::input_help dummy;
    dobj->publish_help( dummy );
    BOOST_CHECK_EQUAL( dobj->entry_map().size(), 2ul );
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "a" ), 1 );
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "b" ), 1 );
    if( dobj->entry_map().count( "b" ) >= 1 )
    {
      BOOST_CHECK_EQUAL( dobj->entry_map().find( "b" )->second, "c" );
    }
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "d" ), 0 );
    BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 3ul );
    BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 1ul );
  }
}



!!!405553.cpp!!!	input_delegater_lifetime_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< core::input_delegater >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< core::input_delegater >::type{} );
  BOOST_CHECK( not std::is_move_constructible< core::input_delegater >::type{} );
  BOOST_CHECK( not( std::is_assignable< core::input_delegater, core::input_delegater >::type{} ) );
  BOOST_CHECK( not( std::has_virtual_destructor< core::input_delegater >::type{} ) );
}
{
  // Construct delegater 
  core::input_delegater dlgater( 1 );
  BOOST_CHECK( dlgater.empty() );
  BOOST_CHECK_EQUAL( dlgater.size(), 0 );
  BOOST_CHECK_EQUAL( dlgater.max_version(), 1 );
  BOOST_CHECK_EQUAL( dlgater.read_version(), 0 );
}

!!!898608.cpp!!!	input_delegater_add_input_delegate_test() : void
{
  const std::string label1( "label_one" );
  const std::string label2( "label_two" );
  boost::shared_ptr< test_meta > sobj1( new test_meta( label1, false, false ) );
  boost::shared_ptr< test_meta > sobj2( new test_meta( label2, true, false ) );

  // Construct delegater
  core::input_delegater dlgater( 1 );

  // add first delegater
  dlgater.add_input_delegate( sobj1 );
  BOOST_CHECK( not dlgater.empty() );
  BOOST_CHECK_EQUAL( dlgater.size(), 1 );
  BOOST_CHECK( dlgater.has_section( label1 ) );
  BOOST_CHECK( not dlgater.has_section( label2 ) );

  // add second delegater
  dlgater.add_input_delegate( sobj2 );
  BOOST_CHECK( not dlgater.empty() );
  BOOST_CHECK_EQUAL( dlgater.size(), 2 );
  BOOST_CHECK( dlgater.has_section( label1 ) );
  BOOST_CHECK( dlgater.has_section( label2 ) );

  // Process input buffer
  {
    core::input_reader dummy;
    dummy.add_buffer( "test_filename", "label_one\n# comment\na\nb c\nd e # hmm\nend\n" );

    dlgater.read_input( dummy );

    BOOST_CHECK_EQUAL( sobj1->get_read_entry_count(), 3ul );
    BOOST_CHECK_EQUAL( sobj1->get_read_end_count(), 1ul );

    BOOST_CHECK_EQUAL( sobj2->get_read_entry_count(), 0ul );
    BOOST_CHECK_EQUAL( sobj2->get_read_end_count(), 0ul );
  }
}
{
  // Construct delegater and add two meta objects with the same section name
  const std::string label1( "label_one" );
  const std::string label2( "label_two" );
  boost::shared_ptr< test_meta > sobj1( new test_meta( label1, false, false ) );
  boost::shared_ptr< test_meta > sobj2( new test_meta( label2, true, false ) );
  boost::shared_ptr< test_meta > sobj3( new test_meta( label2, true, false ) );

  core::input_delegater dlgater( 1 );
  dlgater.add_input_delegate( sobj1 );
  dlgater.add_input_delegate( sobj2 );
  try
  {
    dlgater.add_input_delegate( sobj3 );
    BOOST_ERROR( "expected \"dlgater.add_input_delegate( sobj3 )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Can not add two meta objects for the same input section.\"label_two\"" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
!!!898736.cpp!!!	input_delegater_input_file_versioning_test() : void
{
  // Test valid file version processed
  boost::shared_ptr< core::input_base_meta > dobj( new test_meta( "test" ) );

  const std::string canon_input( "fileversion \t1\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj );

  BOOST_CHECK_NO_THROW( var1.read_input( dummy ) );
  BOOST_CHECK_EQUAL( var1.read_version(), 1ul );
}
{
  // Test invalid file version processed
  boost::shared_ptr< core::input_base_meta > dobj( new test_meta( "test" ) );
  const std::string canon_input( "fileversion 2\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );
  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "File version 2 is too recent for this program" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
{
  // Test invalid file version (non-number) processed
  boost::shared_ptr< core::input_base_meta > dobj( new test_meta( "test" ) );
  const std::string canon_input( "fileversion A2016\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );
  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Non-numeric or negative file version (A2016) is invalid" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
{
  // Test invalid file version (negative number) processed
  boost::shared_ptr< core::input_base_meta > dobj( new test_meta( "test" ) );
  const std::string canon_input( "fileversion -1\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );
  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Non-numeric or negative file version (-1) is invalid" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
!!!898864.cpp!!!	input_delegater_input_sections_test() : void
{
  // Test valid input with sections
  boost::shared_ptr< test_meta > dobj1( new test_meta( "test_one" ) );
  boost::shared_ptr< test_meta > dobj2( new test_meta( "test_two" ) );
  boost::shared_ptr< test_meta > dobj3( new test_meta( "test_three" ) );

  const std::string canon_input( "fileversion 1\ntest_one\nend\ntest_two\n\nend\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj1 );
  var1.add_input_delegate( dobj2 );
  var1.add_input_delegate( dobj3 );

  BOOST_CHECK_NO_THROW( var1.read_input( dummy ) );

  BOOST_CHECK_EQUAL( dobj1->get_read_end_count(), 1ul );
  BOOST_CHECK_EQUAL( dobj2->get_read_end_count(), 1ul );
  BOOST_CHECK_EQUAL( dobj3->get_read_end_count(), 0ul );
}
{
  // Test invalid input (unknown section)
  boost::shared_ptr< core::input_base_meta > dobj1( new test_meta( "test_one" ) );
  boost::shared_ptr< core::input_base_meta > dobj2( new test_meta( "test_two" ) );
  boost::shared_ptr< core::input_base_meta > dobj3( new test_meta( "test_three" ) );

  const std::string canon_input( "fileversion 1\ntest_one\nend\ntest4\n\nend\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj1 );
  var1.add_input_delegate( dobj2 );
  var1.add_input_delegate( dobj3 );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Name test4 is not a valid input section label" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
{
  // Test invalid input (missing required section)
  boost::shared_ptr< core::input_base_meta > dobj1( new test_meta( "test_one" ) );
  boost::shared_ptr< core::input_base_meta > dobj2( new test_meta( "test_two" ) );
  boost::shared_ptr< core::input_base_meta > dobj3( new test_meta( "test_three", false, true ) );

  const std::string canon_input( "fileversion 1\ntest_one\nend\ntest_two\n\nend\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj1 );
  var1.add_input_delegate( dobj2 );
  var1.add_input_delegate( dobj3 );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Missing input file section: test_three" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
{
  // Test valid input (repeated multiple section)
  boost::shared_ptr< core::input_base_meta > dobj1( new test_meta( "test_one" ) );
  boost::shared_ptr< test_meta > dobj2( new test_meta( "test_two", true, false ) );

  const std::string canon_input( "fileversion 1\ntest_one\nend\ntest_two\n\nend\ntest_two\n\nend\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj1 );
  var1.add_input_delegate( dobj2 );

  BOOST_CHECK_NO_THROW( var1.read_input( dummy ) );
  BOOST_CHECK_EQUAL( dobj2->get_read_end_count(), 2ul );
}
{
  // Test invalid input (repeated non-multiple section)
  boost::shared_ptr< core::input_base_meta > dobj1( new test_meta( "test_one" ) );
  boost::shared_ptr< core::input_base_meta > dobj2( new test_meta( "test_two" ) );

  const std::string canon_input( "fileversion 1\ntest_one\nend\ntest_two\n\nend\ntest_two\n\nend\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj1 );
  var1.add_input_delegate( dobj2 );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Input file section test_two appears more than once" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }

}
!!!477616.cpp!!!	output_field_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( std::is_default_constructible< core::output_field >::type{} );
  BOOST_CHECK( std::is_copy_constructible< core::output_field >::type{} );
  BOOST_CHECK( std::is_move_constructible< core::output_field >::type{} );
  BOOST_CHECK( ( std::is_assignable< core::output_field, core::output_field >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< core::output_field >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );

{
  core::output_field aset;
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );
  {
    // Output error if no entries
    core::output_field copy( aset );
    try
    {
      copy.write( std::cout, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }

  aset.set_label( label1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_unit( unit1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_format_function( []( std::ostream& os, std::size_t i )
  {
    os << i;
  } );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );
  {
    // Output should work
    std::stringstream store;
    BOOST_CHECK_NO_THROW( aset.write( store, 0 ) );
    const std::string output( store.str() );
    BOOST_CHECK( not output.empty() );
    BOOST_CHECK_EQUAL( output.size(), 1 );
    BOOST_CHECK_EQUAL( output, "0" );
  }
  {
    // Output should work
    std::stringstream store;
    BOOST_CHECK_NO_THROW( aset.write( store, 101 ) );
    const std::string output( store.str() );
    BOOST_CHECK( not output.empty() );
    BOOST_CHECK_EQUAL( output.size(), 3 );
    BOOST_CHECK_EQUAL( output, "101" );
  }
  core::output_field bset;
  BOOST_CHECK_EQUAL( bset.label(), emptr_str );
  BOOST_CHECK_EQUAL( bset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( bset.valid(), false );

  bset = aset;
  BOOST_CHECK_EQUAL( bset.unit(), unit1 );
  BOOST_CHECK_EQUAL( bset.label(), label1 );
  BOOST_CHECK_EQUAL( bset.valid(), true );

  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  core::output_field cset( aset );
  BOOST_CHECK_EQUAL( cset.unit(), unit1 );
  BOOST_CHECK_EQUAL( cset.label(), label1 );
  BOOST_CHECK_EQUAL( cset.valid(), true );

  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  aset = aset;
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  core::output_field dset( std::move( aset ) );
  BOOST_CHECK_EQUAL( dset.unit(), unit1 );
  BOOST_CHECK_EQUAL( dset.label(), label1 );
  BOOST_CHECK_EQUAL( dset.valid(), true );

  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  core::output_field eset;
  BOOST_CHECK_EQUAL( eset.label(), emptr_str );
  BOOST_CHECK_EQUAL( eset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( eset.valid(), false );

  std::swap( eset, bset );
  BOOST_CHECK_EQUAL( eset.unit(), unit1 );
  BOOST_CHECK_EQUAL( eset.label(), label1 );
  BOOST_CHECK_EQUAL( eset.valid(), true );

  BOOST_CHECK_EQUAL( bset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( bset.label(), emptr_str );
  BOOST_CHECK_EQUAL( bset.valid(), false );
}
!!!484912.cpp!!!	output_series_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( std::is_default_constructible< core::output_series >::type{} );
  BOOST_CHECK( std::is_copy_constructible< core::output_series >::type{} );
  BOOST_CHECK( std::is_move_constructible< core::output_series >::type{} );
  BOOST_CHECK( ( std::is_assignable< core::output_series, core::output_series >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< core::output_series >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
const std::string test_fname
{ "result.dat"
};
const std::string test_uuid
{ "1a2b3c4d"
};
const std::string test_title
{ "Something or other."
};
{
  core::output_series aset;
  BOOST_CHECK_EQUAL( aset.title(), emptr_str );
  BOOST_CHECK_EQUAL( aset.uuid(), emptr_str );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  aset.set_uuid( test_uuid );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.title(), emptr_str );

  aset.set_title( test_title );
  BOOST_CHECK_EQUAL( aset.title(), test_title );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_series bset;
  BOOST_CHECK_EQUAL( bset.title(), emptr_str );
  BOOST_CHECK_EQUAL( bset.uuid(), emptr_str );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  bset = aset;
  BOOST_CHECK_EQUAL( bset.title(), test_title );
  BOOST_CHECK_EQUAL( bset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_series cset( aset );
  BOOST_CHECK_EQUAL( cset.title(), test_title );
  BOOST_CHECK_EQUAL( cset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  aset = aset;
  BOOST_CHECK_EQUAL( aset.title(), test_title );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_series dset( std::move( aset ) );
  BOOST_CHECK_EQUAL( dset.title(), test_title );
  BOOST_CHECK_EQUAL( dset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  // Output error if no entries
  {
    core::output_series dsetcp( dset );
    try
    {
      dsetcp.do_header( std::cout );
      BOOST_ERROR( "expected \"dsetcp.do_header( std::cout )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  {
    core::output_series dsetcp( dset );
    try
    {
      dsetcp.do_body( std::cout );
      BOOST_ERROR( "expected \"dsetcp.do_body( std::cout )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  {
    utility::memory_sink sink;
    core::output_series dsetcp( dset );
    try
    {
      dsetcp.write( test_fname, sink, true );
      BOOST_ERROR( "expected \"dsetcp.write( test_fname, sink, true )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  {
    utility::memory_sink sink;
    core::output_series dsetcp( dset );
    try
    {
      dsetcp.write( test_fname, sink, false );
      BOOST_ERROR( "expected \"dsetcp.write( test_fname, sink, false )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
}
struct person
{
  std::string name;
  std::size_t day_of_birth;
  std::size_t month_of_birth;
  std::size_t year_of_birth;
};

struct family
{
  std::vector< person > ppl;
  std::size_t day( std::size_t i ) const
  {
    return ppl[ i ].day_of_birth;
  }
  std::size_t month( std::size_t i ) const
  {
    return ppl[ i ].month_of_birth;
  }
  std::size_t year( std::size_t i ) const
  {
    return ppl[ i ].year_of_birth;
  }
  std::string name( std::size_t i ) const
  {
    return ppl[ i ].name;
  }
  std::size_t size() const
  {
    return ppl.size();
  }
};

const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  person me { "justin", 17, 4, 1965 };

  core::output_series dset( test_uuid );
  dset.set_title( test_title );
  dset.push_back_entry( core::output_field( label1, unit1, [&me]( std::ostream& os, std::size_t )
  {
    os << me.name;
  } ) );
  dset.push_back_entry( core::output_field( label2, unit2, [&me]( std::ostream& os, std::size_t )
  {
    os << me.day_of_birth;
  } ) );
  dset.push_back_entry( core::output_field( label3, unit3, [&me]( std::ostream& os, std::size_t )
  {
    os << me.month_of_birth;
  } ) );
  dset.push_back_entry( core::output_field( label4, unit4, [&me]( std::ostream& os, std::size_t )
  {
    os << me.year_of_birth;
  } ) );

  {
    std::stringstream store;
    dset.do_header( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_NE( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_NE( output.find( test_title ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
  }
  {
    std::stringstream store;
    dset.do_body( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_EQUAL( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
    BOOST_CHECK_NE( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_NE( output.find( "1965" ), std::string::npos );
  }
}
!!!471728.cpp!!!	output_dataset_test() : void
// CTOR TESTS
// ----------
std::string emptr_str;
const std::string test_fname { "result.dat" };
const std::string test_uuid { "1a2b3c4d" };
const std::string test_title { "Something or other." };
{
  core::output_dataset aset;
  BOOST_CHECK_EQUAL( aset.title(), emptr_str );
  BOOST_CHECK_EQUAL( aset.uuid(), emptr_str );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  aset.set_uuid( test_uuid );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.title(), emptr_str );

  aset.set_title( test_title );
  BOOST_CHECK_EQUAL( aset.title(), test_title );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_dataset bset;
  BOOST_CHECK_EQUAL( bset.title(), emptr_str );
  BOOST_CHECK_EQUAL( bset.uuid(), emptr_str );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  bset = aset;
  BOOST_CHECK_EQUAL( bset.title(), test_title );
  BOOST_CHECK_EQUAL( bset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_dataset cset( aset );
  BOOST_CHECK_EQUAL( cset.title(), test_title );
  BOOST_CHECK_EQUAL( cset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  aset = aset;
  BOOST_CHECK_EQUAL( aset.title(), test_title );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_dataset dset( std::move( aset ) );
  BOOST_CHECK_EQUAL( dset.title(), test_title );
  BOOST_CHECK_EQUAL( dset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  // Output error if no entries
  {
    core::output_dataset dsetcp( dset );
    try
    {
      dsetcp.do_header( std::cout );
      BOOST_ERROR( "expected \"dsetcp.do_header( std::cout )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  {
    core::output_dataset dsetcp( dset );
    try
    {
      dsetcp.do_body( std::cout );
      BOOST_ERROR( "expected \"dsetcp.do_body( std::cout )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write data set without any fields" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  {
    utility::memory_sink sink;
    core::output_dataset dsetcp( dset );
    try
    {
      dsetcp.write( test_fname, sink );
      BOOST_ERROR( "expected \"dsetcp.write( test_fname, sink )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write data set without any fields" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
}
struct person
{
  std::string name;
  std::size_t day_of_birth;
  std::size_t month_of_birth;
  std::size_t year_of_birth;
};

struct family
{
  std::vector< person > ppl;
  std::size_t day( std::size_t i ) const
  {
    return ppl[ i ].day_of_birth;
  }
  std::size_t month( std::size_t i ) const
  {
    return ppl[ i ].month_of_birth;
  }
  std::size_t year( std::size_t i ) const
  {
    return ppl[ i ].year_of_birth;
  }
  std::string name( std::size_t i ) const
  {
    return ppl[ i ].name;
  }
  std::size_t size() const
  {
    return ppl.size();
  }
};

const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  person me { "justin", 17, 4, 1965 };

  core::output_dataset dset( { test_uuid }, []()
  {
    return 1;
  } );
  dset.set_title( test_title );
  dset.push_back_entry( core::output_field( label1, unit1, [&me]( std::ostream& os, std::size_t )
  {
    os << me.name;
  } ) );
  dset.push_back_entry( core::output_field( label2, unit2, [&me]( std::ostream& os, std::size_t )
  {
    os << me.day_of_birth;
  } ) );
  dset.push_back_entry( core::output_field( label3, unit3, [&me]( std::ostream& os, std::size_t )
  {
    os << me.month_of_birth;
  } ) );
  dset.push_back_entry( core::output_field( label4, unit4, [&me]( std::ostream& os, std::size_t )
  {
    os << me.year_of_birth;
  } ) );

  {
    std::stringstream store;
    dset.do_header( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_NE( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_NE( output.find( test_title ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
  }
  {
    std::stringstream store;
    dset.do_body( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_EQUAL( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
    BOOST_CHECK_NE( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_NE( output.find( "1965" ), std::string::npos );
  }
}

{
  family myfamily;
  myfamily.ppl.push_back( { "justin", 17, 4, 1965 } );
  myfamily.ppl.push_back( { "sean", 15, 4, 1969 } );
  myfamily.ppl.push_back( { "debi", 8, 2, 1963 } );
  myfamily.ppl.push_back( { "susan", 19, 6, 1953 } );
  myfamily.ppl.push_back( { "peabody", 1, 1, 2012 } );
  core::output_dataset dset( { test_uuid }, [&myfamily]()
  {
    return myfamily.size();
  } );
  dset.push_back_entry( core::output_field( label1, unit1, [&myfamily]( std::ostream& os, std::size_t i )
  {
    os << myfamily.name( i );
  } ) );
  dset.push_back_entry( core::output_field( label2, unit2, [&myfamily]( std::ostream& os, std::size_t i )
  {
    os << myfamily.ppl[ i ].day_of_birth;
  } ) );
  dset.push_back_entry( core::output_field( label3, unit3, [&myfamily]( std::ostream& os, std::size_t i )
  {
    os << myfamily.month( i );
  } ) );
  dset.push_back_entry( core::output_field( label4, unit4, [&myfamily]( std::ostream& os, std::size_t i )
  {
    os << myfamily.year( i );
  } ) );

  {
    std::stringstream store;
    dset.do_header( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_NE( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "TITLE" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
  }
  dset.set_title( test_title );
  {
    std::stringstream store;
    dset.do_header( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_NE( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_NE( output.find( "TITLE" ), std::string::npos );
    BOOST_CHECK_NE( output.find( test_title ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
  }
  {
    std::stringstream store;
    dset.do_body( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_EQUAL( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "TITLE" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
    BOOST_CHECK_NE( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_NE( output.find( "1965" ), std::string::npos );
    BOOST_CHECK_NE( output.find( "peabody" ), std::string::npos );
    BOOST_CHECK_EQUAL( std::count( output.begin(), output.end(), '\n' ), 5 );
  }
}

!!!1694256.cpp!!!	output_filter_lifetime_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< core::fixed_width_output_filter >::type{} );
  BOOST_CHECK( std::is_copy_constructible< core::fixed_width_output_filter >::type{} );
  BOOST_CHECK( std::is_move_constructible< core::fixed_width_output_filter >::type{} );
  BOOST_CHECK( ( std::is_assignable< core::fixed_width_output_filter, core::fixed_width_output_filter >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< core::fixed_width_output_filter >::type{} );
}
// CTOR TESTS
// ----------
{
  core::fixed_width_output_filter aset( 0, 0, 0 );
  BOOST_CHECK_EQUAL( aset.text_width(), 0ul );
  BOOST_CHECK_EQUAL( aset.depth(), 0ul );
  BOOST_CHECK_EQUAL( aset.indent_size(), 0ul );
}
{
  core::fixed_width_output_filter aset( 2, 1, 40 );
  BOOST_CHECK_EQUAL( aset.text_width(), 40ul );
  BOOST_CHECK_EQUAL( aset.depth(), 1ul );
  BOOST_CHECK_EQUAL( aset.indent_size(), 2ul );
  {
    core::fixed_width_output_filter aset1( aset );
    BOOST_CHECK_EQUAL( aset1.text_width(), 40ul );
    BOOST_CHECK_EQUAL( aset1.depth(), 1ul );
    BOOST_CHECK_EQUAL( aset1.indent_size(), 2ul );
  }
  {
    core::fixed_width_output_filter aset2( aset );
    core::fixed_width_output_filter aset1( std::move( aset2 ) );
    BOOST_CHECK_EQUAL( aset1.text_width(), 40ul );
    BOOST_CHECK_EQUAL( aset1.depth(), 1ul );
    BOOST_CHECK_EQUAL( aset1.indent_size(), 2ul );
  }
}
!!!1694640.cpp!!!	output_filter_method_test() : void
// USAGE TESTS
// ----------
{
  core::fixed_width_output_filter aset( 2, 1, 10 );
  namespace io = boost::iostreams;
  {
    std::stringstream result;
    const std::string input( "This is some text that I want to format." );
    const std::string output( "  This is \n  some \n  text \n  that I \n  want to \n  format." );
    {
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    //std::cout << "\n--\n" << resultstr << "\n--\n";
    //std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( "Now for some exceedingly elongated words." );
    const std::string output( "  Now for \n  some \n  exceedin\n  gly \n  elongate\n  d words." );
    {
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    //std::cout << "\n--\n" << resultstr << "\n--\n";
    //std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( "Now to change the indenting." );
    const std::string output( "    Now to\n    change\n    the \n    indent\n    ing." );
    {
      aset.increment_depth();
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    //std::cout << "\n--\n" << resultstr << "\n--\n";
    //std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( " a b c  d e f g h i j k l m n o p" );
    const std::string output( "  a b c  d\n  e f g h \n  i j k l \n  m n o p" );
    {
      aset.decrement_depth();
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    //std::cout << "\n--\n" << resultstr << "\n--\n";
    //std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( " 1234567890 1234567890" );
    const std::string output( "  12345678\n  90 \n  12345678\n  90" );
    {
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    //std::cout << "\n--\n" << resultstr << "\n--\n";
    //std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( " 1234567890 1234567890" );
    const std::string output( "1234567890\n1234567890" );
    {
      aset.decrement_depth();
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    //std::cout << "\n--\n" << resultstr << "\n--\n";
    //std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( " -12.34567890 1234.567890" );
    const std::string output( "-12.345678\n90 \n1234.56789\n0" );
    {
      aset.decrement_depth();
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    //std::cout << "\n--\n" << resultstr << "\n--\n";
    //std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
}
!!!1710640.cpp!!!	indent_guard_lifetime_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< core::indent_guard >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< core::indent_guard >::type{} );
  BOOST_CHECK( not std::is_move_constructible< core::indent_guard >::type{} );
  BOOST_CHECK( not ( std::is_assignable< core::indent_guard, core::indent_guard >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< core::indent_guard >::type{} );
}
// CTOR TESTS
// ----------
{
  core::fixed_width_output_filter aset( 2, 1, 40 );
  BOOST_CHECK_EQUAL( aset.depth(), 1ul );
  {
    core::indent_guard grd( aset );
    BOOST_CHECK_EQUAL( aset.depth(), 2ul );
  }
  BOOST_CHECK_EQUAL( aset.depth(), 1ul );
}
!!!1728944.cpp!!!	help_entry_lifetime_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( std::is_default_constructible< core::help_entry >::type{} );
  BOOST_CHECK( std::is_copy_constructible< core::help_entry >::type{} );
  BOOST_CHECK( std::is_move_constructible< core::help_entry >::type{} );
  BOOST_CHECK( ( std::is_assignable< core::help_entry, core::help_entry >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< core::help_entry >::type{} );
}
// CTOR TESTS
// ----------
const std::string nul_string;
const std::string title( "title" );
const std::string type_desc( "integral number" );
const std::string range( "> 0" );
const std::string defval( "10" );
const std::string desc( "blah blah blah" );
std::stringstream store;
{
  core::help_entry hentry;
  BOOST_CHECK_EQUAL( hentry.default_value(), nul_string );
  BOOST_CHECK_EQUAL( hentry.description(), nul_string );
  BOOST_CHECK_EQUAL( hentry.range(), nul_string );
  BOOST_CHECK_EQUAL( hentry.title(), nul_string );
  BOOST_CHECK_EQUAL( hentry.type_desc(), nul_string );
}
{
  core::help_entry hentry( title, type_desc, range, defval, desc );
  BOOST_CHECK_EQUAL( hentry.default_value(), defval );
  BOOST_CHECK_EQUAL( hentry.description(), desc );
  BOOST_CHECK_EQUAL( hentry.range(), range );
  BOOST_CHECK_EQUAL( hentry.title(), title );
  BOOST_CHECK_EQUAL( hentry.type_desc(), type_desc );
  {
    core::help_entry hentry1( hentry );
    BOOST_CHECK_EQUAL( hentry1.default_value(), defval );
    BOOST_CHECK_EQUAL( hentry1.description(), desc );
    BOOST_CHECK_EQUAL( hentry1.range(), range );
    BOOST_CHECK_EQUAL( hentry1.title(), title );
    BOOST_CHECK_EQUAL( hentry1.type_desc(), type_desc );
  }
  {
    core::help_entry hentry1;
    BOOST_CHECK_EQUAL( hentry1.default_value(), nul_string );
    BOOST_CHECK_EQUAL( hentry1.description(), nul_string );
    BOOST_CHECK_EQUAL( hentry1.range(), nul_string );
    BOOST_CHECK_EQUAL( hentry1.title(), nul_string );
    BOOST_CHECK_EQUAL( hentry1.type_desc(), nul_string );
    hentry1 = hentry;
    BOOST_CHECK_EQUAL( hentry1.default_value(), defval );
    BOOST_CHECK_EQUAL( hentry1.description(), desc );
    BOOST_CHECK_EQUAL( hentry1.range(), range );
    BOOST_CHECK_EQUAL( hentry1.title(), title );
    BOOST_CHECK_EQUAL( hentry1.type_desc(), type_desc );
  }
  {
    core::help_entry hentry2( hentry );
    core::help_entry hentry1( std::move( hentry2 ) );
    BOOST_CHECK_EQUAL( hentry1.default_value(), defval );
    BOOST_CHECK_EQUAL( hentry1.description(), desc );
    BOOST_CHECK_EQUAL( hentry1.range(), range );
    BOOST_CHECK_EQUAL( hentry1.title(), title );
    BOOST_CHECK_EQUAL( hentry1.type_desc(), type_desc );
  }
  boost::archive::text_oarchive oa( store );
  oa << hentry;
}
{
  core::help_entry hentry;
  BOOST_CHECK_EQUAL( hentry.default_value(), nul_string );
  BOOST_CHECK_EQUAL( hentry.description(), nul_string );
  BOOST_CHECK_EQUAL( hentry.range(), nul_string );
  BOOST_CHECK_EQUAL( hentry.title(), nul_string );
  BOOST_CHECK_EQUAL( hentry.type_desc(), nul_string );
  boost::archive::text_iarchive ia( store );
  ia >> hentry;
  BOOST_CHECK_EQUAL( hentry.default_value(), defval );
  BOOST_CHECK_EQUAL( hentry.description(), desc );
  BOOST_CHECK_EQUAL( hentry.range(), range );
  BOOST_CHECK_EQUAL( hentry.title(), title );
  BOOST_CHECK_EQUAL( hentry.type_desc(), type_desc );
 }
!!!1728816.cpp!!!	help_entry_method_test() : void
const std::string nul_string;
const std::string title( "title" );
const std::string type_desc( "integral number" );
const std::string range( "> 0" );
const std::string defval( "10" );
const std::string desc( "blah blah blah" );
{
  core::help_entry hentry;
  BOOST_CHECK_EQUAL( hentry.default_value(), nul_string );
  hentry.default_value( defval );
  BOOST_CHECK_EQUAL( hentry.default_value(), defval );
  BOOST_CHECK_EQUAL( hentry.description(), nul_string );
  hentry.description( desc );
  BOOST_CHECK_EQUAL( hentry.description(), desc );
  BOOST_CHECK_EQUAL( hentry.range(), nul_string );
  hentry.range( range );
  BOOST_CHECK_EQUAL( hentry.range(), range );
  BOOST_CHECK_EQUAL( hentry.title(), nul_string );
  hentry.title( title );
  BOOST_CHECK_EQUAL( hentry.title(), title );
  BOOST_CHECK_EQUAL( hentry.type_desc(), nul_string );
  hentry.type_desc( type_desc );
  BOOST_CHECK_EQUAL( hentry.type_desc(), type_desc );

  {
    const std::string output( "  title\n    [integral number: range(> 0), \n    default{10}]\n    blah blah blah\n" );
    core::fixed_width_output_filter filt( 2, 1, 40 );
    std::stringstream os;
    hentry.write( filt, os );
    //std::cout << "\n--\n" << os.str() << "\n--\n";
    BOOST_CHECK_EQUAL( os.str(), output );
  }
}
!!!1729968.cpp!!!	help_subtype_lifetime_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( std::is_default_constructible< core::help_subtype >::type{} );
  BOOST_CHECK( std::is_copy_constructible< core::help_subtype >::type{} );
  BOOST_CHECK( std::is_move_constructible< core::help_subtype >::type{} );
  BOOST_CHECK( ( std::is_assignable< core::help_subtype, core::help_subtype >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< core::help_subtype >::type{} );
}
// CTOR TESTS
// ----------
const std::string nul_string;
const std::string title( "title" );
const std::string desc( "blah blah blah" );
std::stringstream store;
{
  core::help_subtype hsubtype;
  BOOST_CHECK_EQUAL( hsubtype.description(), nul_string );
  BOOST_CHECK_EQUAL( hsubtype.title(), nul_string );
  BOOST_CHECK_EQUAL( hsubtype.size(), 0ul );
  BOOST_CHECK( hsubtype.empty() );
  BOOST_CHECK( hsubtype.begin() == hsubtype.end() );
}
{
  core::help_subtype hsubtype( title, desc );
  BOOST_CHECK_EQUAL( hsubtype.description(), desc );
  BOOST_CHECK_EQUAL( hsubtype.title(), title );
  BOOST_CHECK_EQUAL( hsubtype.size(), 0ul );
  BOOST_CHECK( hsubtype.empty() );
  BOOST_CHECK( hsubtype.begin() == hsubtype.end() );
  {
    core::help_subtype hsubtype1( hsubtype );
    BOOST_CHECK_EQUAL( hsubtype1.description(), desc );
    BOOST_CHECK_EQUAL( hsubtype1.title(), title );
    BOOST_CHECK_EQUAL( hsubtype.size(), 0ul );
    BOOST_CHECK( hsubtype.empty() );
    BOOST_CHECK( hsubtype.begin() == hsubtype.end() );
  }
  {
    core::help_subtype hsubtype1;
    BOOST_CHECK_EQUAL( hsubtype.description(), desc );
    BOOST_CHECK_EQUAL( hsubtype.title(), title );
    BOOST_CHECK_EQUAL( hsubtype.size(), 0ul );
    BOOST_CHECK( hsubtype.empty() );
    BOOST_CHECK( hsubtype.begin() == hsubtype.end() );
    hsubtype1 = hsubtype;
    BOOST_CHECK_EQUAL( hsubtype1.description(), desc );
    BOOST_CHECK_EQUAL( hsubtype1.title(), title );
    BOOST_CHECK_EQUAL( hsubtype.size(), 0ul );
    BOOST_CHECK( hsubtype.empty() );
    BOOST_CHECK( hsubtype.begin() == hsubtype.end() );
  }
  {
    core::help_subtype hsubtype2( hsubtype );
    core::help_subtype hsubtype1( std::move( hsubtype2 ) );
    BOOST_CHECK_EQUAL( hsubtype1.description(), desc );
    BOOST_CHECK_EQUAL( hsubtype1.title(), title );
    BOOST_CHECK_EQUAL( hsubtype.size(), 0ul );
    BOOST_CHECK( hsubtype.empty() );
    BOOST_CHECK( hsubtype.begin() == hsubtype.end() );
  }
  boost::archive::text_oarchive oa( store );
  oa << hsubtype;
}
{
  core::help_subtype hsubtype;
  BOOST_CHECK_EQUAL( hsubtype.description(), nul_string );
  BOOST_CHECK_EQUAL( hsubtype.title(), nul_string );
  BOOST_CHECK_EQUAL( hsubtype.size(), 0ul );
  BOOST_CHECK( hsubtype.empty() );
  BOOST_CHECK( hsubtype.begin() == hsubtype.end() );
  boost::archive::text_iarchive ia( store );
  ia >> hsubtype;
  BOOST_CHECK_EQUAL( hsubtype.description(), desc );
  BOOST_CHECK_EQUAL( hsubtype.title(), title );
  BOOST_CHECK_EQUAL( hsubtype.size(), 0ul );
  BOOST_CHECK( hsubtype.empty() );
  BOOST_CHECK( hsubtype.begin() == hsubtype.end() );
 }
!!!1729840.cpp!!!	help_subtype_method_test() : void
const std::string nul_string;
const std::string title( "title" );
const std::string type_desc( "integral number" );
const std::string range( "> 0" );
const std::string defval( "10" );
const std::string desc( "blah blah blah" );
const std::string output( "  title\n    blah blah blah\n    Options:\n    title\n      [integral number: range(> 0), \n      default{10}]\n      blah blah blah\n" );
std::stringstream store;
{
  core::help_subtype hsubtype;
  BOOST_CHECK_EQUAL( hsubtype.description(), nul_string );
  hsubtype.description( desc );
  BOOST_CHECK_EQUAL( hsubtype.description(), desc );
  BOOST_CHECK_EQUAL( hsubtype.title(), nul_string );
  hsubtype.title( title );
  BOOST_CHECK_EQUAL( hsubtype.title(), title );

  hsubtype.add_entry( { title, type_desc, range, defval, desc } );
  BOOST_CHECK_EQUAL( hsubtype.size(), 1ul );
  BOOST_CHECK( not hsubtype.empty() );
  BOOST_CHECK( hsubtype.has_entry( title ) );
  BOOST_CHECK_EQUAL( hsubtype.get_entry( title ).default_value(), defval );
  {
    core::fixed_width_output_filter filt( 2, 1, 40 );
    std::stringstream os;
    hsubtype.write( filt, os );
    //std::cout << "\n--\n" << os.str() << "\n--\n";
    BOOST_CHECK_EQUAL( os.str(), output );
  }
  boost::archive::text_oarchive oa( store );
  oa << hsubtype;
}
{
  core::help_subtype hsubtype;
  BOOST_CHECK_EQUAL( hsubtype.description(), nul_string );
  BOOST_CHECK_EQUAL( hsubtype.title(), nul_string );
  BOOST_CHECK_EQUAL( hsubtype.size(), 0ul );
  BOOST_CHECK( hsubtype.empty() );
  BOOST_CHECK( hsubtype.begin() == hsubtype.end() );
  boost::archive::text_iarchive ia( store );
  ia >> hsubtype;
  BOOST_CHECK_EQUAL( hsubtype.description(), desc );
  BOOST_CHECK_EQUAL( hsubtype.title(), title );
  BOOST_CHECK_EQUAL( hsubtype.size(), 1ul );
  BOOST_CHECK( not hsubtype.empty() );
  BOOST_CHECK( hsubtype.has_entry( title ) );
  {
    core::fixed_width_output_filter filt( 2, 1, 40 );
    std::stringstream os;
    hsubtype.write( filt, os );
    BOOST_CHECK_EQUAL( os.str(), output );
  }
}
!!!1722288.cpp!!!	help_section_lifetime_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( std::is_default_constructible< core::help_section >::type{} );
  BOOST_CHECK( std::is_copy_constructible< core::help_section >::type{} );
  BOOST_CHECK( std::is_move_constructible< core::help_section >::type{} );
  BOOST_CHECK( ( std::is_assignable< core::help_section, core::help_section >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< core::help_section >::type{} );
}
// CTOR TESTS
// ----------
const std::string nul_string;
const std::string title( "title" );
const std::string desc( "blah blah blah" );
std::stringstream store;
{
  core::help_section hsection;
  BOOST_CHECK_EQUAL( hsection.description(), nul_string );
  BOOST_CHECK_EQUAL( hsection.title(), nul_string );
  BOOST_CHECK_EQUAL( hsection.entry_size(), 0ul );
  BOOST_CHECK( hsection.entry_empty() );
  BOOST_CHECK( hsection.entry_begin() == hsection.entry_end() );
  BOOST_CHECK_EQUAL( hsection.subtype_size(), 0ul );
  BOOST_CHECK( hsection.subtype_empty() );
  BOOST_CHECK( hsection.subtype_begin() == hsection.subtype_end() );
}
{
  core::help_section hsection( title, desc );
  BOOST_CHECK_EQUAL( hsection.description(), desc );
  BOOST_CHECK_EQUAL( hsection.title(), title );
  BOOST_CHECK_EQUAL( hsection.entry_size(), 0ul );
  BOOST_CHECK( hsection.entry_empty() );
  BOOST_CHECK( hsection.entry_begin() == hsection.entry_end() );
  BOOST_CHECK_EQUAL( hsection.subtype_size(), 0ul );
  BOOST_CHECK( hsection.subtype_empty() );
  BOOST_CHECK( hsection.subtype_begin() == hsection.subtype_end() );
  {
    core::help_section hsection1( hsection );
    BOOST_CHECK_EQUAL( hsection1.description(), desc );
    BOOST_CHECK_EQUAL( hsection1.title(), title );
    BOOST_CHECK_EQUAL( hsection.entry_size(), 0ul );
    BOOST_CHECK( hsection.entry_empty() );
    BOOST_CHECK( hsection.entry_begin() == hsection.entry_end() );
    BOOST_CHECK_EQUAL( hsection.subtype_size(), 0ul );
    BOOST_CHECK( hsection.subtype_empty() );
    BOOST_CHECK( hsection.subtype_begin() == hsection.subtype_end() );
  }
  {
    core::help_section hsection1;
    BOOST_CHECK_EQUAL( hsection.description(), desc );
    BOOST_CHECK_EQUAL( hsection.title(), title );
    BOOST_CHECK_EQUAL( hsection.entry_size(), 0ul );
    BOOST_CHECK( hsection.entry_empty() );
    BOOST_CHECK( hsection.entry_begin() == hsection.entry_end() );
    BOOST_CHECK_EQUAL( hsection.subtype_size(), 0ul );
    BOOST_CHECK( hsection.subtype_empty() );
    BOOST_CHECK( hsection.subtype_begin() == hsection.subtype_end() );
    hsection1 = hsection;
    BOOST_CHECK_EQUAL( hsection1.description(), desc );
    BOOST_CHECK_EQUAL( hsection1.title(), title );
    BOOST_CHECK_EQUAL( hsection.entry_size(), 0ul );
    BOOST_CHECK( hsection.entry_empty() );
    BOOST_CHECK( hsection.entry_begin() == hsection.entry_end() );
    BOOST_CHECK_EQUAL( hsection.subtype_size(), 0ul );
    BOOST_CHECK( hsection.subtype_empty() );
    BOOST_CHECK( hsection.subtype_begin() == hsection.subtype_end() );
  }
  {
    core::help_section hsection2( hsection );
    core::help_section hsection1( std::move( hsection2 ) );
    BOOST_CHECK_EQUAL( hsection1.description(), desc );
    BOOST_CHECK_EQUAL( hsection1.title(), title );
    BOOST_CHECK_EQUAL( hsection.entry_size(), 0ul );
    BOOST_CHECK( hsection.entry_empty() );
    BOOST_CHECK( hsection.entry_begin() == hsection.entry_end() );
    BOOST_CHECK_EQUAL( hsection.subtype_size(), 0ul );
    BOOST_CHECK( hsection.subtype_empty() );
    BOOST_CHECK( hsection.subtype_begin() == hsection.subtype_end() );
  }
  boost::archive::text_oarchive oa( store );
  oa << hsection;
}
{
  core::help_section hsection;
  BOOST_CHECK_EQUAL( hsection.description(), nul_string );
  BOOST_CHECK_EQUAL( hsection.title(), nul_string );
  BOOST_CHECK_EQUAL( hsection.entry_size(), 0ul );
  BOOST_CHECK( hsection.entry_empty() );
  BOOST_CHECK( hsection.entry_begin() == hsection.entry_end() );
  BOOST_CHECK_EQUAL( hsection.subtype_size(), 0ul );
  BOOST_CHECK( hsection.subtype_empty() );
  BOOST_CHECK( hsection.subtype_begin() == hsection.subtype_end() );
  boost::archive::text_iarchive ia( store );
  ia >> hsection;
  BOOST_CHECK_EQUAL( hsection.description(), desc );
  BOOST_CHECK_EQUAL( hsection.title(), title );
  BOOST_CHECK_EQUAL( hsection.entry_size(), 0ul );
  BOOST_CHECK( hsection.entry_empty() );
  BOOST_CHECK( hsection.entry_begin() == hsection.entry_end() );
  BOOST_CHECK_EQUAL( hsection.subtype_size(), 0ul );
  BOOST_CHECK( hsection.subtype_empty() );
  BOOST_CHECK( hsection.subtype_begin() == hsection.subtype_end() );
 }
!!!1722160.cpp!!!	help_section_method_test() : void
const std::string nul_string;
const std::string title( "title" );
const std::string type_desc( "integral number" );
const std::string range( "> 0" );
const std::string defval( "10" );
const std::string desc( "blah blah blah" );
const std::string title1( "title1" );
const std::string title2( "title2" );
std::stringstream store;
{
  core::help_section hsection;
  BOOST_CHECK_EQUAL( hsection.description(), nul_string );
  hsection.description( desc );
  BOOST_CHECK_EQUAL( hsection.description(), desc );
  BOOST_CHECK_EQUAL( hsection.title(), nul_string );
  hsection.title( title );
  BOOST_CHECK_EQUAL( hsection.title(), title );

  hsection.add_entry( { title, type_desc, range, defval, desc } );
  BOOST_CHECK_EQUAL( hsection.entry_size(), 1ul );
  BOOST_CHECK( not hsection.entry_empty() );
  BOOST_CHECK( hsection.has_entry( title ) );
  BOOST_CHECK_EQUAL( hsection.get_entry( title ).default_value(), defval );
  {
    core::help_subtype hsubtype( title1, desc );
    hsubtype.add_entry( { title2, type_desc, range, defval, desc } );
    BOOST_CHECK_EQUAL( hsubtype.size(), 1ul );
    BOOST_CHECK( not hsubtype.empty() );
    BOOST_CHECK( hsubtype.has_entry( title2 ) );
    BOOST_CHECK_EQUAL( hsubtype.get_entry( title2 ).default_value(), defval );
    hsection.add_subtype( hsubtype );
  }
  BOOST_CHECK_EQUAL( hsection.subtype_size(), 1ul );
  BOOST_CHECK( not hsection.subtype_empty() );
  BOOST_CHECK( hsection.has_subtype( title1 ) );
  BOOST_CHECK_EQUAL( hsection.get_subtype( title1 ).description(), desc );
  boost::archive::text_oarchive oa( store );
  oa << hsection;
}
{
  core::help_section hsection;
  BOOST_CHECK_EQUAL( hsection.description(), nul_string );
  BOOST_CHECK_EQUAL( hsection.title(), nul_string );
  BOOST_CHECK_EQUAL( hsection.entry_size(), 0ul );
  BOOST_CHECK_EQUAL( hsection.subtype_size(), 0ul );
  boost::archive::text_iarchive ia( store );
  ia >> hsection;
  BOOST_CHECK_EQUAL( hsection.description(), desc );
  BOOST_CHECK_EQUAL( hsection.title(), title );
  BOOST_CHECK_EQUAL( hsection.entry_size(), 1ul );
  BOOST_CHECK_EQUAL( hsection.subtype_size(), 1ul );
  {
    const std::string output( "  title\n    blah blah blah\n    Options:\n    title\n      [integral number: range(> 0), \n      default{10}]\n      blah blah blah\n    type\n      [one of: title1]\n      This section represents a class of\n      types in the the simulation. Each \n      type can have individual options. \n      These options may only be valid in\n      combination with the specific type\n      .\n\n      Description of available types:\n      title1\n        blah blah blah\n        Options:\n        title2\n          [integral number: range(> 0), \n          default{10}]\n          blah blah blah\n" );
    core::fixed_width_output_filter filt( 2, 1, 40 );
    std::stringstream os;
    hsection.write( filt, os );
    //std::cout << "--\n" << os.str() << "--\n";
    BOOST_CHECK_EQUAL( os.str(), output );
  }
}
