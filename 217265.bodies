class core_test_suite
!!!555312.cpp!!!	test_read_input_buffer() : void
const std::string dummy_input( "\n\n# A comment\nsection # Another comment\nname1 = value1\n1 2.3 4 not a num # 6.2\nname1 value1" );
const std::string dummy_filename( "dummy" );
const boost::filesystem::path dummy_path( boost::filesystem::absolute( "dummy" ) );
const std::string dummy_path_str( dummy_path.string() );

{
  Reader rdr;
  // TEST reader next part 1
  rdr.add_buffer( dummy_filename, dummy_input );
  BOOST_CHECK( rdr.next() );
  BOOST_CHECK_EQUAL( "section # Another comment", rdr.line() );
  BOOST_CHECK_EQUAL( "section", rdr.name() );
  BOOST_CHECK_EQUAL( "", rdr.value() );
  BOOST_CHECK_EQUAL( 4, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_path_str, rdr.current_filename() );
  BOOST_CHECK_NE( dummy_filename, rdr.current_filename() );

  // TEST reader next part 2
  BOOST_CHECK( rdr.next() );
  BOOST_CHECK_EQUAL( "name1 = value1", rdr.line() );
  BOOST_CHECK_EQUAL( "name1", rdr.name() );
  BOOST_CHECK_EQUAL( "value1", rdr.value() );
  BOOST_CHECK_EQUAL( 5, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_path_str, rdr.current_filename() );
  BOOST_CHECK_NE( dummy_filename, rdr.current_filename() );
  // TEST reader next part 3
  BOOST_CHECK( rdr.next() );
  BOOST_CHECK_EQUAL( "1 2.3 4 not a num # 6.2", rdr.line() );
  BOOST_CHECK_EQUAL( "1", rdr.name() );
  BOOST_CHECK_EQUAL( "2.3 4 not a num", rdr.value() );
  BOOST_CHECK_EQUAL( 6, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_path_str, rdr.current_filename() );
  BOOST_CHECK_NE( dummy_filename, rdr.current_filename() );
  // TEST reader next part 4
  BOOST_CHECK( rdr.next() );
  BOOST_CHECK_EQUAL( "name1 value1", rdr.line() );
  BOOST_CHECK_EQUAL( "name1", rdr.name() );
  BOOST_CHECK_EQUAL( "value1", rdr.value() );
  BOOST_CHECK_EQUAL( 7, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_path_str, rdr.current_filename() );
  BOOST_CHECK_NE( dummy_filename, rdr.current_filename() );
  // TEST reader next part 5
  BOOST_CHECK( not rdr.next() );
  BOOST_CHECK_EQUAL( "", rdr.line() );
  BOOST_CHECK_EQUAL( "", rdr.name() );
  BOOST_CHECK_EQUAL( "", rdr.value() );
  // zero line number and "" indicate no file.
  BOOST_CHECK_EQUAL( 0, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( "", rdr.current_filename() );
  // Check stability of calling next after last element.
  BOOST_CHECK( not rdr.next() );
  BOOST_CHECK_EQUAL( "", rdr.line() );
  BOOST_CHECK_EQUAL( "", rdr.name() );
  BOOST_CHECK_EQUAL( "", rdr.value() );
  // zero line number and "" indicate no file.
  BOOST_CHECK_EQUAL( 0, rdr.current_line_number() );
  BOOST_CHECK_EQUAL( "", rdr.current_filename() );
}
!!!898992.cpp!!!	test_input_base_meta() : void
//// CTOR TESTS
{
  // Static Lifetime method tests
  BOOST_CHECK( not typename std::is_default_constructible< Meta >::type{} );
  BOOST_CHECK( not typename std::is_copy_constructible< Meta >::type{} );
  BOOST_CHECK( not typename std::is_move_constructible< Meta >::type{} );
  BOOST_CHECK( not (typename std::is_assignable< Meta, Meta >::type{}) );
  BOOST_CHECK( typename std::has_virtual_destructor< Meta >::type{} );
}
// ----------
const std::string label( "name" );
{
  std::unique_ptr< core::input_base_meta > dobj( new Meta( label, false, false ) );
  BOOST_CHECK_EQUAL( dobj->section_label(), label );
  BOOST_CHECK_EQUAL( dobj->multiple(), false );
  BOOST_CHECK_EQUAL( dobj->required(), false );
}
{
  std::unique_ptr< core::input_base_meta > dobj( new Meta( label, true, false ) );
  BOOST_CHECK_EQUAL( dobj->section_label(), label );
  BOOST_CHECK_EQUAL( dobj->multiple(), true );
  BOOST_CHECK_EQUAL( dobj->required(), false );
}
{
  std::unique_ptr< core::input_base_meta > dobj( new Meta( label, false, true ) );
  BOOST_CHECK_EQUAL( dobj->section_label(), label );
  BOOST_CHECK_EQUAL( dobj->multiple(), false );
  BOOST_CHECK_EQUAL( dobj->required(), true );
}
{
  std::unique_ptr< core::input_base_meta > dobj( new Meta( label, true, true ) );
  BOOST_CHECK_EQUAL( dobj->section_label(), label );
  BOOST_CHECK_EQUAL( dobj->multiple(), true );
  BOOST_CHECK_EQUAL( dobj->required(), true );
}


!!!406193.cpp!!!	input_help_test() : void

{
  // Static Lifetime method tests

  BOOST_CHECK( std::is_default_constructible< core::input_help >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< core::input_help >::type{} );
  BOOST_CHECK( not std::is_move_constructible< core::input_help >::type{} );
  BOOST_CHECK( (not std::is_assignable< core::input_help, core::input_help >::type{}) );
  BOOST_CHECK( not std::has_virtual_destructor< core::input_help >::type{} );
}

std::string section1(core::strngs::fsspec());
std::string section2(core::strngs::fssalt());
std::string sectdesc1("Specie definition input section variables and expected values.");
std::string sectdesc2("Salt definition input section variables and expected values.");
std::string argname11(core::strngs::fsname());
std::string argname12(core::strngs::fsrtgr());
std::string argname21(core::strngs::fsname());
std::string description11("[required, two letters] specie code name (quotes optional).");
std::string description12("[\""+core::strngs::fsfree()+"\" type only, required, number > 0] Probability this specie is used in a individual ion grand-canonical trial compared to other species.");
std::string description21("[required, four letters] salt code name (quotes optional).");

{
  // default ctor
  core::input_help tmp;

  BOOST_CHECK(tmp.empty());
  BOOST_CHECK_EQUAL(tmp.size(), 0ul);
  BOOST_CHECK(not tmp.has_section(section1));
}
{
  // test adding a section
  core::input_help tmp;

  BOOST_CHECK(tmp.empty());
  BOOST_CHECK_EQUAL(tmp.size(), 0ul);
  BOOST_CHECK(not tmp.has_section(section1));

  tmp.add_section(section1, sectdesc1);

  BOOST_CHECK(not tmp.empty());
  BOOST_CHECK_EQUAL(tmp.size(), 1ul);
  BOOST_CHECK(tmp.has_section(section1));

  // test adding an option after adding section
  tmp.add_option( section1, argname11, description11 );

  // test adding an option without adding a section
  BOOST_CHECK( not tmp.has_section( section2 ) );

  tmp.add_option( section2, argname21, description21 );
  BOOST_CHECK_EQUAL( tmp.size(), 2ul );
  BOOST_CHECK( tmp.has_section( section2 ) );

  // test adding a section (with description) after section has been added.
  // This should simply add the description to the existing option.
  BOOST_CHECK( tmp.has_section( section2 ));
  tmp.add_section( section2, sectdesc2 );

  BOOST_CHECK_EQUAL(tmp.size(), 2ul);
  BOOST_CHECK( tmp.has_section( section1 ) );
  BOOST_CHECK( tmp.has_section( section2 ) );

  // test adding an option (1.2)
  tmp.add_option( section1, argname12, description12 );

  {
    // test of printing a section
    std::stringstream os;
    tmp.print( os, section1 );
    const std::string output( os.str() );
    boost::tokenizer<> tok( output );
    boost::tokenizer<> toksearch1( sectdesc1 );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch1.begin(), toksearch1.end() ) );
    // Check description of section 2 is not present
    boost::tokenizer<> toksearch2( sectdesc2 );
    BOOST_CHECK( tok.end() == std::search( tok.begin(), tok.end(), toksearch2.begin(), toksearch2.end() ) );
    boost::tokenizer<> toksearch3( description12 );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch3.begin(), toksearch3.end() ) );
    boost::tokenizer<> toksearch4( description21 );
    BOOST_CHECK( tok.end() == std::search( tok.begin(), tok.end(), toksearch4.begin(), toksearch4.end() ) );
  }
  {
    // test printing everything
    std::stringstream os;
    tmp.print( os );
    const std::string output( os.str() );
    boost::tokenizer<> tok( output );
    boost::tokenizer<> toksearch1( sectdesc1 );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch1.begin(), toksearch1.end() ) );
    // Check description of section 2 is present
    boost::tokenizer<> toksearch2( sectdesc2 );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch2.begin(), toksearch2.end() ) );
    boost::tokenizer<> toksearch3( description12 );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch3.begin(), toksearch3.end() ) );
    boost::tokenizer<> toksearch4( description21 );
    BOOST_CHECK( tok.end() != std::search( tok.begin(), tok.end(), toksearch4.begin(), toksearch4.end() ) );
  }
}

!!!405297.cpp!!!	dictionary_test() : void
// A
BOOST_CHECK_EQUAL( core::strngs::fsaccu(), "accum" );
BOOST_CHECK_EQUAL( core::strngs::fsadd(),  "add" );
// B
BOOST_CHECK_EQUAL( core::strngs::bulk_label(), "bulk" );
// C
BOOST_CHECK_EQUAL( core::strngs::fscgin(), "calgin" );
BOOST_CHECK_EQUAL( core::strngs::fschex(), "chex" );
BOOST_CHECK_EQUAL( core::strngs::fschnl(), "channel" );
BOOST_CHECK_EQUAL( core::strngs::fschon(), "chonly" );
BOOST_CHECK_EQUAL( core::strngs::fschpt(), "usepot" );
BOOST_CHECK_EQUAL( core::strngs::fsclac(), "calacc" );
BOOST_CHECK_EQUAL( core::strngs::fsclmb(), "calmob" );
BOOST_CHECK_EQUAL( core::strngs::fsconf(), "conf" );
BOOST_CHECK_EQUAL( core::strngs::fscrdf(), "calrdf" );
BOOST_CHECK_EQUAL( core::strngs::fsctrg(), "ctarg" );
BOOST_CHECK_EQUAL( core::strngs::comment_begin(), "#" );
BOOST_CHECK_EQUAL( core::strngs::comment_end(), "" );
// D
BOOST_CHECK_EQUAL( core::strngs::fsd(),    "d" );
BOOST_CHECK_EQUAL( core::strngs::fsdrg(),  "drg" );
BOOST_CHECK_EQUAL( core::strngs::fsdrmi(), "drmaxin" );
BOOST_CHECK_EQUAL( core::strngs::fsdrmo(), "drmaxout" );
BOOST_CHECK_EQUAL( core::strngs::fsdxf(),  "dxf" );
BOOST_CHECK_EQUAL( core::strngs::fsdxw(),  "dxw" );
BOOST_CHECK_EQUAL( core::strngs::fsdzg(),  "dzg" );
// E
BOOST_CHECK_EQUAL( core::strngs::fsend(),  "end" );
BOOST_CHECK_EQUAL( core::strngs::fsenth(), "enthalpy" );
BOOST_CHECK_EQUAL( core::strngs::fsentr(), "entropy" );
BOOST_CHECK_EQUAL( core::strngs::fsepsc(), "epsch" );
BOOST_CHECK_EQUAL( core::strngs::fsepsp(), "epspr" );
BOOST_CHECK_EQUAL( core::strngs::fsepsw(), "epsw" );
BOOST_CHECK_EQUAL( core::strngs::fsexct(), "excited" );
BOOST_CHECK_EQUAL( core::strngs::evaluator_label(), "evaluator" );
// F
BOOST_CHECK_EQUAL( core::strngs::fsflxd(), "flex" );
BOOST_CHECK_EQUAL( core::strngs::fsfree(), "free" );
BOOST_CHECK_EQUAL( core::strngs::fsfver(), "fileversion" );
// G
BOOST_CHECK_EQUAL( core::strngs::fsgeom(), "geom" );
BOOST_CHECK_EQUAL( core::strngs::fsgrid(), "usegrid" );
BOOST_CHECK_EQUAL( core::strngs::fsgrl1(), "rl1" );
BOOST_CHECK_EQUAL( core::strngs::fsgrl4(), "rl4" );
BOOST_CHECK_EQUAL( core::strngs::fsgrl5(), "rl5" );
BOOST_CHECK_EQUAL( core::strngs::fsgrlc(), "rlcurv" );
BOOST_CHECK_EQUAL( core::strngs::fsgrlv(), "rlvest" );
BOOST_CHECK_EQUAL( core::strngs::fsgrnd(), "ground" );
BOOST_CHECK_EQUAL( core::strngs::fsgzl1(), "zl1" );
BOOST_CHECK_EQUAL( core::strngs::fsgzl4(), "zl4" );
BOOST_CHECK_EQUAL( core::strngs::fsgzlm(), "zlimit" );
BOOST_CHECK_EQUAL( core::strngs::fsgzoc(), "zocc" );
// H
BOOST_CHECK_EQUAL( core::strngs::horizontal_bar(), "----------------------------------------------------------------------" );
// I
BOOST_CHECK_EQUAL( core::strngs::fsincl(), "include" );
BOOST_CHECK_EQUAL( core::strngs::fsisav(), "isave" );
BOOST_CHECK_EQUAL( core::strngs::fsislt(), "cation" );
BOOST_CHECK_EQUAL( core::strngs::fsiwid(), "iwidom" );
BOOST_CHECK_EQUAL( core::strngs::imc_label(), "super-looper" );
BOOST_CHECK_EQUAL( core::strngs::inner_label(), "inner" );
BOOST_CHECK_EQUAL( core::strngs::inputpattern_label(), "input" );
// J
// K
BOOST_CHECK_EQUAL( core::strngs::fskmob(), "mobk" );
// L
BOOST_CHECK_EQUAL( core::strngs::localizer_label(), "localize" );
// M
BOOST_CHECK_EQUAL( core::strngs::fsmobl(), "mob" );
// N
BOOST_CHECK_EQUAL( core::strngs::fsname(), "name" );
BOOST_CHECK_EQUAL( core::strngs::fsnavr(), "naver" );
BOOST_CHECK_EQUAL( core::strngs::fsnmcf(), "multiconf" );
BOOST_CHECK_EQUAL( core::strngs::fsn(),    "n" );
BOOST_CHECK_EQUAL( core::strngs::fsnoch(), "nocharge" );
BOOST_CHECK_EQUAL( core::strngs::fsnsrt(), "oldreg" );
BOOST_CHECK_EQUAL( core::strngs::fsnstp(), "nstep" );
BOOST_CHECK_EQUAL( core::strngs::fsnsub(), "nsub" );
BOOST_CHECK_EQUAL( core::strngs::fsntrg(), "ntarg" );
BOOST_CHECK_EQUAL( core::strngs::fsnblk(), "nbulk" );
// O
BOOST_CHECK_EQUAL( core::strngs::outputdir_label(), "outputdir" );
// P
BOOST_CHECK_EQUAL( core::strngs::fsptch(), "patch" );
// Q
// R
BOOST_CHECK_EQUAL( core::strngs::fsregn(), "region" );
BOOST_CHECK_EQUAL( core::strngs::fsrtex(), "ratexc" );
BOOST_CHECK_EQUAL( core::strngs::fsrtgr(), "ratgr" );
BOOST_CHECK_EQUAL( core::strngs::fsrtid(), "ratind" );
BOOST_CHECK_EQUAL( core::strngs::fsrtjp(), "ratjmp" );
BOOST_CHECK_EQUAL( core::strngs::fsrtmv(), "ratmov" );
BOOST_CHECK_EQUAL( core::strngs::fsrtrg(), "ratreg" );
BOOST_CHECK_EQUAL( core::strngs::fsrtsl(), "ratslt" );
BOOST_CHECK_EQUAL( core::strngs::fsrtsp(), "ratspc" );
BOOST_CHECK_EQUAL( core::strngs::fsrtsw(), "ratswap" );
BOOST_CHECK_EQUAL( core::strngs::rate_label(), "rate" );
// S
BOOST_CHECK_EQUAL( core::strngs::fssalt(), "salt" );
BOOST_CHECK_EQUAL( core::strngs::fsspec(), "specie" );
BOOST_CHECK_EQUAL( core::strngs::fssubs(), "subspecie" );
BOOST_CHECK_EQUAL( core::strngs::sampler_label(), "sampler" );
BOOST_CHECK_EQUAL( core::strngs::simulator_label(), "simulator" );
// T
BOOST_CHECK_EQUAL( core::strngs::fstry(),  "trial" );
BOOST_CHECK_EQUAL( core::strngs::fstsi(),  "kelvin" );
BOOST_CHECK_EQUAL( core::strngs::fstype(), "type" );
// U, V
// W
BOOST_CHECK_EQUAL( core::strngs::fswidm(), "calwid" );
// X, Y
// Z
BOOST_CHECK_EQUAL( core::strngs::fsz(),    "z" );

!!!1372080.cpp!!!	input_error_message_test() : void
BOOST_CHECK_EQUAL( str( core::input_error_messages::bad_boolean_value() % "type" % "green" % "world" ), "Parameter \"type\" value (green) is not an expected boolean value in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::bad_number_value() % "type" % "green" % "world" ), "Parameter \"type\" value (green) is not an expected numerical value in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::bad_subtype_value() % "type" % "green" % "world" ), "Parameter \"type\" value (green) does not name a valid world subtype (see documentation)." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::bad_value() % "type" % "green" % "world" ), "Parameter \"type\" value (green) is not valid in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::duplicate_parameter() % "green" % "world" ), "Parameter \"green\" appears more than once in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::missing_parameter() % "green" % "world" ), "Required parameter \"green\" was not found in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::missing_parameters() % "world" ), "Required parameters were not found in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::missing_value() % "green" % "world" ), "Parameter \"green\" requires a value in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::invalid_parameter() % "green" % "world" ), "Parameter \"green\" is not valid in a world section." );

BOOST_CHECK_EQUAL( str( core::input_error_messages::invalid_parameter_subtype() % "green" %  "world" % "colour" ), "Parameter \"green\" is not valid in a world \"colour\" type section." );
!!!899504.cpp!!!	strngs_has_spaces_test() : void
std::vector< std::pair< std::string, std::size_t > > words;
words.push_back( std::make_pair( "test case", true ) );
words.push_back( std::make_pair( " case", true ) );
words.push_back( std::make_pair( "case ", true ) );
words.push_back( std::make_pair( "case\tpp", true ) );
words.push_back( std::make_pair( "case\npp", true ) );
words.push_back( std::make_pair( "case", false ) );
words.push_back( std::make_pair( "ca4e", false ) );
words.push_back( std::make_pair( "456.7", false ) );
for( auto item : words )
{
  BOOST_CHECK_EQUAL( core::strngs::has_spaces( item.first ), item.second );
}

!!!899760.cpp!!!	strngs_is_one_word_test() : void
std::vector< std::pair< std::string, std::size_t > > words;
words.push_back( std::make_pair( "test case", false ) );
words.push_back( std::make_pair( " case", false ) );
words.push_back( std::make_pair( "case ", false ) );
words.push_back( std::make_pair( "case\tpp", false ) );
words.push_back( std::make_pair( "case\npp", false ) );
words.push_back( std::make_pair( "case", true ) );
words.push_back( std::make_pair( "ca4e", false ) );
words.push_back( std::make_pair( "456.7", false ) );
for( auto item : words )
{
  BOOST_CHECK_EQUAL( core::strngs::is_one_word( item.first ), item.second );
}

!!!900016.cpp!!!	strngs_is_valid_name() : void
std::vector< std::pair< std::string, std::size_t > > words;
words.push_back( std::make_pair( "test case", false ) );
words.push_back( std::make_pair( " case", false ) );
words.push_back( std::make_pair( "case ", false ) );
words.push_back( std::make_pair( "case\tpp", false ) );
words.push_back( std::make_pair( "case\npp", false ) );
words.push_back( std::make_pair( "case_pp", true ) );
words.push_back( std::make_pair( "case_", true ) );
words.push_back( std::make_pair( "case", true ) );
words.push_back( std::make_pair( "ca4e", true ) );
words.push_back( std::make_pair( "456.7", true ) );
for( auto item : words )
{
  BOOST_CHECK_EQUAL( core::strngs::is_valid_name( item.first ), item.second );
}

!!!405425.cpp!!!	numerical_constants_test() : void
// Invariant : file_version always less/equal to file_version_max
BOOST_CHECK_EQUAL( core::constants::filver, 1 );
BOOST_CHECK_EQUAL( core::constants::fvermx, 1 );
BOOST_CHECK_LE( core::constants::filver, core::constants::fvermx );
// TEST CONSTANTS HAVE FIXED VALUES
BOOST_CHECK_EQUAL( core::constants::angstrom(), 1.0E-10 );
BOOST_CHECK_EQUAL( core::constants::avogadro_number(), 6.02214E23 );
BOOST_CHECK_EQUAL( core::constants::boltzmann_constant(), 1.3806E-23 );
BOOST_CHECK_EQUAL( core::constants::electron_charge(), 1.6021917E-19 );
BOOST_CHECK_EQUAL( core::constants::epsilon_0(), 8.8542E-12 );
BOOST_CHECK_EQUAL( core::constants::pi(), 3.141592653589793 );
BOOST_CHECK_EQUAL( core::constants::to_SI(), 1660.539276735512625080121 );
// Program constants that may be deprecated in future.
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::ibulk ), 3 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::ichan ), 2 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::ifilt ), 1 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::izlim ), 0 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::mag ), 12584210 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::nionmx ), 2048 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::nnewmx ), 4 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::npchmx ), 2048 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::nrgnmx ), 4 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::nsltmx ), 4 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::nspcmx ), 16 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::ntotmx ), 8192 );
BOOST_CHECK_EQUAL( static_cast< int >( core::constants::nzgmx ), 4096 );


!!!855856.cpp!!!	input_base_reader_statics_test() : void
{
  // Static Lifetime method tests

  // NOTE, not default constructible because it is an abstract class
  BOOST_CHECK( not std::is_default_constructible< core::input_base_reader >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< core::input_base_reader >::type{} );
  BOOST_CHECK( not std::is_move_constructible< core::input_base_reader >::type{} );
  BOOST_CHECK( (not std::is_assignable< core::input_base_reader, core::input_base_reader >::type{}) );
  BOOST_CHECK( std::has_virtual_destructor< core::input_base_reader >::type{} );
}
{
   // TEST BOOL CONVERTERS
   {
      // Converting string to bool
      // Converting string to bool: true -> true
      const std::string test ("true");
      bool pass = false;
      pass = core::input_base_reader::read_as_bool(test);
      BOOST_CHECK_EQUAL(pass, true);
   }
   {
      // Converting string to bool
      // Converting string to bool: false -> false
      const std::string test ("false");
      bool pass = true;
      pass = core::input_base_reader::read_as_bool(test);
      BOOST_CHECK_EQUAL(pass, false);
   }
   {
      // Converting string to bool
      // Converting string to bool: 0 -> false
      const std::string test ("0");
      bool pass = true;
      pass = core::input_base_reader::read_as_bool(test);
      BOOST_CHECK_EQUAL(pass, false);
   }
   {
      // Converting string to bool
      // Converting string to bool: 1 -> true
      const std::string test ("1");
      bool pass = false;
      pass = core::input_base_reader::read_as_bool(test);
      BOOST_CHECK_EQUAL(pass, true);

   }
   {
      // Converting string to bool
      // Converting string to bool: .false. -> false
      const std::string test (".false.");
      bool pass = true;
      pass = core::input_base_reader::read_as_bool(test);
      BOOST_CHECK_EQUAL(pass, false);
   }
   {
      // Converting string to bool
      // Converting string to bool: 2.0 -> ?true?
      const std::string test ("2.0");
      bool pass = true;
      BOOST_CHECK_THROW(pass = core::input_base_reader::read_as_bool(test), boost::bad_lexical_cast);
      BOOST_CHECK_EQUAL(pass, true);
   }
   {
      // Converting string to bool
      // Converting string to bool: 2 -> ?true?
      const std::string test ("2");
      bool pass = true;
      BOOST_CHECK_THROW(pass = core::input_base_reader::read_as_bool(test), boost::bad_lexical_cast);
      BOOST_CHECK_EQUAL(pass, true);
   }

}
{
   // Test of dequoting
   {
      const std::string expect("abc  ");
      const std::string input1("'abc  '");   // -> |abc  |
      const std::string input2("\"abc  \""); // -> |abc  |
      const std::string input3("\"abc  '");  // unchanged
      const std::string input4("\"abc  \" ");// -> |abc  |
      const std::string input5("\"abc  ' "); // unchanged
      std::string result;

      result = core::input_base_reader::dequote(input1);
      BOOST_CHECK_EQUAL(result, expect);

      result = core::input_base_reader::dequote(input2);
      BOOST_CHECK_EQUAL(result, expect);

      result = core::input_base_reader::dequote(input3);
      BOOST_CHECK_EQUAL(result, input3);

      result = core::input_base_reader::dequote(input4);
      BOOST_CHECK_EQUAL(result, expect);

      result = core::input_base_reader::dequote(input5);
      BOOST_CHECK_EQUAL(result, input5);
   }
   {
      // No quotes
      // Unquoted text: unchanged
      std::string result = "The lazy dog.";
      const std::string pass = "The lazy dog.";
      result = core::input_base_reader::dequote(result);
      BOOST_CHECK_EQUAL(result, pass);
   }
   {
      // Uneven quoted (front) text: unchanged
      std::string result = "\"The lazy dog.";
      const std::string pass = "\"The lazy dog.";
      result = core::input_base_reader::dequote(result);
      BOOST_CHECK_EQUAL(result, pass);
   }
   {
      // Uneven quotes (back) text: unchanged
      std::string result = "The lazy dog.\"";
      const std::string pass = "The lazy dog.\"";
      result = core::input_base_reader::dequote(result);
      BOOST_CHECK_EQUAL(result, pass);
   }
   {
      // Matched quotes [\"] text: strip quotes
      std::string result = "\"The lazy dog.\"";
      const std::string pass = "The lazy dog.";
      result = core::input_base_reader::dequote(result);
      BOOST_CHECK_EQUAL(result, pass);
   }
   {
      // Matched multi-quoted text: strip one set of quotes
      std::string result = "\"\"The lazy dog.\"\"";
      const std::string pass = "\"The lazy dog.\"";
      result = core::input_base_reader::dequote(result);
      BOOST_CHECK_EQUAL(result, pass);
   }
   {
      // Matched quoted with one end embedded in text: unchanged
      std::string result = "\"The\" lazy dog.";
      const std::string pass = "\"The\" lazy dog.";
      result = core::input_base_reader::dequote(result);
      BOOST_CHECK_EQUAL(result, pass);
   }
   {
      // Matched quoted ['] text: strip quotes
      std::string result = "'The lazy dog.'";
      const std::string pass = "The lazy dog.";
      result = core::input_base_reader::dequote(result);
      BOOST_CHECK_EQUAL(result, pass);
   }
   {
      // Mismatched quoted [\"...'] text: unchanged
      std::string result = "\"The lazy dog.'";
      const std::string pass = "\"The lazy dog.'";
      result = core::input_base_reader::dequote(result);
      BOOST_CHECK_EQUAL(result, pass);
   }
   {
      // Matched quoted [\"] text with external spacing: strip quotes and
      // whitespace
      std::string result = "\"The lazy dog. \" ";
      const std::string pass = "The lazy dog. ";
      result = core::input_base_reader::dequote(result);
      BOOST_CHECK_EQUAL(result, pass);
   }
   {
      // Matched quoted [\"] text with internal spacing: strip quotes, leave
      // internal whitespace
      std::string result = "\"The lazy dog. \"";
      const std::string pass = "The lazy dog. ";
      result = core::input_base_reader::dequote(result);
      BOOST_CHECK_EQUAL(result, pass);
   }
}
{
   // TEST Decommenting
   const std::string input1("#abc  '"); // empty

   const std::string expect2(" ");
   const std::string input2(" #abc  "); // -> | |

   const std::string expect3("abc  ");
   const std::string input3("abc  # "); // -> |abc  |

   const std::string input4("abc   ");  // unchanged

   const std::string input5("abc  \\# "); // unchanged

   const std::string input6("\"abc  # \""); // unchanged

   const std::string expect7("\'abc\'  ");
   const std::string input7("\'abc\'  # ");

   const std::string input8("\"abc\"  \"# "); // -> unchanged

   const std::string expect9("\"abc\'  \"");
   const std::string input9("\"abc\'  \"# ");

   const std::string expectA("abc  \\\\");
   const std::string inputA("abc  \\\\# ");
   std::string result;

   result = core::input_base_reader::decomment(input1);
   BOOST_CHECK(result.empty());

   result = core::input_base_reader::decomment(input2);
   BOOST_CHECK_EQUAL(result, expect2);

   result = core::input_base_reader::decomment(input3);
   BOOST_CHECK_EQUAL(result, expect3);

   result = core::input_base_reader::decomment(input4);
   BOOST_CHECK_EQUAL(result, input4);

   result = core::input_base_reader::decomment(input5);
   BOOST_CHECK_EQUAL(result, input5);

   result = core::input_base_reader::decomment(input6);
   BOOST_CHECK_EQUAL(result, input6);

   result = core::input_base_reader::decomment(input7);
   BOOST_CHECK_EQUAL(result, expect7);

   result = core::input_base_reader::decomment(input8);
   BOOST_CHECK_EQUAL(result, input8);

   result = core::input_base_reader::decomment(input9);
   BOOST_CHECK_EQUAL(result, expect9);

   result = core::input_base_reader::decomment(inputA);
   BOOST_CHECK_EQUAL(result, expectA);

}
// READ AS FLOATS
{
   std::vector< double > result;
   BOOST_CHECK( core::input_base_reader::read_as_floats("-1.0 2.4 1.3", result) );
   BOOST_CHECK_EQUAL( result.size(), 3 );
   BOOST_CHECK_EQUAL( result[0], -1.0 );
   BOOST_CHECK_EQUAL( result[1], 2.4 );
   BOOST_CHECK_EQUAL( result[2], 1.3 );
}
{
   std::vector< double > result;
   BOOST_CHECK( not core::input_base_reader::read_as_floats("1 2 3 ABC 4", result) );
   BOOST_CHECK_EQUAL( result.size(), 3 );
   BOOST_CHECK_EQUAL( result[0], 1.0 );
   BOOST_CHECK_EQUAL( result[1], 2.0 );
   BOOST_CHECK_EQUAL( result[2], 3.0 );
}
{
   std::vector< double > result;
   BOOST_CHECK( core::input_base_reader::read_as_floats("1", result) );
   BOOST_CHECK_EQUAL(result.size(),1);
   BOOST_CHECK_EQUAL(result[0],1.0);
}
!!!554672.cpp!!!	input_base_reader_test() : void
////////////
// Simple (no-op) derived class to enable testing of base class methods
class test_reader: public core::input_base_reader
{
public:
  bool do_next() override
  {
    return false;
  };
  std::string current_filename() const override
  {
    return std::string();
  }
  std::size_t current_line_number() const override
  {
    return 0;
  }
  void add_buffer(const boost::filesystem::path &, std::string) override {}
  void add_include(const boost::filesystem::path &) override {}
};
//--template < class Archive >
//--void serialize( Archive &ar, input_base_reader &rr, const int version = 0)
//--{
//--   rr.serialize( ar );
//--};
{
  // TEST reader ctor
  test_reader test;
  BOOST_CHECK_EQUAL( test.line().size(), 0 );
  BOOST_CHECK_EQUAL( test.name().size(), 0 );
  BOOST_CHECK_EQUAL( test.value().size(), 0 );
}
std::stringstream store;
{
  // TEST set_line
  test_reader test;

  // serialization
  boost::archive::text_oarchive oa( store );
  {
    // name only
    const std::string ll( "section" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), ll );
    BOOST_CHECK_EQUAL( test.name(), ll );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // name value with '=' separator
    const std::string ll( "name1 = value1" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), ll );
    BOOST_CHECK_EQUAL( test.name(), "name1" );
    BOOST_CHECK_EQUAL( test.value(), "value1" );

    // SAVE POINT 1
    oa << test;

    BOOST_CHECK_NE( test.line().size(), 0 );
    BOOST_CHECK_NE( test.name().size(), 0 );
    BOOST_CHECK_NE( test.value().size(), 0 );
    test.clear();
    BOOST_CHECK_EQUAL( test.line().size(), 0 );
    BOOST_CHECK_EQUAL( test.name().size(), 0 );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // name value with ' ' separator
    const std::string ll( "name2    value2" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), ll );
    BOOST_CHECK_EQUAL( test.name(), "name2" );
    BOOST_CHECK_EQUAL( test.value(), "value2" );

    // SAVE POINT 2
    oa << test;

    BOOST_CHECK_NE( test.line().size(), 0 );
    BOOST_CHECK_NE( test.name().size(), 0 );
    BOOST_CHECK_NE( test.value().size(), 0 );
    BOOST_CHECK( not test.next() );
    BOOST_CHECK_EQUAL( test.line().size(), 0 );
    BOOST_CHECK_EQUAL( test.name().size(), 0 );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // comment line
    const std::string ll( "# section" );
    BOOST_CHECK( not test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), "" );
    BOOST_CHECK_EQUAL( test.name().size(), 0 );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // empty line
    const std::string ll( "" );
    BOOST_CHECK( not test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), ll );
    BOOST_CHECK_EQUAL( test.name().size(), 0 );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // line with values separated by spaces and a comment
    const std::string ll( "1 2.3 4 not a num # COMMENT" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.trimmed_line(), "1 2.3 4 not a num" );
    BOOST_CHECK_EQUAL( test.name(), "1" );
    BOOST_CHECK_EQUAL( test.value(), "2.3 4 not a num" );
  }
  {
    // name only with a comment
    const std::string ll( "section # COMMENT" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.name(), "section" );
    BOOST_CHECK_EQUAL( test.value().size(), 0 );
  }
  {
    // value only ??
    const std::string ll( " = section" );
    BOOST_CHECK( test.set_line( ll ) );
    BOOST_CHECK_EQUAL( test.line(), ll );
    BOOST_CHECK_EQUAL( test.name().size(), 0  );
    BOOST_CHECK_EQUAL( test.value(), "section" );
  }

}
{

  boost::archive::text_iarchive ia( store );
  {
    test_reader test;
    // FROM SAVE POINT 1
    ia >> test;
    BOOST_CHECK_EQUAL( test.line(), "name1 = value1" );
    BOOST_CHECK_EQUAL( test.name(), "name1" );
    BOOST_CHECK_EQUAL( test.value(), "value1" );
  }
  {
    test_reader test;
    // FROM SAVE POINT 2
    ia >> test;
    BOOST_CHECK_EQUAL( test.line(), "name2    value2" );
    BOOST_CHECK_EQUAL( test.name(), "name2" );
    BOOST_CHECK_EQUAL( test.value(), "value2" );
  }
}

!!!550960.cpp!!!	input_node_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( std::is_default_constructible< core::input_node >::type{} );
  BOOST_CHECK( std::is_copy_constructible< core::input_node >::type{} );
  BOOST_CHECK( std::is_move_constructible< core::input_node >::type{} );
  BOOST_CHECK( (std::is_assignable< core::input_node, core::input_node >::type{}) );
  BOOST_CHECK( not std::has_virtual_destructor< core::input_node >::type{} );
}

const std::string dummy_input("\n\n# A comment\nsection # Another comment\nname1 = value1\n1 2.3 4 not a num # 6.2\nname1 value1\n\n");
const std::string  dummy_filename("dummy");
const boost::filesystem::path dummy_path( boost::filesystem::absolute( "dummy" ) );
const std::vector< std::string > lines = { "", "", "# A comment", "section # Another comment", "name1 = value1", "1 2.3 4 not a num # 6.2", "name1 value1", "", "", "" };
const std::vector< std::size_t > pos = { 1, 2, 14, 40, 55, 79, 92, 93, 94, 94 };
const std::vector< std::size_t > linenums = { 1, 2, 3, 4, 5, 6, 7, 8, 8, 8 };

std::stringstream store;
{
  core::input_node node;
  node.set_buffer( dummy_filename, dummy_input );

  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
  BOOST_CHECK_EQUAL( node.eof(), false );

  boost::archive::text_oarchive oa( store );
  oa << node;

  for (std::size_t ii = 0; ii != 10; ++ii )
  {
    std::string line;
    node.getline( line );
    BOOST_CHECK( node.eof() == (ii >= 7) );
    BOOST_CHECK_EQUAL( line, lines[ii] );
    BOOST_CHECK_EQUAL( node.file_position(), pos[ii] );
    BOOST_CHECK_EQUAL( node.line_number(), linenums[ii] );
    BOOST_CHECK_EQUAL( node.path(), dummy_path );
  }
  node.rewind();
  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
  for (std::size_t ii = 0; ii != 8; ++ii )
  {
    std::string line;
    node.getline( line );
    BOOST_CHECK( node.eof() == (ii >= 7) );
    BOOST_CHECK_EQUAL( line, lines[ii] );
    BOOST_CHECK_EQUAL( node.file_position(), pos[ii] );
    BOOST_CHECK_EQUAL( node.line_number(), linenums[ii] );
    BOOST_CHECK_EQUAL( node.path(), dummy_path );
  }
}
{
  core::input_node node;
  boost::archive::text_iarchive ia( store );
  ia >> node;
  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );

  for (std::size_t ii = 0; ii != 8; ++ii )
  {
    std::string line;
    node.getline( line );
    BOOST_CHECK( node.eof() == (ii >= 7) );
    BOOST_CHECK_EQUAL( line, lines[ii] );
    BOOST_CHECK_EQUAL( node.file_position(), pos[ii] );
    BOOST_CHECK_EQUAL( node.line_number(), linenums[ii] );
    BOOST_CHECK_EQUAL( node.path(), dummy_path );
  }
}

// Test of input that is a single line without \n
{
  const std::string single_input("section ");
  core::input_node node;
  node.set_buffer( dummy_filename, single_input );

  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
  BOOST_CHECK_EQUAL( node.eof(), false );

  std::string line;
  node.getline( line );
  BOOST_CHECK( node.eof() );
  BOOST_CHECK_EQUAL( line, single_input );
  BOOST_CHECK_EQUAL( node.file_position(), single_input.size() );
  BOOST_CHECK_EQUAL( node.line_number(), 1 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
}

// Test of empty input
{
  const std::string empty_input{};
  core::input_node node;
  node.set_buffer( dummy_filename, empty_input );

  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
  BOOST_CHECK_EQUAL( node.eof(), true );
}

// Test of empty single line input
{
  const std::string empty_input{"\n"};
  core::input_node node;
  node.set_buffer( dummy_filename, empty_input );

  BOOST_CHECK_EQUAL( node.file_position(), 0 );
  BOOST_CHECK_EQUAL( node.line_number(), 0 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
  BOOST_CHECK_EQUAL( node.eof(), false );
  std::string line;
  node.getline( line );
  BOOST_CHECK( node.eof() );
  BOOST_CHECK_EQUAL( line, "" );
  BOOST_CHECK_EQUAL( node.file_position(), 1 );
  BOOST_CHECK_EQUAL( node.line_number(), 1 );
  BOOST_CHECK_EQUAL( node.path(), dummy_path );
}

!!!554800.cpp!!!	input_preprocess_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( std::is_default_constructible< core::input_preprocess >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< core::input_preprocess >::type{} );
  BOOST_CHECK( not std::is_move_constructible< core::input_preprocess >::type{} );
  BOOST_CHECK( (not std::is_assignable< core::input_preprocess, core::input_preprocess >::type{}) );
  BOOST_CHECK( std::has_virtual_destructor< core::input_preprocess >::type{} );
}
{
   // TEST reader ctor
   core::input_preprocess test;
   BOOST_CHECK_EQUAL( "", test.line() );
   BOOST_CHECK_EQUAL( "", test.name() );
   BOOST_CHECK_EQUAL( "", test.value() );
   BOOST_CHECK_EQUAL( 0, test.current_line_number() );
   BOOST_CHECK_EQUAL( "", test.current_filename() );
}
{
   // Test standard reader behavior (uses memory buffers only). 
   core_test_suite::test_read_input_buffer< core::input_preprocess >();
}
// test serialization
//
// input_preprocess should read the content of the input files, including any
// "include" files, into internal buffers that can be serialized.
std::stringstream store;
const std::string dummy_input("\n\n# A comment\nsection # Another comment\nname1 = value1\n1 2.3 4 not a num # 6.2\nname1 value1");
const std::string  dummy_filename("dummy");
const boost::filesystem::path dummy_path( boost::filesystem::absolute( "dummy" ) );
{
   core::input_preprocess test;
   test.add_buffer( dummy_filename, dummy_input );
   boost::archive::text_oarchive oa( store );
   oa << test;
}
{
   core::input_preprocess rdr;
   boost::archive::text_iarchive ia( store );
   ia >> rdr;

   BOOST_CHECK( rdr.next() );
   BOOST_CHECK_EQUAL( "section # Another comment", rdr.line() );
   BOOST_CHECK_EQUAL( "section", rdr.name() );
   BOOST_CHECK_EQUAL( "", rdr.value() );
   BOOST_CHECK_EQUAL( 4, rdr.current_line_number() );
   BOOST_CHECK_EQUAL( dummy_path, rdr.current_filename() );

   // TEST reader next part 2
   BOOST_CHECK(rdr.next());
   BOOST_CHECK_EQUAL("name1 = value1",rdr.line());
   BOOST_CHECK_EQUAL("name1",rdr.name());
   BOOST_CHECK_EQUAL("value1",rdr.value());
   BOOST_CHECK_EQUAL(5,rdr.current_line_number());
   BOOST_CHECK_EQUAL(dummy_path,rdr.current_filename());

   // TEST reader next part 3
   BOOST_CHECK(rdr.next());
   BOOST_CHECK_EQUAL("1 2.3 4 not a num # 6.2",rdr.line());
   BOOST_CHECK_EQUAL("1",rdr.name());
   BOOST_CHECK_EQUAL("2.3 4 not a num",rdr.value());
   BOOST_CHECK_EQUAL(6,rdr.current_line_number());
   BOOST_CHECK_EQUAL(dummy_path,rdr.current_filename());

   // TEST reader next part 4
   BOOST_CHECK(rdr.next());
   BOOST_CHECK_EQUAL("name1 value1",rdr.line());
   BOOST_CHECK_EQUAL("name1",rdr.name());
   BOOST_CHECK_EQUAL("value1",rdr.value());
   BOOST_CHECK_EQUAL(7,rdr.current_line_number());
   BOOST_CHECK_EQUAL(dummy_path,rdr.current_filename());

   // TEST reader next part 5
   BOOST_CHECK(not rdr.next());
   BOOST_CHECK_EQUAL("",rdr.line());
   BOOST_CHECK_EQUAL("",rdr.name());
   BOOST_CHECK_EQUAL("",rdr.value());
}

!!!406065.cpp!!!	input_reader_test() : void
std::string dummy_input( "\n\n# A comment\nsection # Another comment\nname1 = value1\n1 2.3 4 not a num # 6.2\nname1 value1" );
std::string dummy_filename( boost::filesystem::absolute( "dummy" ).string() );

{
  core_test_suite::test_read_input_buffer< core::input_reader >();
}
{
  // TEST reader ctor
  std::istringstream input( dummy_input );
  core::input_reader test( dummy_filename,input );
  BOOST_CHECK_EQUAL( "",test.line() );
  BOOST_CHECK_EQUAL( "",test.name() );
  BOOST_CHECK_EQUAL( "",test.value() );
  BOOST_CHECK_EQUAL( 0,test.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_filename,test.current_filename() );

}
{
  // TEST reader next part 1
  std::istringstream input( dummy_input );
  core::input_reader test( dummy_filename,input );
  BOOST_CHECK( test.next() );
  BOOST_CHECK_EQUAL( "section # Another comment",test.line() );
  BOOST_CHECK_EQUAL( "section",test.name() );
  BOOST_CHECK_EQUAL( "",test.value() );
  BOOST_CHECK_EQUAL( 4,test.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_filename,test.current_filename() );

  // TEST reader next part 2
  BOOST_CHECK( test.next() );
  BOOST_CHECK_EQUAL( "name1 = value1",test.line() );
  BOOST_CHECK_EQUAL( "name1",test.name() );
  BOOST_CHECK_EQUAL( "value1",test.value() );
  BOOST_CHECK_EQUAL( 5,test.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_filename,test.current_filename() );

  // TEST reader next part 3
  BOOST_CHECK( test.next() );
  BOOST_CHECK_EQUAL( "1 2.3 4 not a num # 6.2",test.line() );
  BOOST_CHECK_EQUAL( "1",test.name() );
  BOOST_CHECK_EQUAL( "2.3 4 not a num",test.value() );
  BOOST_CHECK_EQUAL( 6,test.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_filename,test.current_filename() );

  {
    std::vector< double > result;
    test.read_as_floats( test.line(), result );
    BOOST_CHECK_EQUAL( result.size(),3 );
    BOOST_CHECK_EQUAL( result[0],1.0 );
    BOOST_CHECK_EQUAL( result[1],2.3 );
    BOOST_CHECK_EQUAL( result[2],4.0 );
  }
  // TEST reader next part 4
  BOOST_CHECK( test.next() );
  BOOST_CHECK_EQUAL( "name1 value1",test.line() );
  BOOST_CHECK_EQUAL( "name1",test.name() );
  BOOST_CHECK_EQUAL( "value1",test.value() );
  BOOST_CHECK_EQUAL( 7,test.current_line_number() );
  BOOST_CHECK_EQUAL( dummy_filename,test.current_filename() );

  // TEST reader next part 5
  BOOST_CHECK( not test.next() );
  BOOST_CHECK_EQUAL( "",test.line() );
  BOOST_CHECK_EQUAL( "",test.name() );
  BOOST_CHECK_EQUAL( "",test.value() );
  // zero line number and "" indicate no file.
  BOOST_CHECK_EQUAL( 0,test.current_line_number() );
  BOOST_CHECK_EQUAL( "",test.current_filename() );
  // Check stability of calling next after last element.
  BOOST_CHECK( not test.next() );
  BOOST_CHECK_EQUAL( "",test.line() );
  BOOST_CHECK_EQUAL( "",test.name() );
  BOOST_CHECK_EQUAL( "",test.value() );
  // zero line number and "" indicate no file.
  BOOST_CHECK_EQUAL( 0,test.current_line_number() );
  BOOST_CHECK_EQUAL( "",test.current_filename() );

}

!!!484528.cpp!!!	input_section_test() : void
// CTOR TESTS
// ----------
const std::string empty_str;
const std::string label1 { "label1" };
const std::string name1 { "name1" };
const std::string name2 { "name2" };
const std::string name3 { "name3" };
const std::string name4 { "name4" };
const std::string value1 { "value1" };
const double value2 { 1.25 };
const std::string svalue2 { "1.250000" };
const std::size_t value3 { 125ul };
const std::string svalue3 { "125" };
const bool value4 { true };
const std::string svalue4 { "true" };
std::stringstream store;
{
   // default empty ctor
   core::input_section isec;
   BOOST_CHECK_EQUAL( isec.label(), empty_str );
   BOOST_CHECK_EQUAL( isec.size(), 0 );
   BOOST_CHECK_EQUAL( isec.empty(), true );

   isec.set_label( label1 );
   BOOST_CHECK_EQUAL( isec.label(), label1 );
   BOOST_CHECK_EQUAL( isec.size(), 0 );
   BOOST_CHECK_EQUAL( isec.empty(), true );

   BOOST_CHECK_EQUAL( isec.has_entry( name1 ), false );
   isec.add_entry( name1, value1 );
   BOOST_CHECK_EQUAL( isec.label(), label1 );
   BOOST_CHECK_EQUAL( isec.has_entry( name1 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name1 ), value1 );
   BOOST_CHECK_EQUAL( isec.size(), 1 );
   BOOST_CHECK_EQUAL( isec.empty(), false );

   BOOST_CHECK_EQUAL( isec.has_entry( name2 ), false );
   isec.add_entry( name2, value2 );
   BOOST_CHECK_EQUAL( isec.has_entry( name2 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name2 ), svalue2 );
   BOOST_CHECK_EQUAL( isec.size(), 2 );

   BOOST_CHECK_EQUAL( isec.has_entry( name3 ), false );
   isec.add_entry( name3, value3 );
   BOOST_CHECK_EQUAL( isec.has_entry( name3 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name3 ), svalue3 );
   BOOST_CHECK_EQUAL( isec.size(), 3 );

   BOOST_CHECK_EQUAL( isec.has_entry( name4 ), false );
   isec.add_entry( name4, value4 );
   BOOST_CHECK_EQUAL( isec.has_entry( name4 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name4 ), svalue4 );
   BOOST_CHECK_EQUAL( isec.size(), 4 );

   {
      // serialization
      boost::archive::text_oarchive oa( store );
      oa << isec;
      BOOST_CHECK_EQUAL( isec.label(), label1 );
      BOOST_CHECK_EQUAL( isec.has_entry( name1 ), true );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), value1 );
      BOOST_CHECK_EQUAL( isec.has_entry( name2 ), true );
      BOOST_CHECK_EQUAL( isec.get_entry( name2 ), svalue2 );
      BOOST_CHECK_EQUAL( isec.has_entry( name3 ), true );
      BOOST_CHECK_EQUAL( isec.get_entry( name3 ), svalue3 );
      BOOST_CHECK_EQUAL( isec.has_entry( name4 ), true );
      BOOST_CHECK_EQUAL( isec.get_entry( name4 ), svalue4 );
      BOOST_CHECK_EQUAL( isec.size(), 4 );
      BOOST_CHECK_EQUAL( isec.empty(), false );
   }

   {
      // copy ctor
      core::input_section isec_copy( isec );
      BOOST_CHECK_EQUAL( isec_copy.label(), label1 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name1 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name1 ), value1 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name2 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name2 ), svalue2 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name3 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name3 ), svalue3 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name4 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name4 ), svalue4 );
      BOOST_CHECK_EQUAL( isec_copy.size(), 4 );
      BOOST_CHECK_EQUAL( isec_copy.empty(), false );
   }
   {
      // assignment
      core::input_section isec_copy;
      BOOST_CHECK_EQUAL( isec_copy.label(), empty_str );
      BOOST_CHECK_EQUAL( isec_copy.size(), 0 );
      BOOST_CHECK_EQUAL( isec_copy.empty(), true );

      isec_copy = isec;

      BOOST_CHECK_EQUAL( isec_copy.label(), label1 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name1 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name1 ), value1 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name2 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name2 ), svalue2 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name3 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name3 ), svalue3 );
      BOOST_CHECK_EQUAL( isec_copy.has_entry( name4 ), true );
      BOOST_CHECK_EQUAL( isec_copy.get_entry( name4 ), svalue4 );
      BOOST_CHECK_EQUAL( isec_copy.size(), 4 );
      BOOST_CHECK_EQUAL( isec_copy.empty(), false );
   }

   {
      // move
      core::input_section isec_copy( isec );
      core::input_section isec_move( std::move( isec_copy ) );
      BOOST_CHECK_EQUAL( isec_copy.label(), empty_str );
      BOOST_CHECK_EQUAL( isec_copy.size(), 0 );
      BOOST_CHECK_EQUAL( isec_copy.empty(), true );

      BOOST_CHECK_EQUAL( isec_move.label(), label1 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name1 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name1 ), value1 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name2 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name2 ), svalue2 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name3 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name3 ), svalue3 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name4 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name4 ), svalue4 );
      BOOST_CHECK_EQUAL( isec_move.size(), 4 );
      BOOST_CHECK_EQUAL( isec_move.empty(), false );
   }

   {
      // swap
      core::input_section isec_copy( isec );
      core::input_section isec_move;

      std::swap( isec_move, isec_copy );

      BOOST_CHECK_EQUAL( isec_copy.label(), empty_str );
      BOOST_CHECK_EQUAL( isec_copy.size(), 0 );
      BOOST_CHECK_EQUAL( isec_copy.empty(), true );

      BOOST_CHECK_EQUAL( isec_move.label(), label1 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name1 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name1 ), value1 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name2 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name2 ), svalue2 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name3 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name3 ), svalue3 );
      BOOST_CHECK_EQUAL( isec_move.has_entry( name4 ), true );
      BOOST_CHECK_EQUAL( isec_move.get_entry( name4 ), svalue4 );
      BOOST_CHECK_EQUAL( isec_move.size(), 4 );
      BOOST_CHECK_EQUAL( isec_move.empty(), false );
   }
}
{
   // test add_entry
   // add_entry(string)  ABOVE
   // add_entry(unsigned long) as size_t ABOVE
   // add_entry(double) ABOVE
   {
      // add_entry(bool)
      core::input_section isec;
      isec.add_entry( name1, true );
      isec.add_entry( name2, false );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "true" );
      BOOST_CHECK_EQUAL( isec.get_entry( name2 ), "false" );
   }
   {
      // add_entry(int)
      core::input_section isec;
      int value { -170465 };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "-170465" );
   }
   {
      // add_entry(long)
      core::input_section isec;
      int64_t value { -17046500000000000L };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "-17046500000000000" );
   }
   {
      // add_entry(long long)
      core::input_section isec;
      long long value { -1704650000000000000LL };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "-1704650000000000000" );
   }
   {
      // add_entry(uint)
      core::input_section isec;
      uint32_t value { 170465 };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "170465" );
   }
   {
      // add_entry(unsigned long long)
      core::input_section isec;
      unsigned long long value { 170465000000000000ULL };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "170465000000000000" );
   }
   {
      // add_entry(float)
      core::input_section isec;
      float value { 1.125E15F };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "1.125e+15" );
   }
   {
      // add_entry(long double)
      core::input_section isec;
      long double value { 1.125E500L };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "1.125e+500" );
   }
   {
      // template< class T > add_entry(T)
      core::input_section isec;
      particle::coordinate value { 17.0, 4.0, 1965.0 };
      isec.add_entry( name1, value );
      BOOST_CHECK_EQUAL( isec.get_entry( name1 ), "17 4 1965" );
   }
}
{
   // deserialization
   core::input_section isec;
   boost::archive::text_iarchive ia( store );
   ia >> isec;

   BOOST_CHECK_EQUAL( isec.label(), label1 );
   BOOST_CHECK_EQUAL( isec.has_entry( name1 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name1 ), value1 );
   BOOST_CHECK_EQUAL( isec.has_entry( name2 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name2 ), svalue2 );
   BOOST_CHECK_EQUAL( isec.has_entry( name3 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name3 ), svalue3 );
   BOOST_CHECK_EQUAL( isec.has_entry( name4 ), true );
   BOOST_CHECK_EQUAL( isec.get_entry( name4 ), svalue4 );
   BOOST_CHECK_EQUAL( isec.size(), 4 );
   BOOST_CHECK_EQUAL( isec.empty(), false );

   // Write test
   {
      std::stringstream output;
      isec.write( output );
      const std::string result { output.str() };
      boost::tokenizer< boost::escaped_list_separator< char > > tok(result, { "\\", " \n\t", "\"\'" } );
      std::vector< std::string > wordlist = { label1, name1, value1, name2, svalue2, name3, svalue3, name4, svalue4, "end" };
      BOOST_CHECK( std::equal( wordlist.begin(), wordlist.end(), tok.begin() ) );
      auto t_iter = tok.begin();
      for (auto w_iter = wordlist.begin(); w_iter != wordlist.end(); ++w_iter, ++t_iter)
      {
         BOOST_CHECK_EQUAL( *t_iter, *w_iter );
      }
   }
}
!!!1286704.cpp!!!	input_document_test() : void
// CTOR TESTS
// ----------
const std::size_t version{ 21 };
std::stringstream store;
const std::string label1 { "label1" };
const std::string label2 { "label2" };
{
   // default
   core::input_document idoc( version );
   BOOST_CHECK_EQUAL( idoc.size(), 0 );
   BOOST_CHECK_EQUAL( idoc.empty(), true );
   BOOST_CHECK_EQUAL( idoc.version(), version );

   std::size_t idx;
   idx = idoc.add_section( label1 );

   BOOST_CHECK_EQUAL( idx, 0 );
   BOOST_CHECK_EQUAL( idoc[ idx ].label(), label1 );
   BOOST_CHECK_EQUAL( idoc.size(), 1 );
   BOOST_CHECK_EQUAL( idoc.empty(), false );
   BOOST_CHECK_EQUAL( idoc.version(), version );

   idx = idoc.add_section( label2 );

   BOOST_CHECK_EQUAL( idx, 1 );
   BOOST_CHECK_EQUAL( idoc[ idx ].label(), label2 );
   BOOST_CHECK_EQUAL( idoc.size(), 2 );

   boost::archive::text_oarchive oa( store );
   oa << idoc;

   {
      // copy ctor
      core::input_document idoc2( idoc );
      BOOST_CHECK_EQUAL( idoc2.version(), version );
      BOOST_CHECK_EQUAL( idoc2[ 0 ].label(), label1 );
      BOOST_CHECK_EQUAL( idoc2[ 1 ].label(), label2 );
      BOOST_CHECK_EQUAL( idoc2.size(), 2 );
      BOOST_CHECK_EQUAL( idoc2.empty(), false );
      // check idoc unchanged
      BOOST_CHECK_EQUAL( idoc.version(), version );
      BOOST_CHECK_EQUAL( idoc[ 0 ].label(), label1 );
      BOOST_CHECK_EQUAL( idoc[ 1 ].label(), label2 );
      BOOST_CHECK_EQUAL( idoc.size(), 2 );
      BOOST_CHECK_EQUAL( idoc.empty(), false );
   }

   {
      // assignement
      core::input_document idoc2( 1 );
      BOOST_CHECK_EQUAL( idoc2.size(), 0 );
      BOOST_CHECK_EQUAL( idoc2.empty(), true );
      BOOST_CHECK_EQUAL( idoc2.version(), 1 );

      idoc2 = idoc;
      BOOST_CHECK_EQUAL( idoc2.version(), version );
      BOOST_CHECK_EQUAL( idoc2[ 0 ].label(), label1 );
      BOOST_CHECK_EQUAL( idoc2[ 1 ].label(), label2 );
      BOOST_CHECK_EQUAL( idoc2.size(), 2 );
      BOOST_CHECK_EQUAL( idoc2.empty(), false );
      // check idoc unchanged
      BOOST_CHECK_EQUAL( idoc.version(), version );
      BOOST_CHECK_EQUAL( idoc[ 0 ].label(), label1 );
      BOOST_CHECK_EQUAL( idoc[ 1 ].label(), label2 );
      BOOST_CHECK_EQUAL( idoc.size(), 2 );
      BOOST_CHECK_EQUAL( idoc.empty(), false );
   }

   {
      // move
      core::input_document idoc2( idoc );
      core::input_document idoc3( std::move( idoc2 ) );
      BOOST_CHECK_EQUAL( idoc2.size(), 0 );
      BOOST_CHECK_EQUAL( idoc2.empty(), true );
      // value of idoc2.version is probably implementation dependent

      BOOST_CHECK_EQUAL( idoc3.version(), version );
      BOOST_CHECK_EQUAL( idoc3[ 0 ].label(), label1 );
      BOOST_CHECK_EQUAL( idoc3[ 1 ].label(), label2 );
      BOOST_CHECK_EQUAL( idoc3.size(), 2 );
      BOOST_CHECK_EQUAL( idoc3.empty(), false );
   }
}
{
   core::input_document idoc( 0 );
   boost::archive::text_iarchive ia( store );
   ia >> idoc;

   // check idoc unchanged
   BOOST_CHECK_EQUAL( idoc.version(), version );
   BOOST_CHECK_EQUAL( idoc[ 0 ].label(), label1 );
   BOOST_CHECK_EQUAL( idoc[ 1 ].label(), label2 );
   BOOST_CHECK_EQUAL( idoc.size(), 2 );
   BOOST_CHECK_EQUAL( idoc.empty(), false );
   // Write test
   {
      std::stringstream output;
      idoc.write( output );
      const std::string result { output.str() };
      boost::tokenizer< boost::escaped_list_separator< char > > tok(result, { "\\", " \n\t", "\"\'" } );
      std::vector< std::string > wordlist = { core::strngs::fsfver(), "21", "", label1, "end", "", label2, "end" };
      BOOST_CHECK( std::equal( wordlist.begin(), wordlist.end(), tok.begin() ) );
      auto t_iter = tok.begin();
      for (auto w_iter = wordlist.begin(); w_iter != wordlist.end(); ++w_iter, ++t_iter)
      {
         BOOST_CHECK_EQUAL( *t_iter, *w_iter );
      }
   }}
!!!471856.cpp!!!	input_definition_test() : void
{
  // Static Lifetime method tests: noncopyable virtual pattern
  BOOST_CHECK( not std::is_default_constructible< core::input_definition >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< core::input_definition >::type{} );
  BOOST_CHECK( not std::is_move_constructible< core::input_definition >::type{} );
  BOOST_CHECK( not( std::is_assignable< core::input_definition, core::input_definition >::type{} ) );
  BOOST_CHECK( std::has_virtual_destructor< core::input_definition >::type{} );
}
// ----------
const std::string label1 { "label1" };
const std::string seclabel { "label2" };
const std::string name1 { "name1" };
const std::string desc1 { "desc1" };
const std::string name2 { "name2" };
const std::string desc2 { "desc2" };
{
  // default
  core::input_definition idoc( label1 );
  BOOST_CHECK_EQUAL( idoc.label(), label1 );
  BOOST_CHECK_EQUAL( idoc.size(), 0 );
  BOOST_CHECK_EQUAL( idoc.empty(), true );

  BOOST_CHECK_NO_THROW( idoc.add_definition( name1, desc1 ) );
  BOOST_CHECK( idoc.has_definition( name1 ) );
  BOOST_CHECK_EQUAL( idoc.size(), 1 );
  BOOST_CHECK_EQUAL( idoc.empty(), false );

  BOOST_CHECK_NO_THROW( idoc.add_definition( name2, desc2 ) );
  BOOST_CHECK( idoc.has_definition( name2 ) );
  BOOST_CHECK_EQUAL( idoc.size(), 2 );

  core::input_help helper;

  idoc.publish_help( helper, seclabel );

  std::stringstream store;
  helper.print( store );

  const std::string msg( store.str() );

  BOOST_CHECK_LT( msg.find( "--" + name1 + "(subtype " + label1 + ")" ), msg.size() );
  BOOST_CHECK_LT( msg.find( "--" + name2 + "(subtype " + label1 + ")" ), msg.size() );
  BOOST_CHECK_LT( msg.find( desc1 ), msg.size() );
  BOOST_CHECK_LT( msg.find( desc2 ), msg.size() );

  // Attempt to add definition with existing name.
  try
  {
    idoc.add_definition( name1, desc1 );
    BOOST_ERROR( "expected \"idoc.add_definition( name1, desc1 )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Can not overwrite existing definitions" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}


!!!899120.cpp!!!	test_meta_lifetime_test() : void
// CTOR TESTS
core_test_suite::test_input_base_meta< test_meta >();
// test test_meta attribute initialisation.
{
  const std::string label( "name" );
  std::unique_ptr< test_meta > dobj( new test_meta( label, true, false ) );
  BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 0ul );
  BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 0ul );
  BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 0ul );
}
!!!899248.cpp!!!	test_meta_publish_help_test() : void
{
  // 
  // Call publish_help, all other attributes unaffected.
  // 
  std::unique_ptr< test_meta > dobj( new test_meta( "label" ) );
  BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 0ul );
  {
    core::input_help dummy;
    dobj->publish_help( dummy );
    BOOST_CHECK_EQUAL( dobj->entry_map().size(), 0ul );
    BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 0ul );
    BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 0ul );
    BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 1ul );
  }
}
!!!891952.cpp!!!	test_meta_read_section_test() : void
const std::string label( "name" );
{
  //
  // Read section with no name/value pairs
  //
  std::unique_ptr< test_meta > dobj( new test_meta( label ) );
  {
    core::input_reader dummy;
    dummy.add_buffer( "test_filename", "name\n# comment\nend\n" );
    while( dummy.next() )
    {
      if( dummy.name() == "name" )
      {
        dobj->read_section( dummy );
        BOOST_CHECK_EQUAL( dobj->entry_map().size(), 0ul );
        BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 0ul );
        BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 0ul );
      }
    }
  }
  {
    core::input_help dummy;
    dobj->publish_help( dummy );
    BOOST_CHECK_EQUAL( dobj->entry_map().size(), 0ul );
    BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 0ul );
    BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 1ul );
  }
}
{
  //
  // Read section with one name/value pair
  //
  std::unique_ptr< test_meta > dobj( new test_meta( label ) );
  {
    core::input_reader dummy;
    dummy.add_buffer( "test_filename", "name\nhello world\nend\n" );
    while( dummy.next() )
    {
      if( dummy.name() == "name" )
      {
        dobj->read_section( dummy );
        BOOST_CHECK_EQUAL( dobj->entry_map().size(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
      }
    }
  }
}
{
  //
  // Read section with three name/value pair
  //
  std::unique_ptr< test_meta > dobj( new test_meta( label ) );
  {
    core::input_reader dummy;
    dummy.add_buffer( "test_filename", "name\n# comment\na\nb c\nd e # hmm\nend\n" );
    while( dummy.next() )
    {
      if( dummy.name() == "name" )
      {
        dobj->read_section( dummy );
        BOOST_CHECK_EQUAL( dobj->entry_map().size(), 3ul );
        BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 3ul );
        BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 0ul );
      }
    }
  }
  {
    core::input_help dummy;
    dobj->publish_help( dummy );
    BOOST_CHECK_EQUAL( dobj->entry_map().size(), 3ul );
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "a" ), 1 );
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "b" ), 1 );
    if( dobj->entry_map().count( "b" ) >= 1 )
    {
      BOOST_CHECK_EQUAL( dobj->entry_map().find( "b" )->second, "c" );
    }
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "d" ), 1 );
    if( dobj->entry_map().count( "d" ) >= 1 )
    {
      BOOST_CHECK_EQUAL( dobj->entry_map().find( "d" )->second, "e" );
    }
    BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 3ul );
    BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 1ul );
  }
}
{
  //
  // Read section with three name/value pair, one duplicated
  //
  std::unique_ptr< test_meta > dobj( new test_meta( label ) );
  {
    core::input_reader dummy;
    dummy.add_buffer( "test_filename", "name\n# comment\na\nb c\nb e # hmm\nend\n" );
    // second value of "b" silently ignored.
    while( dummy.next() )
    {
      if( dummy.name() == "name" )
      {
        dobj->read_section( dummy );
        BOOST_CHECK_EQUAL( dobj->entry_map().size(), 2ul );
        BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 3ul );
        BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
        BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 0ul );
      }
    }
  }
  {
    core::input_help dummy;
    dobj->publish_help( dummy );
    BOOST_CHECK_EQUAL( dobj->entry_map().size(), 2ul );
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "a" ), 1 );
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "b" ), 1 );
    if( dobj->entry_map().count( "b" ) >= 1 )
    {
      BOOST_CHECK_EQUAL( dobj->entry_map().find( "b" )->second, "c" );
    }
    BOOST_CHECK_EQUAL( dobj->entry_map().count( "d" ), 0 );
    BOOST_CHECK_EQUAL( dobj->get_read_entry_count(), 3ul );
    BOOST_CHECK_EQUAL( dobj->get_read_end_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_reset_count(), 1ul );
    BOOST_CHECK_EQUAL( dobj->get_publish_help_count(), 1ul );
  }
}



!!!405553.cpp!!!	input_delegater_lifetime_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< core::input_delegater >::type{} );
  BOOST_CHECK( not std::is_copy_constructible< core::input_delegater >::type{} );
  BOOST_CHECK( not std::is_move_constructible< core::input_delegater >::type{} );
  BOOST_CHECK( not( std::is_assignable< core::input_delegater, core::input_delegater >::type{} ) );
  BOOST_CHECK( not( std::has_virtual_destructor< core::input_delegater >::type{} ) );
}
{
  // Construct delegater 
  core::input_delegater dlgater( 1 );
  BOOST_CHECK( dlgater.empty() );
  BOOST_CHECK_EQUAL( dlgater.size(), 0 );
  BOOST_CHECK_EQUAL( dlgater.max_version(), 1 );
  BOOST_CHECK_EQUAL( dlgater.read_version(), 0 );
}

!!!898608.cpp!!!	input_delegater_add_input_delegate_test() : void
{
  const std::string label1( "label_one" );
  const std::string label2( "label_two" );
  boost::shared_ptr< test_meta > sobj1( new test_meta( label1, false, false ) );
  boost::shared_ptr< test_meta > sobj2( new test_meta( label2, true, false ) );

  // Construct delegater
  core::input_delegater dlgater( 1 );

  // add first delegater
  dlgater.add_input_delegate( sobj1 );
  BOOST_CHECK( not dlgater.empty() );
  BOOST_CHECK_EQUAL( dlgater.size(), 1 );
  BOOST_CHECK( dlgater.has_section( label1 ) );
  BOOST_CHECK( not dlgater.has_section( label2 ) );

  // add second delegater
  dlgater.add_input_delegate( sobj2 );
  BOOST_CHECK( not dlgater.empty() );
  BOOST_CHECK_EQUAL( dlgater.size(), 2 );
  BOOST_CHECK( dlgater.has_section( label1 ) );
  BOOST_CHECK( dlgater.has_section( label2 ) );

  // Process input buffer
  {
    core::input_reader dummy;
    dummy.add_buffer( "test_filename", "label_one\n# comment\na\nb c\nd e # hmm\nend\n" );

    dlgater.read_input( dummy );

    BOOST_CHECK_EQUAL( sobj1->get_read_entry_count(), 3ul );
    BOOST_CHECK_EQUAL( sobj1->get_read_end_count(), 1ul );

    BOOST_CHECK_EQUAL( sobj2->get_read_entry_count(), 0ul );
    BOOST_CHECK_EQUAL( sobj2->get_read_end_count(), 0ul );
  }
}
{
  // Construct delegater and add two meta objects with the same section name
  const std::string label1( "label_one" );
  const std::string label2( "label_two" );
  boost::shared_ptr< test_meta > sobj1( new test_meta( label1, false, false ) );
  boost::shared_ptr< test_meta > sobj2( new test_meta( label2, true, false ) );
  boost::shared_ptr< test_meta > sobj3( new test_meta( label2, true, false ) );

  core::input_delegater dlgater( 1 );
  dlgater.add_input_delegate( sobj1 );
  dlgater.add_input_delegate( sobj2 );
  try
  {
    dlgater.add_input_delegate( sobj3 );
    BOOST_ERROR( "expected \"dlgater.add_input_delegate( sobj3 )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Can not add two meta objects for the same input section.\"label_two\"" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
!!!898736.cpp!!!	input_delegater_input_file_versioning_test() : void
{
  // Test valid file version processed
  boost::shared_ptr< core::input_base_meta > dobj( new test_meta( "test" ) );

  const std::string canon_input( "fileversion \t1\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj );

  BOOST_CHECK_NO_THROW( var1.read_input( dummy ) );
  BOOST_CHECK_EQUAL( var1.read_version(), 1ul );
}
{
  // Test invalid file version processed
  boost::shared_ptr< core::input_base_meta > dobj( new test_meta( "test" ) );
  const std::string canon_input( "fileversion 2\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );
  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "File version 2 is too recent for this program" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
{
  // Test invalid file version (non-number) processed
  boost::shared_ptr< core::input_base_meta > dobj( new test_meta( "test" ) );
  const std::string canon_input( "fileversion A2016\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );
  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Non-numeric or negative file version (A2016) is invalid" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
{
  // Test invalid file version (negative number) processed
  boost::shared_ptr< core::input_base_meta > dobj( new test_meta( "test" ) );
  const std::string canon_input( "fileversion -1\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );
  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Non-numeric or negative file version (-1) is invalid" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
!!!898864.cpp!!!	input_delegater_input_sections_test() : void
{
  // Test valid input with sections
  boost::shared_ptr< test_meta > dobj1( new test_meta( "test_one" ) );
  boost::shared_ptr< test_meta > dobj2( new test_meta( "test_two" ) );
  boost::shared_ptr< test_meta > dobj3( new test_meta( "test_three" ) );

  const std::string canon_input( "fileversion 1\ntest_one\nend\ntest_two\n\nend\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj1 );
  var1.add_input_delegate( dobj2 );
  var1.add_input_delegate( dobj3 );

  BOOST_CHECK_NO_THROW( var1.read_input( dummy ) );

  BOOST_CHECK_EQUAL( dobj1->get_read_end_count(), 1ul );
  BOOST_CHECK_EQUAL( dobj2->get_read_end_count(), 1ul );
  BOOST_CHECK_EQUAL( dobj3->get_read_end_count(), 0ul );
}
{
  // Test invalid input (unknown section)
  boost::shared_ptr< core::input_base_meta > dobj1( new test_meta( "test_one" ) );
  boost::shared_ptr< core::input_base_meta > dobj2( new test_meta( "test_two" ) );
  boost::shared_ptr< core::input_base_meta > dobj3( new test_meta( "test_three" ) );

  const std::string canon_input( "fileversion 1\ntest_one\nend\ntest4\n\nend\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj1 );
  var1.add_input_delegate( dobj2 );
  var1.add_input_delegate( dobj3 );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Name test4 is not a valid input section label" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
{
  // Test invalid input (missing required section)
  boost::shared_ptr< core::input_base_meta > dobj1( new test_meta( "test_one" ) );
  boost::shared_ptr< core::input_base_meta > dobj2( new test_meta( "test_two" ) );
  boost::shared_ptr< core::input_base_meta > dobj3( new test_meta( "test_three", false, true ) );

  const std::string canon_input( "fileversion 1\ntest_one\nend\ntest_two\n\nend\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj1 );
  var1.add_input_delegate( dobj2 );
  var1.add_input_delegate( dobj3 );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Missing input file section: test_three" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }
}
{
  // Test valid input (repeated multiple section)
  boost::shared_ptr< core::input_base_meta > dobj1( new test_meta( "test_one" ) );
  boost::shared_ptr< test_meta > dobj2( new test_meta( "test_two", true, false ) );

  const std::string canon_input( "fileversion 1\ntest_one\nend\ntest_two\n\nend\ntest_two\n\nend\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj1 );
  var1.add_input_delegate( dobj2 );

  BOOST_CHECK_NO_THROW( var1.read_input( dummy ) );
  BOOST_CHECK_EQUAL( dobj2->get_read_end_count(), 2ul );
}
{
  // Test invalid input (repeated non-multiple section)
  boost::shared_ptr< core::input_base_meta > dobj1( new test_meta( "test_one" ) );
  boost::shared_ptr< core::input_base_meta > dobj2( new test_meta( "test_two" ) );

  const std::string canon_input( "fileversion 1\ntest_one\nend\ntest_two\n\nend\ntest_two\n\nend\n" );
  core::input_reader dummy;
  dummy.add_buffer( "test_filename", canon_input );

  core::input_delegater var1( 1ul );

  var1.add_input_delegate( dobj1 );
  var1.add_input_delegate( dobj2 );

  try
  {
    var1.read_input( dummy );
    BOOST_ERROR( "expected \"var1.read_input( dummy )\" exception not thrown" );
  }
  catch( std::runtime_error const& err )
  {
    const std::string msg( err.what() );
    //std::cout << msg << "\n";
    BOOST_CHECK( msg.find( "Input file section test_two appears more than once" ) < msg.size() );
  }
  catch( std::exception const& err )
  {
    BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
  }

}
!!!477616.cpp!!!	output_field_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( std::is_default_constructible< core::output_field >::type{} );
  BOOST_CHECK( std::is_copy_constructible< core::output_field >::type{} );
  BOOST_CHECK( std::is_move_constructible< core::output_field >::type{} );
  BOOST_CHECK( ( std::is_assignable< core::output_field, core::output_field >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< core::output_field >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );

{
  core::output_field aset;
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );
  {
    // Output error if no entries
    core::output_field copy( aset );
    try
    {
      copy.write( std::cout, 0 );
      BOOST_ERROR( "expected \"copy.write( std::cout, 0 )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write incomplete field" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }

  aset.set_label( label1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_unit( unit1 );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  aset.set_format_function( []( std::ostream& os, std::size_t i )
  {
    os << i;
  } );
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );
  {
    // Output should work
    std::stringstream store;
    BOOST_CHECK_NO_THROW( aset.write( store, 0 ) );
    const std::string output( store.str() );
    BOOST_CHECK( not output.empty() );
    BOOST_CHECK_EQUAL( output.size(), 1 );
    BOOST_CHECK_EQUAL( output, "0" );
  }
  {
    // Output should work
    std::stringstream store;
    BOOST_CHECK_NO_THROW( aset.write( store, 101 ) );
    const std::string output( store.str() );
    BOOST_CHECK( not output.empty() );
    BOOST_CHECK_EQUAL( output.size(), 3 );
    BOOST_CHECK_EQUAL( output, "101" );
  }
  core::output_field bset;
  BOOST_CHECK_EQUAL( bset.label(), emptr_str );
  BOOST_CHECK_EQUAL( bset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( bset.valid(), false );

  bset = aset;
  BOOST_CHECK_EQUAL( bset.unit(), unit1 );
  BOOST_CHECK_EQUAL( bset.label(), label1 );
  BOOST_CHECK_EQUAL( bset.valid(), true );

  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  core::output_field cset( aset );
  BOOST_CHECK_EQUAL( cset.unit(), unit1 );
  BOOST_CHECK_EQUAL( cset.label(), label1 );
  BOOST_CHECK_EQUAL( cset.valid(), true );

  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  aset = aset;
  BOOST_CHECK_EQUAL( aset.unit(), unit1 );
  BOOST_CHECK_EQUAL( aset.label(), label1 );
  BOOST_CHECK_EQUAL( aset.valid(), true );

  core::output_field dset( std::move( aset ) );
  BOOST_CHECK_EQUAL( dset.unit(), unit1 );
  BOOST_CHECK_EQUAL( dset.label(), label1 );
  BOOST_CHECK_EQUAL( dset.valid(), true );

  BOOST_CHECK_EQUAL( aset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( aset.label(), emptr_str );
  BOOST_CHECK_EQUAL( aset.valid(), false );

  core::output_field eset;
  BOOST_CHECK_EQUAL( eset.label(), emptr_str );
  BOOST_CHECK_EQUAL( eset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( eset.valid(), false );

  std::swap( eset, bset );
  BOOST_CHECK_EQUAL( eset.unit(), unit1 );
  BOOST_CHECK_EQUAL( eset.label(), label1 );
  BOOST_CHECK_EQUAL( eset.valid(), true );

  BOOST_CHECK_EQUAL( bset.unit(), emptr_str );
  BOOST_CHECK_EQUAL( bset.label(), emptr_str );
  BOOST_CHECK_EQUAL( bset.valid(), false );
}
!!!484912.cpp!!!	output_series_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( std::is_default_constructible< core::output_series >::type{} );
  BOOST_CHECK( std::is_copy_constructible< core::output_series >::type{} );
  BOOST_CHECK( std::is_move_constructible< core::output_series >::type{} );
  BOOST_CHECK( ( std::is_assignable< core::output_series, core::output_series >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< core::output_series >::type{} );
}
// CTOR TESTS
// ----------
std::string emptr_str;
const std::string test_fname
{ "result.dat"
};
const std::string test_uuid
{ "1a2b3c4d"
};
const std::string test_title
{ "Something or other."
};
{
  core::output_series aset;
  BOOST_CHECK_EQUAL( aset.title(), emptr_str );
  BOOST_CHECK_EQUAL( aset.uuid(), emptr_str );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  aset.set_uuid( test_uuid );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.title(), emptr_str );

  aset.set_title( test_title );
  BOOST_CHECK_EQUAL( aset.title(), test_title );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_series bset;
  BOOST_CHECK_EQUAL( bset.title(), emptr_str );
  BOOST_CHECK_EQUAL( bset.uuid(), emptr_str );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  bset = aset;
  BOOST_CHECK_EQUAL( bset.title(), test_title );
  BOOST_CHECK_EQUAL( bset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_series cset( aset );
  BOOST_CHECK_EQUAL( cset.title(), test_title );
  BOOST_CHECK_EQUAL( cset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  aset = aset;
  BOOST_CHECK_EQUAL( aset.title(), test_title );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_series dset( std::move( aset ) );
  BOOST_CHECK_EQUAL( dset.title(), test_title );
  BOOST_CHECK_EQUAL( dset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  // Output error if no entries
  {
    core::output_series dsetcp( dset );
    try
    {
      dsetcp.do_header( std::cout );
      BOOST_ERROR( "expected \"dsetcp.do_header( std::cout )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  {
    core::output_series dsetcp( dset );
    try
    {
      dsetcp.do_body( std::cout );
      BOOST_ERROR( "expected \"dsetcp.do_body( std::cout )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  {
    utility::memory_sink sink;
    core::output_series dsetcp( dset );
    try
    {
      dsetcp.write( test_fname, sink, true );
      BOOST_ERROR( "expected \"dsetcp.write( test_fname, sink, true )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  {
    utility::memory_sink sink;
    core::output_series dsetcp( dset );
    try
    {
      dsetcp.write( test_fname, sink, false );
      BOOST_ERROR( "expected \"dsetcp.write( test_fname, sink, false )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
}
struct person
{
  std::string name;
  std::size_t day_of_birth;
  std::size_t month_of_birth;
  std::size_t year_of_birth;
};

struct family
{
  std::vector< person > ppl;
  std::size_t day( std::size_t i ) const
  {
    return ppl[ i ].day_of_birth;
  }
  std::size_t month( std::size_t i ) const
  {
    return ppl[ i ].month_of_birth;
  }
  std::size_t year( std::size_t i ) const
  {
    return ppl[ i ].year_of_birth;
  }
  std::string name( std::size_t i ) const
  {
    return ppl[ i ].name;
  }
  std::size_t size() const
  {
    return ppl.size();
  }
};

const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  person me { "justin", 17, 4, 1965 };

  core::output_series dset( test_uuid );
  dset.set_title( test_title );
  dset.push_back_entry( core::output_field( label1, unit1, [&me]( std::ostream& os, std::size_t )
  {
    os << me.name;
  } ) );
  dset.push_back_entry( core::output_field( label2, unit2, [&me]( std::ostream& os, std::size_t )
  {
    os << me.day_of_birth;
  } ) );
  dset.push_back_entry( core::output_field( label3, unit3, [&me]( std::ostream& os, std::size_t )
  {
    os << me.month_of_birth;
  } ) );
  dset.push_back_entry( core::output_field( label4, unit4, [&me]( std::ostream& os, std::size_t )
  {
    os << me.year_of_birth;
  } ) );

  {
    std::stringstream store;
    dset.do_header( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_NE( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_NE( output.find( test_title ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
  }
  {
    std::stringstream store;
    dset.do_body( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_EQUAL( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
    BOOST_CHECK_NE( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_NE( output.find( "1965" ), std::string::npos );
  }
}
!!!471728.cpp!!!	output_dataset_test() : void
// CTOR TESTS
// ----------
std::string emptr_str;
const std::string test_fname { "result.dat" };
const std::string test_uuid { "1a2b3c4d" };
const std::string test_title { "Something or other." };
{
  core::output_dataset aset;
  BOOST_CHECK_EQUAL( aset.title(), emptr_str );
  BOOST_CHECK_EQUAL( aset.uuid(), emptr_str );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  aset.set_uuid( test_uuid );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.title(), emptr_str );

  aset.set_title( test_title );
  BOOST_CHECK_EQUAL( aset.title(), test_title );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_dataset bset;
  BOOST_CHECK_EQUAL( bset.title(), emptr_str );
  BOOST_CHECK_EQUAL( bset.uuid(), emptr_str );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  bset = aset;
  BOOST_CHECK_EQUAL( bset.title(), test_title );
  BOOST_CHECK_EQUAL( bset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_dataset cset( aset );
  BOOST_CHECK_EQUAL( cset.title(), test_title );
  BOOST_CHECK_EQUAL( cset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  aset = aset;
  BOOST_CHECK_EQUAL( aset.title(), test_title );
  BOOST_CHECK_EQUAL( aset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  core::output_dataset dset( std::move( aset ) );
  BOOST_CHECK_EQUAL( dset.title(), test_title );
  BOOST_CHECK_EQUAL( dset.uuid(), test_uuid );
  BOOST_CHECK_EQUAL( aset.size(), 0 );
  BOOST_CHECK_EQUAL( aset.empty(), true );
  BOOST_CHECK( aset.begin() == aset.end() );

  // Output error if no entries
  {
    core::output_dataset dsetcp( dset );
    try
    {
      dsetcp.do_header( std::cout );
      BOOST_ERROR( "expected \"dsetcp.do_header( std::cout )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write output with no fields defined" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  {
    core::output_dataset dsetcp( dset );
    try
    {
      dsetcp.do_body( std::cout );
      BOOST_ERROR( "expected \"dsetcp.do_body( std::cout )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write data set without any fields" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
  {
    utility::memory_sink sink;
    core::output_dataset dsetcp( dset );
    try
    {
      dsetcp.write( test_fname, sink );
      BOOST_ERROR( "expected \"dsetcp.write( test_fname, sink )\" exception not thrown" );
    }
    catch( std::runtime_error const& err )
    {
      const std::string msg( err.what() );
      //std::cout << msg << "\n";
      BOOST_CHECK( msg.find( "Can not write data set without any fields" ) < msg.size() );
    }
    catch( std::exception const& err )
    {
      BOOST_ERROR( std::string( "exception thrown by \"dg.read_input( reader )\" was not expected type: " ) + err.what() );
    }
  }
}
struct person
{
  std::string name;
  std::size_t day_of_birth;
  std::size_t month_of_birth;
  std::size_t year_of_birth;
};

struct family
{
  std::vector< person > ppl;
  std::size_t day( std::size_t i ) const
  {
    return ppl[ i ].day_of_birth;
  }
  std::size_t month( std::size_t i ) const
  {
    return ppl[ i ].month_of_birth;
  }
  std::size_t year( std::size_t i ) const
  {
    return ppl[ i ].year_of_birth;
  }
  std::string name( std::size_t i ) const
  {
    return ppl[ i ].name;
  }
  std::size_t size() const
  {
    return ppl.size();
  }
};

const std::string label1( "name" );
const std::string label2( "day" );
const std::string label3( "month" );
const std::string label4( "year" );
const std::string unit1( "label" );
const std::string unit2( "ordinal1" );
const std::string unit3( "ordinal2" );
const std::string unit4( "ordinal3" );
{
  person me { "justin", 17, 4, 1965 };

  core::output_dataset dset( { test_uuid }, []()
  {
    return 1;
  } );
  dset.set_title( test_title );
  dset.push_back_entry( core::output_field( label1, unit1, [&me]( std::ostream& os, std::size_t )
  {
    os << me.name;
  } ) );
  dset.push_back_entry( core::output_field( label2, unit2, [&me]( std::ostream& os, std::size_t )
  {
    os << me.day_of_birth;
  } ) );
  dset.push_back_entry( core::output_field( label3, unit3, [&me]( std::ostream& os, std::size_t )
  {
    os << me.month_of_birth;
  } ) );
  dset.push_back_entry( core::output_field( label4, unit4, [&me]( std::ostream& os, std::size_t )
  {
    os << me.year_of_birth;
  } ) );

  {
    std::stringstream store;
    dset.do_header( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_NE( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_NE( output.find( test_title ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
  }
  {
    std::stringstream store;
    dset.do_body( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_EQUAL( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
    BOOST_CHECK_NE( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_NE( output.find( "1965" ), std::string::npos );
  }
}

{
  family myfamily;
  myfamily.ppl.push_back( { "justin", 17, 4, 1965 } );
  myfamily.ppl.push_back( { "sean", 15, 4, 1969 } );
  myfamily.ppl.push_back( { "debi", 8, 2, 1963 } );
  myfamily.ppl.push_back( { "susan", 19, 6, 1953 } );
  myfamily.ppl.push_back( { "peabody", 1, 1, 2012 } );
  core::output_dataset dset( { test_uuid }, [&myfamily]()
  {
    return myfamily.size();
  } );
  dset.push_back_entry( core::output_field( label1, unit1, [&myfamily]( std::ostream& os, std::size_t i )
  {
    os << myfamily.name( i );
  } ) );
  dset.push_back_entry( core::output_field( label2, unit2, [&myfamily]( std::ostream& os, std::size_t i )
  {
    os << myfamily.ppl[ i ].day_of_birth;
  } ) );
  dset.push_back_entry( core::output_field( label3, unit3, [&myfamily]( std::ostream& os, std::size_t i )
  {
    os << myfamily.month( i );
  } ) );
  dset.push_back_entry( core::output_field( label4, unit4, [&myfamily]( std::ostream& os, std::size_t i )
  {
    os << myfamily.year( i );
  } ) );

  {
    std::stringstream store;
    dset.do_header( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_NE( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "TITLE" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
  }
  dset.set_title( test_title );
  {
    std::stringstream store;
    dset.do_header( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_NE( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_NE( output.find( "TITLE" ), std::string::npos );
    BOOST_CHECK_NE( output.find( test_title ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "1965" ), std::string::npos );
  }
  {
    std::stringstream store;
    dset.do_body( store );
    const std::string output
    {
      store.str()
    };
    BOOST_CHECK_EQUAL( output.find( test_uuid ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( "TITLE" ), std::string::npos );
    BOOST_CHECK_EQUAL( output.find( test_title ), std::string::npos );
    BOOST_CHECK_NE( output.find( "justin" ), std::string::npos );
    BOOST_CHECK_NE( output.find( "1965" ), std::string::npos );
    BOOST_CHECK_NE( output.find( "peabody" ), std::string::npos );
    BOOST_CHECK_EQUAL( std::count( output.begin(), output.end(), '\n' ), 5 );
  }
}

!!!1694256.cpp!!!	output_filter_lifetime_test() : void
{
  // Static Lifetime method tests
  BOOST_CHECK( not std::is_default_constructible< core::fixed_width_output_filter >::type{} );
  BOOST_CHECK( std::is_copy_constructible< core::fixed_width_output_filter >::type{} );
  BOOST_CHECK( std::is_move_constructible< core::fixed_width_output_filter >::type{} );
  BOOST_CHECK( ( std::is_assignable< core::fixed_width_output_filter, core::fixed_width_output_filter >::type{} ) );
  BOOST_CHECK( not std::has_virtual_destructor< core::fixed_width_output_filter >::type{} );
}
// CTOR TESTS
// ----------
{
  core::fixed_width_output_filter aset( 0, 0, 0 );
  BOOST_CHECK_EQUAL( aset.text_width(), 0ul );
  BOOST_CHECK_EQUAL( aset.depth(), 0ul );
  BOOST_CHECK_EQUAL( aset.indent_size(), 0ul );
}
{
  core::fixed_width_output_filter aset( 2, 1, 40 );
  BOOST_CHECK_EQUAL( aset.text_width(), 40ul );
  BOOST_CHECK_EQUAL( aset.depth(), 1ul );
  BOOST_CHECK_EQUAL( aset.indent_size(), 2ul );
  {
    core::fixed_width_output_filter aset1( aset );
    BOOST_CHECK_EQUAL( aset1.text_width(), 40ul );
    BOOST_CHECK_EQUAL( aset1.depth(), 1ul );
    BOOST_CHECK_EQUAL( aset1.indent_size(), 2ul );
  }
  {
    core::fixed_width_output_filter aset2( aset );
    core::fixed_width_output_filter aset1( std::move( aset2 ) );
    BOOST_CHECK_EQUAL( aset1.text_width(), 40ul );
    BOOST_CHECK_EQUAL( aset1.depth(), 1ul );
    BOOST_CHECK_EQUAL( aset1.indent_size(), 2ul );
  }
}
!!!1694640.cpp!!!	output_filter_method_test() : void
// USAGE TESTS
// ----------
{
  core::fixed_width_output_filter aset( 2, 1, 10 );
  namespace io = boost::iostreams;
  {
    std::stringstream result;
    const std::string input( "This is some text that I want to format." );
    const std::string output( "  This is \n  some \n  text \n  that I \n  want to \n  format." );
    {
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    std::cout << "\n--\n" << resultstr << "\n--\n";
    std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( "Now for some exceedingly elongated words." );
    const std::string output( "  Now for \n  some \n  exceedin\n  gly \n  elongate\n  d words." );
    {
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    std::cout << "\n--\n" << resultstr << "\n--\n";
    std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( "Now to change the indenting." );
    const std::string output( "    Now to\n    change\n    the \n    indent\n    ing." );
    {
      aset.increment_depth();
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    std::cout << "\n--\n" << resultstr << "\n--\n";
    std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( " a b c  d e f g h i j k l m n o p" );
    const std::string output( "  a b c  d\n  e f g h \n  i j k l \n  m n o p" );
    {
      aset.decrement_depth();
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    std::cout << "\n--\n" << resultstr << "\n--\n";
    std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( " 1234567890 1234567890" );
    const std::string output( "  12345678\n  90 \n  12345678\n  90" );
    {
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    std::cout << "\n--\n" << resultstr << "\n--\n";
    std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( " 1234567890 1234567890" );
    const std::string output( "1234567890\n1234567890" );
    {
      aset.decrement_depth();
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    std::cout << "\n--\n" << resultstr << "\n--\n";
    std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
  {
    std::stringstream result;
    const std::string input( " -12.34567890 1234.567890" );
    const std::string output( "-12.345678\n90 \n1234.56789\n0" );
    {
      aset.decrement_depth();
      io::filtering_ostream out;
      out.push( aset );
      out.push( result );
      io::write( out, input.data(), input.size() );
    }
    const std::string resultstr( result.str() );
    std::cout << "\n--\n" << resultstr << "\n--\n";
    std::cout << "\n**\n" << output << "\n**\n";
    BOOST_CHECK_EQUAL( resultstr, output );
    if( resultstr != output )
    {
      const std::size_t minsz = std::min( resultstr.size(), output.size() );
      for( std::size_t ii = 0; ii != minsz; ++ii )
      {
        BOOST_CHECK_EQUAL( resultstr[ii], output[ii] );
      }
    }
  }
}
