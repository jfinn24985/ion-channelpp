class acceptance_observable
!!!1326128.cpp!!!	add_definition(inout meta : sampler_meta) : void
std::string desc( "Monitor the trial acceptance rate for the different trial types. This is a metric to optimise the simulation and is not a result of the simulation." );
std::unique_ptr< tracked_definition > result( new tracked_definition( type_label_(), desc, &acceptance_observable::make_sampler ) );
// no extra parameters
meta.add_tracked_type( result );

!!!718128.cpp!!!	description(inout out : ostream) : void
out << " " << this->type_label_() << "\n";
out << " " << std::string( this->type_label_().size(), '-' ) << "\n";
out << "    Collect and report trial acceptance probabilities.\n";
!!!718384.cpp!!!	get_value() : boost::any
boost::any result = this->data_;
return result;
!!!719280.cpp!!!	make_sampler(in param_set : string) : tracked_observable
UTILITY_INPUT(param_set.empty(), "Sampler type \""+acceptance_observable::type_label_()+"\" requires no parameters.", core::strngs::sampler_label(), nullptr);
boost::shared_ptr< tracked_observable > tmp(new acceptance_observable);
return tmp;
!!!718640.cpp!!!	on_report(inout out : ostream, inout sink : base_sink) : void
// data is  [change_hash] : <<success/trial>> : <<attempts>>
// (0, 1, 1, 0) 0.66666667          0 0.30000000 0.00000000
if( not this->data_.empty() )
{
// CHECK ALL COUNTS ARE EQUAL
  UTILITY_ENSURE_OLD( const std::size_t check_counter = this->data_.begin()->second.first.count() );
  const static boost::format title_str( " %14s %10s %10s %10s %10s" );
  out << boost::format( title_str ) % "Trial" % "Accept.av" % "Accept.var" % "Trial.av" % "Trial.var" << "\n";
  const static boost::format format_str( " %14s %10.8f %10.8f %10.8f %10.8f" );
  typedef boost::tuple< std::string, double, double, double, double > datum_t;
  std::vector< datum_t > dataset;
  for( auto const& entry : this->data_ )
  {
    std::stringstream hashval;
    hashval << entry.first;
    dataset.push_back( { hashval.str(), entry.second.first.mean(), entry.second.first.variance(), entry.second.second.mean(), entry.second.second.variance() } );
    out << boost::format( format_str ) % hashval.str() % entry.second.first.mean() % entry.second.first.variance() % entry.second.second.mean() % entry.second.second.variance() << "\n";
    UTILITY_ENSURE( check_counter == entry.second.first.count(), "Serious error, estimater counters should all be equal" );
    UTILITY_ENSURE( check_counter == entry.second.second.count(), "Serious error, estimater counters should all be equal" );
  }
  {
    // Write out trial acceptance data

    const std::string filename { "acceptance.dat" };
    const std::size_t sz { this->data_.size() };

    output_dataset dset { [sz]() { return sz; } };
    dset.set_title( "Trial acceptance and rate data." );

    dset.push_back_entry( observable::output_field( "TRIAL", "CHANGE_HASH", [&dataset]( std::ostream& os, std::size_t ii )
    {
      os << boost::tuples::get< 0 >( dataset[ii] );
    } ) );

    dset.push_back_entry( observable::output_field( "ACCEPT.MEAN", "RATE", [&dataset]( std::ostream& os, std::size_t ii )
    {
      os << boost::tuples::get< 1 >( dataset[ii] );
    } ) );

    dset.push_back_entry( observable::output_field( "ACCEPT.VAR", "RATE", [&dataset]( std::ostream& os, std::size_t ii )
    {
      os << boost::tuples::get< 2 >( dataset[ii] );
    } ) );

    dset.push_back_entry( observable::output_field( "ATTEMPT.MEAN", "RATE", [&dataset]( std::ostream& os, std::size_t ii )
    {
      os << boost::tuples::get< 3 >( dataset[ii] );
    } ) );

    dset.push_back_entry( observable::output_field( "ATTEMPT.VARIANCE", "RATE", [&dataset]( std::ostream& os, std::size_t ii )
    {
      os << boost::tuples::get< 4 >( dataset[ii] );
    } ) );

    dset.write( filename, sink );
  }
}
!!!1485104.cpp!!!	on_sample(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager) : void
// If we have a vary rare trial it might not appear in the
// first sample window. Therefore we may need to add an
// estimater after the first sample window. This would
// require incrementing the counter of new estimater by
// calling append "count" times with zero.
std::size_t count = 0;
if( not this->data_.empty() )
{
  count = this->data_.begin()->second.first.count();
}
for( auto & entry : this->dictionary_ )
{
  // entry.first : hash
  // entry.second.first : success
  // entry.second.second : attempts
  auto iter = this->data_.find( entry.first );
  // iter->first : hash
  // iter->second.first : success chance per attempt
  // iter->second.second : attempt chance
  if( this->data_.end() == iter )
  {
    iter = this->data_.insert( std::make_pair( entry.first, std::pair< utility::estimater, utility::estimater >{} ) ).first;
    // for late added estimaters we need to increase their
    // counter
    for( std::size_t catchup = 0; catchup != count; ++catchup)
    {
       iter->second.first.append( 0.0 );
       iter->second.second.append( 0.0 );
    }
  }
  if( 0 == entry.second.second )
  {
     iter->second.first.append( 0.0 );
     iter->second.second.append( 0.0 );
  }
  else
  {
     iter->second.first.append( double(entry.second.first)/double(entry.second.second) );
     iter->second.second.append( double(entry.second.second)/double(this->total_) );
  }
  // reset counters
  entry.second.first = 0ul;
  entry.second.second = 0ul;
}
// reset total count
this->total_ = 0ul;
!!!718000.cpp!!!	on_trial_end(in trial : change_set) : void
++this->total_;
auto iter = this->dictionary_.find( trial.id() );
if( this->dictionary_.end() == iter )
{
  iter = this->dictionary_.insert( std::pair< particle::change_hash, std::pair< std::size_t, std::size_t > >( trial.id(), { 0ul, 0ul } ) ).first;
}
++(iter->second.second);
if (trial.accept())
{
  ++(iter->second.first);
}
!!!718512.cpp!!!	prepare(in pman : particle_manager, in gman : geometry_manager, in eman : evaluator_manager, in sman : report_manager) : void
this->data_.clear();
this->dictionary_.clear();
this->total_ = 0ul;
!!!719408.cpp!!!	do_write_document(inout wr : input_document, in ix : size_t) : void
wr[ix].add_entry(core::strngs::fstype(), this->type_label_());

