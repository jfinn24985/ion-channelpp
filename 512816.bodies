class jump_in
!!!1161520.cpp!!!	generate(in particles : particle_manager, in regions : geometry_manager, inout rgnr : random_distribution) : change_set
std::unique_ptr< particle::change_set > resultset( new particle::change_set );
auto const& ens = particles.get_ensemble();
particle::change_atom atom;
atom.key = this->key().key;
const std::size_t spc_count( ens.specie_count( atom.key ) );
// Select a particle at random: We can do this because we are selecting from
// anywhere.
switch( spc_count )
{
case 0:
{
  resultset->set_fail(); // No particles of this specie
  return resultset;
}
break;
case 1:
{
  atom.index = ens.nth_specie_index( atom.key, 0 );
}
break;
default:
{
  atom.index = ens.nth_specie_index( atom.key, rgnr.randint( 0, spc_count - 1 ) );
}
break;
}
// Get old position
atom.old_position = ens.position( atom.index );
// New random position within specific region
if( this->region_index_ == 0 )
{
  // not yet assigned
  this->region_index_ = regions.region_key( this->region_name_ );
  UTILITY_CHECK( this->region_index_ != 0, "System region and can not be the subregion target of a jump in/out" );
}
atom.new_position = regions.get_region( this->region_index_ ).new_position( rgnr, particles.get_specie( atom.key ).radius() );
// No need to check for valid position because new
// position should always give a valid position.
resultset->add_atom( atom );
return resultset;

!!!1161520.python!!!	generate(in particles : particle_manager, in regions : geometry_manager, inout rgnr : random_distribution) : change_set
self.begin_trial()
ens = sys.get_ensemble()
genr = sys.get_random()
import change_set
resultset = change_set.change_set( self )
result = change_set.change_atom()
resultset.add_atom( result )
result.key = self.specie_key()
if sys.get_specie( result.key ).count() == 0:
  resultset.fail = True # No particles of this specie
  return resultset
elif sys.get_specie( result.key ).count() == 1:
  result.index = ens.nth_specie_index( result.key, 0 )
else:
  result.index = ens.nth_specie_index( result.key, genr.randint( 0, sys.get_specie( result.key ).count() - 1) )
result.old_position = ens.position ( result.index )
sys.get_cell_region().new_position( result.new_position, result.key, genr )
if not sys.get_cell_region().is_valid_position( result.new_position, result.key ):
  resultset.fail = True # not a valid position
return resultset

!!!1208112.cpp!!!	add_definition(inout meta : choice_meta) : void
trial::choice_definition defn;

defn.type_name_ = "jump-in";
defn.factory_ = &trial::chooser< jump_in >::make_chooser;
{
  std::string name = core::strngs::fsregn();
  std::string help = "[name, required] The name of one of the sub-regions defined in the simulation. It is an error to use the name of the whole simulation region.";
  defn.parameter_definition_.insert( std::make_pair( name, help ) );
}
UTILITY_CHECK( not meta.has_trial_type( defn.type_name_ ), "This type has already been added to this meta object." );
meta.add_trial_type( defn );
!!!1207984.cpp!!!	make_choice(in ispec : size_t, in params : string) : jump_in
// needed information
// ispec : from ispec arg
// region_name : from param arg
std::string region_name {};
const std::string region_name_label { core::strngs::fsregn() }; 

// --------------------
// region label (required)
// check for required parameters.
UTILITY_INPUT( params.count( region_name_label ) == 1, "Trial type \"jump-in\" requires parameter \"" + region_name_label + "\".", core::strngs::fstry() );
UTILITY_INPUT( not params.at( region_name_label ).empty(), "Trial type \"jump-in\" parameter \"" + region_name_label + "\" must have a value.", core::strngs::fstry() );
region_name = core::input_base_reader::dequote( params.at( region_name_label ) );
boost::algorithm::trim( region_name );

// build region object.
std::unique_ptr< jump_in > current( new jump_in( ispec, region_name ) );
return current;




