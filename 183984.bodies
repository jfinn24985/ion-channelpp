class chooser_by_simulator
!!!253232.cpp!!!	description(inout os : ostream) : void
static const boost::format header(" %6s %7.2f");
os << boost::format(header) % core::strngs::fstype() % (100.0*this->rate_) << "\n";
!!!253360.cpp!!!	do_write_document(inout wr : input_document, in ix : size_t) : void
wr[ ix ].add_entry( core::strngs::fstype(), this->type_ );
wr[ ix ].add_entry( core::strngs::rate_label(), this->rate_ );
for (auto const& param : this->parameter_set_)
{
  wr[ ix ].add_entry( param.first, param.second );
}
!!!253488.cpp!!!	generate_choices(in sim : simulator, inout choices : base_choice) : void
std::set< std::string > include, exclude;
if ( this->parameter_set_.find( core::strngs::fsspec() ) != this->parameter_set_.end() )
{
   // Have inclusion/exclusion list
   boost::char_separator< char > sep(" ");
   boost::tokenizer< boost::char_separator< char > > tok( this->parameter_set_.at( core::strngs::fsspec() ), sep );
   for ( auto const& entry : tok )
   {
      if ( entry[0] == '+' )
      {
         include.insert( entry.substr( 1, 2 ) );
      }
      else if ( entry[0] == '-' )
      {
         exclude.insert( entry.substr( 1, 2 ) );
      }
      else
      {
         include.insert( entry.substr( 0, 2 ) );
      }
   }
}
// Require that species are not in both include and exclude lists
if ( not include.empty() and not exclude.empty() )
{
   for ( auto const& entry : include )
   {
      UTILITY_INPUT( 0 == exclude.count( entry ),
                     "Specie label "+entry+" set as included and excluded",
                     core::strngs::fstry() );
   }
}

// Downcast sim object.
Sim const& subsim = dynamic_cast< Sim const& >( sim );
for (std::size_t ispec = 0; ispec != sim.specie_count (); ++ispec)
{
   // All species with non-zero specie rate can have a displacement move
   auto const& spec = sim.get_specie( ispec );
   // Only species in include OR not in exclude list.
   if ( ( include.empty() or 0 < include.count( spec.label() ) )
         and ( exclude.empty() or 0 == exclude.count( spec.label() ) ) )
   {
      const double choice_rate { this->rate_ * spec.rate() };
      if ( not utility::feq( choice_rate, 0.0 ) )
      {
         std::unique_ptr< base_choice > choice_ptr( new Choice( ispec, this->parameter_set_, subsim ) );
         choice_ptr->set_probability( choice_rate );
         choices.push_back( choice_ptr.get() );
         choice_ptr.release();
      }
   }
}
!!!254512.cpp!!!	make_chooser(in params : string, in type : string, in rate : double, inout sim : simulator) : void
std::unique_ptr< base_chooser > choice_ptr( new chooser_by_simulator< Choice, Sim >( params, type, rate ) );
sim.add_chooser( choice_ptr.release() );
